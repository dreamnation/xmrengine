//////////////////////////////////////////////////////////////
//
// Copyright (c) 2009 Careminster Limited and Melanie Thielker
// Copyright (c) 2010 Mike Rieker, Beverly, MA, USA
//
// All rights reserved
//

using System;
using System.Threading;
using System.Reflection;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.Remoting.Lifetime;
using System.Security.Policy;
using System.IO;
using System.Xml;
using System.Text;
using Mono.Tasklets;
using OpenMetaverse;
using OpenSim.Framework;
using OpenSim.Region.ScriptEngine.Interfaces;
using OpenSim.Region.ScriptEngine.Shared;
using OpenSim.Region.ScriptEngine.Shared.Api;
using OpenSim.Region.ScriptEngine.Shared.ScriptBase;
using OpenSim.Region.ScriptEngine.XMREngine;
using OpenSim.Region.Framework.Scenes;
using log4net;

#include "lsltypes.h"

// This class exists in the main app domain
//
namespace OpenSim.Region.ScriptEngine.XMREngine
{
    public enum SubsArray {
        SCRIPT = 0,
        BEAPI,
        SIZE
    };

    /**
     * @brief Which queue it is in as far as running is concerned,
     *        ie, m_StartQueue, m_YieldQueue, m_SleepQueue, etc.
     * Allowed transitions:
     *   Starts in CONSTRUCT when constructed
     *   CONSTRUCT->ONSTARTQ          : only by thread that constructed it
     *   IDLE->ONSTARTQ,RESETTING     : by any thread but must have m_QueueLock when transitioning
     *   ONSTARTQ->RUNNING,RESETTING  : only by thread that removed it from m_StartQueue
     *   ONYIELDQ->RUNNING,RESETTING  : only by thread that removed it from m_YieldQueue
     *   ONSLEEPQ->ONYIELDQ,RESETTING : only by thread that removed it from m_SleepQueue
     *   RUNNING->whatever1           : only by thread that transitioned it to RUNNING
     *                                  whatever1 = IDLE,ONSLEEPQ,ONYIELDQ,ONSTARTQ,SUSPENDED,FINISHED
     *   FINSHED->whatever2           : only by thread that transitioned it to FINISHED
     *                                  whatever2 = IDLE,ONSTARTQ,DISPOSED
     *   SUSPENDED->ONSTARTQ          : by any thread (NOT YET IMPLEMENTED, should be under some kind of lock?)
     *   RESETTING->ONSTARTQ          : only by the thread that transitioned it to RESETTING
     */
    public enum XMRInstState {
        CONSTRUCT,  // it is being constructed
        IDLE,       // nothing happening (finished last event and m_EventQueue is empty)
        ONSTARTQ,   // inserted on m_Engine.m_StartQueue
        RUNNING,    // currently being executed by RunOne()
        ONSLEEPQ,   // inserted on m_Engine.m_SleepQueue
        ONYIELDQ,   // inserted on m_Engine.m_YieldQueue
        FINISHED,   // just finished handling an event
        SUSPENDED,  // m_SuspendCount > 0
        RESETTING,  // being reset via external call
        DISPOSED    // has been disposed
    }

    public partial class XMRInstance : XMRInstAbstract, IDisposable
    {
        /******************************************************************\
         *  This module contains the instance variables for XMRInstance.  *
        \******************************************************************/

        public const int MAXEVENTQUEUE = 64;

        public static readonly DetectParams[] zeroDetectParams = new DetectParams[0];
        public static readonly object[] zeroObjectArray = new object[0];

        private static readonly ILog m_log =
            LogManager.GetLogger(MethodBase.GetCurrentMethod().DeclaringType);

        // For a given m_AssetID, do we have the compiled object code and where
        // is it?  m_CompiledScriptRefCount keeps track of how many m_ObjCode
        // pointers are valid.
        public static object m_CompileLock = new object();
        private static Dictionary<UUID, ScriptObjCode> m_CompiledScriptObjCode = new Dictionary<UUID, ScriptObjCode>();
        private static Dictionary<UUID, int> m_CompiledScriptRefCount = new Dictionary<UUID, int>();

        public  XMRInstance  m_NextInst;  // used by XMRInstQueue
        public  XMRInstance  m_PrevInst;
        public  XMRInstState m_IState;

        public  SceneObjectPart m_Part = null;
        public  uint m_LocalID = 0;
        public  TaskInventoryItem m_Item = null;
        public  UUID m_ItemID;
        public  UUID m_AssetID;

        private XMREngine m_Engine = null;
        private string m_ScriptBasePath;
        private string m_StateFileName;
        private string m_SourceCode;
        private ScriptObjCode m_ObjCode;
        private bool m_PostOnRez;
        private DetectParams[] m_DetectParams = null;
        private bool m_Die = false;
        private int m_StartParam = 0;
        private StateSource m_StateSource;
        public  string m_DescName;
        private bool[] m_HaveEventHandlers;
        public  UIntPtr m_StackSize;
        private ArrayList m_CompilerErrors;
        private DateTime m_LastRanAt = DateTime.MinValue;
        private string m_RunOnePhase = "hasn't run";
        private string m_CheckRunPhase = "hasn't checked";
        private int m_CheckRunLine = 0;
        public  int m_InstEHEvent  = 0;  // number of events dequeued (StartEventHandler called)
        public  int m_InstEHSlice  = 0;  // number of times handler timesliced (ResumeEx called)
        public  int m_CPUTime      = 0;  // accumulated CPU time (milliseconds)

        public bool   m_CheckRunStressOdd;     // use odd number of stack frames to offset stack this time
        public bool   m_CheckRunStressWrite;   // true: microthread suspended because it wrote stress; false: normal suspend
        public int    m_CheckRunStressStack;   // number of stack frames remaingin to offset this time
        public Stream m_CheckRunStressStream;  // null: normal mode; else: stream to write stress data to / read stress data from
        public bool   m_ForceReset;

        // If code needs to have both m_QueueLock and m_RunLock,
        // be sure to lock m_RunLock first then m_QueueLock, as
        // that is the order used in RunOne().
        // These locks are currently separated to allow the script
        // to call API routines that queue events back to the script.
        // If we just had one lock, then the queuing would deadlock.

        // guards m_DetachQuantum, m_EventQueue, m_EventCounts, m_Running, m_Suspended
        public Object m_QueueLock = new Object();

        // true iff allowed to accept new events
        private bool m_Running = true;

        // queue of events that haven't been acted upon yet
        public LinkedList<EventParams> m_EventQueue = new LinkedList<EventParams>();

        // number of events of each code currently in m_EventQueue.
        private int[] m_EventCounts = new int[(int)ScriptEventCode.Size];


        // locked whilst running on the microthread stack (or about to run on it or just ran on it)
        private Object m_RunLock = new Object();

        // script won't step while > 0.  bus-atomic updates only.
        private int m_SuspendCount = 0;

        // don't run any of script until this time
        // or until one of these events are queued
        public DateTime m_SleepUntil = DateTime.MinValue;
        public int m_SleepEventMask1 = 0;
        public int m_SleepEventMask2 = 0;

        private Dictionary<string,IScriptApi> m_Apis =
                new Dictionary<string,IScriptApi>();

        public ScriptEventCode eventCode = ScriptEventCode.None;
                                                  // event handler being executed (None when idle)
                                                  // - code assumes that only the event handling microthread
                                                  //   transitions eventCode from non-idle to idle
                                                  // - idle to non-idle is always Interlocked
        public ScriptObjCode objCode;             // the script's object code pointer

        /*
         * We will use this microthread to run the scripts event handlers.
         */
        private ScriptUThread microthread;

        /*
         * Continuation layer to serialize/deserialize script stack.
         */
        public ScriptContinuation continuation;

        /*
         * Set to suspend microthread at next CheckRun() call.
         */
        public bool suspendOnCheckRunHold;
        public bool suspendOnCheckRunTemp;   // false: keep running
                                             //  true: suspend on next call to CheckRun()

        /*
         * Set to perform migration.
         */
        public BinaryReader migrateInReader;   // used to read script state from a file
        public Stream       migrateInStream;
        public Dictionary<int, object> migrateInObjects;
        public BinaryWriter migrateOutWriter;  // used to write script state to a file
        public Stream       migrateOutStream;
        public bool         migrateComplete;   // false: migration in progress; true: migration complete
        public Dictionary<object, int> migrateOutObjects;

        /*
         * The subsArray[] is used by continuations to say which object references
         * it must translate between sender and receiver.
         *
         * Save()/Load() are 'smart' enough to translate any references it finds on
         * the stack to these objects on the receiving end without being explicitly 
         * told:
         *
         *   1) continuation object itself
         *   2) writer stream object references are translated to null
         *   3) subsArray object itself
         *   4) dllsArray object itself
         *
         * So any additional object references on the stack we want translated must 
         * be placed in subsArray[].
         *
         * Finally, any objects not in the list of (3) or in subsArray are passed to
         * the general serialize/deserialize routines and thus get reconstructed by
         * value.  This is how things like vectors and strings get sent.
         *
         * Bottom line is this array contains references to objects that can be active
         * when Save() is called, other than objects that are to be reconstructed by
         * serialization/deserialization.
         */
        public object[] subsArray = new object[(int)SubsArray.SIZE];

        /*
         * The dllsArray[] tells the continuations what DLL filename translation must
         * be done between the sender and receiver.
         *
         * Basically, unless the DLL has the same exact path on sending and receiving
         * systems, this must include all DLLs that have MMRContableAttribute() routines
         * in them.
         */
        public string[] dllsArray;

        /*
         * Makes sure migration data version is same on both ends.
         */
        public static byte migrationVersion = 8;

        /**
         * @brief types of data we serialize
         */
        private enum Ser : byte {
            NULL,
            EVENTCODE,
            LSLFLOAT,
            LSLINT,
            LSLKEY,
            LSLLIST,
            LSLROT,
            LSLSTR,
            LSLVEC,
            OBJARRAY,
            SYSDOUB,
            SYSFLOAT,
            SYSINT,
            SYSSTR,
            XMRARRAY,
            DETPRMS,
            DUPREF
        }

        // Scripts start suspended now. This means that event queues will
        // accept events, but will not actually run them until the core
        // tells it it's OK. This is needed to prevent loss of link messages
        // in complex objects, where no event can be allowed to run until
        // all possible link message receivers' queues are established.
        // Guarded by m_QueueLock.
        public bool m_Suspended = true;

        // When llDie is executed within the attach(NULL_KEY) event of
        // a script being detached to inventory, the DeleteSceneObject call
        // it causes will delete the script instances before their state can
        // be saved. Therefore, the instance needs to know that it's being
        // detached to inventory, rather than to ground.
        // Also, the attach(NULL_KEY) event needs to run with priority, and
        // it also needs to have a limited quantum.
        // If this is nonzero, we're detaching to inventory.
        // Guarded by m_QueueLock.
        private int m_DetachQuantum = 0;

        // Finally, we need to wait until the quantum is done, or the script
        // suspends itself. This should be efficient, so we use an event
        // for it instead of spinning busy.
        // It's born ready, but will be reset when the detach is posted.
        // It will then be set again on suspend/completion
        private ManualResetEvent m_DetachReady = new ManualResetEvent(true);
    }
}
