//////////////////////////////////////////////////////////////
//
// Copyright (c) 2009 Careminster Limited and Melanie Thielker
// Copyright (c) 2010 Mike Rieker, Beverly, MA, USA
//
// All rights reserved
//

using System;
using System.Threading;
using System.Reflection;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.Remoting.Lifetime;
using System.Security.Policy;
using System.IO;
using System.Xml;
using System.Text;
using Mono.Tasklets;
using OpenMetaverse;
using OpenSim.Framework;
using OpenSim.Region.ScriptEngine.Interfaces;
using OpenSim.Region.ScriptEngine.Shared;
using OpenSim.Region.ScriptEngine.Shared.Api;
using OpenSim.Region.ScriptEngine.Shared.ScriptBase;
using OpenSim.Region.ScriptEngine.XMREngine;
using OpenSim.Region.Framework.Scenes;
using log4net;

#include "lsltypes.h"

namespace OpenSim.Region.ScriptEngine.XMREngine
{
    /****************************************************\
     *  This file contains routines called by scripts.  *
    \****************************************************/

    public class XMRLSL_Api : LSL_Api
    {
        public AsyncCommandManager acm;
        private XMRInstance inst;

        public void InitXMRLSLApi(XMRInstance i)
        {
            acm = AsyncCommands;
            inst = i;
        }

        protected override void ScriptSleep(int ms)
        {
            inst.Sleep(ms);
        }

        public override void llSleep(double sec)
        {
            inst.Sleep((int)(sec * 1000.0));
        }

        public override void llDie()
        {
            inst.Die();
        }
    }

    public partial class XMRInstance
    {
        /**
         * @brief The script is calling llReset().
         *        We throw an exception to unwind the script out to its main
         *        causing all the finally's to execute and it will also set
         *        eventCode = None to indicate event handler has completed.
         */
        public void ApiReset()
        {
            ClearQueueExceptLinkMessages();

            throw new ScriptResetException();
        }

        /**
         * @brief The script is calling one of the llDetected...(int number)
         *        functions.  Return corresponding DetectParams pointer.
         */
        public DetectParams GetDetectParams(int number)
        {
            if (m_DetectParams == null)
                return null;

            if (number < 0 || number >= m_DetectParams.Length)
                return null;

            return m_DetectParams[number];
        }

        /**
         * @brief Script is calling llDie, so flag the run loop to delete script
         *        once we are off the microthread stack, and throw an exception
         *        to unwind the stack asap.
         */
        public void Die()
        {
            // llDie doesn't work in attachments!
///???            if (m_Part.ParentGroup.RootPart.IsAttachment || m_DetachQuantum > 0)
///???                return;

            throw new ScriptDieException();
        }

        /**
         * @brief Called by script to sleep for the given number of milliseconds.
         */
        public void Sleep(int ms)
        {
            lock (m_QueueLock) {

                /*
                 * Say how long to sleep.
                 */
                m_SleepUntil = DateTime.UtcNow + TimeSpan.FromMilliseconds(ms);

                /*
                 * Don't wake on any events.
                 */
                m_SleepEventMask1 = 0;
                m_SleepEventMask2 = 0;
            }

            /*
             * The compiler follows all calls to llSleep() with a call to CheckRun().
             * So tell CheckRun() to suspend the microthread.
             */
            suspendOnCheckRunTemp = true;
        }

        /**
         * Block script execution until an event is queued or a timeout is reached.
         * @param timeout = maximum number of seconds to wait
         * @param returnMask = if event is queued that matches these mask bits,
         *                     the script is woken, that event is dequeued and
         *                     returned to the caller.  The event handler is not
         *                     executed.
         * @param backgroundMask = if any of these events are queued while waiting,
         *                         execute their event handlers.  When any such event
         *                         handler exits, continue waiting for events or the
         *                         timeout.
         * @returns empty list: no event was queued that matched returnMask and the timeout was reached
         *                      or a background event handler changed state (eg, via 'state' statement)
         *                else: list giving parameters of the event:
         *                      [0] = event code (integer)
         *                   [1..n] = call parameters to the event, if any
         * Notes:
         *   1) Scrips should use XMREVENTMASKn_<eventname> symbols for the mask arguments,
         *      where n is 1 or 2 for mask1 or mask2 arguments.
         *      The list[0] return argument can be decoded by using XMREVENTCODE_<eventname> symbols.
         *   2) If all masks are zero, the call ends up acting like llSleep.
         *   3) If an event is enabled in both returnMask and backgroundMask, the returnMask bit
         *      action takes precedence, ie, the event is returned.  This allows a simple specification
         *      of -1 for both backgroundMask arguments to indicate that all events not listed in
         *      the returnMask argumetns should be handled in the background.
         *   4) Any events not listed in either returnMask or backgroundMask arguments will be
         *      queued for later processing (subject to normal queue limits).
         *   5) Background event handlers execute as calls from within xmrEventDequeue, they do
         *      not execute as separate threads.  Thus any background event handlers must return
         *      before the call to xmrEventDequeue will return.
         *   6) If a background event handler changes state (eg, via 'state' statement), the state
         *      is immediately changed and the script-level xmrEventDequeue call does not return.
         *   7) For returned events, the detect parameters are overwritten by the returned event.
         *      For background events, the detect parameters are saved and restored.
         *   8) Scripts must contain dummy event handler definitions for any event types that may 
         *      be returned by xmrEventDequeue, to let the runtime know that the script is capable 
         *      of processing that event type.  Otherwise, the event may not be queued to the script.
         */
        private static LSL_List emptyList = new LSL_List (new object[0]);

        public override LSL_List xmrEventDequeue (SCRIPTFLOAT timeout, int returnMask1, int returnMask2, 
                                                  int backgroundMask1, int backgroundMask2)
        {
            DateTime sleepUntil = DateTime.UtcNow + TimeSpan.FromMilliseconds (timeout * 1000.0);
            EventParams evt = null;
            int callNo, evc1, evc2;
            int mask1 = returnMask1 | backgroundMask1;  // codes 00..31
            int mask2 = returnMask2 | backgroundMask2;  // codes 32..63
            LinkedListNode<EventParams> lln = null;
            object[] sv;
            ScriptEventCode evc;

            if (callMode == CALLMODE_NORMAL) goto findevent;
            sv          = RestoreStackFrame ("xmrEventDequeue", out callNo);
            sleepUntil  = DateTime.Parse ((string)sv[0]);
            returnMask1 = (int)sv[1];
            returnMask2 = (int)sv[2];
            mask1       = (int)sv[3];
            mask2       = (int)sv[4];
            goto __call0;

            /*
             * Find first event that matches either the return or background masks.
             */
        findevent:
            Monitor.Enter (m_QueueLock);
            for (lln = m_EventQueue.First; lln != null; lln = lln.Next) {
                evt  = lln.Value;
                evc  = (ScriptEventCode)Enum.Parse (typeof (ScriptEventCode), evt.EventName);
                evc1 = (int)evc;
                evc2 = evc1 - 32;
                if ((((uint)evc1 < (uint)32) && (((mask1 >> evc1) & 1) != 0)) ||
                    (((uint)evc2 < (uint)32) && (((mask2 >> evc2) & 1) != 0))) goto remfromq;
            }

            /*
             * Nothing found, sleep while one comes in.
             */
            m_SleepUntil = sleepUntil;
            m_SleepEventMask1 = mask1;
            m_SleepEventMask2 = mask2;
            Monitor.Exit (m_QueueLock);
            suspendOnCheckRunTemp = true;
        __call0:
            try {
                CheckRun (0);
            } finally {
                if (callMode != CALLMODE_NORMAL) {
                    sv    = CaptureStackFrame ("xmrEventDequeue", 0, 5);
                    sv[0] = sleepUntil.ToString ();
                    sv[1] = returnMask1;
                    sv[2] = returnMask2;
                    sv[3] = mask1;
                    sv[4] = mask2;
                }
            }
            goto checktmo;

            /*
             * Found one, remove it from queue.
             */
        remfromq:
            m_EventQueue.Remove (lln);
            m_EventCounts[evc1] --;
            Monitor.Exit (m_QueueLock);

            /*
             * See if returnable or background event.
             */
            if ((((uint)evc1 < (uint)32) && (((returnMask1 >> evc1) & 1) != 0)) ||
                (((uint)evc2 < (uint)32) && (((returnMask2 >> evc2) & 1) != 0))) {

                /*
                 * Returnable event, return its parameters in a list.
                 * Also set the detect parameters to what the event has.
                 */
                int plen = evt.Params.Length;
                object[] plist = new object[plen+1];
                plist[0] = (LSL_Integer)evc1;
                for (int i = 0; i < plen;) {
                    object ob = evt.Params[i];
                         if (ob is int)         ob = (LSL_Integer)(int)ob;
                    else if (ob is SCRIPTFLOAT) ob = (LSL_Float)(SCRIPTFLOAT)ob;
                    else if (ob is string)      ob = (LSL_String)(string)ob;
                    plist[++i] = ob;
                }
                m_DetectParams = evt.DetectParams;
                return new LSL_List (plist);
            }

            /*
             * It is a background event, simply call its event handler,
             * then check event queue again.
             */
            ScriptEventHandler seh = m_ObjCode.scriptEventHandlerTable[stateCode,evc1];
            if (seh != null) {
                DetectParams[]  saveDetParams = this.m_DetectParams;
                object[]        saveEHArgs    = this.ehArgs;
                ScriptEventCode saveEventCode = this.eventCode;

                this.m_DetectParams = evt.DetectParams;
                this.ehArgs         = evt.Params;
                this.eventCode      = evc;

                try {
                    seh (this);
                } finally {
                    this.m_DetectParams = saveDetParams;
                    this.ehArgs         = saveEHArgs;
                    this.eventCode      = saveEventCode;
                }
            }

            /*
             * Keep waiting until we find a returnable event or timeout.
             */
        checktmo:
            if (DateTime.UtcNow < sleepUntil) goto findevent;

            /*
             * We timed out, return an empty list.
             */
            return emptyList;
        }

        /**
         * @brief Enqueue an event
         * @param ev = as returned by xmrEventDequeue saying which event type to queue
         *             and what argument list to pass to it.  The llDetect...() parameters
         *             are as currently set for the script (use xmrEventLoadDets to set how
         *             you want them to be different).
         */
        public override void xmrEventEnqueue (LSL_List ev)
        {
            object[] data = ev.Data;
            ScriptEventCode evc = (ScriptEventCode)ListInt (data[0]);

            int nargs = data.Length - 1;
            object[] args = new object[nargs];
            Array.Copy (data, 1, args, 0, nargs);

            PostEvent (new EventParams (evc.ToString (), args, m_DetectParams));
        }

        /**
         * @brief Save current detect params into a list
         * @returns a list containing current detect param values
         */
        private const int saveDPVer = 1;

        public override LSL_List xmrEventSaveDets ()
        {
            int len = m_DetectParams.Length;
            object[] dps = new object[len*16+1];
            int j = 0;
            dps[j++] = (LSL_Integer)saveDPVer;
            for (int i = 0; i < len; i ++) {
                DetectParams dp = m_DetectParams[i];
                dps[j++] = (LSL_String)dp.Key.ToString();    // UUID
                dps[j++] = dp.OffsetPos;                     // vector
                dps[j++] = (LSL_Integer)dp.LinkNum;          // integer
                dps[j++] = (LSL_String)dp.Group.ToString();  // UUID
                dps[j++] = (LSL_String)dp.Name;              // string
                dps[j++] = (LSL_String)dp.Owner.ToString();  // UUID
                dps[j++] = dp.Position;                      // vector
                dps[j++] = dp.Rotation;                      // rotation
                dps[j++] = (LSL_Integer)dp.Type;             // integer
                dps[j++] = dp.Velocity;                      // vector
                dps[j++] = dp.TouchST;                       // vector
                dps[j++] = dp.TouchNormal;                   // vector
                dps[j++] = dp.TouchBinormal;                 // vector
                dps[j++] = dp.TouchPos;                      // vector
                dps[j++] = dp.TouchUV;                       // vector
                dps[j++] = (LSL_Integer)dp.TouchFace;        // integer
            }
            return new LSL_List (dps);
        }

        /**
         * @brief Load current detect params from a list
         * @param dpList = as returned by xmrEventSaveDets()
         */
        public override void xmrEventLoadDets (LSL_List dpList)
        {
            object[] objs = dpList.Data;
            int j = 0;
            if ((objs.Length % 16 != 1) || (ListInt (objs[j++]) != saveDPVer)) {
                throw new Exception ("invalid detect param format");
            }

            int len = objs.Length / 16;
            DetectParams[] dps = new DetectParams[len];
            SurfaceTouchEventArgs stea = new SurfaceTouchEventArgs ();

            for (int i = 0; i < len; i ++) {
                DetectParams dp = new DetectParams ();

                dp.Key         = new UUID (ListStr (objs[j++]));
                dp.OffsetPos   = (LSL_Vector)objs[j++];
                dp.LinkNum     = ListInt (objs[j++]);
                dp.Group       = new UUID (ListStr (objs[j++]));
                dp.Name        = ListStr (objs[j++]);
                dp.Owner       = new UUID (ListStr (objs[j++]));
                dp.Position    = (LSL_Vector)objs[j++];
                dp.Rotation    = (LSL_Rotation)objs[j++];
                dp.Type        = ListInt (objs[j++]);
                dp.Velocity    = (LSL_Vector)objs[j++];

                stea.STCoord   = LSLVec2OMVec ((LSL_Vector)objs[j++]);
                stea.Normal    = LSLVec2OMVec ((LSL_Vector)objs[j++]);
                stea.Binormal  = LSLVec2OMVec ((LSL_Vector)objs[j++]);
                stea.Position  = LSLVec2OMVec ((LSL_Vector)objs[j++]);
                stea.UVCoord   = LSLVec2OMVec ((LSL_Vector)objs[j++]);
                stea.FaceIndex = ListInt (objs[j++]);

                dp.SurfaceTouchArgs = stea;

                dps[i] = dp;
            }

            m_DetectParams = dps;
        }

        /**
         * @brief The script is executing a 'state <newState>;' command.
         * Tell outer layers to cancel any event triggers, like llListen(),
         * then tell outer layers which events the new state has handlers for.
         * We also clear the event queue as per http://wiki.secondlife.com/wiki/State
         */
        public void StateChange()
        {
            /*
             * Cancel any llListen()s etc.
             * But llSetTimerEvent() should persist.
             */
            object[] timers = m_XMRLSLApi.acm.TimerPlugin.GetSerializationData(m_ItemID);
            AsyncCommandManager.RemoveScript(m_Engine, m_LocalID, m_ItemID);
            m_XMRLSLApi.acm.TimerPlugin.CreateFromData(m_LocalID, m_ItemID, UUID.Zero, timers);

            /*
             * Tell whoever cares which event handlers the new state has.
             */
            m_Part.SetScriptEvents(m_ItemID, GetStateEventFlags(stateCode));

            /*
             * Clear out any old events from the queue.
             */
            lock (m_QueueLock) {
                m_EventQueue.Clear();
                for (int i = m_EventCounts.Length; -- i >= 0;) m_EventCounts[i] = 0;
            }
        }

        /**
         * @brief Script is calling xmrStackLeft().
         */
        public override int xmrStackLeft()
        {
            return (int)MMRUThread.StackLeft();
        }
    }

    /**
     * @brief Thrown by things like llResetScript() to unconditionally
     *        unwind as script and reset it to the default state_entry
     *        handler.  We don't want script-level try/catch to intercept
     *        these so scripts can't interfere with the behavior.
     */
    public class ScriptResetException : Exception, IXMRUncatchable { }

    /**
     * @brief Thrown by things like llDie() to unconditionally unwind as 
     *        script.  We don't want script-level try/catch to intercept
     *        these so scripts can't interfere with the behavior.
     */
    public class ScriptDieException : Exception, IXMRUncatchable { }
}
