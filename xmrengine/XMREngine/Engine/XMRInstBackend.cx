//////////////////////////////////////////////////////////////
//
// Copyright (c) 2009 Careminster Limited and Melanie Thielker
// Copyright (c) 2010 Mike Rieker, Beverly, MA, USA
//
// All rights reserved
//

using System;
using System.Threading;
using System.Reflection;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.Remoting.Lifetime;
using System.Security.Policy;
using System.IO;
using System.Xml;
using System.Text;
using Mono.Tasklets;
using OpenMetaverse;
using OpenSim.Framework;
using OpenSim.Region.ScriptEngine.Interfaces;
using OpenSim.Region.ScriptEngine.Shared;
using OpenSim.Region.ScriptEngine.Shared.Api;
using OpenSim.Region.ScriptEngine.Shared.ScriptBase;
using OpenSim.Region.ScriptEngine.XMREngine;
using OpenSim.Region.Framework.Scenes;
using log4net;

#include "lsltypes.h"

namespace OpenSim.Region.ScriptEngine.XMREngine
{
    /****************************************************\
     *  This file contains routines called by scripts.  *
    \****************************************************/

    public class XMRLSL_Api : LSL_Api
    {
        protected override void ScriptSleep(int delay)
        {
            if (m_ScriptEngine is XMREngine)
            {
                XMREngine e = (XMREngine)m_ScriptEngine;

                e.GetInstance(m_itemID).Sleep(delay);
            }
            else
            {
                base.ScriptSleep(delay);
            }
        }

        public override void llSleep(double sec)
        {
            if (m_ScriptEngine is XMREngine)
            {
                XMREngine e = (XMREngine)m_ScriptEngine;

                e.GetInstance(m_itemID).Sleep((int)(sec * 1000.0));
            }
            else
            {
                base.llSleep(sec);
            }
        }

        public override void llDie()
        {
            if (m_ScriptEngine is XMREngine)
            {
                XMREngine e = (XMREngine)m_ScriptEngine;

                e.GetInstance(m_itemID).Die();
            }
            else
            {
                base.llDie();
            }
        }

        public override LSL_Integer llGetFreeMemory()
        {
            if (m_ScriptEngine is XMREngine)
            {
                XMREngine e = (XMREngine)m_ScriptEngine;

                return new LSL_Integer(e.GetInstance(m_itemID).heapLeft);
            }
            else
            {
                return base.llGetFreeMemory();
            }
        }
    }

    public partial class XMRInstance
    {
        /**
         * @brief The script is calling llReset().
         *        We throw an exception to unwind the script out to its main
         *        causing all the finally's to execute and it will also set
         *        eventCode = None to indicate event handler has completed.
         */
        public void ApiReset()
        {
            m_Die = false;
            throw new XMRScriptResetException();
        }

        /**
         * @brief Called by consoleWrite(string) call.
         */
        public override void ConsoleWrite (string s)
        {
            Console.WriteLine ("XMRInstance.ConsoleWrite: " + this.m_DescName + ": " + s);
        }

        /**
         * @brief The script is calling one of the llDetected...(int number)
         *        functions.  Return corresponding DetectParams pointer.
         */
        public DetectParams GetDetectParams(int number)
        {
            if (m_DetectParams == null)
                return null;

            if (number < 0 || number >= m_DetectParams.Length)
                return null;

            return m_DetectParams[number];
        }

        /**
         * @brief Script is calling llDie, so flag the run loop to delete script
         *        once we are off the microthread stack, and throw an exception
         *        to unwind the stack asap.
         */
        public void Die()
        {
            // llDie doesn't work in attachments!
            if (m_Part.ParentGroup.RootPart.IsAttachment || m_DetachQuantum > 0)
                return;

            m_Die = true;
            throw new XMRScriptResetException();
        }

        /**
         * @brief Called by script to sleep for the given number of milliseconds.
         */
        public void Sleep(int ms)
        {
            lock (m_QueueLock) {

                /*
                 * Say how long to sleep.
                 */
                m_SleepUntil = DateTime.UtcNow + TimeSpan.FromMilliseconds(ms);

                /*
                 * Don't wake on any events.
                 */
                m_SleepEventMask1 = 0;
                m_SleepEventMask2 = 0;
            }

            /*
             * The compiler follows all calls to llSleep() with a call to CheckRun().
             * So tell CheckRun() to suspend the microthread.
             */
            suspendOnCheckRunTemp = true;
        }

        /**
         * Block script execution until an event is queued or a timeout is reached.
         * @param timeout = maximum number of seconds to wait
         * @param returnMask = if event is queued that matches these mask bits,
         *                     the script is woken, that event is dequeued and
         *                     returned to the caller.  The event handler is not
         *                     executed.
         * @param backgroundMask = if any of these events are queued while waiting,
         *                         execute their event handlers.  When any such event
         *                         handler exits, continue waiting for events or the
         *                         timeout.
         * @param line = linenumber in script of the call
         * @returns empty list: no event was queued that matched returnMask and the timeout was reached
         *                      or a background event handler changed state (eg, via 'state' statement)
         *                else: list giving parameters of the event:
         *                      [0] = event code (integer)
         *                   [1..n] = call parameters to the event, if any
         * Notes:
         *   1) Scrips should use XMREVENTMASKn_<eventname> symbols for the mask arguments,
         *      where n is 1 or 2 for mask1 or mask2 arguments.
         *      The list[0] return argument can be decoded by using XMREVENTCODE_<eventname> symbols.
         *   2) If all masks are zero, the call ends up acting like llSleep.
         *   3) If an event is enabled in both returnMask and backgroundMask, the returnMask bit
         *      action takes precedence, ie, the event is returned.  This allows a simple specification
         *      of -1 for both backgroundMask arguments to indicate that all events not listed in
         *      the returnMask argumetns should be handled in the background.
         *   4) Any events not listed in either returnMask or backgroundMask arguments will be
         *      queued for later processing (subject to normal queue limits).
         *   5) Background event handlers execute as calls from within XMREventDequeue, they do
         *      not execute as separate threads.  Thus any background event handlers must return
         *      before the call to xmrEventDequeue will return.
         *   6) If a background event handler changes state (eg, via 'state' statement), the state
         *      is immediately changed and the script-level xmrEventDequeue call does not return.
         *   7) For returned events, the detect parameters are overwritten by the returned event.
         *      For background events, the detect parameters are saved and restored.
         *   8) Scripts must contain dummy event handler definitions for any event types that may 
         *      be returned by XMREventDequeue, to let the runtime know that the script is capable 
         *      of processing that event type.  Otherwise, the event may not be queued to the script.
         */
        private static LSL_List emptyList = new LSL_List (new object[0]);

        [MMRContableAttribute ()]
        public override LSL_List XMREventDequeue (SCRIPTFLOAT timeout, int returnMask1, int returnMask2, 
                                                  int backgroundMask1, int backgroundMask2, int line)
        {
            DateTime sleepUntil = DateTime.UtcNow + TimeSpan.FromMilliseconds (timeout * 1000.0);
            EventParams evt = null;
            int evc1, evc2;
            int mask1 = returnMask1 | backgroundMask1;  // codes 00..31
            int mask2 = returnMask2 | backgroundMask2;  // codes 32..63
            LinkedListNode<EventParams> lln = null;
            ScriptEventCode evc;

            do {

                /*
                 * Find first event that matches either the return or background masks.
                 */
                Monitor.Enter (m_QueueLock);
                for (lln = m_EventQueue.First; lln != null; lln = lln.Next) {
                    evt  = lln.Value;
                    evc  = (ScriptEventCode)Enum.Parse (typeof (ScriptEventCode), evt.EventName);
                    evc1 = (int)evc;
                    evc2 = evc1 - 32;
                    if ((((uint)evc1 < (uint)32) && (((mask1 >> evc1) & 1) != 0)) ||
                        (((uint)evc2 < (uint)32) && (((mask2 >> evc2) & 1) != 0))) goto remfromq;
                }

                /*
                 * Nothing found, sleep while one comes in.
                 */
                m_SleepUntil = sleepUntil;
                m_SleepEventMask1 = mask1;
                m_SleepEventMask2 = mask2;
                Monitor.Exit (m_QueueLock);
                suspendOnCheckRunTemp = true;
                CheckRun (line);
                continue;

                /*
                 * Found one, remove it from queue.
                 */
            remfromq:
                m_EventQueue.Remove (lln);
                m_EventCounts[evc1] --;
                Monitor.Exit (m_QueueLock);

                /*
                 * See if returnable or background event.
                 */
                if ((((uint)evc1 < (uint)32) && (((returnMask1 >> evc1) & 1) != 0)) ||
                    (((uint)evc2 < (uint)32) && (((returnMask2 >> evc2) & 1) != 0))) {

                    /*
                     * Returnable event, return its parameters in a list.
                     * Also set the detect parameters to what the event has.
                     */
                    int plen = evt.Params.Length;
                    object[] plist = new object[plen+1];
                    plist[0] = (LSL_Integer)evc1;
                    for (int i = 0; i < plen;) {
                        object ob = evt.Params[i];
                             if (ob is int)         ob = (LSL_Integer)(int)ob;
                        else if (ob is SCRIPTFLOAT) ob = (LSL_Float)(SCRIPTFLOAT)ob;
                        else if (ob is string)      ob = (LSL_String)(string)ob;
                        plist[++i] = ob;
                    }
                    m_DetectParams = evt.DetectParams;
                    return new LSL_List (plist);
                }

                /*
                 * It is a background event, simply call its event handler,
                 * then check event queue again.
                 */
                ScriptEventHandler seh = objCode.scriptEventHandlerTable[stateCode,evc1];
                if (seh != null) {
                    DetectParams[]  saveDetParams = this.m_DetectParams;
                    object[]        saveEHArgs    = this.ehArgs;
                    ScriptEventCode saveEventCode = this.eventCode;

                    this.m_DetectParams = evt.DetectParams;
                    this.ehArgs         = evt.Params;
                    this.eventCode      = evc;

                    seh (this);

                    this.m_DetectParams = saveDetParams;
                    this.ehArgs         = saveEHArgs;
                    this.eventCode      = saveEventCode;
                }

                /*
                 * Keep waiting until we find a returnable event or timeout.
                 * Also stop waiting if a background event handler changed state.
                 */
            } while (!stateChanged && (DateTime.UtcNow < sleepUntil));

            /*
             * We timed out or background event handler changed state, return an empty list.
             */
            return emptyList;
        }

        /**
         * @brief Save current detect params into a list
         * @returns a list containing current detect param values
         */
        private const int saveDPVer = 1;

        [MMRContableAttribute ()]
        public override LSL_List XMREventSaveDets ()
        {
            int len = m_DetectParams.Length;
            object[] dps = new object[len*16+1];
            int j = 0;
            dps[j++] = (LSL_Integer)saveDPVer;
            for (int i = 0; i < len; i ++) {
                DetectParams dp = m_DetectParams[i];
                dps[j++] = (LSL_String)dp.Key.ToString();    // UUID
                dps[j++] = dp.OffsetPos;                     // vector
                dps[j++] = (LSL_Integer)dp.LinkNum;          // integer
                dps[j++] = (LSL_String)dp.Group.ToString();  // UUID
                dps[j++] = (LSL_String)dp.Name;              // string
                dps[j++] = (LSL_String)dp.Owner.ToString();  // UUID
                dps[j++] = dp.Position;                      // vector
                dps[j++] = dp.Rotation;                      // rotation
                dps[j++] = (LSL_Integer)dp.Type;             // integer
                dps[j++] = dp.Velocity;                      // vector
                dps[j++] = dp.TouchST;                       // vector
                dps[j++] = dp.TouchNormal;                   // vector
                dps[j++] = dp.TouchBinormal;                 // vector
                dps[j++] = dp.TouchPos;                      // vector
                dps[j++] = dp.TouchUV;                       // vector
                dps[j++] = (LSL_Integer)dp.TouchFace;        // integer
            }
            return new LSL_List (dps);
        }

        /**
         * @brief Load current detect params from a list
         * @param dpList = as returned by XMREventSaveDets()
         */
        [MMRContableAttribute ()]
        public override void XMREventLoadDets (LSL_List dpList)
        {
            object[] objs = dpList.Data;
            int j = 0;
            if ((objs.Length % 16 != 1) || (ListInt (objs[j++]) != saveDPVer)) {
                throw new Exception ("invalid detect param format");
            }

            int len = objs.Length / 16;
            DetectParams[] dps = new DetectParams[len];
            SurfaceTouchEventArgs stea = new SurfaceTouchEventArgs ();

            for (int i = 0; i < len; i ++) {
                DetectParams dp = new DetectParams ();

                dp.Key         = new UUID (ListStr (objs[j++]));
                dp.OffsetPos   = (LSL_Vector)objs[j++];
                dp.LinkNum     = ListInt (objs[j++]);
                dp.Group       = new UUID (ListStr (objs[j++]));
                dp.Name        = ListStr (objs[j++]);
                dp.Owner       = new UUID (ListStr (objs[j++]));
                dp.Position    = (LSL_Vector)objs[j++];
                dp.Rotation    = (LSL_Rotation)objs[j++];
                dp.Type        = ListInt (objs[j++]);
                dp.Velocity    = (LSL_Vector)objs[j++];

                stea.STCoord   = LSLVec2OMVec ((LSL_Vector)objs[j++]);
                stea.Normal    = LSLVec2OMVec ((LSL_Vector)objs[j++]);
                stea.Binormal  = LSLVec2OMVec ((LSL_Vector)objs[j++]);
                stea.Position  = LSLVec2OMVec ((LSL_Vector)objs[j++]);
                stea.UVCoord   = LSLVec2OMVec ((LSL_Vector)objs[j++]);
                stea.FaceIndex = ListInt (objs[j++]);

                dp.SurfaceTouchArgs = stea;

                dps[i] = dp;
            }

            m_DetectParams = dps;
        }
            

        /**
         * @brief The script is executing a 'state <newState>;' command.
         * Tell outer layers to cancel any event triggers, like llListen(),
         * then tell outer layers which events the new state has handlers for.
         */
        public void StateChange()
        {
            AsyncCommandManager.StateChange(m_Engine, m_LocalID, m_ItemID);
            m_Part.SetScriptEvents(m_ItemID, 
                                   GetStateEventFlags(stateCode));
        }

        /**
         * @brief Script is calling xmrStackLeft().
         */
        public override int StackLeft()
        {
            return (int)MMRUThread.StackLeft();
        }
    }

    public class XMRScriptResetException : Exception { }
}
