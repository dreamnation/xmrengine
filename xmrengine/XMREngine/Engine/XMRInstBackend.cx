//////////////////////////////////////////////////////////////
//
// Copyright (c) 2009 Careminster Limited and Melanie Thielker
// Copyright (c) 2010 Mike Rieker, Beverly, MA, USA
//
// All rights reserved
//

using System;
using System.Threading;
using System.Reflection;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.Remoting.Lifetime;
using System.Security.Policy;
using System.IO;
using System.Xml;
using System.Text;
using Mono.Tasklets;
using OpenMetaverse;
using OpenSim.Framework;
using OpenSim.Region.ScriptEngine.Interfaces;
using OpenSim.Region.ScriptEngine.Shared;
using OpenSim.Region.ScriptEngine.Shared.Api;
using OpenSim.Region.ScriptEngine.Shared.ScriptBase;
using OpenSim.Region.ScriptEngine.XMREngine;
using OpenSim.Region.Framework.Scenes;
using log4net;

#include "lsltypes.h"

namespace OpenSim.Region.ScriptEngine.XMREngine
{
    /****************************************************\
     *  This file contains routines called by scripts.  *
    \****************************************************/

    public class XMRLSL_Api : LSL_Api
    {
        protected override void ScriptSleep(int ms)
        {
            XMREngine e = (XMREngine)m_ScriptEngine;
            XMRInstance inst = e.GetInstance(m_itemID);
            inst.Sleep(ms);
        }

        public override void llSleep(double sec)
        {
            XMREngine e = (XMREngine)m_ScriptEngine;
            XMRInstance inst = e.GetInstance(m_itemID);
            inst.Sleep((int)(sec * 1000.0));
        }

        public override void llDie()
        {
            XMREngine e = (XMREngine)m_ScriptEngine;
            XMRInstance inst = e.GetInstance(m_itemID);
            inst.Die();
        }

        /* Can't override in latest OpenSim ---
         * Scripts can use xmrHeapLeft() and xmrStackLeft() if they want
        public override LSL_Integer llGetFreeMemory()
        {
            XMREngine e = (XMREngine)m_ScriptEngine;
            XMRInstance inst = e.GetInstance(m_itemID);
            return new LSL_Integer(inst.heapLeft);
        }*/
    }

    public partial class XMRInstance
    {
        /**
         * @brief The script is calling llReset().
         *        We throw an exception to unwind the script out to its main
         *        causing all the finally's to execute and it will also set
         *        eventCode = None to indicate event handler has completed.
         */
        public void ApiReset()
        {
            throw new ScriptResetException();
        }

        /**
         * @brief Called by consoleWrite(string) call.
         */
        public override void ConsoleWrite (string s)
        {
            Console.WriteLine ("XMRInstance.ConsoleWrite: " + this.m_DescName + ": " + s);
        }

        /**
         * @brief The script is calling one of the llDetected...(int number)
         *        functions.  Return corresponding DetectParams pointer.
         */
        public DetectParams GetDetectParams(int number)
        {
            if (m_DetectParams == null)
                return null;

            if (number < 0 || number >= m_DetectParams.Length)
                return null;

            return m_DetectParams[number];
        }

        /**
         * @brief Script is calling llDie, so flag the run loop to delete script
         *        once we are off the microthread stack, and throw an exception
         *        to unwind the stack asap.
         */
        public void Die()
        {
            // llDie doesn't work in attachments!
///???            if (m_Part.ParentGroup.RootPart.IsAttachment || m_DetachQuantum > 0)
///???                return;

            throw new ScriptDieException();
        }

        /**
         * @brief Called by script to sleep for the given number of milliseconds.
         */
        public void Sleep(int ms)
        {
            lock (m_QueueLock) {

                /*
                 * Say how long to sleep.
                 */
                m_SleepUntil = DateTime.UtcNow + TimeSpan.FromMilliseconds(ms);

                /*
                 * Don't wake on any events.
                 */
                m_SleepEventMask1 = 0;
                m_SleepEventMask2 = 0;
            }

            /*
             * The compiler follows all calls to llSleep() with a call to CheckRun().
             * So tell CheckRun() to suspend the microthread.
             */
            suspendOnCheckRunTemp = true;
        }

        /**
         * Block script execution until an event is queued or a timeout is reached.
         * @param timeout = maximum number of seconds to wait
         * @param returnMask = if event is queued that matches these mask bits,
         *                     the script is woken, that event is dequeued and
         *                     returned to the caller.  The event handler is not
         *                     executed.
         * @param backgroundMask = if any of these events are queued while waiting,
         *                         execute their event handlers.  When any such event
         *                         handler exits, continue waiting for events or the
         *                         timeout.
         * @param line = linenumber in script of the call
         * @returns empty list: no event was queued that matched returnMask and the timeout was reached
         *                      or a background event handler changed state (eg, via 'state' statement)
         *                else: list giving parameters of the event:
         *                      [0] = event code (integer)
         *                   [1..n] = call parameters to the event, if any
         * Notes:
         *   1) Scrips should use XMREVENTMASKn_<eventname> symbols for the mask arguments,
         *      where n is 1 or 2 for mask1 or mask2 arguments.
         *      The list[0] return argument can be decoded by using XMREVENTCODE_<eventname> symbols.
         *   2) If all masks are zero, the call ends up acting like llSleep.
         *   3) If an event is enabled in both returnMask and backgroundMask, the returnMask bit
         *      action takes precedence, ie, the event is returned.  This allows a simple specification
         *      of -1 for both backgroundMask arguments to indicate that all events not listed in
         *      the returnMask argumetns should be handled in the background.
         *   4) Any events not listed in either returnMask or backgroundMask arguments will be
         *      queued for later processing (subject to normal queue limits).
         *   5) Background event handlers execute as calls from within XMREventDequeue, they do
         *      not execute as separate threads.  Thus any background event handlers must return
         *      before the call to xmrEventDequeue will return.
         *   6) If a background event handler changes state (eg, via 'state' statement), the state
         *      is immediately changed and the script-level xmrEventDequeue call does not return.
         *   7) For returned events, the detect parameters are overwritten by the returned event.
         *      For background events, the detect parameters are saved and restored.
         *   8) Scripts must contain dummy event handler definitions for any event types that may 
         *      be returned by XMREventDequeue, to let the runtime know that the script is capable 
         *      of processing that event type.  Otherwise, the event may not be queued to the script.
         */
        private static LSL_List emptyList = new LSL_List (new object[0]);

        public override LSL_List XMREventDequeue (SCRIPTFLOAT timeout, int returnMask1, int returnMask2, 
                                                  int backgroundMask1, int backgroundMask2, int line)
        {
            DateTime sleepUntil = DateTime.UtcNow + TimeSpan.FromMilliseconds (timeout * 1000.0);
            EventParams evt = null;
            int callNo, evc1, evc2;
            int mask1 = returnMask1 | backgroundMask1;  // codes 00..31
            int mask2 = returnMask2 | backgroundMask2;  // codes 32..63
            LinkedListNode<EventParams> lln = null;
            object[] sv;
            ScriptEventCode evc;

            if (callMode == 0) goto findevent;
            sv          = RestoreStackFrame ("XMREventDequeue", out callNo);
            sleepUntil  = DateTime.Parse ((string)sv[0]);
            returnMask1 = (int)sv[1];
            returnMask2 = (int)sv[2];
            mask1       = (int)sv[3];
            mask2       = (int)sv[4];
            line        = (int)sv[5];
            goto __call0;

            /*
             * Find first event that matches either the return or background masks.
             */
        findevent:
            Monitor.Enter (m_QueueLock);
            for (lln = m_EventQueue.First; lln != null; lln = lln.Next) {
                evt  = lln.Value;
                evc  = (ScriptEventCode)Enum.Parse (typeof (ScriptEventCode), evt.EventName);
                evc1 = (int)evc;
                evc2 = evc1 - 32;
                if ((((uint)evc1 < (uint)32) && (((mask1 >> evc1) & 1) != 0)) ||
                    (((uint)evc2 < (uint)32) && (((mask2 >> evc2) & 1) != 0))) goto remfromq;
            }

            /*
             * Nothing found, sleep while one comes in.
             */
            m_SleepUntil = sleepUntil;
            m_SleepEventMask1 = mask1;
            m_SleepEventMask2 = mask2;
            Monitor.Exit (m_QueueLock);
            suspendOnCheckRunTemp = true;
        __call0:
            try {
                CheckRun (line);
            } finally {
                if (callMode != 0) {
                    sv    = CaptureStackFrame ("XMREventDequeue", 0, 6);
                    sv[0] = sleepUntil.ToString ();
                    sv[1] = returnMask1;
                    sv[2] = returnMask2;
                    sv[3] = mask1;
                    sv[4] = mask2;
                    sv[5] = line;
                }
            }
            goto checktmo;

            /*
             * Found one, remove it from queue.
             */
        remfromq:
            m_EventQueue.Remove (lln);
            m_EventCounts[evc1] --;
            Monitor.Exit (m_QueueLock);

            /*
             * See if returnable or background event.
             */
            if ((((uint)evc1 < (uint)32) && (((returnMask1 >> evc1) & 1) != 0)) ||
                (((uint)evc2 < (uint)32) && (((returnMask2 >> evc2) & 1) != 0))) {

                /*
                 * Returnable event, return its parameters in a list.
                 * Also set the detect parameters to what the event has.
                 */
                int plen = evt.Params.Length;
                object[] plist = new object[plen+1];
                plist[0] = (LSL_Integer)evc1;
                for (int i = 0; i < plen;) {
                    object ob = evt.Params[i];
                         if (ob is int)         ob = (LSL_Integer)(int)ob;
                    else if (ob is SCRIPTFLOAT) ob = (LSL_Float)(SCRIPTFLOAT)ob;
                    else if (ob is string)      ob = (LSL_String)(string)ob;
                    plist[++i] = ob;
                }
                m_DetectParams = evt.DetectParams;
                return new LSL_List (plist);
            }

            /*
             * It is a background event, simply call its event handler,
             * then check event queue again.
             */
            ScriptEventHandler seh = objCode.scriptEventHandlerTable[stateCode,evc1];
            if (seh != null) {
                DetectParams[]  saveDetParams = this.m_DetectParams;
                object[]        saveEHArgs    = this.ehArgs;
                ScriptEventCode saveEventCode = this.eventCode;

                this.m_DetectParams = evt.DetectParams;
                this.ehArgs         = evt.Params;
                this.eventCode      = evc;

                seh (this);

                this.m_DetectParams = saveDetParams;
                this.ehArgs         = saveEHArgs;
                this.eventCode      = saveEventCode;
            }

            /*
             * Keep waiting until we find a returnable event or timeout.
             * Also stop waiting if a background event handler changed state.
             */
        checktmo:
            if (!stateChanged && (DateTime.UtcNow < sleepUntil)) goto findevent;

            /*
             * We timed out or background event handler changed state, return an empty list.
             */
            return emptyList;
        }

        /**
         * @brief Enqueue an event
         * @param ev = as returned by XMREventDequeue saying which event type to queue
         *             and what argument list to pass to it.  The llDetect...() parameters
         *             are as currently set for the script (use xmrEventLoadDets to set how
         *             you want them to be different).
         */
        public override void XMREventEnqueue (LSL_List ev)
        {

            object[] data = ev.Data;
            ScriptEventCode evc = (ScriptEventCode)ListInt (data[0]);

            int nargs = data.Length - 1;
            object[] args = new object[nargs];
            Array.Copy (data, 1, args, 0, nargs);

            PostEvent (new EventParams (evc.ToString (), args, m_DetectParams));
        }

        /**
         * @brief Call the current state's event handler.
         * @param ev = as returned by XMREventDequeue saying which event handler to call
         *             and what argument list to pass to it.  The llDetect...() parameters
         *             are as currently set for the script (use xmrEventLoadDets to set how
         *             you want them to be different).
         */
        public override void XMREventCallHandler (LSL_List ev)
        {
            object[] data = ev.Data;
            int evc = ListInt (data[0]);
            ScriptEventHandler seh = objCode.scriptEventHandlerTable[stateCode,evc];
            if (seh != null) {
                int nargs = data.Length - 1;
                object[] args = new object[nargs];
                Array.Copy (data, 1, args, 0, nargs);

                object[]        saveEHArgs    = this.ehArgs;
                ScriptEventCode saveEventCode = this.eventCode;

                this.ehArgs    = args;
                this.eventCode = (ScriptEventCode)evc;

                seh (this);

                this.ehArgs    = saveEHArgs;
                this.eventCode = saveEventCode;
            }
        }

        /**
         * @brief Save current detect params into a list
         * @returns a list containing current detect param values
         */
        private const int saveDPVer = 1;

        public override LSL_List XMREventSaveDets ()
        {
            int len = m_DetectParams.Length;
            object[] dps = new object[len*16+1];
            int j = 0;
            dps[j++] = (LSL_Integer)saveDPVer;
            for (int i = 0; i < len; i ++) {
                DetectParams dp = m_DetectParams[i];
                dps[j++] = (LSL_String)dp.Key.ToString();    // UUID
                dps[j++] = dp.OffsetPos;                     // vector
                dps[j++] = (LSL_Integer)dp.LinkNum;          // integer
                dps[j++] = (LSL_String)dp.Group.ToString();  // UUID
                dps[j++] = (LSL_String)dp.Name;              // string
                dps[j++] = (LSL_String)dp.Owner.ToString();  // UUID
                dps[j++] = dp.Position;                      // vector
                dps[j++] = dp.Rotation;                      // rotation
                dps[j++] = (LSL_Integer)dp.Type;             // integer
                dps[j++] = dp.Velocity;                      // vector
                dps[j++] = dp.TouchST;                       // vector
                dps[j++] = dp.TouchNormal;                   // vector
                dps[j++] = dp.TouchBinormal;                 // vector
                dps[j++] = dp.TouchPos;                      // vector
                dps[j++] = dp.TouchUV;                       // vector
                dps[j++] = (LSL_Integer)dp.TouchFace;        // integer
            }
            return new LSL_List (dps);
        }

        /**
         * @brief Load current detect params from a list
         * @param dpList = as returned by XMREventSaveDets()
         */
        public override void XMREventLoadDets (LSL_List dpList)
        {
            object[] objs = dpList.Data;
            int j = 0;
            if ((objs.Length % 16 != 1) || (ListInt (objs[j++]) != saveDPVer)) {
                throw new Exception ("invalid detect param format");
            }

            int len = objs.Length / 16;
            DetectParams[] dps = new DetectParams[len];
            SurfaceTouchEventArgs stea = new SurfaceTouchEventArgs ();

            for (int i = 0; i < len; i ++) {
                DetectParams dp = new DetectParams ();

                dp.Key         = new UUID (ListStr (objs[j++]));
                dp.OffsetPos   = (LSL_Vector)objs[j++];
                dp.LinkNum     = ListInt (objs[j++]);
                dp.Group       = new UUID (ListStr (objs[j++]));
                dp.Name        = ListStr (objs[j++]);
                dp.Owner       = new UUID (ListStr (objs[j++]));
                dp.Position    = (LSL_Vector)objs[j++];
                dp.Rotation    = (LSL_Rotation)objs[j++];
                dp.Type        = ListInt (objs[j++]);
                dp.Velocity    = (LSL_Vector)objs[j++];

                stea.STCoord   = LSLVec2OMVec ((LSL_Vector)objs[j++]);
                stea.Normal    = LSLVec2OMVec ((LSL_Vector)objs[j++]);
                stea.Binormal  = LSLVec2OMVec ((LSL_Vector)objs[j++]);
                stea.Position  = LSLVec2OMVec ((LSL_Vector)objs[j++]);
                stea.UVCoord   = LSLVec2OMVec ((LSL_Vector)objs[j++]);
                stea.FaceIndex = ListInt (objs[j++]);

                dp.SurfaceTouchArgs = stea;

                dps[i] = dp;
            }

            m_DetectParams = dps;
        }

        /**
         * @brief Wrap osParseJSON() so we return an array to the script.
         *        No coherent example of its use in scripts on web found.
         * see http://www.json.org/ for more details on JSON
         */
        private static LSL_List nullList = new LSL_List (new object[0]);
        public override XMR_Array XMRosParseJSON (string json)
        {
            XMR_Array dict = new XMR_Array ();
            int idx = ParseJSON (dict, nullList, json, 0);
            while (idx < json.Length) {
                if (json[idx] > ' ') throw new Exception ("left-over json " + json);
                idx ++;
            }
            return dict;
        }

        private static int ParseJSON (XMR_Array dict, LSL_List keys, string json, int idx)
        {
            char c;

            while ((c = json[idx++]) <= ' ') { }
            switch (c) {

                // '{' <keystring> ':' <value> [ ',' <keystring> ':' <value> ... ] '}'
                case '{': {
                    do {
                        string key = ParseJSONString (json, ref idx);
                        while ((c = json[idx++]) <= ' ') { }
                        if (c != ':') throw new Exception ("missing : after key");
                        idx = ParseJSON (dict, ParseJSONKeyAdd (keys, key), json, idx);
                        while ((c = json[idx++]) <= ' ') { }
                    } while (c == ',');
                    if (c != '}') throw new Exception ("missing , or } after value");
                    break;
                }

                // '[' <value> [ ',' <value> ... ] ']'
                case '[': {
                    int index = 0;
                    do {
                        object key = index ++;
                        idx = ParseJSON (dict, ParseJSONKeyAdd (keys, key), json, idx);
                        while ((c = json[idx++]) <= ' ') { }
                    } while (c == ',');
                    if (c != ']') throw new Exception ("missing , or ] after value");
                    break;
                }

                // '"'<string>'"'
                case '"': {
                    -- idx;
                    string val = ParseJSONString (json, ref idx);
                    dict.SetByKey (keys, val);
                    break;
                }

                // true false null
                case 't': {
                    if (json.Substring (idx, 3) != "rue") throw new Exception ("bad true in json");
                    idx += 3;
                    dict.SetByKey (keys, 1);
                    break;
                }

                case 'f': {
                    if (json.Substring (idx, 4) != "alse") throw new Exception ("bad false in json");
                    idx += 4;
                    dict.SetByKey (keys, 0);
                    break;
                }

                case 'n': {
                    if (json.Substring (idx, 3) != "ull") throw new Exception ("bad null in json");
                    idx += 3;
                    dict.SetByKey (keys, null);
                    break;
                }

                // otherwise assume it's a number
                default: {
                    -- idx;
                    object val = ParseJSONNumber (json, ref idx);
                    dict.SetByKey (keys, val);
                    break;
                }
            }

            return idx;
        }

        // Given the key for a whole array, create a key for a given element of the array
        private static LSL_List ParseJSONKeyAdd (LSL_List oldkeys, object key)
        {
            int oldkeyslen = oldkeys.Length;
            object[] array = oldkeys.Data;
            Array.Resize<object> (ref array, oldkeyslen + 1);
            array[oldkeyslen] = key;
            return new LSL_List (array);
        }

        // Parse out a JSON string
        private static string ParseJSONString (string json, ref int idx)
        {
            char c;

            while ((c = json[idx++]) <= ' ') { }
            if (c != '"') throw new Exception ("bad start of json string");

            StringBuilder sb = new StringBuilder ();
            while ((c = json[idx++]) != '"') {
                if (c == '\\') {
                    c = json[idx++];
                    switch (c) {
                        case 'b': {
                            c = '\b';
                            break;
                        }
                        case 'f': {
                            c = '\f';
                            break;
                        }
                        case 'n': {
                            c = '\n';
                            break;
                        }
                        case 'r': {
                            c = '\r';
                            break;
                        }
                        case 't': {
                            c = '\t';
                            break;
                        }
                        case 'u': {
                            c = (char) Int32.Parse (json.Substring (idx, 4), 
                                                    System.Globalization.NumberStyles.HexNumber);
                            idx += 4;
                            break;
                        }
                        default: break;
                    }
                }
                sb.Append (c);
            }
            return sb.ToString ();
        }

        // Parse out a JSON number
        private static object ParseJSONNumber (string json, ref int idx)
        {
            char c;

            while ((c = json[idx++]) <= ' ') { }

            bool expneg = false;
            bool isneg  = false;
            int decpt   = -1;
            int expon   = 0;
            int ival    = 0;
            SCRIPTFLOAT dval = 0;

            if (c == '-') {
                isneg = true;
                c = json[idx++];
            }
            if ((c < '0') || (c > '9')) {
                throw new Exception ("bad json number");
            }
            while ((c >= '0') && (c <= '9')) {
                dval *= 10;
                ival *= 10;
                dval += c - '0';
                ival += c - '0';
                c = '\0';
                if (idx < json.Length) c = json[idx++];
            }
            if (c == '.') {
                decpt = 0;
                c = '\0';
                if (idx < json.Length) c = json[idx++];
                while ((c >= '0') && (c <= '9')) {
                    dval *= 10;
                    dval += c - '0';
                    decpt ++;
                    c = '\0';
                    if (idx < json.Length) c = json[idx++];
                }
            }
            if ((c == 'e') || (c == 'E')) {
                if (decpt < 0) decpt = 0;
                c = json[idx++];
                if (c == '-') expneg = true;
                if ((c == '-') || (c == '+')) c = json[idx++];
                while ((c >= '0') && (c <= '9')) {
                    expon *= 10;
                    expon += c - '0';
                    c = '\0';
                    if (idx < json.Length) c = json[idx++];
                }
                if (expneg) expon = -expon;
            }

            if (c != 0) -- idx;
            if (decpt < 0) {
                if (isneg) ival = -ival;
                return ival;
            } else {
                if (isneg) dval = -dval;
                dval *= Math.Pow (10, expon - decpt);
                return dval;
            }
        }

        /**
         * @brief The script is executing a 'state <newState>;' command.
         * Tell outer layers to cancel any event triggers, like llListen(),
         * then tell outer layers which events the new state has handlers for.
         */
        public void StateChange()
        {
///???            AsyncCommandManager.StateChange(m_Engine, m_LocalID, m_ItemID);
            m_Part.SetScriptEvents(m_ItemID, 
                                   GetStateEventFlags(stateCode));
        }

        /**
         * @brief Script is calling xmrStackLeft().
         */
        public override int StackLeft()
        {
            return (int)MMRUThread.StackLeft();
        }
    }

    /**
     * @brief Thrown by things like llResetScript() to unconditionally
     *        unwind as script and reset it to the default state_entry
     *        handler.  We don't want script-level try/catch to intercept
     *        these so scripts can't interfere with the behavior.
     */
    public class ScriptResetException : Exception, IXMRUncatchable { }

    /**
     * @brief Thrown by things like llDie() to unconditionally unwind as 
     *        script.  We don't want script-level try/catch to intercept
     *        these so scripts can't interfere with the behavior.
     */
    public class ScriptDieException : Exception, IXMRUncatchable { }
}
