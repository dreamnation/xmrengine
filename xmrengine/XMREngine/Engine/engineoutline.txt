
Significant entrypoints:

    engine.Initialise()
    engine.AddRegion()
    engine.RemoveRegion()
    engine.RegionLoaded()
    engine.StartProcessing()

    engine.PostScriptEvent() [2 incarnations]      // enqueue event via instance.PostEvent()
    engine.PostObjectEvent() [2 incarnations]      // enqueue event via instance.PostEvent()
    engine.SetScriptState()                        // set instance.Running = true/false (unlocked)
    engine.ApiResetScript()                        // call instance.ApiReset()
    engine.ResetScript() = engine.OnScriptReset()  // call instance.Reset()
    engine.GetXMLState()                           // snapshot of script state via instance.GetExecutionState() + object code
    engine.SetXMLState()                           // write .state and .xmrobj files from xml (called before OnRezScript()) (uses XMRInstance.m_CompileLock)
    engine.OnRezScript()                           // create script instance, compiling if necessary, via new XMRInstance() and engine.QueueToStart()
    engine.OnRemoveScript()                        // delete script instance, via instance.suspendOnCheckRunHold = true, delete .state file and instance.Dispose()
    engine.OnStartScript()                         // instance.Running = true
    engine.OnStopScript()                          // instance.Running = false
    engine.QueueToStart()                          // [internal] queue instance to StartQueue then wake up script thread
    engine.WakeFromSleep()                         // [internal] move thread from SleepQueue and put on YieldQueue then wake up script thread
    engine.Suspend()                               // call instance.Sleep(ms)
    engine.Die()                                   // call instance.Die()
    engine.SuspendScript()                         // call instance.SUspend()
    engine.ResumeScript()                          // call instance.Resume()
    engine.RegisterInstance()                      // [internal] add instance to engine's itemID->instance dictionary

engine.DoMaintenance()
    instance.GetExecutionState()
        suspendOnCheckRunHold = true                // get CheckRun() to suspend microthread asap
        with instance.m_RunLock:                    // wait for microthread to suspend and block it from resuming
            instance.MigrateOutEventHandler()       // get copy of script globals and stack
                instance.captureStackFrames = true
                instance.microthread.Resume()       // get stack frames pushed to instance.stackFrames (wipes microthread out)
                instance.captureStackFrames = false
                save stack frames
                this.stackFramesRestored = false
                instance.microthread.Start()        // restore microthread stack from instance.stackFrames and clear instance.stackFrames
            capture other global script state
            suspendOnCheckRunHold = false           // allow microthread to run normally
        write captured data to <instance>.state file

instance.Ctor()
    instance.m_IState = CONSTRUCT
    instance.InstantiateScript()
        with XMRInstance.m_CompileLock:
            instance.TryToCompile()
            instance.LoadObjCode()
            instance.LoadInitialState()
                if <instance>.state exists {
                    instance.LoadScriptState()
                } else {
                    instance.PostEvent("state_entry")
                }
                maybe post other events via instance.PostEvent()
    engine.RegisterInstance(instance)
    suspendOnCheckRunHold = false
    suspendOnCheckRunTemp = false

instance.Dispose()
    instance.suspendOnCheckRunHold = true           // suspend microthread on next call to CheckRun()
    with instance.m_RunLock:                        // wait for microthread to suspend and block it from starting again
        instance.microthread.Dispose()
        instance.microthread = null
    tell OpenSim to stop sending us events
    with XMRInstance.m_CompileLock:
        decrement instance.m_ObjCode refcount to gc script dynamic methods

// Running = true: accept new incoming events
//          false: ignore new incoming events
instance.Running set()
    with instance.m_QueueLock:
        instance.m_Running = value
        if (!value) {
            instance.m_EventQueue.Clear()
            instance.m_EventCounts[*] = 0

// Queue an incoming event to the script and maybe wake the script up
instance.PostEvent()
    with instance.m_QueueLock:
        if (!instance.m_Running) return             // ignore event if not running
        if instance.m_EventCounts++ too big, return // only queue so many of each event type
        instance.m_EventQueue.Add()                 // add new event somewhere in queue
        maybe transition instance.m_IState IDLE->ONSTARTQ
    if transitioned IDLE->ONSTARTQ, engine.QueueToStart()
    if event satisfied instance.m_SleepEventMask, engine.WakeFromSleep()

instance.Reset()                                   // called from outside script microthread context
                                                   // eg, clicking Reset button in script edit window
    transition state -> XMRInstState.RESETTING using various locks
    with instance.m_RunLock:
        reset instance.microthread stack
        instance.ResetLocked()
            various OpenSim calls to reset stuff
            clear instance.m_EventQueue
            reset other instance stuff
            queue default state_entry() event via instance.PostEvent()
            suspendOnCheckRun{Hold,Temp} = false

instance.Resume()
    with instance.m_QueueLock:
        m_Suspended = false
        engine.QueueToStart()
        m_HasRun = true

instance.Suspend()
    with instance.m_QueueLock:
        m_Suspended = true


/*************************************\
 *  SYSTEM THREAD THAT RUNS SCRIPTS  *
\*************************************/


engine.RunScriptThread()
    while (!engine.m_Exiting) {
        for instances on engine.m_StartQueue:
            instance.RunOne()
            engine.HandleNewIState(instance)
        move expired instance timers from engine.m_SleepQueue to engine.m_YieldQueue
        wait for an instance to be runnable (on engine.m_YieldQueue) and dequeue it
        instance.RunOne()                                               // run a little bit of one script
            if instance.m_SleepUntil unsatisfied, return ONSLEEPQ       // still in llSleep() interval
            if instance.m_SuspendCount unsatisfied, return SUSPENDED
            with instance.m_RunLock:                                    // get control of instance.microthread, don't unlock until microthread suspends or exits
                if instance.microthread == null, return DISPOSED        // instance.Dispose() has been called
                if instance.eventCode != ScriptEventCode.None {         // see if already handling an event
                    instance.microthread.Resume()                       //   if so, resume event handler where it left off until microthread suspends or exits
                } else {
                    with instance.m_QueueLock:                          // access the instance.m_EventQueue
                        if instance.m_Suspended, return FINISHED        // if suspended, pretend there is nothing for this script to do now
                        try to dequeue from instance.m_EventQueue
                        if queue was empty, return FINISHED
                    instance.StartEventHandler()                        // execute event handler until either it finishes or microthread suspends
                        instance.eventCode   = event to be processed
                        instance.ehArgs      = event arguments
                        instance.stackFrames = null                     // - start from beginning of handler (no stack frames to restore first)
                        instance.microthread.Start()
                    if script threw up {
                        instance.HandleScriptException()
                            instance.eventCode = ScriptEventCode.None   // no longer running an event handler, microthread stack is unwound
                            if ScriptDeleteException {
                                instance.m_SleepUntil = eternity
                                instance.m_Part.Inventory.RemoveInventoryItem()
                            } else if ScriptDieException {
                                instance.m_SleepUntil = eternity
                                engine.World.DeleteSceneObject()
                            } if ScriptResetException {
                                instance.ResetLocked()
                            } else {
                                instance.llOwnerSay(message)
                                instance.m_SleepUntil = eternity
                            }
                        return FINISHED
                    }
                }
            return ONYIELDQ
        engine.HandleNewIState(instance)
            switch (new state) {
                ONSLEEPQ:  put on sleep queue in ONSLEEPQ state
                ONYIELDQ:  put on yield queue in ONYIELDQ state
                FINISHED:  if events queued, put on start queue in ONSTARTQ state
                                       else, put in IDLE state
                SUSPENDED: put in SUSPENDED state
                DISPOSED:  put in DISPOSED state
            }
    }


/**********************************************\
 *  STUFF THAT RUNS ON THE MICROTHREAD STACK  *
\**********************************************/


// This is the script code and backend API calls running on the instance.microthread stack
// Start with:
//   instance.stateCode   = which state the script is in
//   instance.eventCode   = which event handler of that state to execute
//   instance.ehArgs      = arguments to pass to the event handler
//   instance.stackFrames = null: start event handler from the beginning
//                          else: resume event handler from this point
instance.microthread.Main()
    instance.callMode = CALLMODE_NORMAL or CALLMODE_RESTORE
    instance.microthread.CallSEH()
        instance.objCode.scriptEventHandlerTable[instance.stateCode,instance.eventCode]
            ...
                instance.CheckRun()
                    while (suspendOnCheckRunHold || suspendOnCheckRunTemp) {
                        if (instance.captureStackFrames) {
                            instance.callMode = CALLMODE_SAVE
                            throw StackCaptureException()
                        }
                        if (instance.callMode == CALLMODE_RESTORE) {
                            this.stackFramesRestore = true
                            instance.callMode = CALLMODE_NORMAL
                        }
                        instance.suspendOnCheckRunTemp = false
                        MMRUThread.Suspend()
                    }
        while (instance.stateChanged) {
            call old state's state_exit() handler if any
            set up new state code
            instance.StateChange()
            call new state's state_entry() handler if any
        }
        instance.eventCode = ScriptEventCode.None


// called from within script microthread context
// eg, calling llResetScript()
instance.ApiReset()
    throw ScriptResetException()


// called from within script microthread context
// eg, calling llDie()
instance.Die()
    throw ScriptDieException()


// called from within script microthread context
// eg, calling llSleep(s)
instance.Sleep(ms)
    with instance.m_QueueLock:
        m_SleepUntil = when to wake up
    suspendOnCheckRunTemp = true                   // next call to CheckRun() suspends microthread

