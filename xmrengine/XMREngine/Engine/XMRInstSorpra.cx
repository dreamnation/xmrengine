/***************************************************\
 *  COPYRIGHT 2013, Mike Rieker, Beverly, MA, USA  *
 *  All rights reserved.                           *
\***************************************************/

using log4net;
using OpenMetaverse;
using OpenSim.Framework;
using OpenSim.Region.Framework.Scenes;
using OpenSim.Region.ScriptEngine.Shared;
using System;
using System.Collections.Generic;
using System.Xml;

#include "lsltypes.h"

//#define SorpraDebug(msg) m_log.Debug ("[xmrSetObjRegPosRotAsync]*: " + msg)
#define SorpraDebug(msg) do { } while (false)

namespace OpenSim.Region.ScriptEngine.XMREngine
{
    public partial class XMRInstance
    {
        /**
         * @brief Move object to new position and rotation asynchronously.
         *        Can move object across region boundary.
         * @param pos    = new position within current region (same coords as llGetPos())
         * @param rot    = new rotation within current region (same coords as llGetRot())
         * @param evcode = event handler code to post when move complete (XMREVENTCODE_whatever)
         *                 -1 to not bother delivering event
         * @param evargs = arguments to pass to event handler
         * @returns false: completed synchronously, no event will be queued
         *           true: event will be queued when move completed
         */
        public const double SORPRA_MIN_CROSS  = 1.0 / 512.0;  // ie, ~2mm
        public const int    SORPRA_TIMEOUT_MS = 30000;        // ie, 30sec
        public override bool xmrSetObjRegPosRotAsync (LSL_Vector pos, LSL_Rotation rot, int evcode, LSL_List evargs)
        {
            /*
             * Check for synchronous completion, ie, object stays within current region.
             * This case is handled correctly by SceneObjectGroup, including any seated avatars.
             */
            if ((pos.x >= 0) && (pos.x < Constants.RegionSize) &&
                (pos.y >= 0) && (pos.y < Constants.RegionSize)) {
                SceneObjectGroup sog = m_Part.ParentGroup;
                sog.UpdateGroupRotationPR (pos, rot);
                return false;
            }

            /*
             * Crosses region boundary, sync processing with frame updates.
             * The avatars must be unseated then moved to new region followed
             * by moving the object and finally reseating the avatars.
             * We have to move a minimum amount though or some OpenSim components
             * seem to be confused, eg, moving to -0.0000001 doesn't work reliably.
             */
            if ((pos.x <                   0.0) && (pos.x >                       -SORPRA_MIN_CROSS)) pos.x = -SORPRA_MIN_CROSS;
            if ((pos.y <                   0.0) && (pos.y >                       -SORPRA_MIN_CROSS)) pos.y = -SORPRA_MIN_CROSS;
            if ((pos.x >= Constants.RegionSize) && (pos.x < Constants.RegionSize + SORPRA_MIN_CROSS)) pos.x = Constants.RegionSize + SORPRA_MIN_CROSS;
            if ((pos.y >= Constants.RegionSize) && (pos.y < Constants.RegionSize + SORPRA_MIN_CROSS)) pos.y = Constants.RegionSize + SORPRA_MIN_CROSS;

            double reglocx = (double)m_Engine.m_Scene.RegionInfo.RegionLocX * Constants.RegionSize;
            double reglocy = (double)m_Engine.m_Scene.RegionInfo.RegionLocY * Constants.RegionSize;
            SetObjRegPosRotAsync sorpra = new SetObjRegPosRotAsync (this);
            sorpra.pos     = (OpenMetaverse.Vector3)pos;
            sorpra.rot     = (OpenMetaverse.Quaternion)rot;
            sorpra.gblposx = reglocx + pos.x;
            sorpra.gblposy = reglocy + pos.y;
            if (evcode >= 0) {
                string evn = ((ScriptEventCode)evcode).ToString ();
                sorpra.eps = new EventParams (evn, evargs.Data, zeroDetectParams);
            }
            m_Engine.AddOnFrameUpdate (sorpra.StandUpAvs);
            return true;
        }

        private class SetObjRegPosRotAsync {
            public EventParams eps;
            public OpenMetaverse.Quaternion rot;
            public OpenMetaverse.Vector3 pos;
            public double gblposx, gblposy;

            private bool objPushed;
            private DateTime timeoutAt;
            private int resetCount;
            private List<SeatedAv> seatedAvs;
            private XMRInstance inst;

            public SetObjRegPosRotAsync (XMRInstance inst)
            {
                this.inst       = inst;
                this.resetCount = inst.m_ResetCount;
                this.timeoutAt  = DateTime.UtcNow + TimeSpan.FromMilliseconds (SORPRA_TIMEOUT_MS);
            }

            /**
             * @brief Executes as part of scene frame update.
             *        It moves the object and any seated avatars to new sim.
             */
            public void StandUpAvs ()
            {
                if (DeadCheck ()) return;

                try {
                    Scene scene = inst.m_Engine.m_Scene;

                    // point to object as a whole (all linked parts)
                    SceneObjectGroup sog = inst.m_Part.ParentGroup;

                    // see if any avatars are seated on any part of the object
                    int sac = sog.GetSittingAvatarsCount ();
                    seatedAvs = new List<SeatedAv> (sac);
                    if (sac > 0) {

                        // get list of parts in link set
                        SceneObjectPart[] sops = sog.Parts;

                        // see which avatars are on which part
                        foreach (SceneObjectPart sop in sops) {
                            if (sop.GetSittingAvatarsCount () > 0) {
                                HashSet<UUID> seateds = sop.GetSittingAvatars ();
                                foreach (UUID avid in seateds) {
                                    ScenePresence sp = scene.GetScenePresence (avid);
                                    if ((sp != null) && !sp.IsChildAgent) {
                                        SeatedAv sav = new SeatedAv ();
                                        sav.avUUID = avid;
                                        sav.partID = sop.UUID;
                                        seatedAvs.Add (sav);
                                    }
                                }
                            }
                        }

                        // unseat all those avatars
                        foreach (SeatedAv sav in seatedAvs) {
                            ScenePresence sp = scene.GetScenePresence (sav.avUUID);
                            if ((sp != null) && !sp.IsChildAgent) {
                                SorpraDebug ("stand up " + sav.avUUID);
                                sp.StandUp ();
                            }
                        }
                    }

                    // start unseated avatars heading to position in new region
                    // wait for any unseated avatars to reach their targets
                    // then move object
                    MoveAvatars ();
                } catch (Exception e) {
                    m_log.Error ("[xmrSetObjRegPosRotAsync]: " + e.ToString ());
                }
            }

            /**
             * @brief All the avatars are standing.
             *        Move them and the object to the new region.
             */
            private void MoveAvatars ()
            {
                if (DeadCheck ()) return;

                try {
                    Scene scene = inst.m_Engine.m_Scene;

                    // Start moving any avatars that need moving by giving them velocity toward 'pos'.
                    // Just setting position with sp.AbsolutePosition doesn't seem to move them at all.
                    bool needToWait = false;
                    foreach (SeatedAv sav in seatedAvs) {
                        ScenePresence sp = scene.GetScenePresence (sav.avUUID);
                        if ((sp != null) && !sp.IsChildAgent) {

                            // See where avatar is now and give a vector to point to where we want it to go.
                            // Code adapted from sp.AddNewMovement() but can't use AddNewMovement() because
                            // it will zero out the velocity because the avatar might be falling as a result
                            // of the unseat animation and so it will take a long time for it to move.
                            // Zero out the Z component because it can swamp out the X,Y and otherwise doesn't
                            // seem to have much effect anyway.
                            OpenMetaverse.Vector3 avpos = sp.AbsolutePosition;
                            OpenMetaverse.Vector3 avvel = pos - avpos;
                            avvel.Z = 0.0F;
                            avvel.Normalize ();
                            avvel  *= 0.03F * 128.0F * sp.SpeedModifier;
                            SorpraDebug ("push av " + sav.avUUID + " from " + avpos + " by " + avvel);

                            sp.Velocity = avvel;
                            scene.EventManager.TriggerScenePresenceUpdated (sp);

                            // We saw an avatar was out of position so we will check its position again next cycle
                            needToWait  = true;
                        }
                    }

                    // move object to new position and region without any avatars sitting on it
                    // the avatars should be on their way to the new region waiting for it to arrive
                    if (!objPushed) {
                        SceneObjectGroup sog = inst.m_Part.ParentGroup;
                        SorpraDebug ("initial move to " + pos);
                        inst.m_Sorpra = this;                  // set this data to be migrated over to remote sim
                        sog.UpdateGroupRotationPR (pos, rot);  // migrate object to remote sim along with its data
                        inst.m_Sorpra = null;                  // this data no longer needs to be migrated
                        objPushed = true;
                    }

                    // if some avatars were still in old region, come back on next frame update to check again
                    if (needToWait) {
                        inst.m_Engine.AddOnFrameUpdate (MoveAvatars);
                        return;
                    }

                    // everything pushed out of sending region
                    // when the object arrives in its new location, Finish() will be called.
                } catch (Exception e) {
                    m_log.Error ("[xmrSetObjRegPosRotAsync]: " + e.ToString ());
                }
            }

            /**
             * @brief Movement complete, sit everyone back down on object and post event.
             *        This executes as part of the scene frame update thread in new region.
             */
            public void Finish ()
            {
                if (DeadCheck ()) return;

                Scene scene = inst.m_Engine.m_Scene;

                /*
                 * Make sure all avatars that were seated on the object
                 * are now root (not child) avatars in this sim.  If not,
                 * wait for another scene frame update to happen then
                 * check again.
                 */
                foreach (SeatedAv sav in seatedAvs) {
                    ScenePresence sp = scene.GetScenePresence (sav.avUUID);
                    if ((sp == null) || sp.IsChildAgent) {
                        SorpraDebug ("waiting on " + sav.avUUID);
                        inst.m_Engine.AddOnFrameUpdate (Finish);
                        return;
                    }
                }

                /*
                 * Seems more stable if we wait an extra frame before reseating.
                 * Otherwise we sometimes get jump to Y+512 when seating avatars.
                 *
                 * EntityTransferModule.Cross() seems to re-compute the position
                 * of the object in the new region using same region-relative co-
                 * ordinates as the old region and so the object ends up moving to
                 * the wrong position in the new region.  So give it time to do
                 * its bad work then we move it to the correct position after this
                 * delay.
                 */
                inst.m_Engine.AddOnFrameUpdate (Finish2);
            }

            private void Finish2 ()
            {
                if (DeadCheck ()) return;

                Scene scene = inst.m_Engine.m_Scene;

                /*
                 * Move object to make sure it is at target coordinates.
                 * Theoretically this should always be a local move.
                 */
                double reglocx = (double)scene.RegionInfo.RegionLocX * Constants.RegionSize;
                double reglocy = (double)scene.RegionInfo.RegionLocY * Constants.RegionSize;
                pos.X = (float)(gblposx - reglocx);
                pos.Y = (float)(gblposy - reglocy);
                SorpraDebug ("final move to " + pos);
                SceneObjectGroup sog = inst.m_Part.ParentGroup;
                sog.UpdateGroupRotationPR (pos, rot);

                /*
                 * Sit everyone back down on object.
                 */
                foreach (SeatedAv sav in seatedAvs) {
                    ScenePresence sp = scene.GetScenePresence (sav.avUUID);
                    if (sp != null) {
                        SorpraDebug ("seating " + sav.avUUID);
                        sp.HandleAgentRequestSit (null, UUID.Zero, sav.partID, OpenMetaverse.Vector3.Zero);
                    }
                }

                /*
                 * Tell script it is now moved by posting the requested event.
                 */
                if (eps != null) {
                    SorpraDebug ("posting event");
                    inst.PostEvent (eps);
                }
                SorpraDebug ("done");
            }

            /**
             * @brief Make sure we aren't hung (eg, waiting for an avatar to
             *        finish TPing but they have logged out meanwhile).
             */
            private bool DeadCheck ()
            {
                if (inst.m_ResetCount != this.resetCount) {
                    m_log.Debug ("[xmrSetObjRegPosRotAsync]: script was reset");
                    return true;
                }
                if (DateTime.UtcNow > this.timeoutAt) {
                    m_log.Error ("[xmrSetObjRegPosRotAsync]: timed out");
                    return true;
                }
                return false;
            }

            /**
             * @brief Being migrated out as part of being moved to another server
             *        or this server is being shut down.
             */
            public void GetXml (XmlElement sorpraxml)
            {
                XmlDocument doc = sorpraxml.OwnerDocument;

                /*
                 * <Target Pos="x,y,z" Rot="x,y,z,w" Gbl="x,y" />
                 */
                XmlElement targxml = doc.CreateElement ("Target");
                targxml.SetAttribute ("Pos", pos.ToString ());
                targxml.SetAttribute ("Rot", rot.ToString ());
                targxml.SetAttribute ("Gbl", gblposx.ToString () + "," + gblposy.ToString ());
                sorpraxml.AppendChild (targxml);

                /*
                 * <Seateds>
                 *   <Seated Avid="uuid" Part="uuid" />
                 *   ...
                 * </Seateds>
                 */
                XmlElement sitsxml = doc.CreateElement ("Seateds");
                foreach (SeatedAv sav in seatedAvs) {
                    XmlElement sitxml = doc.CreateElement ("Seated");
                    sitxml.SetAttribute ("Avid", sav.avUUID.ToString ());
                    sitxml.SetAttribute ("Part", sav.partID.ToString ());
                    sitsxml.AppendChild (sitxml);
                }
                sorpraxml.AppendChild (sitsxml);

                /*
                 * <EventParams Name="eventname">
                 *   <EventArg Type="typename" Val="value" />
                 *   ...
                 * </EventParams>
                 */
                if (eps != null) {
                    XmlElement epsxml = doc.CreateElement ("EventParams");
                    epsxml.SetAttribute ("Name", eps.EventName);
                    foreach (object eparg in eps.Params) {
                        XmlElement epargxml = doc.CreateElement ("EventArg");

                        string typstr = null;
                        string valstr = null;
                        if (eparg is LSL_Float) {
                            typstr = "float";
                            valstr = inst.xmrFloat2String ((LSL_Float)eparg, "");
                        }
                        if (eparg is LSL_Integer) {
                            typstr = "integer";
                            valstr = inst.xmrInteger2String ((LSL_Integer)eparg, "");
                        }
                        if (eparg is LSL_Rotation) {
                            typstr = "rotation";
                            valstr = inst.xmrRotation2String ((LSL_Rotation)eparg, "");
                        }
                        if (eparg is LSL_String) {
                            typstr = "string";
                            valstr = eparg.ToString ();
                        }
                        if (eparg is LSL_Vector) {
                            typstr = "vector";
                            valstr = inst.xmrVector2String ((LSL_Vector)eparg, "");
                        }
                        if (eparg is SCRIPTFLOAT) {
                            typstr = "float";
                            valstr = inst.xmrFloat2String ((SCRIPTFLOAT)eparg, "");
                        }
                        if (eparg is int) {
                            typstr = "integer";
                            valstr = inst.xmrInteger2String ((int)eparg, "");
                        }
                        if (eparg is string) {
                            typstr = "string";
                            valstr = (string)eparg;
                        }
                        if (typstr == null) {
                            throw new Exception ("unsupported event params type " + eparg.GetType ().Name);
                        }

                        epargxml.SetAttribute ("Type", typstr);
                        epargxml.SetAttribute ("Val",  valstr);
                        epsxml.AppendChild (epargxml);
                    }
                    sorpraxml.AppendChild (epsxml);
                }
            }

            /**
             * @brief Restore values when being migrated in from a sender.
             */
            public void SetXml (XmlElement sorpraxml)
            {
                /*
                 * <Target Pos="x,y,z" Rot="x,y,z,w" Gbl="x,y" />
                 */
                XmlElement targxml = (XmlElement)sorpraxml.SelectSingleNode ("Target");
                string posstr = targxml.GetAttribute ("Pos");
                string rotstr = targxml.GetAttribute ("Rot");
                string gblstr = targxml.GetAttribute ("Gbl");
                pos = OpenMetaverse.Vector3.Parse (posstr);
                rot = OpenMetaverse.Quaternion.Parse (rotstr);
                string[] gblstrxy = gblstr.Split (new char[] { ',' });
                gblposx = double.Parse (gblstrxy[0]);
                gblposy = double.Parse (gblstrxy[1]);

                /*
                 * <Seateds>
                 *   <Seated Avid="uuid" Part="uuid" />
                 *   ...
                 * </Seateds>
                 */
                XmlElement sitsxml = (XmlElement)sorpraxml.SelectSingleNode ("Seateds");
                XmlNodeList sitxmllist = sitsxml.SelectNodes ("Seated");
                seatedAvs = new List<SeatedAv> (sitxmllist.Count);
                foreach (XmlElement sitxml in sitxmllist) {
                    string avid  = sitxml.GetAttribute ("Avid");
                    string part  = sitxml.GetAttribute ("Part");
                    SeatedAv sav = new SeatedAv ();
                    sav.avUUID   = new UUID (avid);
                    sav.partID   = new UUID (part);
                    seatedAvs.Add (sav);
                }

                /*
                 * <EventParams Name="eventname">
                 *   <EventArg Type="typename" Val="value" />
                 *   ...
                 * </EventParams>
                 */
                XmlElement epsxml = (XmlElement)sorpraxml.SelectSingleNode ("EventParams");
                if (epsxml != null) {
                    XmlNodeList evasxml = epsxml.SelectNodes ("EventArg");
                    object[] evargs = new object[evasxml.Count];
                    int i = 0;
                    foreach (XmlElement evaxml in evasxml) {
                        string typstr = evaxml.GetAttribute ("Type");
                        string valstr = evaxml.GetAttribute ("Val");
                        switch (typstr) {
                            case "float": {
                                evargs[i++] = inst.xmrString2Float (valstr);
                                break;
                            }
                            case "integer": {
                                evargs[i++] = inst.xmrString2Integer (valstr);
                                break;
                            }
                            case "rotation": {
                                evargs[i++] = inst.xmrString2Rotation (valstr);
                                break;
                            }
                            case "string": {
                                evargs[i++] = valstr;
                                break;
                            }
                            case "vector": {
                                evargs[i++] = inst.xmrString2Vector (valstr);
                                break;
                            }
                            default: throw new Exception ("unsupported event params type " + typstr);
                        }
                    }
                    string evname = epsxml.GetAttribute ("Name");
                    eps = new EventParams (evname, evargs, new DetectParams[0]);
                }
            }

            private class SeatedAv {
                public UUID avUUID;
                public UUID partID;
            }
        }
    }
}
