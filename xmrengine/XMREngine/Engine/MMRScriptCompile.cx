/********************************************************\
 *  COPYRIGHT 2009,2010, Mike Rieker, Beverly, MA, USA  *
 *  All rights reserved.                                *
\********************************************************/

/**
 * @brief Compile a script to produce a ScriptObjCode object
 */

using System;
using System.IO;
using System.IO.Compression;
using System.Reflection;
using System.Security.Cryptography;
using System.Text;

#define strcasecmp(s,t) String.Compare(s,t,StringComparison.OrdinalIgnoreCase)

namespace OpenSim.Region.ScriptEngine.XMREngine
{
    public class ScriptCompile
    {
        public delegate string FetchSource (string cameFrom);

        private static readonly log4net.ILog m_log =
            log4net.LogManager.GetLogger(MethodBase.GetCurrentMethod().DeclaringType);

        /**
         * @brief Compile a script to produce a ScriptObjCode object
         * @param source = 'source' contains the whole script source
         * @param objCodeKey = unique per script source file
         * @param scriptBasePath = where to put files (a directory)
         * @param forceRecompile = false: use existing object file if any
         *                          true: ignore existing object file
         * @param errorMessage = where to write error messages to
         * @param engine = script engine
         * @returns object code pointer or null if compile error
         */
        public delegate string PathName (string filename);
        public static ScriptObjCode Compile (string source, 
                                             string objCodeKey,
                                             string cameFrom, 
                                             PathName scriptBasePath,
                                             bool forceRecompile,
                                             TokenErrorMessage errorMessage,
                                             FetchSource fetchSource)
        {
            bool oldObjFile = false;
            Stream objFileStream = null;
            StreamWriter asmFileWriter = null;
            string envar = null;
            string sourceHash = null;
            TextWriter saveSource = null;

            string asmFileName = scriptBasePath (objCodeKey + ".xmrasm");
            string lslFileName = scriptBasePath (objCodeKey + ".lsl");
            string objFileName = scriptBasePath (objCodeKey + ".xmrobj");
            string tmpFileName = scriptBasePath (objCodeKey + ".xmrtmp");

            /*
             * If we already have an object file, don't bother compiling.
             */
            if (!forceRecompile && File.Exists (objFileName)) {
                objFileStream = File.OpenRead (objFileName);
                oldObjFile = true;
            } else {

                /*
                 * If source file empty, try to read from asset server.
                 */
                if (EmptySource (source)) {
                    source = fetchSource (cameFrom);
                }

                /*
                 * Maybe write script source to a file for debugging.
                 */
                envar = Environment.GetEnvironmentVariable ("MMRScriptCompileSaveSource");
                if ((envar != null) && ((envar[0] & 1) != 0)) {
                    m_log.Debug ("[XMREngine]: MMRScriptCompileSaveSource: saving to " + lslFileName);
                    saveSource = File.CreateText (lslFileName);
                }

                /*
                 * Parse source string into tokens.
                 */
                TokenBegin tokenBegin;
                try {
                    tokenBegin = TokenBegin.Construct(cameFrom, saveSource, errorMessage, source, out sourceHash);
                } finally {
                    if (saveSource != null) saveSource.Close ();
                }
                if (tokenBegin == null) {
                    m_log.Debug ("[XMREngine]: parsing errors on " + objCodeKey);
                    return null;
                }

                /*
                 * Create object file one way or another.
                 */
                try {
                    objFileStream = File.Create (tmpFileName);

                    /*
                     * If source is 'XMROption' 'fetchbinary' ...,
                     * read xmrobj file from the given URL.
                     */
                    if ((tokenBegin.nextToken is TokenName) &&
                        (strcasecmp (((TokenName)tokenBegin.nextToken).val, "XMROption") == 0) &&
                        (tokenBegin.nextToken.nextToken is TokenName) &&
                        (strcasecmp (((TokenName)tokenBegin.nextToken.nextToken).val, "fetchbinary") == 0)) {

                        /*
                         * Open web stream.
                         */
                        Stream webStream = FetchBin (tokenBegin.nextToken.nextToken.nextToken, errorMessage);
                        if (webStream == null) return null;

                        /*
                         * Copy object code from web and write to .xmrobj file.
                         */
                        try {
                            byte[] buffer = new byte[32768];
                            int len;
                            while ((len = webStream.Read (buffer, 0, buffer.Length)) > 0) {
                                objFileStream.Write (buffer, 0, len);
                            }
                        } finally {
                            webStream.Close ();
                        }
                    } else {

                        /*
                         * Create abstract syntax tree from raw tokens.
                         */
                        TokenScript tokenScript = ScriptReduce.Reduce(tokenBegin);
                        if (tokenScript == null) {
                            m_log.Debug ("[XMREngine]: reduction errors on " + objCodeKey);
                            return null;
                        }

                        /*
                         * Compile abstract syntax tree to write object file.
                         */
                        BinaryWriter objFileWriter = new BinaryWriter (objFileStream);
                        bool ok = ScriptCodeGen.CodeGen(tokenScript, objFileWriter, sourceHash);
                        if (!ok) {
                            m_log.Debug ("[XMREngine]: compile error on " + objCodeKey);
                            objFileStream.Close ();
                            return null;
                        }
                    }
                    objFileStream.Close ();

                    /*
                     * File has been completely written.
                     * If there is an old one laying around, delete it now.
                     * Then re-open the new file for reading from the beginning.
                     */
                    if (File.Exists (objFileName)) {
                        File.Replace (tmpFileName, objFileName, null);
                    } else {
                        File.Move (tmpFileName, objFileName);
                    }
                    objFileStream = File.OpenRead (objFileName);
                } finally {

                    /*
                     * In case something went wrong writing temp file, delete it.
                     */
                    try {
                        File.Delete (tmpFileName);
                    } catch {
                    }
                }

                /*
                 * Since we just wrote the .xmrobj file, maybe save disassembly.
                 */
                envar = Environment.GetEnvironmentVariable ("MMRScriptCompileSaveILGen");
                if ((envar != null) && ((envar[0] & 1) != 0)) {
                    m_log.Debug ("[XMREngine]: MMRScriptCompileSaveILGen: saving to " + asmFileName);
                    asmFileWriter = File.CreateText (asmFileName);
                }
            }

            /*
             * Read object file to create ScriptObjCode object.
             * Maybe also write disassembly to a file for debugging.
             */
            BinaryReader objFileReader = new BinaryReader (objFileStream);
            ScriptObjCode scriptObjCode = null;
            try {
                scriptObjCode = new ScriptObjCode (objFileReader, asmFileWriter);
                if (scriptObjCode != null) {
                    scriptObjCode.fileDateUtc = File.GetLastWriteTimeUtc (objFileName);
                }
            } finally {
                objFileReader.Close ();
                if (asmFileWriter != null) {
                    asmFileWriter.Flush ();
                    asmFileWriter.Close ();
                }
            }

            /*
             * Maybe an old object file has reached its expiration date.
             */
            if (oldObjFile && (scriptObjCode != null) && scriptObjCode.IsExpired ()) {
                m_log.Debug ("[XMREngine]: expiration reached on " + objCodeKey + ", reloading");
                scriptObjCode = Compile (source, objCodeKey, cameFrom, scriptBasePath, true, errorMessage, fetchSource);
            }

            return scriptObjCode;
        }

        /**
         * @brief Check for empty source, allowing for a first line of //... script engine selector.
         */
        public static bool EmptySource (string source)
        {
            int len = source.Length;
            bool skipeol = false;
            for (int i = 0; i < len; i ++) {
                char c = source[i];
                skipeol &= c != '\n';
                skipeol |= (c == '/') && (i + 1 < len) && (source[i+1] == '/');
                if ((c > ' ') && !skipeol) return false;
            }
            return true;
        }

        /**
         * @brief Read xmrbin file from a webserver somewhere out there.
         * @param token = tokens after 'XMROption' 'fetchbinary'
         * @param errorMessage = where to write error messages
         * @returns null: some error
         *          else: object file stream
         */
        private static Stream FetchBin (Token token, TokenErrorMessage errorMessage)
        {
            bool error = false;
            string url = null;
            TokenStr urlToken = null;

            /*
             * Parse parameters:
             *    "url"
             *    ;
             */
            for (; !(token is TokenEnd); token = token.nextToken) {
                if (token is TokenKwSemi) break;
                if (token is TokenStr) {
                    if (urlToken == null) {
                        urlToken = (TokenStr)token;
                    } else {
                        errorMessage (token, "only one url string allowed");
                        error = true;
                    }
                    continue;
                }
                errorMessage (token, "unknown item in fetchbinary option");
                error = true;
            }
            if (!(token is TokenKwSemi)) {
                errorMessage (token, "missing ; at end of fetchbinary option");
                error = true;
            } else if (!(token.nextToken is TokenEnd)) {
                errorMessage (token.nextToken, "extra stuff after fetchbinary option");
                error = true;
            } else if (urlToken == null) {
                errorMessage (token, "missing url string");
                error = true;
            }
            if (error) return null;

            url = urlToken.val;
            m_log.Debug ("[XMREngine]: fetching " + url);

            try {

                /*
                 * Get stream to read from webserver.
                 */
                return Decrypt (MMRWebRequest.MakeRequest ("GET", url, null, 0));
            } catch (Exception e) {

                /*
                 * Some error, output message.
                 */
                errorMessage (urlToken, "error fetching: " + e.ToString());
                return null;
            }
        }

#include "../Compiler/MMRScriptXmrBinEncrypt.h"
#include "../Compiler/MMRScriptXmrBinDecrypt.h"
    }
}
