/////////////////////////////////////////////////////////////
//
// Copyright (c)2009 Careminster Limited and Melanie Thielker
// Copyright (c) 2010,2013 Mike Rieker, Beverly, MA, USA
//
// All rights reserved
//

#define TCP if (m_TraceCalls) NoPrint // m_log.DebugFormat

using log4net;
using Mono.Addins;
using Mono.Tasklets;
using Nini.Config;
using OpenSim.Framework;
using OpenSim.Framework.Console;
using OpenSim.Region.ClientStack.Linden;
using OpenSim.Region.Framework.Interfaces;
using OpenSim.Region.Framework.Scenes;
using OpenSim.Region.ScriptEngine.Interfaces;
using OpenSim.Region.ScriptEngine.Shared;
using OpenMetaverse;
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Threading;
using System.Timers;
using System.Xml;

[assembly: Addin("XMREngine", "0.1")]
[assembly: AddinDependency("OpenSim", "0.5")]

namespace OpenSim.Region.ScriptEngine.XMREngine
{
    [Extension(Path = "/OpenSim/RegionModules", NodeName = "RegionModule", Id = "XMREngine")]
    public partial class XMREngine : INonSharedRegionModule, IScriptEngine,
            IScriptModule
    {
        public  static readonly DetectParams[] zeroDetectParams = new DetectParams[0];
        private static ArrayList noScriptErrors = new ArrayList();
        public  static readonly ILog m_log =
            LogManager.GetLogger(MethodBase.GetCurrentMethod().DeclaringType);
        private static readonly string[] scriptReferencedAssemblies = new string[0];

        private bool m_SuspendScriptThreadFlag;
        private bool m_TraceCalls;
        private bool m_WakeUpThis;
        private DateTime m_LastRanAt = DateTime.MinValue;
        private Scene m_Scene;
        private IConfigSource m_ConfigSource;
        private IConfig m_Config;
        private long m_ScriptExecTime;
        private string m_ScriptBasePath;
        private bool m_Enabled = false;
        private Dictionary<UUID, ArrayList> m_ScriptErrors =
                new Dictionary<UUID, ArrayList>();
        private Dictionary<UUID, List<UUID>> m_ObjectItemList =
                new Dictionary<UUID, List<UUID>>();
        private Dictionary<UUID, XMRInstance[]> m_ObjectInstArray =
                new Dictionary<UUID, XMRInstance[]>();
        private int m_StackSize;
        private int m_HeapSize;
        private object m_WakeUpLock = new object ();
        public  Thread m_ScriptThread = null;
        private Thread m_SleepThread  = null;
        private Thread m_SliceThread  = null;
        private XMRInstance m_RunInstance = null;
        private bool m_Exiting = false;
        private long m_InitializedAt = 0;

        private int m_MaintenanceInterval = 10;

        public Mono.Tasklets.Continuation engstack;
        private System.Timers.Timer m_MaintenanceTimer;

        public string m_traceHeapUse = null;

        /*
         * Various instance lists:
         *   m_InstancesDict = all known instances
         *                     find an instance given its itemID
         *   m_LoadQueue  = instances that have yet to be compiled and loaded
         *   m_StartQueue = instances that have just had event queued to them
         *   m_YieldQueue = instances that are ready to run right now
         *   m_SleepQueue = instances that have m_SleepUntil valid
         *                  sorted by ascending m_SleepUntil
         */
        private Dictionary<UUID, XMRInstance> m_InstancesDict =
                new Dictionary<UUID, XMRInstance>();
        private Queue<XMRInstance> m_LoadQueue = new Queue<XMRInstance> ();
        public  XMRInstQueue m_StartQueue = new XMRInstQueue();
        public  XMRInstQueue m_YieldQueue = new XMRInstQueue();
        public  XMRInstQueue m_SleepQueue = new XMRInstQueue();
        private string m_LockedDict = "nobody";

        public XMREngine()
        {
            m_log.Info ("[XMREngine]: commit " + GITCOMMITHASH + ((GITCOMMITCLEAN != 0) ? "" : "(dirty)") + " " + GITCOMMITDATE);
            string envar = Environment.GetEnvironmentVariable("XMREngineTraceCalls");
            m_TraceCalls = (envar != null) && ((envar[0] & 1) != 0);
            m_log.DebugFormat("[XMREngine]: m_TraceCalls={0}", m_TraceCalls);
        }

        public string Name
        {
            get { return "XMREngine"; }
        }

        public Type ReplaceableInterface
        {
            get { return null; }
        }

        public string ScriptEnginePath
        {
            get { return m_ScriptBasePath; }
        }

        public string ScriptClassName
        {
            get { return "XMREngineScript"; }
        }

        public string ScriptBaseClassName
        {
            get { return typeof (XMRInstance).FullName; }
        }

        public ParameterInfo[] ScriptBaseClassParameters
        {
            get { return typeof(XMRInstance).GetConstructor (new Type[] { typeof (WaitHandle) }).GetParameters (); }
        }

        public string[] ScriptReferencedAssemblies
        {
            get { return scriptReferencedAssemblies; }
        }

        public void Initialise(IConfigSource config)
        {
            TCP("[XMREngine]: Initialize entry");
            m_ConfigSource = config;

            ////foreach (IConfig icfg in config.Configs) {
            ////    m_log.Debug("[XMREngine]: Initialise: configs[" + icfg.Name + "]");
            ////    foreach (string key in icfg.GetKeys ()) {
            ////        m_log.Debug("[XMREngine]: Initialise:     " + key + "=" + icfg.GetExpanded (key));
            ////    }
            ////}

            m_Enabled = false;
            m_Config = config.Configs["XMREngine"];
            if (m_Config == null) {
                m_log.Info("[XMREngine]: no config, assuming disabled");
                return;
            }
            m_Enabled = m_Config.GetBoolean("Enabled", false);
            m_log.InfoFormat("[XMREngine]: config enabled={0}", m_Enabled);
            if (!m_Enabled) {
                return;
            }

            /*
             * Verify that our ScriptEventCode's match OpenSim's scriptEvent's.
             */
            bool err = false;
            for (int i = 0; i < 32; i ++) {
                string mycode = "undefined";
                string oscode = "undefined";
                try {
                    mycode = ((ScriptEventCode)i).ToString();
                    Convert.ToInt32(mycode);
                    mycode = "undefined";
                } catch {
                }
                try {
                    oscode = ((OpenSim.Region.Framework.Scenes.scriptEvents)(1 << i)).ToString();
                    Convert.ToInt32(oscode);
                    oscode = "undefined";
                } catch {
                }
                if (mycode != oscode) {
                    m_log.ErrorFormat("[XMREngine]: {0} mycode={1}, oscode={2}", i, mycode, oscode);
                    err = true;
                }
            }
            if (err) {
                m_Enabled = false;
                return;
            }

            m_StackSize = m_Config.GetInt("ScriptStackSize", 2048) << 10;
            m_HeapSize  = m_Config.GetInt("ScriptHeapSize",  1024) << 10;

            m_log.InfoFormat("[XMREngine]: Enabled, {0}.{1} Meg (0x{2}) stacks",
                    (m_StackSize >> 20).ToString (),
                    (((m_StackSize % 0x100000) * 1000) 
                            >> 20).ToString ("D3"),
                    m_StackSize.ToString ("X"));

            m_log.InfoFormat("[XMREngine]:  ... {0}.{1} Meg (0x{2}) heaps",
                    (m_HeapSize >> 20).ToString (),
                    (((m_HeapSize % 0x100000) * 1000) 
                            >> 20).ToString ("D3"),
                    m_HeapSize.ToString ("X"));

            m_MaintenanceInterval = m_Config.GetInt("MaintenanceInterval", 10);

            if (m_MaintenanceInterval > 0)
            {
                m_MaintenanceTimer = new System.Timers.Timer(m_MaintenanceInterval * 60000);
                m_MaintenanceTimer.Elapsed += DoMaintenance;
                m_MaintenanceTimer.Start();
            }

            MainConsole.Instance.Commands.AddCommand("xmr", false,
                    "xmr",
                    "xmr [...|help|...] ...",
                    "Run xmr script engine commands",
                    RunTest);

            TCP("[XMREngine]: Initialize successful");

            m_InitializedAt = DateTime.UtcNow.Ticks;
        }

        public void AddRegion(Scene scene)
        {
            if (!m_Enabled)
                return;

            TCP("[XMREngine]: XMREngine.AddRegion({0})", scene.RegionInfo.RegionName);

            m_Scene = scene;

            m_Scene.RegisterModuleInterface<IScriptModule>(this);

            m_ScriptBasePath = m_Config.GetString("ScriptBasePath",
                    Path.Combine(".", "ScriptData"));
            m_ScriptBasePath = Path.Combine(m_ScriptBasePath,
                    scene.RegionInfo.RegionID.ToString());

            Directory.CreateDirectory(m_ScriptBasePath);

            m_Scene.EventManager.OnRezScript += OnRezScript;

            m_Scene.StackModuleInterface<IScriptModule>(this);
        }

        /**
         * @brief Called late in shutdown procedure,
         *        after the 'Shutting down..." message.
         */
        public void RemoveRegion(Scene scene)
        {
            if (!m_Enabled)
                return;

            TCP("[XMREngine]: XMREngine.RemoveRegion({0})", scene.RegionInfo.RegionName);

            /*
             * Write script states out to .state files so it will be
             * available when the region is restarted.
             */
            DoMaintenance(null, null);

            /*
             * Stop executing script threads and wait for final
             * one to finish (ie, script gets to CheckRun() call).
             */
            m_Exiting = true;
            if (m_ScriptThread != null) {
                WakeUpScriptThread();
                m_ScriptThread.Join();
                m_ScriptThread = null;
            }
            if (m_SleepThread != null) {
                lock (m_SleepQueue) {
                    Monitor.PulseAll (m_SleepQueue);
                }
                m_SleepThread.Join();
                m_SleepThread = null;
            }
            if (m_SliceThread != null) {
                m_SliceThread.Join();
                m_SliceThread = null;
            }

            m_Scene.EventManager.OnRezScript -= OnRezScript;
            m_Scene.EventManager.OnRemoveScript -= OnRemoveScript;
            m_Scene.EventManager.OnScriptReset -= OnScriptReset;
            m_Scene.EventManager.OnStartScript -= OnStartScript;
            m_Scene.EventManager.OnStopScript -= OnStopScript;
            m_Scene.EventManager.OnGetScriptRunning -= OnGetScriptRunning;
            m_Scene.EventManager.OnShutdown -= OnShutdown;

            m_Enabled = false;
            m_Scene = null;
        }

        public void RegionLoaded(Scene scene)
        {
            if (!m_Enabled)
                return;

            TCP("[XMREngine]: XMREngine.RegionLoaded({0})", scene.RegionInfo.RegionName);

            m_Scene.EventManager.OnRemoveScript += OnRemoveScript;
            m_Scene.EventManager.OnScriptReset += OnScriptReset;
            m_Scene.EventManager.OnStartScript += OnStartScript;
            m_Scene.EventManager.OnStopScript += OnStopScript;
            m_Scene.EventManager.OnGetScriptRunning += OnGetScriptRunning;
            m_Scene.EventManager.OnShutdown += OnShutdown;

            InitEvents();
        }

        public void StartProcessing()
        {
            TCP("[XMREngine]: XMREngine.StartProcessing()");
            m_ScriptThread = new Thread(RunScriptThread);
            m_SleepThread  = new Thread(RunSleepThread);
            m_SliceThread  = new Thread(RunSliceThread);
            m_ScriptThread.Start();
            m_SleepThread.Start();
            m_SliceThread.Start();
        }

        public void Close()
        {
            TCP("[XMREngine]: XMREngine.Close()");
        }

        private void RunTest (string module, string[] args)
        {
            if (args.Length < 2) {
                m_log.Info ("[XMREngine]: missing command, try 'xmr help'");
                return;
            }

            switch (args[1]) {
                case "cvv": {
                    switch (args.Length) {
                        case 2: {
                            m_log.InfoFormat ("[XMREngine]: compiled version value = {0}", 
                                    ScriptCodeGen.COMPILED_VERSION_VALUE);
                            break;
                        }
                        case 3: {
                            try {
                                ScriptCodeGen.COMPILED_VERSION_VALUE = Convert.ToInt32 (args[2]);
                            } catch {
                                m_log.Error ("[XMREngine]: bad/missing version number");
                            }
                            break;
                        }
                        default: {
                            m_log.Error ("[XMREngine]: xmr cvv [<new_compiled_version_value>]");
                            break;
                        }
                    }
                    break;
                }
                case "gc": {
                    GC.Collect();
                    break;
                }
                case "help":
                case "?": {
                    m_log.Info ("[XMREngine]: xmr cvv [<newvalue>] - show/set compiled version value");
                    m_log.Info ("[XMREngine]: xmr gc");
                    m_log.Info ("[XMREngine]: xmr ls [-help ...]");
                    m_log.Info ("[XMREngine]: xmr mvv [<newvalue>] - show/set migration version value");
                    m_log.Info ("[XMREngine]: xmr pev [-help ...] - post event");
                    m_log.Info ("[XMREngine]: xmr reset [-help ...]");
                    m_log.Info ("[XMREngine]: xmr resume - resume script processing");
                    m_log.Info ("[XMREngine]: xmr suspend - suspend script processing");
                    m_log.Info ("[XMREngine]: xmr traceheapuse [<scriptname>] - trace heap usage");
                    break;
                }
                case "ls": {
                    XmrTestLs (args, 2);
                    break;
                }
                case "mvv": {
                    switch (args.Length) {
                        case 2: {
                            m_log.InfoFormat ("[XMREngine]: migration version value = {0}", 
                                    XMRInstance.migrationVersion);
                            break;
                        }
                        case 3: {
                            try {
                                int mvv = Convert.ToInt32 (args[2]);
                                if ((mvv < 0) || (mvv > 255)) throw new Exception ("out of range");
                                XMRInstance.migrationVersion = (byte) mvv;
                            } catch (Exception e) {
                                m_log.Error ("[XMREngine]: bad/missing version number (" + e.Message + ")");
                            }
                            break;
                        }
                        default: {
                            m_log.Error ("[XMREngine]: xmr mvv [<new_migration_version_value>]");
                            break;
                        }
                    }
                    break;
                }
                case "pev": {
                    XmrTestPev (args, 2);
                    break;
                }
                case "reset": {
                    XmrTestReset (args, 2);
                    break;
                }
                case "resume": {
                    m_log.Info ("[XMREngine]: resuming scripts");
                    m_SuspendScriptThreadFlag = false;
                    WakeUpScriptThread();
                    break;
                }
                case "suspend": {
                    m_log.Info ("[XMREngine]: suspending scripts");
                    m_SuspendScriptThreadFlag = true;
                    WakeUpScriptThread();
                    break;
                }
                case "traceheapuse": {
                    switch (args.Length) {
                        case 2: {
                            m_traceHeapUse = null;
                            break;
                        }
                        case 3: {
                            m_traceHeapUse = args[2];
                            break;
                        }
                        default: {
                            m_log.Error ("[XMREngine]: usage: xmr traceheapuse [<scriptname>]");
                            break;
                        }
                    }
                    break;
                }
                default: {
                    m_log.Error ("[XMREngine]: unknown command " + args[1] + ", try 'xmr help'");
                    break;
                }
            }
        }

        // Not required when not using IScriptInstance
        //
        public IScriptWorkItem QueueEventHandler(object parms)
        {
            return null;
        }

        public Scene World
        {
            get { return m_Scene; }
        }

        public IScriptModule ScriptModule
        {
            get { return this; }
        }

        public void SaveAllState()
        {
            m_log.Error("[XMREngine]: XMREngine.SaveAllState() called!!");
        }

        public event ScriptRemoved OnScriptRemoved;
        public event ObjectRemoved OnObjectRemoved;

        // Events targeted at a specific script
        // ... like listen() for an llListen() call
        //
        public bool PostScriptEvent(UUID itemID, EventParams parms)
        {
            XMRInstance instance = GetInstance (itemID);
            if (instance == null) return false;

            TCP("[XMREngine]: XMREngine.PostScriptEvent({0},{1})", itemID.ToString(), parms.EventName);

            instance.PostEvent(parms);
            return true;
        }

        // Events targeted at an object as a whole
        // ... like change() for an avatar wanting to sit at a table
        //     posting the sit to all scripts in all prims of table.
        //
        public bool PostObjectEvent(uint localID, EventParams parms)
        {
            SceneObjectPart part = m_Scene.GetSceneObjectPart(localID);

            if (part == null)
                return false;

            UUID partUUID = part.UUID;

            TCP("[XMREngine]: XMREngine.PostObjectEvent({0},{1})", localID.ToString(), parms.EventName);

            /*
             * Get list of script instances running in the object.
             */
            XMRInstance[] objInstArray;
            lock (m_InstancesDict) {
                if (!m_ObjectInstArray.TryGetValue (partUUID, out objInstArray)) {
                    return false;
                }
                if (objInstArray == null) {
                    objInstArray = RebuildObjectInstArray (partUUID);
                    m_ObjectInstArray[partUUID] = objInstArray;
                }
            }

            /*
             * Post event to all script instances in the object.
             */
            if (objInstArray.Length <= 0) return false;
            foreach (XMRInstance inst in objInstArray) {
                inst.PostEvent (parms);
            }
            return true;
        }

        public DetectParams GetDetectParams(UUID itemID, int number)
        {
            XMRInstance instance = GetInstance (itemID);
            if (instance == null) return null;
            return instance.GetDetectParams(number);
        }

        public void SetMinEventDelay(UUID itemID, double delay)
        {
        }

        public int GetStartParameter(UUID itemID)
        {
            XMRInstance instance = GetInstance (itemID);
            if (instance == null) return 0;
            return instance.StartParam;
        }

        // This is the "set running" method
        //
        public void SetScriptState(UUID itemID, bool state)
        {
            XMRInstance instance = GetInstance (itemID);
            if (instance != null) {
                instance.Running = state;
            }
        }

        // Control display of the "running" checkbox
        //
        public bool GetScriptState(UUID itemID)
        {
            XMRInstance instance = GetInstance (itemID);
            if (instance == null) return false;
            return instance.Running;
        }

        public void SetState(UUID itemID, string newState)
        {
            TCP("[XMREngine]: XMREngine.SetState({0},{1})", itemID.ToString(), newState);
        }

        public void ApiResetScript(UUID itemID)
        {
            XMRInstance instance = GetInstance (itemID);
            if (instance != null) {
                instance.ApiReset();
            }
        }

        public void ResetScript(UUID itemID)
        {
            XMRInstance instance = GetInstance (itemID);
            if (instance != null) {
                instance.Reset();
            }
        }

        public IConfig Config
        {
            get { return m_Config; }
        }

        public IConfigSource ConfigSource
        {
            get { return m_ConfigSource; }
        }

        public string ScriptEngineName
        {
            get { return "XMREngine"; }
        }

        public IScriptApi GetApi(UUID itemID, string name)
        {
            return null;
        }

        /**
         * @brief Get script's current state as an XML string
         *        - called by "Take", "Take Copy" and when object deleted (ie, moved to Trash)
         *        This includes the .state file
         */
        public string GetXMLState(UUID itemID)
        {
            XMRInstance instance = GetInstance (itemID);
            if (instance == null) return String.Empty;

            TCP("[XMREngine]: XMREngine.GetXMLState({0})", itemID.ToString());

            if (!instance.m_HasRun) return String.Empty;

            XmlDocument doc = new XmlDocument();

            /*
             * Set up <State Engine="XMREngine" UUID="itemID" Asset="assetID"> tag.
             */
            XmlElement stateN = doc.CreateElement("", "State", "");
            doc.AppendChild(stateN);

            XmlAttribute engineA = doc.CreateAttribute("", "Engine", "");
            engineA.Value = ScriptEngineName;
            stateN.Attributes.Append(engineA);

            XmlAttribute uuidA = doc.CreateAttribute("", "UUID", "");
            uuidA.Value = itemID.ToString();
            stateN.Attributes.Append(uuidA);

            XmlAttribute assetA = doc.CreateAttribute("", "Asset", "");
            string assetID = instance.AssetID.ToString();
            assetA.Value = assetID;
            stateN.Attributes.Append(assetA);

            /*
             * Get <ScriptState>...</ScriptState> item that hold's script's state.
             * This suspends the script if necessary then takes a snapshot.
             */
            XmlElement scriptStateN = instance.GetExecutionState(doc);
            stateN.AppendChild(scriptStateN);

            return doc.OuterXml;
        }

        // Set script's current state from an XML string
        // - called just before a script is instantiated
        // So we write the .state file so the .state file will be seen when 
        // the script is instantiated.
        public bool SetXMLState(UUID itemID, string xml)
        {
            XmlDocument doc = new XmlDocument();

            try
            {
                doc.LoadXml(xml);
            }
            catch
            {
                return false;
            }
            TCP("[XMREngine]: XMREngine.SetXMLState({0})", itemID.ToString());

            // Make sure <State Engine="XMREngine"> so we know it is in our
            // format.
            XmlElement stateN = (XmlElement)doc.SelectSingleNode("State");
            if (stateN == null)
                return false;

            if (stateN.GetAttribute("Engine") != ScriptEngineName)
                return false;

            // <ScriptState>...</ScriptState> contains contents of .state file.
            XmlElement scriptStateN = (XmlElement)stateN.SelectSingleNode("ScriptState");
            if (scriptStateN == null) {
                return false;
            }
            string sen = stateN.GetAttribute("Engine");
            if ((sen == null) || (sen != ScriptEngineName)) {
                return false;
            }

            XmlAttribute assetA = doc.CreateAttribute("", "Asset", "");
            assetA.Value = stateN.GetAttribute("Asset");
            scriptStateN.Attributes.Append(assetA);

            // Write out the .state file with the <ScriptState ...>...</ScriptState> XML text
            string statePath = XMRInstance.GetStateFileName(m_ScriptBasePath, itemID);
            FileStream ss = File.Create(statePath);
            StreamWriter sw = new StreamWriter(ss);
            sw.Write(scriptStateN.OuterXml);
            sw.Close();
            ss.Close();

            return true;
        }

        public bool PostScriptEvent(UUID itemID, string name, Object[] p)
        {
            if (!m_Enabled)
                return false;

            TCP("[XMREngine]: XMREngine.PostScriptEvent({0},{1})", itemID.ToString(), name);

            return PostScriptEvent(itemID, new EventParams(name, p, zeroDetectParams));
        }

        public bool PostObjectEvent(UUID itemID, string name, Object[] p)
        {
            if (!m_Enabled)
                return false;

            TCP("[XMREngine]: XMREngine.PostObjectEvent({0},{1})", itemID.ToString(), name);

            SceneObjectPart part = m_Scene.GetSceneObjectPart(itemID);
            if (part == null)
                return false;

            return PostObjectEvent(part.LocalId, new EventParams(name, p, zeroDetectParams));
        }

        // Get a script instance loaded, compiling it if necessary
        //
        //  localID     = the object as a whole, may contain many scripts
        //  itemID      = this instance of the script in this object
        //  script      = script source code
        //  startParam  = value passed to 'on_rez' event handler
        //  postOnRez   = true to post an 'on_rez' event to script on load
        //  defEngine   = default script engine
        //  stateSource = post this event to script on load

        public void OnRezScript(uint localID, UUID itemID, string script,
                int startParam, bool postOnRez, string defEngine, int stateSource)
        {
            SceneObjectPart part = m_Scene.GetSceneObjectPart(localID);
            TaskInventoryItem item = part.Inventory.GetInventoryItem(itemID);

            TCP("[XMREngine]: OnRezScript(...,{0},...)", itemID.ToString());

            /*
             * Assume script uses the default engine, whatever that is.
             */
            string engineName = defEngine;

            /*
             * Very first line might contain "//" scriptengine ":".
             */
            string firstline = "";
            string restof1st = "";
            if (script.StartsWith("//")) {
                int lineEnd = script.IndexOf('\n');
                if (lineEnd > 1) firstline = script.Substring(0, lineEnd).Trim();
                int colon = firstline.IndexOf(':');
                if (colon >= 2) {
                    engineName = firstline.Substring(2, colon - 2).Trim();
                    if (engineName == "") engineName = defEngine;
                    restof1st  = "," + firstline.Substring(colon + 1).Trim().ToLowerInvariant() + ",";
                }
            }

            /*
             * Make sure the default or requested engine is us.
             */
            if (engineName != ScriptEngineName) {

                /*
                 * Not us, if requested engine exists, silently ignore script and let
                 * requested engine handle it.
                 */
                IScriptModule[] engines = m_Scene.RequestModuleInterfaces<IScriptModule> ();
                foreach (IScriptModule eng in engines) {
                    if (eng.ScriptEngineName == engineName) {
                        return;
                    }
                }

                /*
                 * Requested engine not defined, warn on console.
                 * Then we try to handle it if we're the default engine, else we ignore it.
                 */
                m_log.Warn ("[XMREngine]: " + itemID.ToString() + " requests undefined/disabled engine " + engineName);
                m_log.Info ("[XMREngine]: first line: " + firstline);
                if (defEngine != ScriptEngineName) {
                    m_log.Info ("[XMREngine]: leaving it to the default script engine (" + defEngine + ") to process it");
                    return;
                }
                m_log.Info ("[XMREngine]: will attempt to processing it anyway as default script engine");
            }

            /*
             * Put on object/instance lists.
             */
            XMRInstance instance   = new XMRInstance();
            instance.m_ForceReset  = restof1st.Contains (",forcereset,");
            instance.m_LocalID     = localID;
            instance.m_ItemID      = itemID;
            instance.m_SourceCode  = script;
            instance.m_StartParam  = startParam;
            instance.m_PostOnRez   = postOnRez;
            instance.m_StateSource = (StateSource)stateSource;
            instance.m_Part        = part;
            instance.m_PartUUID    = part.UUID;
            instance.m_Item        = item;
            instance.m_DescName    = part.Name + ":" + item.Name;
            instance.m_IState      = XMRInstState.COMPILING;

            lock (m_InstancesDict) {
                m_LockedDict = "RegisterInstance";

                // Insert on internal list of all scripts being handled by this engine instance.
                m_InstancesDict[instance.m_ItemID] = instance;

                // Insert on internal list of all scripts being handled by this engine instance
                // that are part of the object.
                List<UUID> itemIDList;
                if (!m_ObjectItemList.TryGetValue(instance.m_PartUUID, out itemIDList)) {
                    itemIDList = new List<UUID>();
                    m_ObjectItemList[instance.m_PartUUID] = itemIDList;
                }
                if (!itemIDList.Contains(instance.m_ItemID)) {
                    itemIDList.Add(instance.m_ItemID);
                    m_ObjectInstArray[instance.m_PartUUID] = null;
                }

                m_LockedDict = "~RegisterInstance";
            }

            /*
             * Queue script in a thread that will compile and load it.
             */
            lock (m_LoadQueue) {
                if (m_LoadQueue.Count == 0) {
                    new System.Threading.Thread (LoadThread).Start ();
                }
                m_LoadQueue.Enqueue (instance);
            }
        }

        /**
         * @brief This runs as a thread whenever there are new scripts to be compiled and loaded.
         */
        private void LoadThread ()
        {
            m_log.Debug ("[XMREngine]: LoadThread entered");
            long when = DateTime.UtcNow.Ticks - 100000000;  // 10sec
            if (when < m_InitializedAt) {
                long msec = (m_InitializedAt - when) / 10000;
                m_log.Debug ("[XMREngine]: LoadThread sleeping for " + msec + " mS");
                Thread.Sleep ((int)msec);
            }
            Monitor.Enter (m_LoadQueue);
            while (m_LoadQueue.Count > 0) {
                XMRInstance instance = m_LoadQueue.Peek ();
                Monitor.Exit (m_LoadQueue);
                LoadThreadWork (instance);
                Monitor.Enter (m_LoadQueue);
                m_LoadQueue.Dequeue ();
            }
            Monitor.Exit (m_LoadQueue);
            m_log.Debug ("[XMREngine]: LoadThread exiting");
            m_Scene.EventManager.TriggerEmptyScriptCompileQueue (0, "");
        }

        /**
         * @brief This routine instantiates one script.
         */
        private void LoadThreadWork (XMRInstance instance)
        {
            /*
             * Compile and load the script in memory.
             */
            ArrayList errors = new ArrayList();
            Exception initerr = null;
            try {
                instance.Initialize(this, m_ScriptBasePath, m_StackSize, m_HeapSize, errors);
            } catch (Exception e1) {
                initerr = e1;
            }
            if ((initerr != null) && !instance.m_ForceReset) {
                UUID itemID = instance.m_ItemID;
                m_log.DebugFormat("[XMREngine]: {0} first load failed ({1}), retrying after reset", itemID.ToString(), initerr.Message);
                m_log.DebugFormat("[XMREngine]:\n{0}", initerr.ToString ());
                initerr = null;
                errors = new ArrayList();
                instance.m_ForceReset = true;
                try {
                    instance.Initialize(this, m_ScriptBasePath, m_StackSize, m_HeapSize, errors);
                } catch (Exception e2) {
                    initerr = e2;
                }
            }
            if (initerr != null) {
                UUID itemID = instance.m_ItemID;
                m_log.DebugFormat("[XMREngine]: Error starting script {0}: {1}",
                                  itemID.ToString(), initerr.Message);
                if (initerr.Message != "compilation errors") {
                    m_log.DebugFormat("[XMREngine]:   exception:\n{0}", initerr.ToString());
                }

                OnRemoveScript (0, itemID);

                /*
                 * Post errors where GetScriptErrors() can see them.
                 */
                if (errors.Count == 0) {
                    errors.Add(initerr.Message);
                } else {
                    foreach (Object err in errors) {
                        m_log.DebugFormat("[XMREngine]:   {0}", err.ToString());
                    }
                }
                lock (m_ScriptErrors) {
                    m_ScriptErrors[instance.m_ItemID] = errors;
                }

                return;
            }

            /*
             * Tell GetScriptErrors() that we have finished compiling/loading
             * successfully (by posting a 0 element array).
             */
            lock (m_ScriptErrors) {
                m_ScriptErrors[instance.m_ItemID] = noScriptErrors;
            }

            /*
             * Transition from CONSTRUCT->ONSTARTQ and give to RunScriptThread().
             * Put it on the start queue so it will run any queued event handlers,
             * such as state_entry() or on_rez().  If there aren't any queued, it
             * will just go to idle state when RunOne() tries to dequeue an event.
             */
            if (instance.m_IState != XMRInstState.CONSTRUCT) throw new Exception("bad state");
            instance.m_IState = XMRInstState.ONSTARTQ;
            QueueToStart(instance);
        }

        public void OnRemoveScript(uint localID, UUID itemID)
        {
            TCP("[XMREngine]: OnRemoveScript(...,{0})", itemID.ToString());

            /*
             * Remove from our list of known scripts.
             * After this, no more events can queue because we won't be
             * able to translate the itemID to an XMRInstance pointer.
             */
            XMRInstance instance = null;
            lock (m_InstancesDict)
            {
                m_LockedDict = "OnRemoveScript:" + itemID.ToString();

                /*
                 * Tell the instance to free off everything it can.
                 */
                if (!m_InstancesDict.TryGetValue(itemID, out instance))
                {
                    m_LockedDict = "~OnRemoveScript";
                    return;
                }

                /*
                 * Tell it to stop executing anything.
                 */
                instance.suspendOnCheckRunHold = true;

                /*
                 * Remove it from our list of known script instances.
                 */
                m_InstancesDict.Remove(itemID);

                List<UUID> itemIDList;
                if (m_ObjectItemList.TryGetValue (instance.m_PartUUID, out itemIDList)) {
                    itemIDList.Remove(itemID);
                    if (itemIDList.Count == 0) {
                        m_ObjectItemList.Remove(instance.m_PartUUID);
                        m_ObjectInstArray.Remove(instance.m_PartUUID);
                    } else {
                        m_ObjectInstArray[instance.m_PartUUID] = null;
                    }
                }

                /*
                 * Delete the .state file as any needed contents were fetched with GetXMLState()
                 * and stored on the database server.
                 */
                string stateFileName = XMRInstance.GetStateFileName(m_ScriptBasePath, itemID);
                File.Delete(stateFileName);

                m_LockedDict = "~~OnRemoveScript";
            }

            /*
             * Free off its stack and fun things like that.
             * If it is running, abort it.
             */
            instance.Dispose ();
        }

        public void OnScriptReset(uint localID, UUID itemID)
        {
            TCP("[XMREngine]: XMREngine.OnScriptReset({0},{1})", localID.ToString(), itemID.ToString());
            ResetScript(itemID);
        }

        public void OnStartScript(uint localID, UUID itemID)
        {
            XMRInstance instance = GetInstance (itemID);
            if (instance != null) {
                instance.Running = true;
            }
        }

        public void OnStopScript(uint localID, UUID itemID)
        {
            XMRInstance instance = GetInstance (itemID);
            if (instance != null) {
                instance.Running = false;
            }
        }

        public void OnGetScriptRunning(IClientAPI controllingClient,
                UUID objectID, UUID itemID)
        {
            XMRInstance instance = GetInstance (itemID);
            if (instance != null) {
                TCP("[XMREngine]: XMREngine.OnGetScriptRunning({0},{1})", objectID.ToString(), itemID.ToString());

                IEventQueue eq = World.RequestModuleInterface<IEventQueue>();
                if (eq == null) {
                    controllingClient.SendScriptRunningReply(objectID, itemID,
                            instance.Running);
                } else {
                    eq.Enqueue(EventQueueHelper.ScriptRunningReplyEvent(objectID,
                            itemID, instance.Running, true),
                            controllingClient.AgentId);
                }
            }
        }

        public bool HasScript(UUID itemID, out bool running)
        {
            XMRInstance instance = GetInstance (itemID);
            if (instance == null) {
                running = true;
                return false;
            }
            running = instance.Running;
            return true;
        }

        /**
         * @brief Gets called early as part of shutdown,
         *        right after "Persisting changed objects" message.
         */
        public void OnShutdown()
        {
            TCP("[XMREngine]: XMREngine.OnShutdown()");
        }

        /**
         * @brief Queue an instance to the StartQueue so it will run.
         *        This queue is used for instances that have just had
         *        an event queued to them when they were previously
         *        idle.  It must only be called by the thread that
         *        transitioned the thread to XMRInstState.ONSTARTQ so
         *        we don't get two threads trying to queue the same
         *        instance to the m_StartQueue at the same time.
         */
        public void QueueToStart(XMRInstance inst)
        {
            lock (m_StartQueue) {
                if (inst.m_IState != XMRInstState.ONSTARTQ) throw new Exception("bad state");
                m_StartQueue.InsertTail(inst);
            }
            WakeUpScriptThread();
        }

        /**
         * @brief A script may be sleeping, in which case we wake it.
         */
        public void WakeFromSleep(XMRInstance inst)
        {
            /*
             * Remove from sleep queue unless someone else already woke it.
             */
            lock (m_SleepQueue) {
                if (inst.m_IState != XMRInstState.ONSLEEPQ) {
                    return;
                }
                m_SleepQueue.Remove(inst);
            }

            /*
             * Put on end of list of scripts that are ready to run.
             */
            inst.m_IState = XMRInstState.ONYIELDQ;
            lock (m_YieldQueue) {
                m_YieldQueue.InsertTail(inst);
            }

            /*
             * Make sure the OS thread is running so it will see the script.
             */
            WakeUpScriptThread();
        }

        /**
         * @brief An instance has just finished running for now,
         *        figure out what to do with it next.
         * @param inst = instance in question, not on any queue at the moment
         * @param newIState = its new state
         * @returns with instance inserted onto proper queue (if any)
         */
        public void HandleNewIState(XMRInstance inst, XMRInstState newIState)
        {
            /*
             * RunOne() should have left the instance in RUNNING state.
             */
            if (inst.m_IState != XMRInstState.RUNNING) throw new Exception("bad state");

            /*
             * Now see what RunOne() wants us to do with the instance next.
             */
            switch (newIState) {

                /*
                 * Instance has set m_SleepUntil to when it wants to sleep until.
                 * So insert instance in sleep queue by ascending wake time.
                 * Then wake the timer thread if this is the new first entry
                 * so it will reset its timer.
                 */
                case XMRInstState.ONSLEEPQ: {
                    lock (m_SleepQueue) {
                        XMRInstance after;

                        inst.m_IState = XMRInstState.ONSLEEPQ;
                        for (after = m_SleepQueue.PeekHead(); after != null; after = after.m_NextInst) {
                            if (after.m_SleepUntil > inst.m_SleepUntil) break;
                        }
                        m_SleepQueue.InsertBefore(inst, after);
                        if (m_SleepQueue.PeekHead() == inst) {
                            Monitor.Pulse (m_SleepQueue);
                        }
                    }
                    break;
                }

                /*
                 * Instance just took a long time to run and got wacked by the
                 * slicer.  So put on end of yield queue to let someone else
                 * run.  If there is no one else, it will run again right away.
                 */
                case XMRInstState.ONYIELDQ: {
                    lock (m_YieldQueue) {
                        inst.m_IState = XMRInstState.ONYIELDQ;
                        m_YieldQueue.InsertTail(inst);
                    }
                    break;
                }

                /*
                 * Instance finished executing an event handler.  So if there is
                 * another event queued for it, put it on the start queue so it
                 * will process the new event.  Otherwise, mark it idle and the
                 * next event to queue to it will start it up.
                 */
                case XMRInstState.FINISHED: {
                    Monitor.Enter(inst.m_QueueLock);
                    if (!inst.m_Suspended && (inst.m_EventQueue.Count > 0)) {
                        Monitor.Exit(inst.m_QueueLock);
                        lock (m_StartQueue) {
                            inst.m_IState = XMRInstState.ONSTARTQ;
                            m_StartQueue.InsertTail (inst);
                        }
                    } else {
                        inst.m_IState = XMRInstState.IDLE;
                        Monitor.Exit(inst.m_QueueLock);
                    }
                    break;
                }

                /*
                 * Its m_SuspendCount > 0.
                 * Don't put it on any queue and it won't run.
                 * Since it's not IDLE, even queuing an event won't start it.
                 */
                case XMRInstState.SUSPENDED: {
                    inst.m_IState = XMRInstState.SUSPENDED;
                    break;
                }

                /*
                 * It has been disposed of.
                 * Just set the new state and all refs should theoretically drop off
                 * as the instance is no longer in any list.
                 */
                case XMRInstState.DISPOSED: {
                    inst.m_IState = XMRInstState.DISPOSED;
                    break;
                }

                /*
                 * RunOne returned something bad.
                 */
                default: throw new Exception("bad new state");
            }
        }

        /**
         * @brief Thread that moves instances from the Sleep queue to the Yield queue.
         */
        private void RunSleepThread()
        {
            double deltaTS;
            int deltaMS;
            XMRInstance inst;

            while (true) {
                lock (m_SleepQueue) {

                    /*
                     * Wait here until there is a script on the timer queue that has expired.
                     */
                    while (true) {
                        if (m_Exiting) return;
                        inst = m_SleepQueue.PeekHead();
                        if (inst == null) {
                            Monitor.Wait (m_SleepQueue);
                            continue;
                        }
                        if (inst.m_IState != XMRInstState.ONSLEEPQ) throw new Exception("bad state");
                        deltaTS = (inst.m_SleepUntil - DateTime.UtcNow).TotalMilliseconds;
                        if (deltaTS <= 0.0) break;
                        deltaMS = Int32.MaxValue;
                        if (deltaTS < Int32.MaxValue) deltaMS = (int)deltaTS;
                        Monitor.Wait (m_SleepQueue, deltaMS);
                    }

                    /*
                     * Remove the expired entry from the timer queue.
                     */
                    m_SleepQueue.RemoveHead();
                }

                /*
                 * Post the script to the yield queue so it will run and wake a script thread to run it.
                 */
                lock (m_YieldQueue) {
                    inst.m_IState = XMRInstState.ONYIELDQ;
                    m_YieldQueue.InsertTail(inst);
                }
                WakeUpScriptThread ();
            }
        }

        /**
         * @brief Thread that runs a time slicer.
         */
        private void RunSliceThread()
        {
            int ms = m_Config.GetInt ("TimeSlice", 50);
            while (!m_Exiting) {

                /*
                 * Let script run for a little bit.
                 */
                System.Threading.Thread.Sleep(ms);

                /*
                 * If some script is running, flag it to suspend
                 * temporarily next time it calls CheckRun().
                 */
                XMRInstance instance = m_RunInstance;
                if (instance != null) {
                    instance.suspendOnCheckRunTemp = true;
                }
            }
        }

        /**
         * @brief A script instance was just removed from the Start or Yield Queue.
         *        So run it for a little bit then stick in whatever queue it should go in.
         */
        private void RunInstance (XMRInstance inst)
        {
            inst.m_IState = XMRInstState.RUNNING;
            m_RunInstance = inst;
            XMRInstState newIState = inst.RunOne();
            m_RunInstance = null;
            HandleNewIState(inst, newIState);
        }

        /**
         * @brief Wake up RumScriptThread() so it will look for something to do.
         */
        private void WakeUpScriptThread()
        {
            lock (m_WakeUpLock) {
                m_WakeUpThis = true;
                Monitor.PulseAll (m_WakeUpLock);
            }
        }

        /**
         * @brief Thread that runs the scripts.
         */
        private void RunScriptThread()
        {
            XMRInstance inst;

            engstack = new Mono.Tasklets.Continuation ();
            engstack.Mark ();

            while (!m_Exiting) {

                /*
                 * Handle 'xmr resume/suspend' commands.
                 */
                if (m_SuspendScriptThreadFlag) {
                    XMREngine.m_log.Debug ("[XMREngine]: scripts suspended");
                    lock (m_WakeUpLock) {
                        while (m_SuspendScriptThreadFlag) {
                            Monitor.Wait (m_WakeUpLock);
                        }
                    }
                    XMREngine.m_log.Debug ("[XMREngine]: scripts resumed");
                }

                m_LastRanAt = DateTime.UtcNow;
                m_ScriptExecTime -= (long)(m_LastRanAt - DateTime.MinValue).TotalMilliseconds;

                /*
                 * If event just queued to any idle scripts
                 * start them right away.  But only start so
                 * many so we can make some progress on yield
                 * queue.
                 */
                int numStarts;
                for (numStarts = 5; -- numStarts >= 0;) {
                    lock (m_StartQueue) {
                        inst = m_StartQueue.RemoveHead();
                    }
                    if (inst == null) break;
                    if (inst.m_IState != XMRInstState.ONSTARTQ) throw new Exception("bad state");
                    if (inst.scrstack == null) {
                        inst.scrstack = new Mono.Tasklets.Continuation ();
                        inst.scrstack.Mark ();
                    }
                    RunInstance (inst);
                }

                /*
                 * If there is something to run, run it
                 * then rescan from the beginning in case
                 * a lot of things have changed meanwhile.
                 *
                 * These are considered lower priority than
                 * m_StartQueue as they have been taking at
                 * least one quantum of CPU time and event
                 * handlers are supposed to be quick.
                 */
                lock (m_YieldQueue) {
                    inst = m_YieldQueue.RemoveHead();
                }
                if (inst != null) {
                    if (inst.m_IState != XMRInstState.ONYIELDQ) throw new Exception("bad state");
                    if (inst.scrstack == null) {
                        inst.scrstack = new Mono.Tasklets.Continuation ();
                        inst.scrstack.Mark ();
                    }
                    RunInstance (inst);
                    numStarts = -1;
                }

                m_ScriptExecTime += (long)(DateTime.UtcNow - DateTime.MinValue).TotalMilliseconds;

                /*
                 * If we left something dangling in the m_StartQueue or m_YieldQueue, go back to check it.
                 */
                if (numStarts < 0) continue;

                /*
                 * Nothing to do, sleep.
                 */
                lock (m_WakeUpLock) {
                    if (!m_WakeUpThis) {
                        Monitor.Wait(m_WakeUpLock);
                    }
                    m_WakeUpThis = false;
                }
            }
        }

        public void Suspend(UUID itemID, int ms)
        {
            XMRInstance instance = GetInstance (itemID);
            if (instance != null) {
                instance.Sleep(ms);
            }
        }

        public void Die(UUID itemID)
        {
            XMRInstance instance = GetInstance (itemID);
            if (instance != null) {
                TCP("[XMREngine]: XMREngine.Die({0})", itemID.ToString());
                instance.Die();
            }
        }

        public XMRInstance GetInstance(UUID itemID)
        {
            XMRInstance instance;
            lock (m_InstancesDict) {
                if (!m_InstancesDict.TryGetValue(itemID, out instance)) {
                    instance = null;
                }
            }
            return instance;
        }

        // Called occasionally to write script state to .state file so the
        // script will restart from its last known state if the region crashes
        // and gets restarted.
        private void DoMaintenance(object source, ElapsedEventArgs e)
        {
            XMRInstance[] instanceArray;

            lock (m_InstancesDict) {
                instanceArray = System.Linq.Enumerable.ToArray(m_InstancesDict.Values);
            }
            foreach (XMRInstance ins in instanceArray)
            {
                // Don't save attachments
///             if (ins.m_Part.ParentGroup.RootPart.IsAttachment)
///                 continue;
                ins.GetExecutionState(new XmlDocument());
            }
        }

        /**
         * @brief Retrieve errors generated by a previous call to OnRezScript().
         *        We are guaranteed this routine will not be called before the
         *        corresponding OnRezScript() has returned.
         */
        public ArrayList GetScriptErrors(UUID itemID)
        {
            ArrayList errors;

            lock (m_ScriptErrors) {
                if (m_ScriptErrors.TryGetValue(itemID, out errors)) {
                    m_ScriptErrors.Remove(itemID);
                } else {
                    errors = noScriptErrors;
                }
            }
            return errors;
        }

        /**
         * @brief Return a list of all script execution times.
         */
        public Dictionary<uint, float> GetObjectScriptsExecutionTimes ()
        {
            Dictionary<uint, float> topScripts = new Dictionary<uint, float> ();
            lock (m_InstancesDict) {
                foreach (XMRInstance instance in m_InstancesDict.Values) {
                    uint rootLocalID = instance.m_Part.ParentGroup.LocalId;
                    float oldTotal;
                    if (!topScripts.TryGetValue (rootLocalID, out oldTotal)) {
                        oldTotal = 0;
                    }
                    topScripts[rootLocalID] = (float)instance.m_CPUTime + oldTotal;
                }
            }
            return topScripts;
        }

        /**
         * @brief A float the value is a representative execution time in
         *        milliseconds of all scripts in the link set.
         * @param itemIDs = list of scripts in the link set
         * @returns milliseconds for all those scripts
         */
        public float GetScriptExecutionTime (List<UUID> itemIDs)
        {
            if ((itemIDs == null) || (itemIDs.Count == 0)) {
                return 0;
            }
            float time = 0;
            foreach (UUID itemID in itemIDs) {
                XMRInstance instance = GetInstance (itemID);
                if ((instance != null) && instance.Running) {
                    time += (float) instance.m_CPUTime;
                }
            }
            return time;
        }

        public void SuspendScript(UUID itemID)
        {
            XMRInstance instance = GetInstance (itemID);
            if (instance != null) {
                TCP("[XMREngine]: XMREngine.SuspendScript({0})", itemID.ToString());
                instance.SuspendIt();
            }
        }

        public void ResumeScript(UUID itemID)
        {
            XMRInstance instance = GetInstance (itemID);
            if (instance != null) {
                TCP("[XMREngine]: XMREngine.ResumeScript({0})", itemID.ToString());
                instance.ResumeIt();
            } else {
                m_log.ErrorFormat("[XMREngine]: ResumeScript called for {0}, which was not found", itemID.ToString());
            }
        }

        /**
         * @brief Rebuild m_ObjectInstArray[partUUID] from m_ObjectItemList[partUUID]
         * @param partUUID = which object in scene to rebuild for
         */
        private XMRInstance[] RebuildObjectInstArray (UUID partUUID)
        {
            List<UUID> itemIDList = m_ObjectItemList[partUUID];
            int n = 0;
            foreach (UUID itemID in itemIDList) {
                if (m_InstancesDict.ContainsKey (itemID)) n ++;
            }
            XMRInstance[] a = new XMRInstance[n];
            n = 0;
            foreach (UUID itemID in itemIDList) {
                if (m_InstancesDict.TryGetValue (itemID, out a[n])) n ++;
            }
            m_ObjectInstArray[partUUID] = a;
            return a;
        }

        public static void NoPrint (params string[] list)
        { }
    }
}
