/***************************************************\
 *  COPYRIGHT 2009, Mike Rieker, Beverly, MA, USA  *
 *  All rights reserved.                           *
\***************************************************/

using Mono.Tasklets;
using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.Remoting;
using System.Text;
using System.Threading;
using OpenSim.Region.ScriptEngine.Shared.ScriptBase;

#include "lsltypes.h"

/*
 *  XMRInstance.StartEventHandler()
 *    MMRUThread.StartEx()
 *      ScriptUThread.MainEx()
 *        ScriptUThread.RunCont()
 *          scriptHandlerEventTable[state,event]()
 *             XMRInstance.CheckRun()
 *                <dump stack>
 *                MMRUThread.Suspend()
 */

namespace OpenSim.Region.ScriptEngine.XMREngine {

    /*************************************************************\
     *  Wrapper around instance to enclose it in a microthread.  *
    \*************************************************************/

    public class ScriptUThread : MMRUThread {

        public XMRInstance instance;

        public ScriptUThread (XMRInstance instance) : base (instance.m_StackSize, instance.m_DescName)
        {
            this.instance = instance;
        }

        /*
         * Called on the microthread stack as part of Start().
         * Start() returns when this method calls Suspend() or
         * when this method returns (whichever happens first).
         */
        public override Exception MainEx ()
        {
            Exception except = null;

            /*
             * Restoring the stress test trumps any other state.
             */
            if (instance.m_CheckRunStressWrite) {

                /*
                 * Use a different stack position each time.
                 */
                if (-- instance.m_CheckRunStressStack >= 0) {
                    except = MainEx();
                    instance.m_CheckRunStressStack ++; // prevent TCO of MainEx() call
                } else {
                    ///???
                }
            }

            /*
             * The normal case is this script event handler is just being
             * called directly at its entrypoint.  The RunItEx() method
             * calls RunCont() below.  Any exceptions thrown by RunCont()
             * are returned by RunItEx().
             */
            else if (instance.migrateInStream == null) {
                instance.callMode = 0;  // normal
                try {
                    RunCont ();
                } catch (Exception e) {
                    except = e;
                }
            }

            /*
             * The other case is that we want to resume execution of
             * a script from its migration data.  So this reads the
             * data from the stream to recreate wherever RunCont()
             * called Save() from, then it jumps to that point.
             *
             * In our case, that point is always within our CheckRun()
             * method, which immediately suspends when the restore is
             * complete, which causes LoadEx() to return at that time.
             */
            else {
                instance.callMode = 2;  // restore
                try {
                    RunCont ();
                } catch (Exception e) {
                    except = e;
                }
            }
            return except;
        }

        public void RunCont ()
        {
            int newStateCode, oldStateCode;
            ScriptEventHandler seh;
            XMRInstance sw = instance;

            /*
             * Process event given by 'stateCode' and 'eventCode'.
             * The event handler should call CheckRun() as often as convenient.
             *
             * We do not have to check for null 'seh' here because
             * StartEventHandler() already checked the table entry.
             */
            sw.stateChanged = false;
            oldStateCode = sw.stateCode;
            seh = sw.objCode.scriptEventHandlerTable[oldStateCode,(int)sw.eventCode];
            seh (sw);

            sw.ehArgs = null;  // we are done with them and no args for
                               // exit_state()/enter_state() anyway

            /*
             * If event handler changed state, call exit_state() on the old state,
             * change the state, then call enter_state() on the new state.
             */
            while (sw.stateChanged) {

                /*
                 * Get what state they transitioned to.
                 */
                newStateCode = sw.stateCode;

                /*
                 * Restore to old state and call its state_exit() handler.
                 */
                sw.stateChanged = false;
                sw.eventCode = ScriptEventCode.state_exit;
                sw.stateCode = oldStateCode;
                seh = sw.objCode.scriptEventHandlerTable[oldStateCode,(int)ScriptEventCode.state_exit];
                if (seh != null) seh (sw);

                /*
                 * Now that the old state can't possibly start any more activity,
                 * cancel any listening handlers, etc, of the old state.
                 */
                sw.stateCode = newStateCode;
                sw.StateChange ();

                /*
                 * Now the new state becomes the old state in case the new state_entry() 
                 * changes state again.
                 */
                oldStateCode = newStateCode;

                /*
                 * Call the new state's state_entry() handler.
                 * I've seen scripts that change state in the state_entry() handler, 
                 * so allow for that by looping back to check sw.stateChanged again.
                 */
                sw.stateChanged = false;
                sw.eventCode = ScriptEventCode.state_entry;
                seh = sw.objCode.scriptEventHandlerTable[newStateCode,(int)ScriptEventCode.state_entry];
                if (seh != null) seh (sw);
            }

            /*
             * Event no longer being processed.
             */
            sw.eventCode = ScriptEventCode.None;
        }
    }
}
