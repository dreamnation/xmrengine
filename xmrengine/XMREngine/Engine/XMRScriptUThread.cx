/***************************************************\
 *  COPYRIGHT 2009, Mike Rieker, Beverly, MA, USA  *
 *  All rights reserved.                           *
\***************************************************/

using Mono.Tasklets;
using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.Remoting;
using System.Text;
using System.Threading;
using OpenSim.Region.ScriptEngine.Shared.ScriptBase;

#include "lsltypes.h"

/*
 *  XMRInstance.StartEventHandler()
 *    MMRUThread.StartEx()
 *      ScriptUThread.MainEx()
 *        ScriptUThread.CallSEH()
 *          scriptHandlerEventTable[state,event]()
 *             XMRInstance.CheckRun()
 *                throw StackCaptureException()
 *                MMRUThread.Suspend()
 */

namespace OpenSim.Region.ScriptEngine.XMREngine {

    /*************************************************************\
     *  Wrapper around instance to enclose it in a microthread.  *
    \*************************************************************/

    public class ScriptUThread : MMRUThread {

        public XMRInstance instance;

        public ScriptUThread (XMRInstance instance) 
                : base ((UIntPtr)(uint)instance.m_StackSize, instance.m_DescName)
        {
            this.instance = instance;
        }

        /*
         * Called on the microthread stack as part of Start().
         * Start() returns when this method calls Suspend() or
         * when this method returns (whichever happens first).
         */
        public override Exception MainEx ()
        {
            /*
             * CALLMODE_NORMAL:  run event handler from the beginning normally
             * CALLMODE_RESTORE: restore event handler stack from stackFrames
             */
            instance.callMode = (instance.stackFrames == null) ? XMRInstAbstract.CALLMODE_NORMAL :
                                                                 XMRInstAbstract.CALLMODE_RESTORE;

            /*
             * Run event handler according to callMode.
             * In either case it is assumed that instance.stateCode and instance.eventCode
             * indicate which event handler is to be called and that instance.ehArgs
             * points to the event handler argument list.
             */
            try {
                CallSEH ();
                return null;
            } catch (Exception e) {
                return e;
            }
        }

        /**
         * @brief Call script's event handler function from the very beginning.
         * @param instance.stateCode = which state the event is happening in
         * @param instance.eventCode = which event is happening in that state
         * @returns when event handler has completed or throws an exception
         *          with instance.eventCode = ScriptEventCode.None
         */
        private void CallSEH ()
        {
            int newStateCode;
            ScriptEventHandler seh;
            XMRInstance sw = instance;

            while (true) {

                /*
                 * Before running any event handler, run any script-defined type destructors.
                 */
                while (true) {
                    XMRSDTypeClassInstance ci;
                    lock (sw.m_sdtcDestroyQueue) {
                        if (sw.m_sdtcDestroyQueue.Count == 0) {
                            sw.m_hasSDTCDestructors = false;
                            break;
                        }
                        ci = sw.m_sdtcDestroyQueue.Dequeue ();
                    }
                    try {
                        ci.RunDestructor ();
                    } catch (ScriptChangeStateException) {
                        // ignore any state changes by the destructor
                    }
                }
                if (sw.eventCode == ScriptEventCode.SDT_Destroy) break;
                    
                /*
                 * Process event given by 'stateCode' and 'eventCode'.
                 * The event handler should call CheckRun() as often as convenient.
                 */
                newStateCode = sw.stateCode;
                seh = sw.m_ObjCode.scriptEventHandlerTable[sw.stateCode,(int)sw.eventCode];
                if (seh != null) {
                    try {
                        seh (sw);
                    } catch (ScriptChangeStateException scse) {
                        newStateCode = scse.newState;
                    }
                }
                sw.ehArgs = null;  // we are done with them and no args for
                                   // exit_state()/enter_state() anyway

                /*
                 * The usual case is no state change.
                 * Even a 'state <samestate>;' statement has no effect except to exit out.
                 * See http://wiki.secondlife.com/wiki/State
                 */
                if (newStateCode == sw.stateCode) break;

                /*
                 * Call old state's state_exit() handler.
                 */
                sw.eventCode = ScriptEventCode.state_exit;
                seh = sw.m_ObjCode.scriptEventHandlerTable[sw.stateCode,(int)ScriptEventCode.state_exit];
                if (seh != null) {
                    try {
                        seh (sw);
                    } catch (ScriptChangeStateException scse) {
                        newStateCode = scse.newState;
                    }
                }

                /*
                 * Now that the old state can't possibly start any more activity,
                 * cancel any listening handlers, etc, of the old state.
                 */
                sw.stateCode = newStateCode;
                sw.StateChange ();

                /*
                 * Loop back to call the new state's state_entry() handler.
                 */
                sw.eventCode = ScriptEventCode.state_entry;
            }

            /*
             * Event no longer being processed.
             */
            sw.eventCode = ScriptEventCode.None;
        }
    }
}
