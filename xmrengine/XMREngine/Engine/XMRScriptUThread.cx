/***************************************************\
 *  COPYRIGHT 2009, Mike Rieker, Beverly, MA, USA  *
 *  All rights reserved.                           *
\***************************************************/

using Mono.Tasklets;
using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.Remoting;
using System.Text;
using System.Threading;
using OpenSim.Region.ScriptEngine.Shared.ScriptBase;

#include "lsltypes.h"

/*
 *  XMRInstance.StartEventHandler()
 *    MMRUThread.StartEx()
 *      ScriptUThread.MainEx()
 *        ScriptUThread.CallSEH()
 *          scriptHandlerEventTable[state,event]()
 *             XMRInstance.CheckRun()
 *                throw StackCaptureException()
 *                MMRUThread.Suspend()
 */

namespace OpenSim.Region.ScriptEngine.XMREngine {

    /*************************************************************\
     *  Wrapper around instance to enclose it in a microthread.  *
    \*************************************************************/

    public class ScriptUThread : MMRUThread {

        public XMRInstance instance;

        public ScriptUThread (XMRInstance instance) : base (instance.m_StackSize, instance.m_DescName)
        {
            this.instance = instance;
        }

        /*
         * Called on the microthread stack as part of Start().
         * Start() returns when this method calls Suspend() or
         * when this method returns (whichever happens first).
         */
        public override Exception MainEx ()
        {
            /*
             * CALLMODE_NORMAL:  run event handler from the beginning normally
             * CALLMODE_RESTORE: restore event handler stack from stackFrames
             */
            instance.callMode = (instance.stackFrames == null) ? XMRInstAbstract.CALLMODE_NORMAL :
                                                                 XMRInstAbstract.CALLMODE_RESTORE;

            /*
             * Run event handler according to callMode.
             * In either case it is assumed that instance.stateCode and instance.eventCode
             * indicate which event handler is to be called and that instance.ehArgs
             * points to the event handler argument list.
             */
            try {
                CallSEH ();
                return null;
            } catch (Exception e) {
                return e;
            }
        }

        /**
         * @brief Call script's event handler function from the very beginning.
         * @param instance.stateCode = which state the event is happening in
         * @param instance.eventCode = which event is happening in that state
         * @returns when event handler has completed or throws an exception
         *          with instance.eventCode = ScriptEventCode.None
         */
        private void CallSEH ()
        {
            int newStateCode, oldStateCode;
            ScriptEventHandler seh;
            XMRInstance sw = instance;

            /*
             * Process event given by 'stateCode' and 'eventCode'.
             * The event handler should call CheckRun() as often as convenient.
             *
             * We do not have to check for null 'seh' here because
             * StartEventHandler() already checked the table entry.
             */
            sw.stateChanged = false;
            oldStateCode = sw.stateCode;
            seh = sw.objCode.scriptEventHandlerTable[oldStateCode,(int)sw.eventCode];
            seh (sw);

            sw.ehArgs = null;  // we are done with them and no args for
                               // exit_state()/enter_state() anyway

            /*
             * If event handler changed state, call exit_state() on the old state,
             * change the state, then call enter_state() on the new state.
             */
            while (sw.stateChanged) {

                /*
                 * Get what state they transitioned to.
                 */
                newStateCode = sw.stateCode;

                /*
                 * Restore to old state and call its state_exit() handler.
                 */
                sw.stateChanged = false;
                sw.eventCode = ScriptEventCode.state_exit;
                sw.stateCode = oldStateCode;
                seh = sw.objCode.scriptEventHandlerTable[oldStateCode,(int)ScriptEventCode.state_exit];
                if (seh != null) seh (sw);

                /*
                 * Now that the old state can't possibly start any more activity,
                 * cancel any listening handlers, etc, of the old state.
                 */
                sw.stateCode = newStateCode;
                sw.StateChange ();

                /*
                 * Now the new state becomes the old state in case the new state_entry() 
                 * changes state again.
                 */
                oldStateCode = newStateCode;

                /*
                 * Call the new state's state_entry() handler.
                 * I've seen scripts that change state in the state_entry() handler, 
                 * so allow for that by looping back to check sw.stateChanged again.
                 */
                sw.stateChanged = false;
                sw.eventCode = ScriptEventCode.state_entry;
                seh = sw.objCode.scriptEventHandlerTable[newStateCode,(int)ScriptEventCode.state_entry];
                if (seh != null) seh (sw);
            }

            /*
             * Event no longer being processed.
             */
            sw.eventCode = ScriptEventCode.None;
        }
    }
}
