/***************************************************\
 *  COPYRIGHT 2009, Mike Rieker, Beverly, MA, USA  *
 *  All rights reserved.                           *
\***************************************************/

using Mono.Tasklets;
using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.Remoting;
using System.Text;
using System.Threading;
using OpenSim.Region.ScriptEngine.Shared.ScriptBase;

#include "lsltypes.h"

/*
 *  XMRInstance.StartEventHandler()
 *    MMRUThread.StartEx()
 *      ScriptUThread.MainEx()
 *        instance.CallSEH()
 *          scriptHandlerEventTable[state,event]()
 *             XMRInstance.CheckRun()
 *                throw StackCaptureException()
 *                MMRUThread.Suspend()
 */

namespace OpenSim.Region.ScriptEngine.XMREngine {

    /*************************************************************\
     *  Wrapper around instance to enclose it in a microthread.  *
    \*************************************************************/

    public class ScriptUThread
#if HAVE_MMRUTHREADS
            : MMRUThread
#else
            : IDisposable
#endif
    {
        public XMRInstance instance;

        public ScriptUThread (XMRInstance instance) 
#if HAVE_MMRUTHREADS
                : base ((UIntPtr)(uint)instance.m_StackSize, instance.m_DescName)
#endif
        {
            this.instance = instance;
        }

#if HAVE_MMRUTHREADS
        /*
         * Called on the microthread stack as part of StartEx().
         * StartEx() returns when this method calls Suspend() or
         * when this method returns (whichever happens first).
         */
        public override Exception MainEx ()
        {
            /*
             * Run event handler according to callMode.
             * In either case it is assumed that instance.stateCode and instance.eventCode
             * indicate which event handler is to be called and that instance.ehArgs
             * points to the event handler argument list.
             */
            try {
                instance.CallSEH ();
                return null;
            } catch (Exception e) {
                return e;
            }
        }

        public void Hiber ()
        {
            MMRUThread.Suspend ();
        }
#else
        private const int SAVEENGINESTACK = 0;
        private const int LOADENGINESTACK = 1;
        private const int SAVESCRIPTSTACK = 2;
        private const int LOADSCRIPTSTACK = 3;

        private Exception except;
        private int active;

        /**
         * @brief Start script event handler from the beginning.
         *        Return when either the script event handler completes
         *        or the script calls Hiber().
         * @returns null: script did not throw any exception so far
         *          else: script threw an exception
         */
        public void Start ()
        {
            Exception e = StartEx ();
            if (e != null) throw e;
        }
        public Exception StartEx ()
        {
            active = 1;

            /*
             * Save engine stack so we know how to jump back to engine in case
             * the script calls Hiber().
             */
            switch (instance.engstack.Store (SAVEENGINESTACK)) {

                /*
                 * Engine stack has been saved, start running the event handler.
                 */
                case SAVEENGINESTACK: {

                    /*
                     * Run event handler according to callMode.
                     * In either case it is assumed that stateCode and eventCode
                     * indicate which event handler is to be called and that ehArgs
                     * points to the event handler argument list.
                     */
                    except = null;
                    try {
                        instance.CallSEH ();
                    } catch (Exception e) {
                        except = e;
                    }

                    /*
                     * We now want to return to the script engine.
                     * Setting active = 0 means the microthread has exited.
                     * We need to call engstack.Restore() in case the script called Hiber()
                     * anywhere, we want to return out the corresponding Restore() and not the
                     * Start().
                     */
                    active = 0;
                    instance.engstack.Restore (LOADENGINESTACK);
                    throw new Exception ("returned from Restore()");
                }

                /*
                 * Script called Hiber() somewhere so just return back out.
                 */
                case LOADENGINESTACK: {
                    break;
                }

                default: throw new Exception ("bad engstack code");
            }

            return except;
        }

        public void Dispose ()
        { }

        /**
         * @brief Determine if script is active.
         * Returns: 0: nothing started or has returned
         *             Wake() must not be called
         *             Start() may be called
         *             Hiber() must not be called
         *         -1: thread has called Hiber()
         *             Wake() may be called
         *             Start() may be called
         *             Hiber() must not be called
         *          1: thread is running
         *             Wake() must not be called
         *             Start() must not be called
         *             Hiber() may be called
         */
        public int Active ()
        {
            return active;
        }

        /**
         * @brief Called by the script wherever it wants to hibernate.
         *        So this means to save the scripts stack in 'instance.scrstack' then
         *        restore the engstack to cause us to return back to the engine.
         */
        public void Hiber ()
        {
            active = -1;

            /*
             * Save where we are in the script's code in 'instance.scrstack'
             * so we can wake the script when Wake() is called.
             */
            switch (instance.scrstack.Store (SAVESCRIPTSTACK)) {

                /*
                 * Script's stack is now saved in 'instance.scrstack'.
                 * Reload the engine's stack from 'instance.engstack' and jump to it.
                 */
                case SAVESCRIPTSTACK: {
                    instance.engstack.Restore (LOADENGINESTACK);
                    throw new Exception ("returned from Restore()");
                }

                /*
                 * Wake() was just called and we want to resume executing script code.
                 */
                case LOADSCRIPTSTACK: {
                    break;
                }

                default: throw new Exception ("bad scrstack code");
            }
        }

        /**
         * @brief We now want to run some more script code from where it last hibernated
         *        until it either finishes the script event handler or until the script
         *        calls Hiber() again.
         */
        public Exception ResumeEx (object dummy)
        {
            active = 1;

            /*
             * Save where we are in the engine's code in 'instance.engstack'
             * so if the script calls Hiber() again or exits, we know how to get
             * back to the engine.
             */
            switch (instance.engstack.Store (SAVEENGINESTACK)) {

                /*
                 * This is original call to Wake() from the engine,
                 * jump to where we left off within Hiber().
                 */
                case SAVEENGINESTACK: {
                    instance.scrstack.Restore (LOADSCRIPTSTACK);
                    throw new Exception ("returned from Restore()");
                }

                /*
                 * Script has called Hiber() again, so return back to
                 * script engine code.
                 */
                case LOADENGINESTACK: {
                    break;
                }

                default: throw new Exception ("bad engstack code");
            }

            return except;
        }
#endif
    }
}
