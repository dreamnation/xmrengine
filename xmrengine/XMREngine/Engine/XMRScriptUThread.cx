/***************************************************\
 *  COPYRIGHT 2009, Mike Rieker, Beverly, MA, USA  *
 *  All rights reserved.                           *
\***************************************************/

using Mono.Tasklets;
using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.Remoting;
using System.Text;
using System.Threading;
using OpenSim.Region.ScriptEngine.Shared.ScriptBase;

#include "lsltypes.h"

/*
 *  XMRInstance.StartEventHandler()
 *    MMRUThread.StartEx()
 *      ScriptUThread.MainEx()
 *        ScriptUThread.CallSEH()
 *          scriptHandlerEventTable[state,event]()
 *             XMRInstance.CheckRun()
 *                throw StackSaveException()
 *                MMRUThread.Suspend()
 */

namespace OpenSim.Region.ScriptEngine.XMREngine {

    /*************************************************************\
     *  Wrapper around instance to enclose it in a microthread.  *
    \*************************************************************/

    public class ScriptUThread : MMRUThread {

        public XMRInstance instance;

        public ScriptUThread (XMRInstance instance) : base (instance.m_StackSize, instance.m_DescName)
        {
            this.instance = instance;
        }

        /*
         * Called on the microthread stack as part of Start().
         * Start() returns when this method calls Suspend() or
         * when this method returns (whichever happens first).
         */
        public override Exception MainEx ()
        {
            Exception except = null;

            /*
             * Restoring the stress test trumps any other state.
             */
            if (instance.m_CheckRunStressWrite) {

                /*
                 * Use a different stack position each time.
                 */
                if (-- instance.m_CheckRunStressStack >= 0) {
                    except = MainEx();
                    instance.m_CheckRunStressStack ++; // prevent TCO of MainEx() call
                } else {
                    ///???
                }
            }

            /*
             * The normal case is this script event handler is just being
             * called directly at its entrypoint.
             */
            else if (instance.callMode == XMRInstAbstract.CALLMODE_NORMAL) {
                instance.callMode = XMRInstAbstract.CALLMODE_NORMAL;
                try {
                    CallSEH ();
                    XMRInstance.m_log.Debug("[XMREngine]: MainEx*: CallSEH() normal returned");
                } catch (Exception e) {
                    except = e;
                    XMRInstance.m_log.Debug("[XMREngine]: MainEx*: CallSEH() normal threw " + e.ToString ());
                }
            }

            /*
             * The other case is that we want to resume execution of
             * a script from its migration data.  So this reads the
             * data from the instance.stackFrames list and eventually
             * ends up calling CheckRun().
             *
             * CheckRun() immediately suspends when the restore is
             * complete, which causes StartEx() to return at that time.
             */
            else {
                if (instance.callMode != XMRInstAbstract.CALLMODE_RESTORE) {
                    throw new Exception ("bad callMode " + instance.callMode);
                }
                try {
                    CallSEH ();
                    XMRInstance.m_log.Debug("[XMREngine]: MainEx*: CallSEH() restore returned");
                } catch (Exception e) {
                    except = e;
                    string s = e.ToString ();
                    int j;
                    for (int i = 0; i < s.Length; i = ++ j) {
                        j = s.IndexOf ('\n', i);
                        if (j < 0) j = s.Length;
                        XMRInstance.m_log.Debug("[XMREngine]: MainEx*: CallSEH() restore threw " + s.Substring (i, j - i));
                    }
                }
                // returns here ONLY after restore has complete AND script
                // has been resumed AND event handler has run to completion
            }
            return except;
        }

        /**
         * @brief Call script's event handler function from the very beginning.
         * @param instance.stateCode = which state the event is happening in
         * @param instance.eventCode = which event is happening in that state
         * @returns when event handler has completed or throws an exception
         *          with instance.eventCode = ScriptEventCode.None
         */
        private void CallSEH ()
        {
            int newStateCode, oldStateCode;
            ScriptEventHandler seh;
            XMRInstance sw = instance;

            /*
             * Process event given by 'stateCode' and 'eventCode'.
             * The event handler should call CheckRun() as often as convenient.
             *
             * We do not have to check for null 'seh' here because
             * StartEventHandler() already checked the table entry.
             */
            sw.stateChanged = false;
            oldStateCode = sw.stateCode;
            seh = sw.objCode.scriptEventHandlerTable[oldStateCode,(int)sw.eventCode];
            seh (sw);

            sw.ehArgs = null;  // we are done with them and no args for
                               // exit_state()/enter_state() anyway

            /*
             * If event handler changed state, call exit_state() on the old state,
             * change the state, then call enter_state() on the new state.
             */
            while (sw.stateChanged) {

                /*
                 * Get what state they transitioned to.
                 */
                newStateCode = sw.stateCode;

                /*
                 * Restore to old state and call its state_exit() handler.
                 */
                sw.stateChanged = false;
                sw.eventCode = ScriptEventCode.state_exit;
                sw.stateCode = oldStateCode;
                seh = sw.objCode.scriptEventHandlerTable[oldStateCode,(int)ScriptEventCode.state_exit];
                if (seh != null) seh (sw);

                /*
                 * Now that the old state can't possibly start any more activity,
                 * cancel any listening handlers, etc, of the old state.
                 */
                sw.stateCode = newStateCode;
                sw.StateChange ();

                /*
                 * Now the new state becomes the old state in case the new state_entry() 
                 * changes state again.
                 */
                oldStateCode = newStateCode;

                /*
                 * Call the new state's state_entry() handler.
                 * I've seen scripts that change state in the state_entry() handler, 
                 * so allow for that by looping back to check sw.stateChanged again.
                 */
                sw.stateChanged = false;
                sw.eventCode = ScriptEventCode.state_entry;
                seh = sw.objCode.scriptEventHandlerTable[newStateCode,(int)ScriptEventCode.state_entry];
                if (seh != null) seh (sw);
            }

            /*
             * Event no longer being processed.
             */
            sw.eventCode = ScriptEventCode.None;
        }
    }
}
