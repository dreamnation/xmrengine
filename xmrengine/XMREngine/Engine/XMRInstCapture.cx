//////////////////////////////////////////////////////////////
//
// Copyright (c) 2009 Careminster Limited and Melanie Thielker
// Copyright (c) 2010 Mike Rieker, Beverly, MA, USA
//
// All rights reserved
//

using System;
using System.Threading;
using System.Reflection;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.Remoting.Lifetime;
using System.Security.Policy;
using System.IO;
using System.Xml;
using System.Text;
using Mono.Tasklets;
using OpenMetaverse;
using OpenSim.Framework;
using OpenSim.Region.ScriptEngine.Interfaces;
using OpenSim.Region.ScriptEngine.Shared;
using OpenSim.Region.ScriptEngine.Shared.Api;
using OpenSim.Region.ScriptEngine.Shared.ScriptBase;
using OpenSim.Region.ScriptEngine.XMREngine;
using OpenSim.Region.Framework.Scenes;
using log4net;

#include "lsltypes.h"

namespace OpenSim.Region.ScriptEngine.XMREngine
{
    public partial class XMRInstance
    {
        /********************************************************************************\
         *  The only method of interest to outside this module is GetExecutionState()   *
         *  which captures the current state of the script into an XML document.        *
         *                                                                              *
         *  The rest of this module contains support routines for GetExecutionState().  *
        \********************************************************************************/

        /**
         * @brief Create an XML element that gives the current state of the script.
         *   <ScriptState Asset=m_AssetID>
         *     <Snapshot>globalsandstackdump</Snapshot>
         *     <Running>m_Running</Running>
         *     <DetectArray ...
         *     <EventQueue ...
         *     <Permissions ...
         *     <Plugins />
         *   </ScriptState>
         * Updates the .state file while we're at it.
         */
        public XmlElement GetExecutionState(XmlDocument doc)
        {
            /*
             * When we're detaching an attachment, we need to wait here.
             */

            // Change this to a 5 second timeout. If things do mess up,
            // we don't want to be stuck forever.
            //
            m_DetachReady.WaitOne(5000);

            XmlElement scriptStateN = doc.CreateElement("", "ScriptState", "");
            scriptStateN.SetAttribute("Engine", m_Engine.ScriptEngineName);
            scriptStateN.SetAttribute("Asset", m_AssetID.ToString());

            /*
             * Make sure we aren't executing part of the script so it stays 
             * stable.  Setting suspendOnCheckRun tells CheckRun() to suspend
             * and return out so RunOne() will release the lock asap.
             */
            suspendOnCheckRunHold = true;
            lock (m_RunLock)
            {
                m_RunOnePhase = "GetExecutionState enter";
                CheckRunLockInvariants(true);

                /*
                 * Get copy of script globals and stack in relocateable form.
                 */
                MemoryStream snapshotStream = new MemoryStream();
                MigrateOutEventHandler(snapshotStream);
                Byte[] snapshotBytes = snapshotStream.ToArray();
                snapshotStream.Close();
                string snapshotString = Convert.ToBase64String(snapshotBytes);
                XmlElement snapshotN = doc.CreateElement("", "Snapshot", "");
                snapshotN.AppendChild(doc.CreateTextNode(snapshotString));
                scriptStateN.AppendChild(snapshotN);
                m_RunOnePhase = "GetExecutionState B"; CheckRunLockInvariants(true);

                /*
                 * "Running" says whether or not we are accepting new events.
                 */
                XmlElement runningN = doc.CreateElement("", "Running", "");
                runningN.AppendChild(doc.CreateTextNode(m_Running.ToString()));
                scriptStateN.AppendChild(runningN);
                m_RunOnePhase = "GetExecutionState C"; CheckRunLockInvariants(true);

                /*
                 * "DoGblInit" says whether or not default:state_entry() will init global vars.
                 */
                XmlElement doGblInitN = doc.CreateElement("", "DoGblInit", "");
                doGblInitN.AppendChild(doc.CreateTextNode(doGblInit.ToString()));
                scriptStateN.AppendChild(doGblInitN);
                m_RunOnePhase = "GetExecutionState D"; CheckRunLockInvariants(true);

                /*
                 * More misc data.
                 */
                XmlNode permissionsN = doc.CreateElement("", "Permissions", "");
                scriptStateN.AppendChild(permissionsN);

                XmlAttribute granterA = doc.CreateAttribute("", "granter", "");
                granterA.Value = m_Item.PermsGranter.ToString();
                permissionsN.Attributes.Append(granterA);

                XmlAttribute maskA = doc.CreateAttribute("", "mask", "");
                maskA.Value = m_Item.PermsMask.ToString();
                permissionsN.Attributes.Append(maskA);
                m_RunOnePhase = "GetExecutionState E"; CheckRunLockInvariants(true);

                /*
                 * "DetectParams" are returned by llDetected...() script functions
                 * for the currently active event, if any.
                 */
                if (m_DetectParams != null)
                {
                    XmlElement detParArrayN = doc.CreateElement("", "DetectArray", "");
                    AppendXMLDetectArray(doc, detParArrayN, m_DetectParams);
                    scriptStateN.AppendChild(detParArrayN);
                }
                m_RunOnePhase = "GetExecutionState F"; CheckRunLockInvariants(true);

                /*
                 * Save any events we have in the queue.
                 * <EventQueue>
                 *   <Event Name="...">
                 *     <param>...</param> ...
                 *     <DetectParams>...</DetectParams> ...
                 *   </Event>
                 *   ...
                 * </EventQueue>
                 */
                XmlElement queuedEventsN = doc.CreateElement("", "EventQueue", "");
                lock (m_QueueLock)
                {
                    foreach (EventParams evt in m_EventQueue)
                    {
                        XmlElement singleEventN = doc.CreateElement("", "Event", "");
                        singleEventN.SetAttribute("Name", evt.EventName);
                        AppendXMLObjectArray(doc, singleEventN, evt.Params, "param");
                        AppendXMLDetectArray(doc, singleEventN, evt.DetectParams);
                        queuedEventsN.AppendChild(singleEventN);
                    }
                }
                scriptStateN.AppendChild(queuedEventsN);
                m_RunOnePhase = "GetExecutionState G"; CheckRunLockInvariants(true);

                /*
                 * "Plugins" indicate enabled timers and listens, etc.
                 */
                Object[] pluginData = 
                        AsyncCommandManager.GetSerializationData(m_Engine,
                                m_ItemID);

                XmlNode plugins = doc.CreateElement("", "Plugins", "");
                AppendXMLObjectArray(doc, plugins, pluginData, "plugin");
                scriptStateN.AppendChild(plugins);
                m_RunOnePhase = "GetExecutionState H"; CheckRunLockInvariants(true);

                /*
                 * Let script run again.
                 */
                suspendOnCheckRunHold = false;

                m_RunOnePhase = "GetExecutionState leave";
                CheckRunLockInvariants(true);
            }

            /*
             * scriptStateN represents the contents of the .state file so
             * write the .state file while we are here.
             */
            FileStream fs = File.Create(m_StateFileName);
            StreamWriter sw = new StreamWriter(fs);
            sw.Write(scriptStateN.OuterXml);
            sw.Close();
            fs.Close();

            return scriptStateN;
        }

        /**
         * @brief Write script state to output stream.
         *        The script microthread is at same state on return,
         *        ie, either inactive or suspended inside CheckRun().
         *
         * Input:
         *  stream = stream to write event handler state information to
         */
        private void MigrateOutEventHandler (Stream stream)
        {
            try {

                /*
                 * The script microthread should be at its Suspend() call within
                 * CheckRun(), unless it has exited.  Tell CheckRun() that it 
                 * should migrate the script out then suspend.
                 */
                this.migrateInReader   = null;
                this.migrateInStream   = null;
                this.migrateOutWriter  = new BinaryWriter (stream);
                this.migrateOutStream  = stream;
                this.migrateOutObjects = new Dictionary<object, int> ();

                /*
                 * Write the basic information out to the stream:
                 *    state, event, eventhandler args, script's globals.
                 */
                stream.WriteByte (migrationVersion);
                stream.WriteByte ((byte)ScriptCodeGen.COMPILED_VERSION_VALUE);
                this.SendObjValue (this.stateCode);
                this.SendObjValue (this.eventCode);
                this.SendObjValue (this.heapLimit - this.heapLeft);
                this.SendObjValue (this.ehArgs);

                this.SendObjArray (this.gblArrays);
                this.SendObjArray (this.gblFloats);
                this.SendObjArray (this.gblIntegers);
                this.SendObjArray (this.gblLists);
                this.SendObjArray (this.gblObjects);
                this.SendObjArray (this.gblRotations);
                this.SendObjArray (this.gblStrings);
                this.SendObjArray (this.gblVectors);

                /*
                 * Resume the microthread and it will throw a StackCaptureException()
                 * with the stack frames saved to this.stackFrames.
                 * Then write the saved stack frames to the output stream.
                 *
                 * There is a stack only if the event code is not None.
                 */
                if (this.eventCode != ScriptEventCode.None) {

                    try {
                        // tell microthread to continue
                        // it should see captureStackFrames and throw StackCaptureException()
                        // ...generating XMRStackFrames as it unwinds
                        this.captureStackFrames = true;
                        Exception except = this.microthread.ResumeEx (null);
                        this.captureStackFrames = false;
                        if (except == null) {
                            throw new Exception ("stack save did not complete");
                        }
                        if (!(except is StackCaptureException)) {
                            throw except;
                        }

                        // first frame we see is the event handler's frame
                        // last frame we see is whatever called CheckRun()
                        for (XMRStackFrame sf = this.stackFrames; sf != null; sf = sf.nextSF) {
                            this.migrateOutWriter.Write (sf.callNo);  // what it was calling when suspended
                            this.migrateOutWriter.Write (sf.funcName);
                            this.SendObjArray (sf.objArray);          // it's args and locals at time of suspension
                        }

                        // no more stack frames
                        this.migrateOutWriter.Write (-1);

                        // now restore script stack
                        // microthread will suspend inside CheckRun() when restore is complete
                        this.stackFramesRestored = false;
                        except = this.microthread.StartEx ();
                        if (except != null) {
                            throw except;
                        }
                        if (!this.stackFramesRestored) {
                            throw new Exception ("restore after save did not complete");
                        }
                    } finally {

                        // make sure CheckRunLockInvariants() won't puque
                        if (this.microthread.Active () == 0) {
                            this.eventCode = ScriptEventCode.None;
                        }
                    }
                }
            } finally {

                /*
                 * No longer migrating.
                 */
                this.migrateOutWriter  = null;
                this.migrateOutStream  = null;
                this.migrateOutObjects = null;
            }
        }

        /**
         * @brief Write an array to the output stream.
         */
        private void SendObjArray (Array array)
        {
            SendObjValue ((object)(int)array.Length);
            for (int i = 0; i < array.Length; i ++) {
                SendObjValue (array.GetValue (i));
            }
        }

        /**
         * @brief Write an object to the output stream.
         * @param graph = object to send
         */
        private void SendObjValue (object graph)
        {
            if (this.migrateOutStream == null) throw new ArgumentNullException ("migrateOutStream");
            if (this.migrateOutWriter == null) throw new ArgumentNullException ("migrateOutWriter");

            /*
             * Value types (including nulls) are always output directly.
             */
            if (graph == null) {
                this.migrateOutWriter.Write ((byte)Ser.NULL);
                return;
            }
            if (graph is ScriptEventCode) {
                this.migrateOutWriter.Write ((byte)Ser.EVENTCODE);
                this.migrateOutWriter.Write ((int)graph);
                return;
            }
            if (graph is LSL_Float) {
                this.migrateOutWriter.Write ((byte)Ser.LSLFLOAT);
                this.migrateOutWriter.Write ((double)((LSL_Float)graph).value);
                return;
            }
            if (graph is LSL_Integer) {
                this.migrateOutWriter.Write ((byte)Ser.LSLINT);
                this.migrateOutWriter.Write ((int)((LSL_Integer)graph).value);
                return;
            }
            if (graph is LSL_Key) {
                this.migrateOutWriter.Write ((byte)Ser.LSLKEY);
                LSL_Key key = (LSL_Key)graph;
                SendObjValue (key.m_string);  // m_string can be null
                return;
            }
            if (graph is LSL_Rotation) {
                this.migrateOutWriter.Write ((byte)Ser.LSLROT);
                this.migrateOutWriter.Write ((double)((LSL_Rotation)graph).x);
                this.migrateOutWriter.Write ((double)((LSL_Rotation)graph).y);
                this.migrateOutWriter.Write ((double)((LSL_Rotation)graph).z);
                this.migrateOutWriter.Write ((double)((LSL_Rotation)graph).s);
                return;
            }
            if (graph is LSL_String) {
                this.migrateOutWriter.Write ((byte)Ser.LSLSTR);
                LSL_String str = (LSL_String)graph;
                SendObjValue (str.m_string);  // m_string can be null
                return;
            }
            if (graph is LSL_Vector) {
                this.migrateOutWriter.Write ((byte)Ser.LSLVEC);
                this.migrateOutWriter.Write ((double)((LSL_Vector)graph).x);
                this.migrateOutWriter.Write ((double)((LSL_Vector)graph).y);
                this.migrateOutWriter.Write ((double)((LSL_Vector)graph).z);
                return;
            }
            if (graph is bool) {
                this.migrateOutWriter.Write ((byte)Ser.SYSBOOL);
                this.migrateOutWriter.Write ((bool)graph);
                return;
            }
            if (graph is double) {
                this.migrateOutWriter.Write ((byte)Ser.SYSDOUB);
                this.migrateOutWriter.Write ((double)graph);
                return;
            }
            if (graph is float) {
                this.migrateOutWriter.Write ((byte)Ser.SYSFLOAT);
                this.migrateOutWriter.Write ((float)graph);
                return;
            }
            if (graph is int) {
                this.migrateOutWriter.Write ((byte)Ser.SYSINT);
                this.migrateOutWriter.Write ((int)graph);
                return;
            }

            /*
             * Script instance pointer is always just that.
             */
            if (graph == this) {
                this.migrateOutWriter.Write ((byte)Ser.XMRINST);
                return;
            }

            /*
             * If this same exact object was already serialized,
             * just output an index telling the receiver to use
             * that same old object, rather than creating a whole
             * new object with the same values.  Also this prevents
             * self-referencing objects (like arrays) from causing
             * an infinite loop.
             */
            int ident;
            if (this.migrateOutObjects.TryGetValue (graph, out ident)) {
                this.migrateOutWriter.Write ((byte)Ser.DUPREF);
                this.migrateOutWriter.Write (ident);
                return;
            }

            /*
             * Object not seen before, save its address with an unique
             * ident number that the receiver can easily regenerate.
             */
            ident = this.migrateOutObjects.Count;
            this.migrateOutObjects.Add (graph, ident);

            /*
             * Now output the object's value(s).
             * If the object self-references, the object is alreay entered
             * in the dictionary and so the self-reference will just emit
             * a DUPREF tag instead of trying to output the whole object 
             * again.
             */
            if (graph is LSL_List) {
                this.migrateOutWriter.Write ((byte)Ser.LSLLIST);
                LSL_List list = (LSL_List)graph;
                SendObjValue (list.Data);
            } else if (graph is XMR_Array) {
                this.migrateOutWriter.Write ((byte)Ser.XMRARRAY);
                ((XMR_Array)graph).SendArrayObj (this.SendObjValue);
            } else if (graph is object[]) {
                this.migrateOutWriter.Write ((byte)Ser.OBJARRAY);
                object[] array = (object[])graph;
                int len = array.Length;
                this.migrateOutWriter.Write (len);
                for (int i = 0; i < len; i ++) {
                    SendObjValue (array[i]);
                }
            } else if (graph is string) {
                this.migrateOutWriter.Write ((byte)Ser.SYSSTR);
                this.migrateOutWriter.Write ((string)graph);
            } else if (graph is DetectParams) {
                DetectParams dp = (DetectParams)graph;
                this.migrateOutWriter.Write ((byte)Ser.DETPRMS);
                this.migrateOutWriter.Write (dp.Key.ToString());    // UUID
                SendObjValue (dp.OffsetPos);                        // vector
                this.migrateOutWriter.Write (dp.LinkNum);           // integer
                this.migrateOutWriter.Write (dp.Group.ToString());  // UUID
                this.migrateOutWriter.Write (dp.Name);              // string
                this.migrateOutWriter.Write (dp.Owner.ToString());  // UUID
                SendObjValue (dp.Position);                         // vector
                SendObjValue (dp.Rotation);                         // rotation
                this.migrateOutWriter.Write (dp.Type);              // integer
                SendObjValue (dp.Velocity);                         // vector
                SendObjValue (dp.TouchST);                          // vector
                SendObjValue (dp.TouchNormal);                      // vector
                SendObjValue (dp.TouchBinormal);                    // vector
                SendObjValue (dp.TouchPos);                         // vector
                SendObjValue (dp.TouchUV);                          // vector
                this.migrateOutWriter.Write (dp.TouchFace);         // integer
            } else if (graph is Delegate) {
                Delegate del = (Delegate)graph;
                this.migrateOutWriter.Write ((byte)Ser.DELEGATE);
                this.migrateOutWriter.Write (del.Method.Name);
                this.migrateOutWriter.Write (TokenTypeDelegate.TryGetSig (del.GetType ()));
                SendObjValue (del.Target);
            } else {
                throw new Exception ("unhandled type " + graph.GetType().ToString());
            }
        }

        /**
         * @brief Convert an DetectParams[] to corresponding XML.
         *        DetectParams[] holds the values retrievable by llDetected...() for
         *        a given event.
         */
        private static void AppendXMLDetectArray(XmlDocument doc, XmlElement parent, DetectParams[] detect)
        {
            foreach (DetectParams d in detect)
            {
                XmlElement detectParamsN = GetXMLDetect(doc, d);
                parent.AppendChild(detectParamsN);
            }
        }

        private static XmlElement GetXMLDetect(XmlDocument doc, DetectParams d)
        {
            XmlElement detectParamsN = doc.CreateElement("", "DetectParams", "");

            XmlAttribute d_key = doc.CreateAttribute("", "key", "");
            d_key.Value = d.Key.ToString();
            detectParamsN.Attributes.Append(d_key);

            XmlAttribute pos = doc.CreateAttribute("", "pos", "");
            pos.Value = d.OffsetPos.ToString();
            detectParamsN.Attributes.Append(pos);

            XmlAttribute d_linkNum = doc.CreateAttribute("", "linkNum", "");
            d_linkNum.Value = d.LinkNum.ToString();
            detectParamsN.Attributes.Append(d_linkNum);

            XmlAttribute d_group = doc.CreateAttribute("", "group", "");
            d_group.Value = d.Group.ToString();
            detectParamsN.Attributes.Append(d_group);

            XmlAttribute d_name = doc.CreateAttribute("", "name", "");
            d_name.Value = d.Name.ToString();
            detectParamsN.Attributes.Append(d_name);

            XmlAttribute d_owner = doc.CreateAttribute("", "owner", "");
            d_owner.Value = d.Owner.ToString();
            detectParamsN.Attributes.Append(d_owner);

            XmlAttribute d_position = doc.CreateAttribute("", "position", "");
            d_position.Value = d.Position.ToString();
            detectParamsN.Attributes.Append(d_position);

            XmlAttribute d_rotation = doc.CreateAttribute("", "rotation", "");
            d_rotation.Value = d.Rotation.ToString();
            detectParamsN.Attributes.Append(d_rotation);

            XmlAttribute d_type = doc.CreateAttribute("", "type", "");
            d_type.Value = d.Type.ToString();
            detectParamsN.Attributes.Append(d_type);

            XmlAttribute d_velocity = doc.CreateAttribute("", "velocity", "");
            d_velocity.Value = d.Velocity.ToString();
            detectParamsN.Attributes.Append(d_velocity);

            return detectParamsN;
        }

        /**
         * @brief Append elements of an array of objects to an XML parent.
         * @param doc = document the parent is part of
         * @param parent = parent to append the items to
         * @param array = array of objects
         * @param tag = <tag ..>...</tag> for each element
         */
        private static void AppendXMLObjectArray(XmlDocument doc, XmlNode parent, object[] array, string tag)
        {
            foreach (object o in array)
            {
                XmlElement element = GetXMLObject(doc, o, tag);
                parent.AppendChild(element);
            }
        }

        /**
         * @brief Get and XML representation of an object.
         * @param doc = document the tag will be put in
         * @param o = object to be represented
         * @param tag = <tag ...>...</tag>
         */
        private static XmlElement GetXMLObject(XmlDocument doc, object o, string tag)
        {
            XmlAttribute typ = doc.CreateAttribute("", "type", "");
            XmlElement n = doc.CreateElement("", tag, "");

            if (o is LSL_List)
            {
                typ.Value = "list";
                n.Attributes.Append(typ);
                AppendXMLObjectArray(doc, n, ((LSL_List)o).Data, "item");
            }
            else
            {
                typ.Value = o.GetType().ToString();
                n.Attributes.Append(typ);
                n.AppendChild(doc.CreateTextNode(o.ToString()));
            }
            return n;
        }
    }
}
