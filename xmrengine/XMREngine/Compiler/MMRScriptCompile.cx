/********************************************************\
 *  COPYRIGHT 2009,2010, Mike Rieker, Beverly, MA, USA  *
 *  All rights reserved.                                *
\********************************************************/

/**
 * @brief Main program for the script compiler.
 */

#define strcasecmp(s,t) String.Compare(s,t,StringComparison.OrdinalIgnoreCase)

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.IO.Compression;
using System.Net;
using System.Reflection;
using System.Security.Cryptography;
using System.Text;
using System.Threading;

namespace OpenSim.Region.ScriptEngine.XMREngine
{

    public class ScriptCompile
    {
        public const int MAX_WEB_SCRIPT_SIZE = 1000000;

        private const bool encryption  = true;  // always true for production use
        private const bool compression = true;  // always true for production use

#ifdef STANDALONE_COMPILER
        /**
         * @brief Stand-alone compiler main program.
         *
         * mono xmrengcomp.exe -out objfilename -asm asmfilename sourcefiles...
         */
        public static void Main (string[] args)
        {
#ifdef SECRET_STUFF
            bool decode = false;
            string asmFileName = null;
#endif
            bool plaintext = false;
            string objFileName = null;
            List<string> sourceFileNames = new List<string> ();

            if (!encryption) {
                Console.WriteLine("ENCRYPTION IS DISABLED");
            }
            if (!compression) {
                Console.WriteLine("COMPRESSION IS DISABLED");
            }

            /*
             * Decode command-line arguments.
             */
            for (int i = 0; i < args.Length; i ++) {
                string arg = args[i];
                if (arg[0] == '?') goto usage;
                if (arg[0] != '-') {
                    sourceFileNames.Add (arg);
                    continue;
                }
#ifdef SECRET_STUFF
                if (arg == "-asm") {
                    asmFileName = args[++i];
                    continue;
                }
                if (arg == "-decode") {
                    decode = true;
                    continue;
                }
                if (arg == "-genkey") {
                    GenKey ();
                    return;
                }
                if (arg == "-plaintext") {
                    plaintext = true;
                    continue;
                }
#endif
                if (arg == "-out") {
                    objFileName = args[++i];
                    continue;
                }
                if (arg == "-version") {
                    goto version;
                }
                Console.WriteLine ("unknown option " + arg);
                goto usage;
            }

#ifdef SECRET_STUFF
            if (decode) {
                if (sourceFileNames.Count != 1) {
                    Console.WriteLine ("need exactly one input file for -decode");
                    goto usage;
                }

                DecodeFile (sourceFileNames[0], asmFileName, objFileName, plaintext);
                return;
            }
#endif

            /*
             * Normal compilation function, make sure an output
             * file was specified (where we will write the encrypted
             * object file).
             */
            if (objFileName == null) {
                Console.WriteLine ("missing -out option");
                goto usage;
            }

            /*
             * Read whole source into memory.
             */
            StringBuilder sourceBuilder = new StringBuilder ();
            if (sourceFileNames.Count == 0) {
                sourceBuilder.Append (Console.In.ReadToEnd ());
            } else {
                foreach (string sourceFileName in sourceFileNames) {
                    sourceBuilder.Append ("# 1 \"" + sourceFileName + "\"\n");
                    sourceBuilder.Append (File.ReadAllText (sourceFileName));
                }
            }
            string source = sourceBuilder.ToString ();

            /*
             * Parse source string into tokens.
             */
            TokenBegin tokenBegin = TokenBegin.Construct(StandAloneErrorMessage, source);
            if (tokenBegin == null) {
                Console.WriteLine ("Parsing errors.");
                Environment.Exit (1);
            }

            /*
             * Create abstract syntax tree from raw tokens.
             */
            TokenScript tokenScript = ScriptReduce.Reduce(tokenBegin);
            if (tokenScript == null) {
                Console.WriteLine ("Reduction errors.");
                Environment.Exit (1);
            }

            /*
             * Attempt to compile AST to object code.
             */
            Stream objFileStream = new FileStream (objFileName, FileMode.Create);
            if (!plaintext) objFileStream = Encrypt (objFileStream);
            BinaryWriter objFileWriter = new BinaryWriter (objFileStream);
            bool ok;
            try {
                ok = ScriptCodeGen.CodeGen(tokenScript, objFileWriter);
            } finally {
                objFileWriter.Close ();
            }
            if (!ok) {
                File.Delete (objFileName);
                Console.WriteLine ("Compilation errors.");
                Environment.Exit (1);
            }

            /*
             * If they want the assembly file, disassemble object file to get it.
             */
#ifdef SECRET_STUFF
            if (asmFileName != null) {
                objFileStream = new FileStream (objFileName, FileMode.Open);
                if (!plaintext) objFileStream = Decrypt (objFileStream);
                BinaryReader objFileReader = new BinaryReader (objFileStream);
                TextWriter asmFileWriter = (asmFileName != "-") ? File.CreateText (asmFileName) : Console.Out;
                try {
                    ScriptCodeGen.PerformGeneration ("", objFileReader, asmFileWriter);
                } finally {
                    objFileReader.Close ();
                    asmFileWriter.Flush ();
                    asmFileWriter.Close ();
                }
            }
#endif
            return;

usage:
            Console.WriteLine ("");
            Console.WriteLine ("xmrengcomp.exe -out <outputxmrobjfile> [<inputsourcefile> ...]");
            Console.WriteLine ("               omit inputsourcefiles to read from stdin");
            Console.WriteLine ("xmrengcomp.exe -version");
#ifdef SECRET_STUFF
            Console.WriteLine ("xmrengcomp.exe -genkey");
            Console.WriteLine ("xmrengcomp.exe -decode [-asm <outputxmrasmfile>] [-out <outputxmrobjfile>] [-plaintext] <inputbinaryfile>");
#endif
version:
            Console.WriteLine ("");
            Console.WriteLine ("XMREngine standalone compiler, version 1." + ScriptCodeGen.COMPILED_VERSION_VALUE);
            Console.WriteLine ("Copyright 2010, Magne Metaverse Research, LLC, Delaware, USA");
            Console.WriteLine ("Any use contrary to EULA is prohibited.");
            Console.WriteLine ("See http://www.meta7.com/xmrecompeula.html for details.");
            Console.WriteLine ("");
        }

        public static void StandAloneErrorMessage (Token token, string message)
        {
            Console.WriteLine ("{0} {1}", token.SrcLoc, message);
        }

#ifdef SECRET_STUFF
        /**
         * @brief Called for the -decode option to figure out what an object file
         *        contains (either encrypted abstract syntax tree or CIL object)
         *        and disassemble it.
         * @param decodeFileName = name of the one-and-only input file
         * @param asmFileName = null: don't bother disassembling
         *                      else: name of assembly output file
         * @param objFileName = null: don't bother writing decrypted CIL object file
         *                      else: name of decrypted CIL object file to write
         */
        private static void DecodeFile (string decodeFileName, string asmFileName, string objFileName, bool plaintext)
        {
            /*
             * Open file to decode.
             */
            Stream decodeFileStream = File.OpenRead (decodeFileName);
            if (!plaintext) decodeFileStream = Decrypt (decodeFileStream);

            /*
             * decodeFileStream = CIL object file.
             * If given an asmFileName, disassemble it.
             */
            TextWriter asmFileWriter = null;
            if (asmFileName != null) {
                Console.WriteLine("Creating disassembly file " + asmFileName);
                asmFileWriter = (asmFileName != "-") ? File.CreateText (asmFileName) : Console.Out;
            }

            /*
             * Read object file to check it for errors.
             * Maybe also write disassembly to a file for debugging.
             */
            BinaryReader objFileReader = new BinaryReader (decodeFileStream);
            try {
                ScriptCodeGen.PerformGeneration ("__assetID__", objFileReader, asmFileWriter);
            } finally {
                objFileReader.Close ();
                if (asmFileWriter != null) {
                    asmFileWriter.Flush ();
                    asmFileWriter.Close ();
                }
            }
            Console.WriteLine("All done.");
        }

        /**
         * @brief This is run only once by Meta7 to generate our public and private
         *        key pair.  A new key can be generated if the compile version changes.
         *
         *        Cut/Paste the results back into this source code so we have the
         *        key values.
         */
        private static void GenKey ()
        {
            RSACryptoServiceProvider rsa = new RSACryptoServiceProvider (rsaBits);
            RSAParameters rsap = rsa.ExportParameters (true);

            byte[][] publicKey  = new byte[][] {
                rsap.Exponent,
                rsap.Modulus
            };

            Console.WriteLine ("publicKey = " + ByteByteArrayToString (publicKey));

            byte[][] privateKey = new byte[][] {
                rsap.D,
                rsap.DP,
                rsap.DQ,
                rsap.Exponent,
                rsap.InverseQ,
                rsap.Modulus,
                rsap.P,
                rsap.Q
            };

            Console.WriteLine ("privateKey = " + ByteByteArrayToString (privateKey));
        }

        public static string ByteByteArrayToString (byte[][] array)
        {
            StringBuilder sb = new StringBuilder ();
            sb.Append ("new byte[][] {");
            for (int i = 0; i < array.Length; i ++) {
                byte[] row = array[i];
                if (i > 0) sb.Append (',');
                sb.Append ("\n      new byte[] {");
                for (int j = 0; j < row.Length; j ++) {
                    if (j > 0) {
                        sb.Append (',');
                        if (j % 8 == 0) {
                            sb.Append ("\n                  ");
                        }
                    }
                    sb.Append (" 0x");
                    sb.Append (row[j].ToString ("X2"));
                }
                sb.Append (" }");
            }
            sb.Append (" };");
            return sb.ToString ();
        }
#endif
#else
        private static readonly log4net.ILog m_log =
            log4net.LogManager.GetLogger(MethodBase.GetCurrentMethod().DeclaringType);

        /**
         * @brief Compile a script to produce a ScriptObjCode object
         * @param source = 'source' contains the whole script source
         * @param assetID = the script asset ID, unique per script source file
         * @param scriptBasePath = where to put files (a directory)
         * @param forceRecompile = false: use existing object file if any
         *                          true: ignore existing object file
         * @param errorMessage = where to write error messages to
         * @returns object code pointer or null if compile error
         */
        public static ScriptObjCode Compile (string source, 
                                             string assetID,
                                             string scriptBasePath,
                                             bool forceRecompile,
                                             TokenErrorMessage errorMessage)
        {
            bool oldObjFile = false;
            Stream objFileStream = null;
            Stream webStream = null;
            StreamWriter asmFileWriter = null;
            string envar = null;
            string fname = Path.Combine (scriptBasePath, assetID);
            string objFileName = GetObjFileName (assetID, scriptBasePath);
            string sourceHash = null;

            /*
             * If we already have an object file, don't bother compiling.
             */
            if (!forceRecompile && File.Exists (objFileName)) {
                objFileStream = File.OpenRead (objFileName);
                oldObjFile = true;
            } else if (source == "") {
                throw new Exception ("source file empty");
            } else {

                /*
                 * Maybe write script source to a file for debugging.
                 */
                envar = Environment.GetEnvironmentVariable ("MMRScriptCompileSaveSource");
                if ((envar != null) && ((envar[0] & 1) != 0)) {
                    m_log.DebugFormat("[XMREngine]: MMRScriptCompileSaveSource: saving to {0}.lsl", fname);
                    File.WriteAllText (fname + ".lsl", source);
                }

                /*
                 * Parse source string into tokens.
                 */
                TokenBegin tokenBegin = TokenBegin.Construct(errorMessage, source);
                if (tokenBegin == null) {
                    m_log.Debug ("[XMREngine]: parsing errors on " + assetID);
                    return null;
                }

                /*
                 * If source is 'XMROption' 'fetchsource' ...
                 * read source file from the given URL.
                 */
                if ((tokenBegin.nextToken is TokenName) &&
                    (strcasecmp (((TokenName)tokenBegin.nextToken).val, "xmroption") == 0) &&
                    (tokenBegin.nextToken.nextToken is TokenName) &&
                    (strcasecmp (((TokenName)tokenBegin.nextToken.nextToken).val, "fetchsource") == 0)) {

                    try {

                        /*
                         * Open web stream.
                         */
                        webStream = FetchBinary (tokenBegin.nextToken.nextToken.nextToken, errorMessage);
                        if (webStream == null) return null;
                        StreamReader webReader = new StreamReader (webStream);

                        /*
                         * Read it all into one string.
                         */
                        int lineLen;
                        int totalChars = 0;
                        char[] lineBuff;
                        List<char[]> stringList = new List<char[]> ();
                        do {
                            lineBuff    = new char[4096];
                            lineLen     = webReader.ReadBlock (lineBuff, 0, lineBuff.Length);
                            stringList.Add (lineBuff);
                            totalChars += lineLen;
                            if (totalChars > MAX_WEB_SCRIPT_SIZE) {
                                throw new Exception ("script exceeds maximum size of " + MAX_WEB_SCRIPT_SIZE);
                            }
                        } while (lineLen == lineBuff.Length);
                        
                        webStream.Close ();
                        webStream = null;
                        StringBuilder sb = new StringBuilder (totalChars);
                        foreach (char[] lineString in stringList) {
                            sb.Append (lineString);
                        }
                        source = sb.ToString ();
                    } finally {
                        if (webStream != null) webStream.Close ();
                    }

                    /*
                     * Maybe write script source to a file for debugging.
                     */
                    envar = Environment.GetEnvironmentVariable ("MMRScriptCompileSaveSource");
                    if ((envar != null) && ((envar[0] & 1) != 0)) {
                        m_log.DebugFormat("[XMREngine]: MMRScriptCompileSaveSource: saving to {0}.lslweb", fname);
                        File.WriteAllText (fname + ".lslweb", source);
                    }

                    /*
                     * Parse source string into tokens.
                     */
                    tokenBegin = TokenBegin.Construct(errorMessage, source);
                    if (tokenBegin == null) {
                        m_log.Debug ("[XMREngine]: parsing errors on " + assetID);
                        return null;
                    }
                }

                /*
                 * Return source hash so caller can know if source changes.
                 */
                {
                    System.Security.Cryptography.MD5 md5 = System.Security.Cryptography.MD5.Create ();
                    byte[] sourceBytes = System.Text.Encoding.ASCII.GetBytes (source);
                    byte[] hashBytes   = md5.ComputeHash (sourceBytes);
                    int hashBytesLen   = hashBytes.Length;
                    StringBuilder sb   = new StringBuilder (hashBytesLen * 2 + 2);
                    for (int i = 0; i < hashBytesLen; i ++) {
                        sb.Append (hashBytes[i].ToString ("X2"));
                    }
                    sourceHash = sb.ToString ();
                }

                /*
                 * Create object file one way or another.
                 */
                try {
                    objFileStream = File.Create (objFileName + ".tmp");

                    /*
                     * If source is 'XMROption' 'fetchbinary' ...,
                     * read xmrobj file from the given URL.
                     */
                    if (false && //////////////// DISABLED ////////////////
                        (tokenBegin.nextToken is TokenName) &&
                        (((TokenName)tokenBegin.nextToken).val == "XMROption") &&
                        (tokenBegin.nextToken.nextToken is TokenName) &&
                        (((TokenName)tokenBegin.nextToken.nextToken).val == "fetchbinary")) {

                        /*
                         * Open web stream.
                         */
                        webStream = FetchBinary (tokenBegin.nextToken.nextToken.nextToken, errorMessage);
                        if (webStream == null) return null;
                        webStream = Decrypt (webStream);

                        /*
                         * Copy object from web and write to .xmrobj file.
                         */
                        byte[] buffer = new byte[32768];
                        int len;
                        while ((len = webStream.Read (buffer, 0, buffer.Length)) > 0) {
                            objFileStream.Write (buffer, 0, len);
                        }
                    } else {

                        /*
                         * Create abstract syntax tree from raw tokens.
                         */
                        TokenScript tokenScript = ScriptReduce.Reduce(tokenBegin);
                        if (tokenScript == null) {
                            m_log.Debug ("[XMREngine]: reduction errors on " + assetID);
                            return null;
                        }

                        /*
                         * Compile abstract syntax tree to write object file.
                         */
                        BinaryWriter objFileWriter = new BinaryWriter (objFileStream);
                        bool ok = ScriptCodeGen.CodeGen(tokenScript, objFileWriter, sourceHash);
                        if (!ok) {
                            m_log.Debug ("[XMREngine]: compile error on " + assetID);
                            objFileStream.Close ();
                            return null;
                        }
                    }
                    objFileStream.Close ();

                    /*
                     * File has been completely written.
                     * If there is an old one laying around, delete it now.
                     * Then re-open the new file for reading from the beginning.
                     */
                    if (File.Exists (objFileName)) {
                        File.Replace (objFileName + ".tmp", objFileName, null);
                    } else {
                        File.Move (objFileName + ".tmp", objFileName);
                    }
                    objFileStream = File.OpenRead (objFileName);
                } finally {

                    /*
                     * In case something went wrong writing temp file, delete it.
                     */
                    try {
                        File.Delete (objFileName + ".tmp");
                    } catch {
                    }
                }

                /*
                 * Since we just wrote the .xmrobj file, maybe save disassembly.
                 */
                envar = Environment.GetEnvironmentVariable ("MMRScriptCompileSaveILGen");
                if ((envar != null) && ((envar[0] & 1) != 0)) {
                    string asmFileName = fname + ".xmrasm";
                    m_log.DebugFormat("[XMREngine]: MMRScriptCompileSaveILGen: saving to {0}", asmFileName);
                    asmFileWriter = File.CreateText (asmFileName);
                }
            }

            /*
             * Read object file to create ScriptObjCode object.
             * Maybe also write disassembly to a file for debugging.
             */
            BinaryReader objFileReader = new BinaryReader (objFileStream);
            ScriptObjCode scriptObjCode = null;
            try {
                scriptObjCode = ScriptCodeGen.PerformGeneration (assetID, objFileReader, asmFileWriter);
                if (scriptObjCode != null) {
                    scriptObjCode.fileDateUtc = File.GetLastWriteTimeUtc (objFileName);
                }
            } finally {
                objFileReader.Close ();
                if (asmFileWriter != null) {
                    asmFileWriter.Flush ();
                    asmFileWriter.Close ();
                }
            }

            /*
             * Maybe an old object file has reached its expiration date.
             */
            if (oldObjFile && (scriptObjCode != null) && scriptObjCode.IsExpired ()) {
                m_log.Debug ("[XMREngine]: expiration reached on " + assetID + ", reloading");
                scriptObjCode = Compile (source, assetID, scriptBasePath, true, errorMessage);
            }

            return scriptObjCode;
        }

        /**
         * @brief Figure out name of object file.
         */
        public static string GetObjFileName (string assetID,
                                             string scriptBasePath)
        {
            string fname = Path.Combine (scriptBasePath, assetID);
            return fname + ".xmrobj";
        }
#endif

        /*
         * Data for encryption.
         */
        private static int rsaBits = 1280;
        private static int aesBits = 256;

        private static byte[] version = new ASCIIEncoding ().GetBytes 
               ("XMRBinary(" + ScriptCodeGen.COMPILED_VERSION_VALUE + ".2)");

#ifdef STANDALONE_COMPILER
        private static byte[][] publicKey = new byte[][] {
      new byte[] { 0x11 },
      new byte[] { 0xE0, 0x55, 0x45, 0xD4, 0xF1, 0x39, 0xB5, 0x65,
                   0x68, 0xF4, 0xA0, 0x4D, 0xD0, 0x68, 0x59, 0x45,
                   0x40, 0x36, 0x96, 0x88, 0x79, 0x7C, 0x21, 0x42,
                   0x60, 0x24, 0x82, 0xCE, 0xD7, 0x35, 0x78, 0xFC,
                   0x63, 0xB5, 0x01, 0x3B, 0xEE, 0xF2, 0xB9, 0x5D,
                   0x3D, 0x95, 0xE8, 0xC1, 0x2F, 0x74, 0xB4, 0x00,
                   0x78, 0xFC, 0xF9, 0x73, 0x98, 0x25, 0x5E, 0xF4,
                   0x18, 0x38, 0xCC, 0xC3, 0x4D, 0x85, 0x0C, 0xAE,
                   0x5A, 0x11, 0xF1, 0x2F, 0xE2, 0xF1, 0xA5, 0x58,
                   0x17, 0xDA, 0x2C, 0x4C, 0x49, 0xBE, 0x5F, 0x7B,
                   0x95, 0x90, 0x2E, 0xB0, 0x79, 0x0C, 0x7A, 0x9B,
                   0x31, 0x0A, 0x58, 0x4A, 0xB5, 0x1D, 0xB3, 0xF1,
                   0x58, 0x33, 0x94, 0xE1, 0x64, 0x16, 0x88, 0x5C,
                   0xAF, 0xF3, 0x8F, 0x68, 0xEF, 0xC7, 0xF9, 0xC0,
                   0x46, 0xA5, 0x83, 0xC1, 0x2F, 0x69, 0x73, 0x50,
                   0x58, 0xA8, 0xE7, 0xBE, 0x91, 0x07, 0x35, 0xF6,
                   0x74, 0xFB, 0x1A, 0x8F, 0x0D, 0xEC, 0xA9, 0x58,
                   0xF2, 0xF5, 0xC1, 0xEB, 0x2B, 0xA0, 0x34, 0x6D,
                   0xBE, 0x6E, 0xD5, 0x73, 0x1F, 0xC1, 0xDA, 0x28,
                   0x01, 0x1C, 0x85, 0xA4, 0x68, 0xF6, 0xB0, 0xFD } };

        // stream = stream to write compressed/encrypted data to
        // returns stream to write plaintext data to
        private static Stream Encrypt (Stream stream)
        {
            stream.Write (version, 0, version.Length);

            if (encryption) {
                RSACryptoServiceProvider rsa = new RSACryptoServiceProvider ();
                RSAParameters rsap = new RSAParameters ();
                rsap.Exponent = publicKey[0];
                rsap.Modulus  = publicKey[1];
                rsa.ImportParameters (rsap);
                int rsaBytes = rsa.KeySize / 8;
                RijndaelManaged aes = new RijndaelManaged ();
                aes.KeySize = aesBits;
                byte[] symKeyEnc = rsa.Encrypt (aes.Key, true);
                byte[] iniVecEnc = rsa.Encrypt (aes.IV,  true);
                if ((symKeyEnc.Length != rsaBytes) ||
                     (iniVecEnc.Length != rsaBytes)) {
                    throw new Exception ("bad key length");
                }
                stream.Write (symKeyEnc, 0, rsaBytes);
                stream.Write (iniVecEnc, 0, rsaBytes);
                stream = new CryptoStream (stream,
                                           aes.CreateEncryptor (),
                                           CryptoStreamMode.Write);
            }
            if (compression) {
                stream = new GZipStream (stream, 
                                         CompressionMode.Compress);
            }
            return stream;
        }
#else
        /**
         * @brief This can be called by live script engine to run a script source through
         *        the stand-alone compiler for testing.  It takes an entire script source
         *        file and sends it to the compiler.  The compiler produces an abstract
         *        syntax tree file which our caller can then read using FetchBinary().
         * @param exefile = external compiler filename
         * @param source  = source file from OpenSim
         * @param fname   = filename to store intermediate .xmrbin file
         */
        private static void RunSourceThroughExternalCompiler (string exefile, string source, string fname)
        {
            ProcessStartInfo psi = new ProcessStartInfo ();
            psi.FileName  = exefile;
            psi.Arguments = "-out " + fname;
            psi.RedirectStandardInput   = true;
            psi.RedirectStandardOutput  = true;
            psi.RedirectStandardError   = true;
            psi.UseShellExecute         = false;
            ExternalCompilerContext ecc = new ExternalCompilerContext ();
            ecc.source = source;
            ecc.proc   = Process.Start (psi);
            ecc.RunIt ();
            if (ecc.hasError) {
                throw new Exception ("external compiler errors:\n" + ecc.errors.ToString ());
            }
        }
        private class ExternalCompilerContext {
            public Process proc;
            public bool hasError = false;
            public string source;
            public StringBuilder errors;
            private Thread tin;
            private Thread tout;
            private Thread terr;
            public void RunIt ()
            {
                errors = new StringBuilder ();
                tin    = new Thread (HandleIn);
                tout   = new Thread (HandleOut);
                terr   = new Thread (HandleErr);
                tin.Start  ();
                tout.Start ();
                terr.Start ();
                tout.Join  ();
                terr.Join  ();
                proc.WaitForExit ();
                tin.Abort  ();
                tin.Join   ();
            }
            public void HandleIn ()
            {
                proc.StandardInput.WriteLine (source);
                proc.StandardInput.Close ();
            }
            public void HandleOut ()
            {
                String line;
                while ((line = proc.StandardOutput.ReadLine ()) != null) {
                    hasError = true;
                    lock (errors) {
                        errors.AppendLine (line);
                    }
                }
            }
            public void HandleErr ()
            {
                String line;
                while ((line = proc.StandardError.ReadLine ()) != null) {
                    hasError = true;
                    lock (errors) {
                        errors.AppendLine (line);
                    }
                }
            }
        }

        /**
         * @brief Read xmrobj file from a webserver somewhere out there and write to object file.
         * @param token = tokens after 'XMROption' 'fetchbinary'
         * @param errorMessage = where to write error messages
         * @returns null: some error
         *          else: object file stream
         */
        private static Stream FetchBinary (Token token, TokenErrorMessage errorMessage)
        {
            bool error = false;
            WebResponse response = null;
            string url = null;
            TokenStr urlToken = null;
            WebRequest request;

            /*
             * Parse parameters:
             *    "url"
             *    ;
             */
            for (; !(token is TokenEnd); token = token.nextToken) {
                if (token is TokenKwSemi) break;
                if (token is TokenStr) {
                    if (urlToken == null) {
                        urlToken = (TokenStr)token;
                    } else {
                        errorMessage (token, "only one url string allowed");
                        error = true;
                    }
                    continue;
                }
                errorMessage (token, "unknown item in fetch option");
                error = true;
            }
            if (!(token is TokenKwSemi)) {
                errorMessage (token, "missing ; at end of fetch option");
                error = true;
            } else if (!(token.nextToken is TokenEnd)) {
                errorMessage (token.nextToken, "extra stuff after fetch option");
                error = true;
            } else if (urlToken == null) {
                errorMessage (token, "missing url string");
                error = true;
            }
            if (error) return null;

            url = urlToken.val;
            m_log.DebugFormat("[XMREngine]: fetching from {0}", url);

            try {

                /*
                 * Get stream to read from webserver.
                 */
                if (url.StartsWith ("file://")) {
                    return File.OpenRead (url.Substring (7));
                } else {
                    request  = WebRequest.Create (url);
                    response = request.GetResponse ();
                    return response.GetResponseStream ();
                }
            } catch (Exception e) {

                /*
                 * Some error, output message.
                 */
                errorMessage (urlToken, "error fetching: " + e.ToString());
                if (response != null) response.Close ();
                return null;
            }
        }
#endif

#if !defined(STANDALONE_COMPILER) || defined(SECRET_STUFF)
        private static byte[][] privateKey = new byte[][] {
      new byte[] { 0x5C, 0x5F, 0x58, 0xFD, 0x54, 0x44, 0xF0, 0x56,
                   0xEE, 0xFB, 0x51, 0x10, 0xFB, 0x76, 0x42, 0xE0,
                   0x47, 0x9E, 0x01, 0xBF, 0xB9, 0x8D, 0x77, 0x1B,
                   0x54, 0xC3, 0xBD, 0x64, 0x3A, 0x7F, 0x6E, 0x0D,
                   0x92, 0x77, 0xB5, 0x36, 0xCB, 0xCD, 0x5B, 0x62,
                   0xA0, 0xE3, 0x5F, 0xD7, 0x13, 0x8A, 0x68, 0x3C,
                   0x6E, 0x0D, 0xD0, 0x20, 0x89, 0xF1, 0x45, 0x37,
                   0x55, 0x44, 0x90, 0x8C, 0xA7, 0x73, 0x05, 0x38,
                   0xBB, 0xAD, 0x08, 0xF5, 0x99, 0xAE, 0xCB, 0x9C,
                   0xBE, 0x87, 0x03, 0x2E, 0x78, 0xB7, 0xCC, 0xF5,
                   0xE1, 0xA4, 0x48, 0x71, 0x6B, 0x24, 0xAC, 0xAA,
                   0xF6, 0xD9, 0xC0, 0x31, 0x3C, 0x21, 0x49, 0x98,
                   0x0F, 0xB0, 0x3D, 0x84, 0x4A, 0xAF, 0x3E, 0x4C,
                   0xDF, 0x2A, 0x46, 0xE4, 0x89, 0xEC, 0x9C, 0xF5,
                   0xEC, 0x18, 0xDE, 0x4A, 0x23, 0xD3, 0x57, 0xF5,
                   0x16, 0x60, 0xE1, 0x66, 0xEA, 0x4D, 0xD7, 0x6C,
                   0xE4, 0x6B, 0x98, 0x9C, 0x87, 0x59, 0x0A, 0xFA,
                   0xBC, 0x54, 0x0C, 0xCE, 0x6C, 0xA4, 0x20, 0x7F,
                   0x2E, 0x4B, 0xED, 0x95, 0x5C, 0x2F, 0x66, 0xD2,
                   0xCE, 0xA7, 0x11, 0x12, 0x2D, 0x15, 0x7B, 0x71 },
      new byte[] { 0xE2, 0x40, 0x70, 0xA4, 0x72, 0x3E, 0xF0, 0x86,
                   0xC6, 0x54, 0xCA, 0x84, 0x40, 0xC9, 0x40, 0xD7,
                   0x6E, 0x55, 0xC0, 0xA0, 0x4C, 0x59, 0x92, 0x90,
                   0x2D, 0xCC, 0x04, 0x84, 0x5C, 0x09, 0x07, 0x94,
                   0x30, 0x31, 0x5A, 0x82, 0x69, 0x56, 0x05, 0x3A,
                   0x96, 0x44, 0x1D, 0xA9, 0x95, 0xC1, 0xD3, 0xDE,
                   0x7F, 0x3B, 0x2C, 0x51, 0x12, 0x55, 0x1E, 0x7D,
                   0xA6, 0x07, 0x65, 0x28, 0x98, 0xC1, 0x33, 0xCB,
                   0xC8, 0xC7, 0x0A, 0x1A, 0xEE, 0x59, 0x01, 0x8B,
                   0x5B, 0xA3, 0xCD, 0x07, 0x4D, 0x75, 0x1A, 0xF1 },
      new byte[] { 0x62, 0x5E, 0xA8, 0x8F, 0x4D, 0x30, 0x38, 0xD2,
                   0x71, 0xDD, 0xE2, 0x26, 0x7D, 0x65, 0xB7, 0xE5,
                   0x89, 0x10, 0x6C, 0x74, 0x44, 0xA7, 0x8D, 0x7D,
                   0xFA, 0xE5, 0x75, 0xF2, 0x69, 0x03, 0xA9, 0x62,
                   0xC5, 0x51, 0xED, 0x8A, 0x78, 0x33, 0x62, 0x69,
                   0xE4, 0xDB, 0x92, 0xED, 0x5C, 0x21, 0x44, 0xEC,
                   0xE5, 0x06, 0x9D, 0xFE, 0xAC, 0x03, 0x2A, 0x96,
                   0xAF, 0x13, 0x8E, 0x50, 0xA6, 0x41, 0xC8, 0xC8,
                   0x9D, 0xEC, 0x83, 0x10, 0x24, 0xD9, 0x7A, 0xCC,
                   0xEE, 0x6B, 0x21, 0xE7, 0xBD, 0x30, 0xA0, 0xB5 },
      new byte[] { 0x11 },
      new byte[] { 0x56, 0x9D, 0x7B, 0x79, 0x93, 0x09, 0x6C, 0x65,
                   0xFC, 0x9D, 0x5F, 0x54, 0x91, 0x7A, 0x21, 0x33,
                   0x45, 0xFE, 0x94, 0xBD, 0xFA, 0x02, 0x77, 0xFF,
                   0x4A, 0xF9, 0xA4, 0x37, 0x41, 0x2E, 0xC1, 0xEC,
                   0xE1, 0xB0, 0xBE, 0x2F, 0xB5, 0x9E, 0x38, 0x6C,
                   0x91, 0x6A, 0xF1, 0xAE, 0xEF, 0xBB, 0xB5, 0x78,
                   0x12, 0x3C, 0x51, 0xA6, 0x81, 0x75, 0x33, 0x69,
                   0x56, 0xC0, 0x6D, 0xE8, 0x7B, 0x12, 0xCB, 0xF8,
                   0x63, 0x5B, 0x11, 0x84, 0x1D, 0x5C, 0x19, 0xC3,
                   0x17, 0xE1, 0xB2, 0x78, 0x5A, 0xA2, 0xDF, 0x6F },
      new byte[] { 0xE0, 0x55, 0x45, 0xD4, 0xF1, 0x39, 0xB5, 0x65,
                   0x68, 0xF4, 0xA0, 0x4D, 0xD0, 0x68, 0x59, 0x45,
                   0x40, 0x36, 0x96, 0x88, 0x79, 0x7C, 0x21, 0x42,
                   0x60, 0x24, 0x82, 0xCE, 0xD7, 0x35, 0x78, 0xFC,
                   0x63, 0xB5, 0x01, 0x3B, 0xEE, 0xF2, 0xB9, 0x5D,
                   0x3D, 0x95, 0xE8, 0xC1, 0x2F, 0x74, 0xB4, 0x00,
                   0x78, 0xFC, 0xF9, 0x73, 0x98, 0x25, 0x5E, 0xF4,
                   0x18, 0x38, 0xCC, 0xC3, 0x4D, 0x85, 0x0C, 0xAE,
                   0x5A, 0x11, 0xF1, 0x2F, 0xE2, 0xF1, 0xA5, 0x58,
                   0x17, 0xDA, 0x2C, 0x4C, 0x49, 0xBE, 0x5F, 0x7B,
                   0x95, 0x90, 0x2E, 0xB0, 0x79, 0x0C, 0x7A, 0x9B,
                   0x31, 0x0A, 0x58, 0x4A, 0xB5, 0x1D, 0xB3, 0xF1,
                   0x58, 0x33, 0x94, 0xE1, 0x64, 0x16, 0x88, 0x5C,
                   0xAF, 0xF3, 0x8F, 0x68, 0xEF, 0xC7, 0xF9, 0xC0,
                   0x46, 0xA5, 0x83, 0xC1, 0x2F, 0x69, 0x73, 0x50,
                   0x58, 0xA8, 0xE7, 0xBE, 0x91, 0x07, 0x35, 0xF6,
                   0x74, 0xFB, 0x1A, 0x8F, 0x0D, 0xEC, 0xA9, 0x58,
                   0xF2, 0xF5, 0xC1, 0xEB, 0x2B, 0xA0, 0x34, 0x6D,
                   0xBE, 0x6E, 0xD5, 0x73, 0x1F, 0xC1, 0xDA, 0x28,
                   0x01, 0x1C, 0x85, 0xA4, 0x68, 0xF6, 0xB0, 0xFD },
      new byte[] { 0xF0, 0x64, 0x77, 0xAE, 0xB9, 0x62, 0xDF, 0x8F,
                   0x32, 0xBA, 0x17, 0x2C, 0x84, 0xD5, 0xD4, 0xE4,
                   0xE5, 0x3B, 0x1C, 0xAA, 0x51, 0x1F, 0x2B, 0xB9,
                   0x30, 0xA8, 0xC4, 0xCC, 0xA1, 0xC9, 0x98, 0x0D,
                   0x73, 0x34, 0x70, 0x2A, 0x8F, 0xEB, 0x65, 0x8E,
                   0x3F, 0xA8, 0x5F, 0x84, 0x2F, 0x1D, 0xF1, 0x1C,
                   0x67, 0x2E, 0xDF, 0x16, 0x23, 0x7A, 0x70, 0x65,
                   0x80, 0x67, 0xDB, 0x7B, 0x22, 0x4D, 0x47, 0x08,
                   0x85, 0x53, 0x7A, 0xBC, 0x9D, 0x3E, 0x91, 0xA4,
                   0x11, 0x5E, 0x09, 0xD7, 0xC2, 0x4C, 0x6C, 0xA1 },
      new byte[] { 0xEE, 0xE5, 0xE2, 0x80, 0x96, 0xE2, 0xD3, 0x23,
                   0xA6, 0xD1, 0xB7, 0x82, 0x0B, 0xF7, 0x07, 0xBF,
                   0xBA, 0x95, 0x99, 0xAC, 0xA6, 0xBB, 0x7C, 0x31,
                   0xF3, 0x9A, 0xF9, 0xDE, 0xFF, 0x08, 0xE4, 0x82,
                   0x28, 0x59, 0x40, 0xE2, 0x91, 0xA1, 0x5C, 0xB8,
                   0x07, 0x39, 0xD2, 0x89, 0x96, 0x99, 0xF0, 0x88,
                   0x75, 0x59, 0x36, 0x8F, 0x0F, 0x75, 0x67, 0x6D,
                   0xF2, 0x54, 0x10, 0x7A, 0xB8, 0x56, 0x9E, 0x79,
                   0x7F, 0x87, 0x87, 0x70, 0x59, 0x7D, 0xE1, 0x16,
                   0x43, 0x04, 0x2D, 0xC5, 0x14, 0x9A, 0xAA, 0xDD } };

        // stream = stream to read compressed/encrypted data from
        // returns stream to read plaintext data from
        private static Stream Decrypt (Stream stream)
        {
            byte[] ver = new byte[version.Length];
            int len = stream.Read (ver, 0, ver.Length);
            if ((len < version.Length) || !memeq (ver, version, ver.Length)) {
                throw new Exception ("script object version mismatch");
            }

            if (encryption) {
                RSACryptoServiceProvider rsa = new RSACryptoServiceProvider ();
                RSAParameters rsap = new RSAParameters ();
                rsap.D        = privateKey[0];
                rsap.DP       = privateKey[1];
                rsap.DQ       = privateKey[2];
                rsap.Exponent = privateKey[3];
                rsap.InverseQ = privateKey[4];
                rsap.Modulus  = privateKey[5];
                rsap.P        = privateKey[6];
                rsap.Q        = privateKey[7];
                rsa.ImportParameters (rsap);
                int rsaBytes = rsa.KeySize / 8;
                RijndaelManaged aes = new RijndaelManaged ();
                aes.KeySize = aesBits;
                byte[] symKeyEnc = new byte[rsaBytes];
                byte[] iniVecEnc = new byte[rsaBytes];
                if ((stream.Read (symKeyEnc, 0, rsaBytes) != rsaBytes) ||
                     (stream.Read (iniVecEnc, 0, rsaBytes) != rsaBytes)) {
                    throw new Exception ("bad key length");
                }
                aes.Key = rsa.Decrypt (symKeyEnc, true);
                aes.IV  = rsa.Decrypt (iniVecEnc, true);
                stream = new CryptoStream (stream,
                                           aes.CreateDecryptor (),
                                           CryptoStreamMode.Read);
            }
            if (compression) {
                stream = new GZipStream (stream,
                                         CompressionMode.Decompress);
            }
            return stream;
        }

        private static bool memeq (byte[] s1, byte[] s2, int len)
        {
            for (int i = 0; i < len; i ++) {
                if (s1[i] != s2[i]) return false;
            }
            return true;
        }
#endif
    }
}
