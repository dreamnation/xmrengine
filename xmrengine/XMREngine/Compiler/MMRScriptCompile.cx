/***************************************************\
 *  COPYRIGHT 2009, Mike Rieker, Beverly, MA, USA  *
 *  All rights reserved.                           *
\***************************************************/

/**
 * @brief Main program for the script compiler.
 */

using System;
using System.Collections.Generic;
using System.IO;
using System.IO.Compression;
using System.Net;
using System.Reflection;
using System.Security.Cryptography;
using System.Text;

namespace OpenSim.Region.ScriptEngine.XMREngine
{

    public class ScriptCompile
    {
        private const bool encryption  = true;  // always true for production use
        private const bool compression = true;  // always true for production use

#ifdef STANDALONE_COMPILER
        /**
         * @brief Stand-alone compiler main program.
         *
         * mono xmrengcomp.exe -out objfilename -asm asmfilename sourcefiles...
         */
        public static void Main (string[] args)
        {
#ifdef SECRET_STUFF
            bool decode = false;
            string asmFileName = null;
            string srcFileName = null;
#endif
            string objFileName = null;
            List<string> sourceFileNames = new List<string> ();

            if (!encryption) {
                Console.WriteLine("ENCRYPTION IS DISABLED");
            }
            if (!compression) {
                Console.WriteLine("COMPRESSION IS DISABLED");
            }

            /*
             * Decode command-line arguments.
             */
            for (int i = 0; i < args.Length; i ++) {
                string arg = args[i];
                if (arg[0] == '?') goto usage;
                if (arg[0] != '-') {
                    sourceFileNames.Add (arg);
                    continue;
                }
#ifdef SECRET_STUFF
                if (arg == "-asm") {
                    asmFileName = args[++i];
                    continue;
                }
                if (arg == "-decode") {
                    decode = true;
                    continue;
                }
                if (arg == "-genkey") {
                    GenKey ();
                    return;
                }
#endif
                if (arg == "-out") {
                    objFileName = args[++i];
                    continue;
                }
#ifdef SECRET_STUFF
                if (arg == "-src") {
                    srcFileName = args[++i];
                    continue;
                }
#endif
                if (arg == "-version") {
                    goto version;
                }
                Console.WriteLine ("unknown option " + arg);
                goto usage;
            }

#ifdef SECRET_STUFF
            if (decode) {
                if (sourceFileNames.Count != 1) {
                    Console.WriteLine ("need exactly one input file for -decode");
                    goto usage;
                }

                DecodeFile (sourceFileNames[0], asmFileName, objFileName, srcFileName);
                return;
            }
#endif

            /*
             * Normal compilation function, make sure an output
             * file was specified (where we will write the encrypted
             * abstract syntax tree).
             */
            if (objFileName == null) {
                Console.WriteLine ("missing -out option");
                goto usage;
            }

            /*
             * Reduce to produce abstract syntax tree.
             */
            StringBuilder sourceBuilder = new StringBuilder ();
            if (sourceFileNames.Count == 0) {
                sourceBuilder.Append (Console.In.ReadToEnd ());
            } else {
                foreach (string sourceFileName in sourceFileNames) {
                    sourceBuilder.Append ("# 1 \"" + sourceFileName + "\"\n");
                    sourceBuilder.Append (File.ReadAllText (sourceFileName));
                }
            }
            TokenScript tokenScript = GenAbsSynTree (sourceBuilder.ToString(),
                                                     StandAloneErrorMessage);
            if (tokenScript == null) {
                Console.WriteLine ("Compilation detected errors.");
                Environment.Exit (1);
            }

            /*
             * Serialize the AST out to the object file.
             * Compress and encrypt while we are at it.
             */
            Stream encFileStream = File.Create (objFileName);
            encFileStream.Write (version, 0, version.Length);
            encFileStream = Encrypt (encFileStream);
            BinaryWriter encBinaryWriter = new BinaryWriter (encFileStream);
            try {
                TokenWriter tokenWriter = new TokenWriter (encBinaryWriter);
                tokenWriter.Write (tokenScript);
            } finally {
                encBinaryWriter.Close ();
            }

            /*
             * Attempt to compile AST to generate error messages.
             */
            MemoryStream memFileStream = new MemoryStream ();
            BinaryWriter memFileWriter = new BinaryWriter (memFileStream);
            if (!ScriptCodeGen.CodeGen(tokenScript, memFileWriter))
            {
                File.Delete (objFileName);
                Console.WriteLine ("Compilation detected errors.");
                Environment.Exit (1);
            }

            /*
             * If they want the assembly file, disassemble object file to get it.
             */
#ifdef SECRET_STUFF
            if (asmFileName != null) {
                memFileWriter.Flush ();
                memFileStream.Seek (0, SeekOrigin.Begin);
                BinaryReader objFileReader = new BinaryReader (memFileStream);
                StreamWriter asmFileWriter = File.CreateText (asmFileName);

                try {
                    ScriptCodeGen.PerformGeneration ("", objFileReader, asmFileWriter);
                } finally {
                    objFileReader.Close ();
                    if (asmFileWriter != null) {
                        asmFileWriter.Flush ();
                        asmFileWriter.Close ();
                    }
                }
            }
#endif
            memFileStream.Close ();
            return;

usage:
            Console.WriteLine ("");
            Console.WriteLine ("xmrengcomp.exe -out <outputxmrbinfile> [<inputsourcefile> ...]");
            Console.WriteLine ("               omit inputsourcefiles to read from stdin");
            Console.WriteLine ("xmrengcomp.exe -version");
#ifdef SECRET_STUFF
            Console.WriteLine ("xmrengcomp.exe -genkey");
            Console.WriteLine ("xmrengcomp.exe -decode [-asm <outputxmrasmfile>] [-out <outputxmrobjfile>] <inputbinaryfile>");
#endif
version:
            Console.WriteLine ("");
            Console.WriteLine ("XMREngine standalone compiler, version 1." + ScriptCodeGen.COMPILED_VERSION_VALUE);
            Console.WriteLine ("Copyright 2010, Magne Metaverse Research, LLC, Delaware, USA");
            Console.WriteLine ("Any use contrary to EULA is prohibited.");
            Console.WriteLine ("See http://www.meta7.com/xmrecompeula.html for details.");
            Console.WriteLine ("");
        }

        public static void StandAloneErrorMessage (Token token, string message)
        {
            Console.WriteLine ("{0} {1}", token.SrcLoc, message);
        }

#ifdef SECRET_STUFF
        /**
         * @brief Called for the -decode option to figure out what an object file
         *        contains (either encrypted abstract syntax tree or CIL object)
         *        and disassemble it.
         * @param decodeFileName = name of the one-and-only input file
         * @param asmFileName = null: don't bother disassembling
         *                      else: name of assembly output file
         * @param objFileName = null: don't bother writing decrypted CIL object file
         *                      else: name of decrypted CIL object file to write
         */
        private static void DecodeFile (string decodeFileName, string asmFileName, string objFileName, string srcFileName)
        {
            /*
             * Open file to decode.
             */
            Stream decodeFileStream = File.OpenRead (decodeFileName);

            /*
             * See if it begins with XMRBinary magic string.
             * If so, it is an encrypted abstract syntax tree file.
             */
            byte[] ver = new byte[version.Length];
            if ((decodeFileStream.Read (ver, 0, ver.Length) == ver.Length) &&
                memeq (ver, version, ver.Length)) {
                Console.WriteLine(decodeFileName + " is an abstract syntax tree file.");

                /*
                 * Set up decrypt function.
                 */
                decodeFileStream = Decrypt (decodeFileStream);

                /*
                 * Deserialize to re-create abstract syntax tree.
                 */
                BinaryReader decodeBinaryReader = new BinaryReader (decodeFileStream);
                TokenReader tokenReader = new TokenReader (decodeBinaryReader, StandAloneErrorMessage);
                TokenScript tokenScript = (TokenScript)tokenReader.ReadToken ();
                decodeBinaryReader.Close ();

                /*
                 * Reconstruct source from abstract syntax tree.
                 */
                if (srcFileName != null) {
                    Console.WriteLine ("Reconstructing source to " + srcFileName);
                    StreamWriter reconstStream = File.CreateText (srcFileName);
                    try {
                        ScriptReconst.Reconst (tokenScript, reconstStream);
                    } finally {
                        reconstStream.Close ();
                    }
                }

                /*
                 * Generate CIL object file to detect compilation errors.
                 */
                MemoryStream memoryFileStream = new MemoryStream ();
                BinaryWriter memFileWriter = new BinaryWriter (memoryFileStream);
                if (!ScriptCodeGen.CodeGen(tokenScript, memFileWriter))
                {
                    Console.WriteLine ("Compilation detected errors.");
                    return;
                }
                memoryFileStream.Flush ();

                /*
                 * Maybe write the decrypted CIL object file out.
                 * This is the same file as used by the script engine loader.
                 */
                if (objFileName != null) {
                    Console.WriteLine("Creating object file " + objFileName);
                    Stream objFileStream = File.Create (objFileName);
                    byte[] objByteArray = memoryFileStream.GetBuffer ();
                    objFileStream.Write (objByteArray, 0, objByteArray.Length);
                    objFileStream.Close ();
                }

                decodeFileStream = memoryFileStream;
            } else {

                /*
                 * Otherwise, assume it is a decrypted CIL object file.
                 */
                Console.WriteLine(decodeFileName + " is a CIL object file.");
                if (objFileName != null) {
                    Console.WriteLine("Not creating object file " + objFileName + " because input is an object file.");
                }
            }

            /*
             * In any case, at this point, decodeFileStream = CIL object file.
             * If given an asmFileName, disassemble it.
             */
            StreamWriter asmFileWriter = null;
            if (asmFileName != null) {
                Console.WriteLine("Creating disassembly file " + asmFileName);
                asmFileWriter = File.CreateText (asmFileName);
            }

            /*
             * Read object file to check it for errors.
             * Maybe also write disassembly to a file for debugging.
             */
            decodeFileStream.Seek (0, SeekOrigin.Begin);
            BinaryReader objFileReader = new BinaryReader (decodeFileStream);
            try {
                ScriptCodeGen.PerformGeneration ("__assetID__", objFileReader, asmFileWriter);
            } finally {
                objFileReader.Close ();
                if (asmFileWriter != null) {
                    asmFileWriter.Flush ();
                    asmFileWriter.Close ();
                }
            }
            Console.WriteLine("All done.");
        }

        /**
         * @brief This is run only once by Meta7 to generate our public and private
         *        key pair.  A new key can be generated if the compile version changes.
         *
         *        Cut/Paste the results back into this source code so we have the
         *        key values.
         */
        private static void GenKey ()
        {
            RSACryptoServiceProvider rsa = new RSACryptoServiceProvider (rsaBits);
            RSAParameters rsap = rsa.ExportParameters (true);

            byte[][] publicKey  = new byte[][] {
                rsap.Exponent,
                rsap.Modulus
            };

            Console.WriteLine ("publicKey = " + ByteByteArrayToString (publicKey));

            byte[][] privateKey = new byte[][] {
                rsap.D,
                rsap.DP,
                rsap.DQ,
                rsap.Exponent,
                rsap.InverseQ,
                rsap.Modulus,
                rsap.P,
                rsap.Q
            };

            Console.WriteLine ("privateKey = " + ByteByteArrayToString (privateKey));
        }

        public static string ByteByteArrayToString (byte[][] array)
        {
            StringBuilder sb = new StringBuilder ();
            sb.Append ("new byte[][] {");
            for (int i = 0; i < array.Length; i ++) {
                byte[] row = array[i];
                if (i > 0) sb.Append (',');
                sb.Append ("\n      new byte[] {");
                for (int j = 0; j < row.Length; j ++) {
                    if (j > 0) {
                        sb.Append (',');
                        if (j % 8 == 0) {
                            sb.Append ("\n                  ");
                        }
                    }
                    sb.Append (" 0x");
                    sb.Append (row[j].ToString ("X2"));
                }
                sb.Append (" }");
            }
            sb.Append (" };");
            return sb.ToString ();
        }
#endif
#else
        private static readonly log4net.ILog m_log =
            log4net.LogManager.GetLogger(MethodBase.GetCurrentMethod().DeclaringType);

        /**
         * @brief Compile a script to produce a ScriptObjCode object
         * @param source = 'source' contains the whole script source
         * @param assetID = the script asset ID, unique per script source file
         * @param scriptBasePath = where to put files (a directory)
         * @param errorMessage = where to write error messages to
         * @returns object code pointer or null if compile error
         */
        public static ScriptObjCode Compile (string source, 
                                             string assetID,
                                             string scriptBasePath,
                                             TokenErrorMessage errorMessage)
        {
            Stream objFileStream = null;
            StreamWriter asmFileWriter = null;
            string envar = null;
            string fname = Path.Combine (scriptBasePath, assetID);
            string objFileName = GetObjFileName (assetID, scriptBasePath);

            /*
             * If we already have an object file, don't bother compiling.
             */
            if (File.Exists (objFileName)) {
                objFileStream = File.OpenRead (objFileName);
            } else {

                /*
                 * Maybe write script source to a file for debugging.
                 */
                envar = Environment.GetEnvironmentVariable ("MMRScriptCompileSaveSource");
                if ((envar != null) && ((envar[0] & 1) != 0)) {
                    m_log.DebugFormat("[XMREngine]: MMRScriptCompileSaveSource: saving to {0}.lsl", fname);
                    File.WriteAllText (fname + ".lsl", source);
                }

                /*
                 * Create abstract syntax tree from raw tokens.
                 */
                TokenScript tokenScript = GenAbsSynTree(source, errorMessage);
                if (tokenScript == null)
                {
                    m_log.DebugFormat("[XMREngine]: compile error on {0}", assetID);
                    return null;
                }

                /*
                 * Scan abstract syntax tree to write object file.
                 */
                objFileStream = File.Create (objFileName);
                BinaryWriter objFileWriter = new BinaryWriter (objFileStream);
                if (!ScriptCodeGen.CodeGen(tokenScript, objFileWriter))
                {
                    objFileStream.Close ();
                    File.Delete (objFileName);
                    m_log.DebugFormat("[XMREngine]: compile error on {0}", assetID);
                    return null;
                }

                /*
                 * Return a reader so the loader can load the file.
                 * Rewind the plaintext object file.
                 */
                objFileStream.Flush ();
                objFileStream.Seek (0, SeekOrigin.Begin);

                /*
                 * Since we just compiled from source, maybe save disassembly.
                 */
                envar = Environment.GetEnvironmentVariable ("MMRScriptCompileSaveILGen");
                if ((envar != null) && ((envar[0] & 1) != 0)) {
                    string asmFileName = fname + ".xmrasm";
                    m_log.DebugFormat("[XMREngine]: MMRScriptCompileSaveILGen: saving to {0}", asmFileName);
                    asmFileWriter = File.CreateText (asmFileName);
                }
            }

            /*
             * Read object file to create ScriptObjCode object.
             * Maybe also write disassembly to a file for debugging.
             */
            BinaryReader objFileReader = new BinaryReader (objFileStream);
            ScriptObjCode scriptObjCode = null;
            try {
                scriptObjCode = ScriptCodeGen.PerformGeneration (assetID, objFileReader, asmFileWriter);
            } finally {
                objFileReader.Close ();
                if (asmFileWriter != null) {
                    asmFileWriter.Flush ();
                    asmFileWriter.Close ();
                }
            }

            return scriptObjCode;
        }

        /**
         * @brief Figure out name of object file.
         */
        public static string GetObjFileName (string assetID,
                                             string scriptBasePath)
        {
            string fname = Path.Combine (scriptBasePath, assetID);
            return fname + ".xmrobj";
        }
#endif

        /**
         * @brief Generate abstract syntax tree from source code
         * @param source = entire source code in one string
         * @param errorMessage = where to write error messages to
         * @returns null: error
         *          else: abstract syntax tree
         */
        public static TokenScript GenAbsSynTree(string source, 
                                                TokenErrorMessage errorMessage)
        {
            /*
             * Parse source string into tokens.
             */
            TokenBegin tokenBegin =
                        TokenBegin.Construct(errorMessage, source);
            if (tokenBegin == null)
            {
                return null;
            }

            /*
             * If source is 'XMROption' 'fetchbinary' ...,
             * read AST file from the given URL.
             */
#ifndef STANDALONE_COMPILER
            if ((tokenBegin.nextToken is TokenName) &&
                (((TokenName)tokenBegin.nextToken).val == "XMROption") &&
                (tokenBegin.nextToken.nextToken is TokenName) &&
                (((TokenName)tokenBegin.nextToken.nextToken).val == "fetchbinary")) {

                return FetchBinary (tokenBegin.nextToken.nextToken.nextToken,
                                    errorMessage);
            }
#endif

            /*
             * Create abstract syntax tree from raw tokens.
             */
            return ScriptReduce.Reduce(tokenBegin);
        }

        /*
         * Data for encryption.
         */
        private static int rsaBits = 1280;
        private static int aesBits = 256;

        private static byte[] version = new ASCIIEncoding ().GetBytes 
               ("XMRBinary(" + ScriptCodeGen.COMPILED_VERSION_VALUE + ".1)");

#ifdef STANDALONE_COMPILER
        private static byte[][] publicKey = new byte[][] {
      new byte[] { 0x11 },
      new byte[] { 0xE0, 0x55, 0x45, 0xD4, 0xF1, 0x39, 0xB5, 0x65,
                   0x68, 0xF4, 0xA0, 0x4D, 0xD0, 0x68, 0x59, 0x45,
                   0x40, 0x36, 0x96, 0x88, 0x79, 0x7C, 0x21, 0x42,
                   0x60, 0x24, 0x82, 0xCE, 0xD7, 0x35, 0x78, 0xFC,
                   0x63, 0xB5, 0x01, 0x3B, 0xEE, 0xF2, 0xB9, 0x5D,
                   0x3D, 0x95, 0xE8, 0xC1, 0x2F, 0x74, 0xB4, 0x00,
                   0x78, 0xFC, 0xF9, 0x73, 0x98, 0x25, 0x5E, 0xF4,
                   0x18, 0x38, 0xCC, 0xC3, 0x4D, 0x85, 0x0C, 0xAE,
                   0x5A, 0x11, 0xF1, 0x2F, 0xE2, 0xF1, 0xA5, 0x58,
                   0x17, 0xDA, 0x2C, 0x4C, 0x49, 0xBE, 0x5F, 0x7B,
                   0x95, 0x90, 0x2E, 0xB0, 0x79, 0x0C, 0x7A, 0x9B,
                   0x31, 0x0A, 0x58, 0x4A, 0xB5, 0x1D, 0xB3, 0xF1,
                   0x58, 0x33, 0x94, 0xE1, 0x64, 0x16, 0x88, 0x5C,
                   0xAF, 0xF3, 0x8F, 0x68, 0xEF, 0xC7, 0xF9, 0xC0,
                   0x46, 0xA5, 0x83, 0xC1, 0x2F, 0x69, 0x73, 0x50,
                   0x58, 0xA8, 0xE7, 0xBE, 0x91, 0x07, 0x35, 0xF6,
                   0x74, 0xFB, 0x1A, 0x8F, 0x0D, 0xEC, 0xA9, 0x58,
                   0xF2, 0xF5, 0xC1, 0xEB, 0x2B, 0xA0, 0x34, 0x6D,
                   0xBE, 0x6E, 0xD5, 0x73, 0x1F, 0xC1, 0xDA, 0x28,
                   0x01, 0x1C, 0x85, 0xA4, 0x68, 0xF6, 0xB0, 0xFD } };

        // stream = stream to write compressed/encrypted data to
        // returns stream to write plaintext data to
        private static Stream Encrypt (Stream stream)
        {
            if (encryption) {
                RSACryptoServiceProvider rsa = new RSACryptoServiceProvider ();
                RSAParameters rsap = new RSAParameters ();
                rsap.Exponent = publicKey[0];
                rsap.Modulus  = publicKey[1];
                rsa.ImportParameters (rsap);
                int rsaBytes = rsa.KeySize / 8;
                RijndaelManaged aes = new RijndaelManaged ();
                aes.KeySize = aesBits;
                byte[] symKeyEnc = rsa.Encrypt (aes.Key, true);
                byte[] iniVecEnc = rsa.Encrypt (aes.IV,  true);
                if ((symKeyEnc.Length != rsaBytes) ||
                     (iniVecEnc.Length != rsaBytes)) {
                    throw new Exception ("bad key length");
                }
                stream.Write (symKeyEnc, 0, rsaBytes);
                stream.Write (iniVecEnc, 0, rsaBytes);
                stream = new CryptoStream (stream,
                                           aes.CreateEncryptor (),
                                           CryptoStreamMode.Write);
            }
            if (compression) {
                stream = new GZipStream (stream, 
                                         CompressionMode.Compress);
            }
            return stream;
        }
#else

        /**
         * @brief Read binary from a webserver somewhere out there and write to object file.
         * @param token = tokens after 'XMROption' 'fetchbinary'
         * @param errorMessage = where to write error messages
         * @returns null: some error
         *          else: abstract syntax tree
         */
        private static TokenScript FetchBinary (Token token, TokenErrorMessage errorMessage)
        {
            bool error = false;
            bool nocache = false;
            byte[] buffer = new byte[4096];
            FileStream fileStream = null;
            WebResponse response = null;
            int length;
            Stream webStream = null;
            string url = null;
            TokenStr urlToken = null;
            WebRequest request;

            /*
             * Parse parameters:
             *    nocache
             *    "url"
             *    ;
             */
            for (; !(token is TokenEnd); token = token.nextToken) {
                if (token is TokenKwSemi) break;
                if (token is TokenStr) {
                    if (urlToken == null) {
                        urlToken = (TokenStr)token;
                    } else {
                        errorMessage (token, "only one url string allowed");
                        error = true;
                    }
                    continue;
                }
                if (token is TokenName) {
                    if (((TokenName)token).val == "nocache") {
                        nocache = true;
                    } else {
                        errorMessage (token, "unknown keyword");
                        error = true;
                    }
                    continue;
                }
                errorMessage (token, "unknown item in fetchbinary option");
                error = true;
            }
            if (!(token is TokenKwSemi)) {
                errorMessage (token, "missing ; at end of fetchbinary option");
                error = true;
            } else if (!(token.nextToken is TokenEnd)) {
                errorMessage (token.nextToken, "extra stuff after fetchbinary option");
                error = true;
            } else if (urlToken == null) {
                errorMessage (token, "missing url string");
                error = true;
            }
            if (error) return null;

            url = urlToken.val;
            m_log.DebugFormat("[XMREngine]: fetching binary from {0}", url);

            try {

                /*
                 * Get stream to read from webserver.
                 */
                request   = WebRequest.Create (url);
                response  = request.GetResponse ();
                webStream = response.GetResponseStream ();

                /*
                 * Make sure we have "XMRBinary(COMPILED_VERSION)".
                 */
                byte[] ver = new byte[version.Length];
                if ((webStream.Read (ver, 0, ver.Length) != ver.Length) ||
                     !memeq (ver, version, ver.Length)) {
                    throw new Exception ("bad xmrbinary version");
                }

                /*
                 * The rest of the stream is compressed & encrypted.
                 */
                webStream = Decrypt (webStream);

                /*
                 * Deserialize to re-create abstract syntax tree.
                 */
                BinaryReader webBinaryReader = new BinaryReader (webStream);
                TokenReader tokenReader = new TokenReader (webBinaryReader, errorMessage);
                TokenScript tokenScript = (TokenScript)tokenReader.ReadToken ();
                webBinaryReader.Close ();
                return tokenScript;
            } catch (Exception e) {

                /*
                 * Some error, output message.
                 */
                errorMessage (urlToken, "error fetching binary: " + e.ToString());
                return null;
            } finally {

                /*
                 * Make sure everything is closed before we return.
                 */
                if (webStream != null) {
                    webStream.Close ();
                }
                if (response != null) {
                    response.Close ();
                }
            }
        }
#endif

#if !defined(STANDALONE_COMPILER) || defined(SECRET_STUFF)
        private static byte[][] privateKey = new byte[][] {
      new byte[] { 0x5C, 0x5F, 0x58, 0xFD, 0x54, 0x44, 0xF0, 0x56,
                   0xEE, 0xFB, 0x51, 0x10, 0xFB, 0x76, 0x42, 0xE0,
                   0x47, 0x9E, 0x01, 0xBF, 0xB9, 0x8D, 0x77, 0x1B,
                   0x54, 0xC3, 0xBD, 0x64, 0x3A, 0x7F, 0x6E, 0x0D,
                   0x92, 0x77, 0xB5, 0x36, 0xCB, 0xCD, 0x5B, 0x62,
                   0xA0, 0xE3, 0x5F, 0xD7, 0x13, 0x8A, 0x68, 0x3C,
                   0x6E, 0x0D, 0xD0, 0x20, 0x89, 0xF1, 0x45, 0x37,
                   0x55, 0x44, 0x90, 0x8C, 0xA7, 0x73, 0x05, 0x38,
                   0xBB, 0xAD, 0x08, 0xF5, 0x99, 0xAE, 0xCB, 0x9C,
                   0xBE, 0x87, 0x03, 0x2E, 0x78, 0xB7, 0xCC, 0xF5,
                   0xE1, 0xA4, 0x48, 0x71, 0x6B, 0x24, 0xAC, 0xAA,
                   0xF6, 0xD9, 0xC0, 0x31, 0x3C, 0x21, 0x49, 0x98,
                   0x0F, 0xB0, 0x3D, 0x84, 0x4A, 0xAF, 0x3E, 0x4C,
                   0xDF, 0x2A, 0x46, 0xE4, 0x89, 0xEC, 0x9C, 0xF5,
                   0xEC, 0x18, 0xDE, 0x4A, 0x23, 0xD3, 0x57, 0xF5,
                   0x16, 0x60, 0xE1, 0x66, 0xEA, 0x4D, 0xD7, 0x6C,
                   0xE4, 0x6B, 0x98, 0x9C, 0x87, 0x59, 0x0A, 0xFA,
                   0xBC, 0x54, 0x0C, 0xCE, 0x6C, 0xA4, 0x20, 0x7F,
                   0x2E, 0x4B, 0xED, 0x95, 0x5C, 0x2F, 0x66, 0xD2,
                   0xCE, 0xA7, 0x11, 0x12, 0x2D, 0x15, 0x7B, 0x71 },
      new byte[] { 0xE2, 0x40, 0x70, 0xA4, 0x72, 0x3E, 0xF0, 0x86,
                   0xC6, 0x54, 0xCA, 0x84, 0x40, 0xC9, 0x40, 0xD7,
                   0x6E, 0x55, 0xC0, 0xA0, 0x4C, 0x59, 0x92, 0x90,
                   0x2D, 0xCC, 0x04, 0x84, 0x5C, 0x09, 0x07, 0x94,
                   0x30, 0x31, 0x5A, 0x82, 0x69, 0x56, 0x05, 0x3A,
                   0x96, 0x44, 0x1D, 0xA9, 0x95, 0xC1, 0xD3, 0xDE,
                   0x7F, 0x3B, 0x2C, 0x51, 0x12, 0x55, 0x1E, 0x7D,
                   0xA6, 0x07, 0x65, 0x28, 0x98, 0xC1, 0x33, 0xCB,
                   0xC8, 0xC7, 0x0A, 0x1A, 0xEE, 0x59, 0x01, 0x8B,
                   0x5B, 0xA3, 0xCD, 0x07, 0x4D, 0x75, 0x1A, 0xF1 },
      new byte[] { 0x62, 0x5E, 0xA8, 0x8F, 0x4D, 0x30, 0x38, 0xD2,
                   0x71, 0xDD, 0xE2, 0x26, 0x7D, 0x65, 0xB7, 0xE5,
                   0x89, 0x10, 0x6C, 0x74, 0x44, 0xA7, 0x8D, 0x7D,
                   0xFA, 0xE5, 0x75, 0xF2, 0x69, 0x03, 0xA9, 0x62,
                   0xC5, 0x51, 0xED, 0x8A, 0x78, 0x33, 0x62, 0x69,
                   0xE4, 0xDB, 0x92, 0xED, 0x5C, 0x21, 0x44, 0xEC,
                   0xE5, 0x06, 0x9D, 0xFE, 0xAC, 0x03, 0x2A, 0x96,
                   0xAF, 0x13, 0x8E, 0x50, 0xA6, 0x41, 0xC8, 0xC8,
                   0x9D, 0xEC, 0x83, 0x10, 0x24, 0xD9, 0x7A, 0xCC,
                   0xEE, 0x6B, 0x21, 0xE7, 0xBD, 0x30, 0xA0, 0xB5 },
      new byte[] { 0x11 },
      new byte[] { 0x56, 0x9D, 0x7B, 0x79, 0x93, 0x09, 0x6C, 0x65,
                   0xFC, 0x9D, 0x5F, 0x54, 0x91, 0x7A, 0x21, 0x33,
                   0x45, 0xFE, 0x94, 0xBD, 0xFA, 0x02, 0x77, 0xFF,
                   0x4A, 0xF9, 0xA4, 0x37, 0x41, 0x2E, 0xC1, 0xEC,
                   0xE1, 0xB0, 0xBE, 0x2F, 0xB5, 0x9E, 0x38, 0x6C,
                   0x91, 0x6A, 0xF1, 0xAE, 0xEF, 0xBB, 0xB5, 0x78,
                   0x12, 0x3C, 0x51, 0xA6, 0x81, 0x75, 0x33, 0x69,
                   0x56, 0xC0, 0x6D, 0xE8, 0x7B, 0x12, 0xCB, 0xF8,
                   0x63, 0x5B, 0x11, 0x84, 0x1D, 0x5C, 0x19, 0xC3,
                   0x17, 0xE1, 0xB2, 0x78, 0x5A, 0xA2, 0xDF, 0x6F },
      new byte[] { 0xE0, 0x55, 0x45, 0xD4, 0xF1, 0x39, 0xB5, 0x65,
                   0x68, 0xF4, 0xA0, 0x4D, 0xD0, 0x68, 0x59, 0x45,
                   0x40, 0x36, 0x96, 0x88, 0x79, 0x7C, 0x21, 0x42,
                   0x60, 0x24, 0x82, 0xCE, 0xD7, 0x35, 0x78, 0xFC,
                   0x63, 0xB5, 0x01, 0x3B, 0xEE, 0xF2, 0xB9, 0x5D,
                   0x3D, 0x95, 0xE8, 0xC1, 0x2F, 0x74, 0xB4, 0x00,
                   0x78, 0xFC, 0xF9, 0x73, 0x98, 0x25, 0x5E, 0xF4,
                   0x18, 0x38, 0xCC, 0xC3, 0x4D, 0x85, 0x0C, 0xAE,
                   0x5A, 0x11, 0xF1, 0x2F, 0xE2, 0xF1, 0xA5, 0x58,
                   0x17, 0xDA, 0x2C, 0x4C, 0x49, 0xBE, 0x5F, 0x7B,
                   0x95, 0x90, 0x2E, 0xB0, 0x79, 0x0C, 0x7A, 0x9B,
                   0x31, 0x0A, 0x58, 0x4A, 0xB5, 0x1D, 0xB3, 0xF1,
                   0x58, 0x33, 0x94, 0xE1, 0x64, 0x16, 0x88, 0x5C,
                   0xAF, 0xF3, 0x8F, 0x68, 0xEF, 0xC7, 0xF9, 0xC0,
                   0x46, 0xA5, 0x83, 0xC1, 0x2F, 0x69, 0x73, 0x50,
                   0x58, 0xA8, 0xE7, 0xBE, 0x91, 0x07, 0x35, 0xF6,
                   0x74, 0xFB, 0x1A, 0x8F, 0x0D, 0xEC, 0xA9, 0x58,
                   0xF2, 0xF5, 0xC1, 0xEB, 0x2B, 0xA0, 0x34, 0x6D,
                   0xBE, 0x6E, 0xD5, 0x73, 0x1F, 0xC1, 0xDA, 0x28,
                   0x01, 0x1C, 0x85, 0xA4, 0x68, 0xF6, 0xB0, 0xFD },
      new byte[] { 0xF0, 0x64, 0x77, 0xAE, 0xB9, 0x62, 0xDF, 0x8F,
                   0x32, 0xBA, 0x17, 0x2C, 0x84, 0xD5, 0xD4, 0xE4,
                   0xE5, 0x3B, 0x1C, 0xAA, 0x51, 0x1F, 0x2B, 0xB9,
                   0x30, 0xA8, 0xC4, 0xCC, 0xA1, 0xC9, 0x98, 0x0D,
                   0x73, 0x34, 0x70, 0x2A, 0x8F, 0xEB, 0x65, 0x8E,
                   0x3F, 0xA8, 0x5F, 0x84, 0x2F, 0x1D, 0xF1, 0x1C,
                   0x67, 0x2E, 0xDF, 0x16, 0x23, 0x7A, 0x70, 0x65,
                   0x80, 0x67, 0xDB, 0x7B, 0x22, 0x4D, 0x47, 0x08,
                   0x85, 0x53, 0x7A, 0xBC, 0x9D, 0x3E, 0x91, 0xA4,
                   0x11, 0x5E, 0x09, 0xD7, 0xC2, 0x4C, 0x6C, 0xA1 },
      new byte[] { 0xEE, 0xE5, 0xE2, 0x80, 0x96, 0xE2, 0xD3, 0x23,
                   0xA6, 0xD1, 0xB7, 0x82, 0x0B, 0xF7, 0x07, 0xBF,
                   0xBA, 0x95, 0x99, 0xAC, 0xA6, 0xBB, 0x7C, 0x31,
                   0xF3, 0x9A, 0xF9, 0xDE, 0xFF, 0x08, 0xE4, 0x82,
                   0x28, 0x59, 0x40, 0xE2, 0x91, 0xA1, 0x5C, 0xB8,
                   0x07, 0x39, 0xD2, 0x89, 0x96, 0x99, 0xF0, 0x88,
                   0x75, 0x59, 0x36, 0x8F, 0x0F, 0x75, 0x67, 0x6D,
                   0xF2, 0x54, 0x10, 0x7A, 0xB8, 0x56, 0x9E, 0x79,
                   0x7F, 0x87, 0x87, 0x70, 0x59, 0x7D, 0xE1, 0x16,
                   0x43, 0x04, 0x2D, 0xC5, 0x14, 0x9A, 0xAA, 0xDD } };

        // stream = stream to read compressed/encrypted data from
        // returns stream to read plaintext data from
        private static Stream Decrypt (Stream stream)
        {
            if (encryption) {
                RSACryptoServiceProvider rsa = new RSACryptoServiceProvider ();
                RSAParameters rsap = new RSAParameters ();
                rsap.D        = privateKey[0];
                rsap.DP       = privateKey[1];
                rsap.DQ       = privateKey[2];
                rsap.Exponent = privateKey[3];
                rsap.InverseQ = privateKey[4];
                rsap.Modulus  = privateKey[5];
                rsap.P        = privateKey[6];
                rsap.Q        = privateKey[7];
                rsa.ImportParameters (rsap);
                int rsaBytes = rsa.KeySize / 8;
                RijndaelManaged aes = new RijndaelManaged ();
                aes.KeySize = aesBits;
                byte[] symKeyEnc = new byte[rsaBytes];
                byte[] iniVecEnc = new byte[rsaBytes];
                if ((stream.Read (symKeyEnc, 0, rsaBytes) != rsaBytes) ||
                     (stream.Read (iniVecEnc, 0, rsaBytes) != rsaBytes)) {
                    throw new Exception ("bad key length");
                }
                aes.Key = rsa.Decrypt (symKeyEnc, true);
                aes.IV  = rsa.Decrypt (iniVecEnc, true);
                stream = new CryptoStream (stream,
                                           aes.CreateDecryptor (),
                                           CryptoStreamMode.Read);
            }
            if (compression) {
                stream = new GZipStream (stream,
                                         CompressionMode.Decompress);
            }
            return stream;
        }

        private static bool memeq (byte[] s1, byte[] s2, int len)
        {
            for (int i = 0; i < len; i ++) {
                if (s1[i] != s2[i]) return false;
            }
            return true;
        }
#endif
    }
}
