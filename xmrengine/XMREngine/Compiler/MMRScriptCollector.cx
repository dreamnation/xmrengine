/***************************************************\
 *  COPYRIGHT 2012, Mike Rieker, Beverly, MA, USA  *
 *  All rights reserved.                           *
\***************************************************/

#define DEBUG 0

using OpenSim.Region.ScriptEngine.Shared.ScriptBase;
using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Reflection.Emit;
using System.Text;

/**
 * @brief Wrapper class for ScriptMyILGen to do simple optimizations.
 *        The main one is to figure out which locals are active at the labels
 *        so the stack capture/restore code doesn't have to do everything.
 *        Second is it removes unnecessary back-to-back stloc/ldloc's.
 */

namespace OpenSim.Region.ScriptEngine.XMREngine
{
	/**
	 * @brief One of these per opcode and label in the function plus other misc markers.
	 *        They form the CIL instruction stream of the function.
	 */
	public abstract class GraphNode {
		public const int OPINDENT =  4;
		public const int OPDEBLEN = 12;

		public ScriptCollector coll;
		public GraphNodeBeginExceptionBlock tryBlock;  // start of enclosing try block
		                                               // null in the catch/finally section
		                                               // null outside of try block
		                                               // for the try node itself, links to outer try block
		public GraphNodeBeginExceptionBlock excBlock;  // start of enclosing try block
		                                               // valid in the catch/finally section
		                                               // null outside of try/catch/finally block
		                                               // for the try node itself, links to outer try block

		/*
		 * List of nodes in order as originally given.
		 */
		public GraphNode nextLin, prevLin;
		public int linSeqNo;

		/**
		 * @brief Save pointer to collector.
		 */
		public GraphNode (ScriptCollector coll)
		{
			this.coll = coll;
		}

		/**
		 * @brief Chain graph node to end of linear list.
		 */
		public GraphNode ChainLin ()
		{
			coll.lastLin.nextLin = this;
			this.prevLin  = coll.lastLin;
			coll.lastLin  = this;
			this.tryBlock = coll.curTryBlock;
			this.excBlock = coll.curExcBlock;
			return this;
		}

		/**
		 * @brief Append to debugging string for printing out the instruction.
		 */
		public abstract void DebString (StringBuilder sb);

		/**
		 * @brief See if this instruction reads a local variable.
		 */
		public virtual ScriptMyLocal ReadsLocal  () { return null; }

		/**
		 * @brief See if this instruction writes a local variable.
		 */
		public virtual ScriptMyLocal WritesLocal () { return null; }

		/**
		 * @brief Write this instruction out to the wrapped object file.
		 */
		public abstract void WriteOutOne (ScriptMyILGen ilGen);

		/**
		 * @brief Iterate through all the possible next nodes, including the next inline node, if any.
		 *        The next inline code is excluded if the instruction never falls through, eg, return, unconditional branch.
		 *        It includes a possible conditional branch to the beginning of the corresponding catch/finally of every 
		 *        instruction in a try section.
		 */
		private System.Collections.Generic.IEnumerable<GraphNode> nextNodes, nextNodesCatchFinally;
		public System.Collections.Generic.IEnumerable<GraphNode> NextNodes
		{ get {
			if (nextNodes == null) {
				nextNodes = GetNNEnumerable ();
				nextNodesCatchFinally = new NNEnumerableCatchFinally (this);
			}
			return nextNodesCatchFinally;
		} }

		/**
		 * @brief This acts as a wrapper around all the other NNEnumerable's below.
		 *        It adds the beginning of the catch/finally as a conditional branch target
		 *        to every instruction in the corresponding try section.
		 */
		private class NNEnumerableCatchFinally : System.Collections.Generic.IEnumerable<GraphNode> {
			private GraphNode gn;
			public NNEnumerableCatchFinally (GraphNode gn)
			{
				this.gn = gn;
			}
			System.Collections.Generic.IEnumerator<GraphNode> System.Collections.Generic.IEnumerable<GraphNode>.GetEnumerator ()
			{
				return new NNEnumeratorCatchFinally (gn);
			}
			System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator ()
			{
				return new NNEnumeratorCatchFinally (gn);
			}
		}
		private class NNEnumeratorCatchFinally : System.Collections.Generic.IEnumerator<GraphNode> {
			private GraphNode gn, nn;
			private int index = 0;
			private System.Collections.Generic.IEnumerator<GraphNode> realEnumerator;
			public NNEnumeratorCatchFinally (GraphNode gn)
			{
				this.gn = gn;
				this.realEnumerator = gn.nextNodes.GetEnumerator ();
			}
			public bool MoveNext ()
			{
				/*
				 * First off, return any targets the instruction can come up with.
				 */
				if (realEnumerator.MoveNext ()) {
					nn = realEnumerator.Current;
					return true;
				}

				/*
				 * Then if this instruction is in a try section, say this instruction 
				 * can potentially branch to the beginning of the corresponding 
				 * catch/finally.
				 */
				if ((index == 0) && (gn.tryBlock != null)) {
					index ++;
					nn = gn.tryBlock.catchFinallyBlock;
					return true;
				}

				/*
				 * That's all we can do.
				 */
				nn = null;
				return false;
			}
			public void Reset ()
			{
				realEnumerator.Reset ();
				index = 0;
				nn = null;
			}
			GraphNode System.Collections.Generic.IEnumerator<GraphNode>.Current {
				get { return nn; }
			}
			object System.Collections.IEnumerator.Current {
				get { return nn; }
			}
			void System.IDisposable.Dispose() { }
		}

		/**
		 * @brief This default iterator always returns the next inline node as the one-and-only next node.
		 *        Other instructions need to override it if they can possibly do other than that.
		 */
		protected virtual System.Collections.Generic.IEnumerable<GraphNode> GetNNEnumerable ()
		{
			return new NNEnumerable (this);
		}
		private class NNEnumerable : System.Collections.Generic.IEnumerable<GraphNode> {
			private GraphNode gn;
			public NNEnumerable (GraphNode gn)
			{
				this.gn = gn;
			}
			System.Collections.Generic.IEnumerator<GraphNode> System.Collections.Generic.IEnumerable<GraphNode>.GetEnumerator ()
			{
				return new NNEnumerator (gn);
			}
			System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator ()
			{
				return new NNEnumerator (gn);
			}
		}
		private class NNEnumerator : System.Collections.Generic.IEnumerator<GraphNode> {
			private GraphNode gn;
			private GraphNode nn;
			private int index;
			public NNEnumerator (GraphNode gn)
			{
				this.gn = gn;
			}
			public bool MoveNext ()
			{
				switch (index) {
					case 0: {
						index ++;
						nn = gn.nextLin;
						return nn != null;
					}
					case 1: {
						nn = null;
						return false;
					}
				}
				throw new Exception ();
			}
			public void Reset ()
			{
				index = 0;
				nn = null;
			}
			GraphNode System.Collections.Generic.IEnumerator<GraphNode>.Current {
				get { return nn; }
			}
			object System.Collections.IEnumerator.Current {
				get { return nn; }
			}
			void System.IDisposable.Dispose() { }
		}
	}

	/**
	 * @brief Things that derive from this are the beginning of a block.
	 *        A block of code is that which begins with a label or is the beginning of all code
	 *        and it contains no labels, ie, it can't be jumped into other than at its beginning.
	 */
	public abstract class GraphNodeBlock : GraphNode {
		public List<ScriptMyLocal> localsWrittenBeforeRead = new List<ScriptMyLocal> ();
		public List<ScriptMyLocal> localsReadBeforeWritten = new List<ScriptMyLocal> ();
		public int hasBeenResolved;
		public GraphNodeBlock (ScriptCollector coll) : base (coll) { }
	}

	/**
	 * @brief This placeholder is at the beginning of the code so the first few instructions 
	 *        belong to some block.
	 */
	public class GraphNodeBegin : GraphNodeBlock {
		public GraphNodeBegin (ScriptCollector coll) : base (coll) { }
		public override void DebString (StringBuilder sb) { sb.Append ("begin"); }
		public override void WriteOutOne (ScriptMyILGen ilGen) { }
	}

	/**
	 * @brief Beginning of try block.
	 */
	public class GraphNodeBeginExceptionBlock : GraphNodeBlock {
		public GraphNodeBeginExceptionBlock outerTryBlock;      // next outer try opcode or null
		public GraphNodeCatchFinallyBlock   catchFinallyBlock;  // start of associated catch or finally
		public GraphNodeEndExceptionBlock   endBlock;           // end of associated catch or finally

		public GraphNodeBeginExceptionBlock (ScriptCollector coll) : base (coll)
		{ }

		public override void DebString (StringBuilder sb)
		{
			sb.Append ("  beginexceptionblock");
		}

		public override void WriteOutOne (ScriptMyILGen ilGen)
		{
			ilGen.BeginExceptionBlock ();
		}
	}

	/**
	 * @brief Beginning of catch or finally block.
	 */
	public abstract class GraphNodeCatchFinallyBlock : GraphNodeBlock {
		public GraphNodeCatchFinallyBlock (ScriptCollector coll) : base (coll)
		{ }
	}

	/**
	 * @brief Beginning of catch block.
	 */
	public class GraphNodeBeginCatchBlock : GraphNodeCatchFinallyBlock {
		public Type excType;

		public GraphNodeBeginCatchBlock (ScriptCollector coll, Type excType) : base (coll)
		{
			this.excType = excType;
		}

		public override void DebString (StringBuilder sb)
		{
			sb.Append ("  begincatchblock");
		}

		public override void WriteOutOne (ScriptMyILGen ilGen)
		{
			ilGen.BeginCatchBlock (excType);
		}
	}

	/**
	 * @brief Beginning of finally block.
	 */
	public class GraphNodeBeginFinallyBlock : GraphNodeCatchFinallyBlock {
		public GraphNodeBeginFinallyBlock (ScriptCollector coll) : base (coll)
		{ }

		public override void DebString (StringBuilder sb)
		{
			sb.Append ("  beginfinallyblock");
		}

		public override void WriteOutOne (ScriptMyILGen ilGen)
		{
			ilGen.BeginFinallyBlock ();
		}
	}

	/**
	 * @brief End of try/catch/finally block.
	 */
	public class GraphNodeEndExceptionBlock : GraphNode {
		public List<GraphNodeBlock> leaveTargets = new List<GraphNodeBlock> ();

		public GraphNodeEndExceptionBlock (ScriptCollector coll) : base (coll)
		{ }

		public override void DebString (StringBuilder sb)
		{
			sb.Append ("  endexceptionblock");
		}

		public override void WriteOutOne (ScriptMyILGen ilGen)
		{
			ilGen.EndExceptionBlock ();
		}

		/**
		 * @brief Return list of leave targets followed by the next linear instruction
		 *        But if the target is outside our scope (eg __retlbl), omit it from the list
		 */
		protected override System.Collections.Generic.IEnumerable<GraphNode> GetNNEnumerable ()
		{
			return new NNEnumerable (this);
		}
		private class NNEnumerable : System.Collections.Generic.IEnumerable<GraphNode> {
			private GraphNodeEndExceptionBlock gn;
			public NNEnumerable (GraphNodeEndExceptionBlock gn)
			{
				this.gn = gn;
			}
			System.Collections.Generic.IEnumerator<GraphNode> System.Collections.Generic.IEnumerable<GraphNode>.GetEnumerator ()
			{
				return new NNEnumerator (gn);
			}
			System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator ()
			{
				return new NNEnumerator (gn);
			}
		}
		private class NNEnumerator : System.Collections.Generic.IEnumerator<GraphNode> {
			private bool doFallThru = true;
			private GraphNodeEndExceptionBlock gn;
			private GraphNode nn;
			private IEnumerator<GraphNodeBlock> leaveTargetEnumerator;
			private int index;
			public NNEnumerator (GraphNodeEndExceptionBlock gn)
			{
				this.gn = gn;
				this.leaveTargetEnumerator = gn.leaveTargets.GetEnumerator ();
			}
			public bool MoveNext ()
			{
				if (doFallThru) {
					nn = gn.nextLin;
					doFallThru = false;
					return true;
				}

				if (leaveTargetEnumerator.MoveNext ()) {
					nn = leaveTargetEnumerator.Current;
					return true;
				}

				nn = null;
				return false;
			}
			public void Reset ()
			{
				doFallThru = true;
				leaveTargetEnumerator.Reset ();
				nn = null;
			}
			GraphNode System.Collections.Generic.IEnumerator<GraphNode>.Current {
				get { return nn; }
			}
			object System.Collections.IEnumerator.Current {
				get { return nn; }
			}
			void System.IDisposable.Dispose() { }
		}
	}

	/**
	 * @brief Actual instruction emits...
	 */
	public abstract class GraphNodeEmit : GraphNode {
		public OpCode opcode;

		public GraphNodeEmit (ScriptCollector coll, OpCode opcode) : base (coll)
		{
			this.opcode = opcode;
		}

		public override void DebString (StringBuilder sb)
		{
			sb.Append ("".PadRight (OPINDENT));
			sb.Append (opcode.ToString ().PadRight (OPDEBLEN));
		}

		private bool CanFallThrough ()
		{
			switch (opcode.FlowControl) {
				case FlowControl.Branch:      return false;  // unconditional branch
				case FlowControl.Break:       return false;  // break
				case FlowControl.Call:        return true;   // call
				case FlowControl.Cond_Branch: return true;   // conditional branch
				case FlowControl.Next:        return true;   // falls through to next instruction
				case FlowControl.Return:      return false;  // return
				case FlowControl.Throw:       return false;  // throw
				default: throw new Exception ("unknown flow control " + opcode.FlowControl);
			}
		}

		/**
		 * @brief If instruction is terminating, we say there is nothing following (eg, return).
		 *        Otherwise, say the one-and-only next instruction is the next instruction inline.
		 */
		protected override System.Collections.Generic.IEnumerable<GraphNode> GetNNEnumerable ()
		{
			return new NNEnumerable (this);
		}
		private class NNEnumerable : System.Collections.Generic.IEnumerable<GraphNode> {
			private GraphNodeEmit gn;
			public NNEnumerable (GraphNodeEmit gn)
			{
				this.gn = gn;
			}
			System.Collections.Generic.IEnumerator<GraphNode> System.Collections.Generic.IEnumerable<GraphNode>.GetEnumerator ()
			{
				return new NNEnumerator (gn);
			}
			System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator ()
			{
				return new NNEnumerator (gn);
			}
		}
		private class NNEnumerator : System.Collections.Generic.IEnumerator<GraphNode> {
			private GraphNodeEmit gn;
			private GraphNode nn;
			private int index;
			public NNEnumerator (GraphNodeEmit gn)
			{
				this.gn = gn;
			}
			public bool MoveNext ()
			{
				switch (index) {
					case 0: {
						if (gn.CanFallThrough ()) {
							index ++;
							nn = gn.nextLin;
							return nn != null;
						}
						return false;
					}
					case 1: {
						nn = null;
						return false;
					}
				}
				throw new Exception ();
			}
			public void Reset ()
			{
				index = 0;
				nn = null;
			}
			GraphNode System.Collections.Generic.IEnumerator<GraphNode>.Current {
				get { return nn; }
			}
			object System.Collections.IEnumerator.Current {
				get { return nn; }
			}
			void System.IDisposable.Dispose() { }
		}
	}

	public class GraphNodeEmitNull : GraphNodeEmit {
		public GraphNodeEmitNull (ScriptCollector coll, OpCode opcode) : base (coll, opcode)
		{ }

		public override void DebString (StringBuilder sb)
		{
			base.DebString (sb);
		}

		public override void WriteOutOne (ScriptMyILGen ilGen)
		{
			ilGen.Emit (opcode);
		}
	}

	public class GraphNodeEmitField : GraphNodeEmit {
		public FieldInfo field;

		public GraphNodeEmitField (ScriptCollector coll, OpCode opcode, FieldInfo field) : base (coll, opcode)
		{
			this.field = field;
		}

		public override void DebString (StringBuilder sb)
		{
			base.DebString (sb);
			sb.Append (field.Name);
		}

		public override void WriteOutOne (ScriptMyILGen ilGen)
		{
			ilGen.Emit (opcode, field);
		}
	}

	public class GraphNodeEmitLocal : GraphNodeEmit {
		public ScriptMyLocal myLocal;

		public GraphNodeEmitLocal (ScriptCollector coll, OpCode opcode, ScriptMyLocal myLocal) : base (coll, opcode)
		{
			this.myLocal = myLocal;
		}

		public override void DebString (StringBuilder sb)
		{
			base.DebString (sb);
			sb.Append (myLocal.name);
		}

		public override ScriptMyLocal ReadsLocal  ()
		{
			if (opcode == OpCodes.Ldloc)  return myLocal;
			if (opcode == OpCodes.Ldloca) return myLocal;
			if (opcode == OpCodes.Stloc)  return null;
			throw new Exception ("unknown opcode " + opcode);
		}
		public override ScriptMyLocal WritesLocal ()
		{
			if (opcode == OpCodes.Ldloc)  return null;
			if (opcode == OpCodes.Ldloca) return myLocal;
			if (opcode == OpCodes.Stloc)  return myLocal;
			throw new Exception ("unknown opcode " + opcode);
		}

		public override void WriteOutOne (ScriptMyILGen ilGen)
		{
			ilGen.Emit (opcode, myLocal);
		}
	}

	public class GraphNodeEmitType : GraphNodeEmit {
		public Type type;

		public GraphNodeEmitType (ScriptCollector coll, OpCode opcode, Type type) : base (coll, opcode)
		{
			this.type = type;
		}

		public override void DebString (StringBuilder sb)
		{
			base.DebString (sb);
			sb.Append (type.Name);
		}

		public override void WriteOutOne (ScriptMyILGen ilGen)
		{
			ilGen.Emit (opcode, type);
		}
	}

	public class GraphNodeEmitLabel : GraphNodeEmit {
		public ScriptMyLabel myLabel;

		public GraphNodeEmitLabel (ScriptCollector coll, OpCode opcode, ScriptMyLabel myLabel) : base (coll, opcode)
		{
			this.myLabel = myLabel;
		}

		public override void DebString (StringBuilder sb)
		{
			base.DebString (sb);
			sb.Append (myLabel.name);
		}

		public override void WriteOutOne (ScriptMyILGen ilGen)
		{
			ilGen.Emit (opcode, myLabel);
		}

		/**
		 * @brief Conditional branches return the next inline followed by the branch target
		 *        Unconditional branches return only the branch target
		 *        But if the target is outside our scope (eg __retlbl), omit it from the list
		 */
		protected override System.Collections.Generic.IEnumerable<GraphNode> GetNNEnumerable ()
		{
			return new NNEnumerable (this);
		}
		private class NNEnumerable : System.Collections.Generic.IEnumerable<GraphNode> {
			private GraphNodeEmitLabel gn;
			public NNEnumerable (GraphNodeEmitLabel gn)
			{
				this.gn = gn;
			}
			System.Collections.Generic.IEnumerator<GraphNode> System.Collections.Generic.IEnumerable<GraphNode>.GetEnumerator ()
			{
				return new NNEnumerator (gn);
			}
			System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator ()
			{
				return new NNEnumerator (gn);
			}
		}
		private class NNEnumerator : System.Collections.Generic.IEnumerator<GraphNode> {
			private GraphNodeEmitLabel gn;
			private GraphNode nn;
			private int index;
			public NNEnumerator (GraphNodeEmitLabel gn)
			{
				this.gn = gn;
			}
			public bool MoveNext ()
			{
				switch (gn.opcode.FlowControl) {
					case FlowControl.Branch: {
						// unconditional branch just goes to target and nothing else
						switch (index) {
							case 0: {
								nn = gn.myLabel.whereAmI;
								index ++;
								return nn != null;
							}
							case 1: {
								return false;
							}
						}
						throw new Exception ();
					}
					case FlowControl.Cond_Branch: {
						// conditional branch goes inline and to target
						switch (index) {
							case 0: {
								nn = gn.nextLin;
								index ++;
								return true;
							}
							case 1: {
								nn = gn.myLabel.whereAmI;
								index ++;
								return nn != null;
							}
							case 2: {
								return false;
							}
						}
						throw new Exception ();
					}
					default: throw new Exception ("unknown flow control " + gn.opcode.FlowControl.ToString () + 
					                              " of " + gn.opcode.ToString ());
				}
			}
			public void Reset ()
			{
				index = 0;
				nn = null;
			}
			GraphNode System.Collections.Generic.IEnumerator<GraphNode>.Current {
				get { return nn; }
			}
			object System.Collections.IEnumerator.Current {
				get { return nn; }
			}
			void System.IDisposable.Dispose() { }
		}
	}

	public class GraphNodeEmitLabelLeave : GraphNodeEmitLabel {
		public GraphNodeBlock unwindTo;  // if unwinding, innermost finally block being unwound
		                                 //         else, same as myTarget.whereAmI
		                                 // null if unwinding completely out of scope, eg, __retlbl

		public GraphNodeEmitLabelLeave (ScriptCollector coll, ScriptMyLabel myLabel) : base (coll, OpCodes.Leave, myLabel)
		{ }

		public override void DebString (StringBuilder sb)
		{
			base.DebString (sb);
			sb.Append (myLabel.name);
		}

		public override void WriteOutOne (ScriptMyILGen ilGen)
		{
			ilGen.Emit (opcode, myLabel);
		}

		/**
		 * @brief Leave instructions only have one unconditional target.
		 *        Either the given target if within the same try block 
		 *        or the beginning of the intervening finally block.
		 */
		protected override System.Collections.Generic.IEnumerable<GraphNode> GetNNEnumerable ()
		{
			return new NNEnumerable (this);
		}
		private class NNEnumerable : System.Collections.Generic.IEnumerable<GraphNode> {
			private GraphNodeEmitLabelLeave gn;
			public NNEnumerable (GraphNodeEmitLabelLeave gn)
			{
				this.gn = gn;
			}
			System.Collections.Generic.IEnumerator<GraphNode> System.Collections.Generic.IEnumerable<GraphNode>.GetEnumerator ()
			{
				return new NNEnumerator (gn);
			}
			System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator ()
			{
				return new NNEnumerator (gn);
			}
		}
		private class NNEnumerator : System.Collections.Generic.IEnumerator<GraphNode> {
			private GraphNodeEmitLabelLeave gn;
			private GraphNode nn;
			private int index;
			public NNEnumerator (GraphNodeEmitLabelLeave gn)
			{
				this.gn = gn;
			}
			public bool MoveNext ()
			{
				if (index == 0) {
					nn = gn.unwindTo;
					index ++;
					return nn != null;
				}
				nn = null;
				return false;
			}
			public void Reset ()
			{
				index = 0;
				nn = null;
			}
			GraphNode System.Collections.Generic.IEnumerator<GraphNode>.Current {
				get { return nn; }
			}
			object System.Collections.IEnumerator.Current {
				get { return nn; }
			}
			void System.IDisposable.Dispose() { }
		}
	}

	public class GraphNodeEmitLabels : GraphNodeEmit {
		public ScriptMyLabel[] myLabels;

		public GraphNodeEmitLabels (ScriptCollector coll, OpCode opcode, ScriptMyLabel[] myLabels) : base (coll, opcode)
		{
			this.myLabels = myLabels;
		}

		public override void DebString (StringBuilder sb)
		{
			base.DebString (sb);
			bool first = true;
			foreach (ScriptMyLabel lbl in myLabels) {
				if (!first) sb.Append (',');
				sb.Append (lbl.name);
				first = false;
			}
		}

		public override void WriteOutOne (ScriptMyILGen ilGen)
		{
			ilGen.Emit (opcode, myLabels);
		}

		/**
		 * @brief Return list of all labels followed by the next linear instruction
		 *        But if the target is outside our scope (eg __retlbl), omit it from the list
		 */
		protected override System.Collections.Generic.IEnumerable<GraphNode> GetNNEnumerable ()
		{
			return new NNEnumerable (this);
		}
		private class NNEnumerable : System.Collections.Generic.IEnumerable<GraphNode> {
			private GraphNodeEmitLabels gn;
			public NNEnumerable (GraphNodeEmitLabels gn)
			{
				this.gn = gn;
			}
			System.Collections.Generic.IEnumerator<GraphNode> System.Collections.Generic.IEnumerable<GraphNode>.GetEnumerator ()
			{
				return new NNEnumerator (gn);
			}
			System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator ()
			{
				return new NNEnumerator (gn);
			}
		}
		private class NNEnumerator : System.Collections.Generic.IEnumerator<GraphNode> {
			private GraphNodeEmitLabels gn;
			private GraphNode nn;
			private int index;
			public NNEnumerator (GraphNodeEmitLabels gn)
			{
				this.gn = gn;
			}
			public bool MoveNext ()
			{
				/*
				 * Return next from list of switch case labels.
				 */
				while (index < gn.myLabels.Length) {
					nn = gn.myLabels[index++].whereAmI;
					if (nn != null) return true;
				}

				/*
				 * If all ran out, the switch instruction falls through.
				 */
				if (index == gn.myLabels.Length) {
					index ++;
					nn = gn.nextLin;
					return true;
				}

				/*
				 * Even ran out of that, say there's nothing more.
				 */
				nn = null;
				return false;
			}
			public void Reset ()
			{
				index = 0;
				nn = null;
			}
			GraphNode System.Collections.Generic.IEnumerator<GraphNode>.Current {
				get { return nn; }
			}
			object System.Collections.IEnumerator.Current {
				get { return nn; }
			}
			void System.IDisposable.Dispose() { }
		}
	}

	public class GraphNodeEmitIntMeth : GraphNodeEmit {
		public ScriptMyILGen method;

		public GraphNodeEmitIntMeth (ScriptCollector coll, OpCode opcode, ScriptMyILGen method) : base (coll, opcode)
		{
			this.method = method;
		}

		public override void DebString (StringBuilder sb)
		{
			base.DebString (sb);
			sb.Append (method.methName);
		}

		public override void WriteOutOne (ScriptMyILGen ilGen)
		{
			ilGen.Emit (opcode, method);
		}
	}

	public class GraphNodeEmitExtMeth : GraphNodeEmit {
		public MethodInfo method;

		public GraphNodeEmitExtMeth (ScriptCollector coll, OpCode opcode, MethodInfo method) : base (coll, opcode)
		{
			this.method = method;
		}

		public override void DebString (StringBuilder sb)
		{
			base.DebString (sb);
			sb.Append (method.Name);
		}

		public override void WriteOutOne (ScriptMyILGen ilGen)
		{
			ilGen.Emit (opcode, method);
		}
	}

	public class GraphNodeEmitCtor : GraphNodeEmit {
		public ConstructorInfo ctor;

		public GraphNodeEmitCtor (ScriptCollector coll, OpCode opcode, ConstructorInfo ctor) : base (coll, opcode)
		{
			this.ctor = ctor;
		}

		public override void DebString (StringBuilder sb)
		{
			base.DebString (sb);
			sb.Append (ctor.ReflectedType.Name);
		}

		public override void WriteOutOne (ScriptMyILGen ilGen)
		{
			ilGen.Emit (opcode, ctor);
		}
	}

	public class GraphNodeEmitDouble : GraphNodeEmit {
		public double value;

		public GraphNodeEmitDouble (ScriptCollector coll, OpCode opcode, double value) : base (coll, opcode)
		{
			this.value = value;
		}

		public override void DebString (StringBuilder sb)
		{
			base.DebString (sb);
			sb.Append (value);
		}

		public override void WriteOutOne (ScriptMyILGen ilGen)
		{
			ilGen.Emit (opcode, value);
		}
	}

	public class GraphNodeEmitFloat : GraphNodeEmit {
		public float value;

		public GraphNodeEmitFloat (ScriptCollector coll, OpCode opcode, float value) : base (coll, opcode)
		{
			this.value = value;
		}

		public override void DebString (StringBuilder sb)
		{
			base.DebString (sb);
			sb.Append (value);
		}

		public override void WriteOutOne (ScriptMyILGen ilGen)
		{
			ilGen.Emit (opcode, value);
		}
	}

	public class GraphNodeEmitInt : GraphNodeEmit {
		public int value;

		public GraphNodeEmitInt (ScriptCollector coll, OpCode opcode, int value) : base (coll, opcode)
		{
			this.value = value;
		}

		public override void DebString (StringBuilder sb)
		{
			base.DebString (sb);
			sb.Append (value);
		}

		public override void WriteOutOne (ScriptMyILGen ilGen)
		{
			ilGen.Emit (opcode, value);
		}
	}

	public class GraphNodeEmitString : GraphNodeEmit {
		public string value;

		public GraphNodeEmitString (ScriptCollector coll, OpCode opcode, string value) : base (coll, opcode)
		{
			this.value = value;
		}

		public override void DebString (StringBuilder sb)
		{
			base.DebString (sb);
			sb.Append ("\"");
			sb.Append (value);
			sb.Append ("\"");
		}

		public override void WriteOutOne (ScriptMyILGen ilGen)
		{
			ilGen.Emit (opcode, value);
		}
	}

	public class GraphNodeMarkLabel : GraphNodeBlock {
		public ScriptMyLabel myLabel;

		public GraphNodeMarkLabel (ScriptCollector coll, ScriptMyLabel myLabel) : base (coll)
		{
			this.myLabel = myLabel;
		}

		public override void DebString (StringBuilder sb)
		{
			sb.Append (myLabel.name);
			sb.Append (":");
		}

		public override void WriteOutOne (ScriptMyILGen ilGen)
		{
			ilGen.MarkLabel (myLabel);
		}
	}


	public class ScriptCollector : ScriptMyILGen {

		private ScriptObjWriter wrapped;
		public GraphNode firstLin, lastLin;
		private bool resolvedSomething;
		private int resolveSequence;
		public GraphNodeBeginExceptionBlock curTryBlock = null;  // pushed at beginning of try
		                                                         // popped at BEGINNING of catch/finally
		public GraphNodeBeginExceptionBlock curExcBlock = null;  // pushed at beginning of try
		                                                         // popped at END of catch/finally

		private List<ScriptMyLocal> declaredLocals = new List<ScriptMyLocal> ();
		private List<ScriptMyLabel> definedLabels  = new List<ScriptMyLabel> ();

		public override string methName { get { return wrapped.methName; } }

		/**
		 * @brief Wrap the optimizer around the ScriptObjWriter to collect the instruction stream.
		 *        All stream-writing calls get saved to our graph nodes instead of being written to object file.
		 */
		public ScriptCollector (ScriptObjWriter wrapped)
		{
			this.wrapped       = wrapped;
			GraphNodeBegin gnb = new GraphNodeBegin (this);
			this.firstLin      = gnb;
			this.lastLin       = gnb;
		}

		public override ScriptMyLocal DeclareLocal (Type type, string name)
		{
			ScriptMyLocal loc = new ScriptMyLocal ();
			loc.name   = name;
			loc.type   = type;
			loc.number = wrapped.localNumber ++;
			declaredLocals.Add (loc);
			return loc;
		}

		public override ScriptMyLabel DefineLabel (string name)
		{
			ScriptMyLabel lbl = new ScriptMyLabel ();
			lbl.name   = name;
			lbl.number = wrapped.labelNumber ++;
			definedLabels.Add (lbl);
			return lbl;
		}

		public override void BeginExceptionBlock ()
		{
			GraphNodeBeginExceptionBlock tryBlock = new GraphNodeBeginExceptionBlock (this);
			tryBlock.ChainLin ();
			this.curExcBlock = tryBlock;
			this.curTryBlock = tryBlock;
		}

		public override void BeginCatchBlock (Type excType)
		{
			GraphNodeBeginCatchBlock catchBlock = new GraphNodeBeginCatchBlock (this, excType);
			catchBlock.ChainLin ();
			curExcBlock.catchFinallyBlock = catchBlock;
			curTryBlock = curExcBlock.tryBlock;
		}

		public override void BeginFinallyBlock ()
		{
			GraphNodeBeginFinallyBlock finallyBlock = new GraphNodeBeginFinallyBlock (this);
			finallyBlock.ChainLin ();
			curExcBlock.catchFinallyBlock = finallyBlock;
			curTryBlock = curExcBlock.tryBlock;
		}

		public override void EndExceptionBlock ()
		{
			GraphNodeEndExceptionBlock endBlock = new GraphNodeEndExceptionBlock (this);
			endBlock.ChainLin ();
			curExcBlock.endBlock = endBlock;
			curTryBlock = curExcBlock.tryBlock;
			curExcBlock = curExcBlock.excBlock;
		}

		public override void Emit (OpCode opcode)
		{
			new GraphNodeEmitNull (this, opcode).ChainLin ();
		}

		public override void Emit (OpCode opcode, FieldInfo field)
		{
			new GraphNodeEmitField (this, opcode, field).ChainLin ();
		}

		public override void Emit (OpCode opcode, ScriptMyLocal myLocal)
		{
			new GraphNodeEmitLocal (this, opcode, myLocal).ChainLin ();
		}

		public override void Emit (OpCode opcode, Type type)
		{
			new GraphNodeEmitType (this, opcode, type).ChainLin ();
		}

		public override void Emit (OpCode opcode, ScriptMyLabel myLabel)
		{
			if (opcode == OpCodes.Leave) {
				new GraphNodeEmitLabelLeave (this, myLabel).ChainLin ();
			} else {
				new GraphNodeEmitLabel (this, opcode, myLabel).ChainLin ();
			}
		}

		public override void Emit (OpCode opcode, ScriptMyLabel[] myLabels)
		{
			new GraphNodeEmitLabels (this, opcode, myLabels).ChainLin ();
		}

		public override void Emit (OpCode opcode, ScriptMyILGen method)
		{
			new GraphNodeEmitIntMeth (this, opcode, method).ChainLin ();
		}

		public override void Emit (OpCode opcode, MethodInfo method)
		{
			new GraphNodeEmitExtMeth (this, opcode, method).ChainLin ();
		}

		public override void Emit (OpCode opcode, ConstructorInfo ctor)
		{
			new GraphNodeEmitCtor (this, opcode, ctor).ChainLin ();
		}

		public override void Emit (OpCode opcode, double value)
		{
			new GraphNodeEmitDouble (this, opcode, value).ChainLin ();
		}

		public override void Emit (OpCode opcode, float value)
		{
			new GraphNodeEmitFloat (this, opcode, value).ChainLin ();
		}

		public override void Emit (OpCode opcode, int value)
		{
			new GraphNodeEmitInt (this, opcode, value).ChainLin ();
		}

		public override void Emit (OpCode opcode, string value)
		{
			new GraphNodeEmitString (this, opcode, value).ChainLin ();
		}

		public override void MarkLabel (ScriptMyLabel myLabel)
		{
			myLabel.whereAmI = new GraphNodeMarkLabel (this, myLabel);
			myLabel.whereAmI.ChainLin ();
		}

		/**
		 * @brief Write the whole graph out to the object file.
		 */
		public ScriptMyILGen WriteOutAll ()
		{
			foreach (ScriptMyLocal loc in declaredLocals) {
				if (loc.isReferenced) wrapped.DeclareLocal (loc);
			}
			foreach (ScriptMyLabel lbl in definedLabels) {
				wrapped.DefineLabel (lbl);
			}
			for (GraphNode gn = firstLin; gn != null; gn = gn.nextLin) {
				gn.WriteOutOne (wrapped);
			}
			return wrapped;
		}

		/**
		 * @brief Perform optimizations.
		 */
		public void Optimize ()
		{
			/*
			 * Scan for OpCodes.Leave instructions.
			 * For each found, its target for flow analysis purposes is the beginning of the corresponding
			 * finally block.  And the end of the finally block gets a conditional branch target of the 
			 * leave instruction's target.  A leave instruction can unwind zero or more finally blocks.
			 */
			for (GraphNode gn = firstLin; gn != null; gn = gn.nextLin) {
				if (gn is GraphNodeEmitLabelLeave) {
					GraphNodeEmitLabelLeave leaveInstr = (GraphNodeEmitLabelLeave)gn;         // the leave instruction
					GraphNodeMarkLabel leaveTarget = leaveInstr.myLabel.whereAmI;             // label being targeted by leave
					GraphNodeBeginExceptionBlock leaveTargetsTryBlock =                       // try block directly enclosing leave target
						(leaveTarget == null) ? null : leaveTarget.tryBlock;              // ...it must not be unwound

					/*
					 * The leave unwinds to the beginning of the innermost finally block being unwound.
					 * The end of the innermost finally block conditionally branches to beginning of next innermost finally being unwound.
					 * The end of that finally block conditionally branches to beginning of next innermost finally being unwound, etc.
					 */
					GraphNodeCatchFinallyBlock innerFinallyBlock = null;
					for (GraphNodeBeginExceptionBlock tryBlock = leaveInstr.tryBlock;
					     tryBlock != leaveTargetsTryBlock;
					     tryBlock  = tryBlock.tryBlock) {
						if (tryBlock == null) throw new Exception ("leave target not at or outer to leave instruction");
						GraphNodeCatchFinallyBlock cfb = tryBlock.catchFinallyBlock;
						if (cfb is GraphNodeBeginFinallyBlock) {
							if (innerFinallyBlock == null) {
								leaveInstr.unwindTo = cfb;
							} else {
								innerFinallyBlock.tryBlock.endBlock.leaveTargets.Add (cfb);
							}
							innerFinallyBlock = cfb;
						}
					}

					/*
					 * The end of the outermost finally being unwound is the target of the leave instruction.
					 * In the case of no finallies being unwound, the leave is just a simple unconditional branch.
					 */
					if (innerFinallyBlock == null) {
						leaveInstr.unwindTo = leaveTarget;
					} else {
						innerFinallyBlock.tryBlock.endBlock.leaveTargets.Add (leaveTarget);
					}
				}
			}

			/*
			 * See which variables a particular block reads before writing.
			 * This just considers the block itself and nothing that it branches to or fallsthru to.
			 */
			GraphNodeBlock currentBlock = null;
			for (GraphNode gn = firstLin; gn != null; gn = gn.nextLin) {
				if (gn is GraphNodeBlock) currentBlock = (GraphNodeBlock)gn;
				ScriptMyLocal rdlcl = gn.ReadsLocal ();
				if ((rdlcl != null) &&
				    !currentBlock.localsWrittenBeforeRead.Contains (rdlcl) && 
				    !currentBlock.localsReadBeforeWritten.Contains (rdlcl)) {
					currentBlock.localsReadBeforeWritten.Add (rdlcl);
				}
				ScriptMyLocal wrlcl = gn.WritesLocal ();
				if ((wrlcl != null) &&
				    !currentBlock.localsWrittenBeforeRead.Contains (wrlcl) && 
				    !currentBlock.localsReadBeforeWritten.Contains (wrlcl)) {
					currentBlock.localsWrittenBeforeRead.Add (wrlcl);
				}
			}

			/*
			 * For every block we branch to, add that blocks readables to our list of readables,
			 * because we need to have those values valid on entry to our block.  But if we write the 
			 * variable before we can possibly branch to that block, then we don't need to have it valid 
			 * on entry to our block.  So basically it looks like the branch instruction is reading 
			 * everything required by any blocks it can branch to.
			 */
			do {
				this.resolvedSomething = false;
				this.resolveSequence ++;
				this.ResolveBlock ((GraphNodeBlock)firstLin);
			} while (this.resolvedSomething);

			/*
			 * Remove all the stloc/ldloc that are back-to-back without the local
			 * being needed afterwards.
			 */
			for (GraphNode gn = firstLin; gn != null; gn = gn.nextLin) {
				if ((gn is GraphNodeEmitLocal) && 
				    (gn.nextLin is GraphNodeEmitLocal)) {
					GraphNodeEmitLocal gnel = (GraphNodeEmitLocal)gn;
					GraphNodeEmitLocal nnel = (GraphNodeEmitLocal)gn.nextLin;
					if ((gnel.opcode == OpCodes.Stloc) && 
					    (nnel.opcode == OpCodes.Ldloc) && 
					    (gnel.myLocal == nnel.myLocal) && 
					    !IsLocalNeededAfterThis (nnel, nnel.myLocal)) {
						gnel.prevLin.nextLin = nnel.nextLin;
						nnel.nextLin.prevLin = gnel.prevLin;
						gn = gnel.prevLin;
					}
				}
			}

			/*
			 * Remove all write-only local variables, ie, those with no ldloc[a] references.
			 * Replace any stloc instructions with pops.
			 */
			for (GraphNode gn = firstLin; gn != null; gn = gn.nextLin) {
				ScriptMyLocal rdlcl = gn.ReadsLocal ();
				if (rdlcl != null) rdlcl.isReferenced = true;
			}
			for (GraphNode gn = firstLin; gn != null; gn = gn.nextLin) {
				ScriptMyLocal wrlcl = gn.WritesLocal ();
				if ((wrlcl != null) && !wrlcl.isReferenced) {
					if (!(gn is GraphNodeEmitLocal) || (((GraphNodeEmitLocal)gn).opcode != OpCodes.Stloc)) {
						throw new Exception ("expecting stloc");
					}
					GraphNodeEmitNull pop = new GraphNodeEmitNull (this, OpCodes.Pop);
					pop.nextLin = gn.nextLin;
					pop.prevLin = gn.prevLin;
					gn.nextLin.prevLin = pop;
					gn.prevLin.nextLin = pop;
					gn = pop;
				}
			}

			/*
			 * Dump out the results.
			 */
#if DEBUG
			Console.WriteLine ("");
			Console.WriteLine (methName);
			Console.WriteLine ("  resolveSequence=" + this.resolveSequence);

			Console.WriteLine ("  Locals:");
			foreach (ScriptMyLocal loc in declaredLocals) {
				Console.WriteLine ("    " + loc.type.Name + "  " + loc.name);
			}

			Console.WriteLine ("  Labels:");
			foreach (ScriptMyLabel lbl in definedLabels) {
				Console.WriteLine ("    " + lbl.name);
			}

			Console.WriteLine ("  Code:");
			int linSeqNos = 0;
			for (GraphNode gn = firstLin; gn != null; gn = gn.nextLin) {
				gn.linSeqNo = ++ linSeqNos;
			}
			for (GraphNode gn = firstLin; gn != null; gn = gn.nextLin) {
				StringBuilder sb = new StringBuilder ();
				sb.Append (gn.linSeqNo.ToString ().PadLeft (5));
				sb.Append (": ");
				gn.DebString (sb);
				if (gn.ReadsLocal  () != null) PadToLength (sb, 60, " [read]");
				if (gn.WritesLocal () != null) PadToLength (sb, 68, " [write]");
				PadToLength (sb, 72, " ->");
				bool first = true;
				foreach (GraphNode nn in gn.NextNodes) {
					if (first) {
						sb.Append (nn.linSeqNo.ToString ().PadLeft (5));
						first = false;
					} else {
						sb.Append (',');
						sb.Append (nn.linSeqNo);
					}
				}
				Console.WriteLine (sb.ToString ());
				if (gn is GraphNodeBlock) {
					GraphNodeBlock gnb = (GraphNodeBlock)gn;
					foreach (ScriptMyLocal lcl in gnb.localsReadBeforeWritten) {
						Console.WriteLine ("         reads " + lcl.name);
					}
				}
			}
#endif
		}

		/**
		 * @brief Scan the given block for branches to other blocks.
		 *        For any locals read by those blocks, mark them as being read by this block, 
		 *        provided this block has not written them by that point.  This makes it look 
		 *        as though the branch instruction is reading all the locals needed by any 
		 *        target blocks.
		 */
		private void ResolveBlock (GraphNodeBlock currentBlock)
		{
			/*
			 * So we don't recurse forever on a backward branch.
			 */
			currentBlock.hasBeenResolved = this.resolveSequence;

			/*
			 * Assume we haven't written any locals yet.
			 */
			List<ScriptMyLocal> localsWrittenSoFar = new List<ScriptMyLocal> ();

			/*
			 * Scan through the instructions in this block.
			 */
			for (GraphNode gn = currentBlock; gn != null;) {

				/*
				 * See if the instruction writes a local we don't know about yet.
				 */
				ScriptMyLocal wrlcl = gn.WritesLocal ();
				if ((wrlcl != null) && !localsWrittenSoFar.Contains (wrlcl)) {
					localsWrittenSoFar.Add (wrlcl);
				}

				/*
				 * Scan through all the possible next instructions after this.
				 * Note that if we are in the first part of a try/catch/finally block, 
				 * every instruction conditionally branches to the beginning of the 
				 * second part (the catch/finally block).
				 */
				GraphNode nextFallthruNode = null;
				foreach (GraphNode nn in gn.NextNodes) {
					if (nn is GraphNodeBlock) {

						/*
						 * Start of a block, go through all locals needed by that block on entry.
						 */
						GraphNodeBlock nextBlock = (GraphNodeBlock)nn;
						if (nextBlock.hasBeenResolved < this.resolveSequence) ResolveBlock (nextBlock);
						foreach (ScriptMyLocal readByNextBlock in nextBlock.localsReadBeforeWritten) {

							/*
							 * If this block hasn't written it by now and this block doesn't already
							 * require it on entry, say this block requires it on entry.
							 */
							if (!localsWrittenSoFar.Contains (readByNextBlock) && 
							    !currentBlock.localsReadBeforeWritten.Contains (readByNextBlock)) {
								currentBlock.localsReadBeforeWritten.Add (readByNextBlock);
								this.resolvedSomething = true;
							}
						}
					} else {

						/*
						 * Not start of a block, should be normal fallthru instruction.
						 */
						if (nextFallthruNode != null) throw new Exception (); // more than one fallthru?
						nextFallthruNode = nn;
					}
				}

				/*
				 * Process next instruction if it isn't the start of a block.
				 */
				gn = nextFallthruNode;
			}
				
		}

		/**
		 * @brief Figure out whether the value in a local var is needed after the given instruction.
		 *        True if we reach the end of the program on all branches before reading it
		 *        True if we write the local var on all branches before reading it
		 *        False otherwise
		 */
		private bool IsLocalNeededAfterThis (GraphNode node, ScriptMyLocal local)
		{
			do {
				GraphNode nextFallthruNode = null;
				foreach (GraphNode nn in node.NextNodes) {
					if (nn is GraphNodeBlock) {
						if (((GraphNodeBlock)nn).localsReadBeforeWritten.Contains (local)) {
							return true;
						}
					} else {
						nextFallthruNode = nn;
					}
				}
				node = nextFallthruNode;
				if (node == null) return false;
				if (node.ReadsLocal () == local) return true;
			} while (node.WritesLocal () != local);
			return false;
		}

		private static void PadToLength (StringBuilder sb, int len, string str)
		{
			int pad = len - sb.Length;
			if (pad < 0) pad = 0;
			sb.Append (str.PadLeft (pad));
		}
	}
}
