/***************************************************\
 *  COPYRIGHT 2012, Mike Rieker, Beverly, MA, USA  *
 *  All rights reserved.                           *
\***************************************************/

#define DEBUG 0

using OpenSim.Region.ScriptEngine.Shared.ScriptBase;
using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Reflection.Emit;
using System.Text;

/**
 * @brief GetNNEnumerable() gets the nextnode enumerable part of a GraphNode,
 *        which in turn gives the list of nodes that can possibly be next in 
 *        a flow-control sense.  It simply instantiates the NNEnumerator sub-
 *        class which does the actual enumeration.
 */
#define BOILERPLATE_GETNNENUMERABLE(qual,GNT) \
		protected qual System.Collections.Generic.IEnumerable<GraphNode> GetNNEnumerable ()						\
		{																\
			return new NNEnumerable (this);												\
		}																\
		private class NNEnumerable : System.Collections.Generic.IEnumerable<GraphNode> {						\
			private GNT gn;														\
			public NNEnumerable (GNT gn)												\
			{															\
				this.gn = gn;													\
			}															\
			System.Collections.Generic.IEnumerator<GraphNode> System.Collections.Generic.IEnumerable<GraphNode>.GetEnumerator ()	\
			{															\
				return new NNEnumerator (gn);											\
			}															\
			System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator ()						\
			{															\
				return new NNEnumerator (gn);											\
			}															\
		}

/**
 * @brief These methods are required as part of the interface for a NNEnumerator class.
 *        They assume the current nextnode is stored in a member called 'nn'.
 */
#define BOILERPLATE_NNENUMERATOR_CURRENT_DISPOSE \
			GraphNode System.Collections.Generic.IEnumerator<GraphNode>.Current {	\
				get { return this.nn; }						\
			}									\
			object System.Collections.IEnumerator.Current {				\
				get { return this.nn; }						\
			}									\
			void System.IDisposable.Dispose() { }

/**
 * @brief Wrapper class for ScriptMyILGen to do simple optimizations.
 *        The main one is to figure out which locals are active at the labels
 *        so the stack capture/restore code doesn't have to do everything.
 *        Second is it removes unnecessary back-to-back stloc/ldloc's.
 */

namespace OpenSim.Region.ScriptEngine.XMREngine
{
	/**
	 * @brief One of these per opcode and label in the function plus other misc markers.
	 *        They form the CIL instruction stream of the function.
	 */
	public abstract class GraphNode {
		public const int OPINDENT =  4;
		public const int OPDEBLEN = 12;

		public ScriptCollector coll;
		public GraphNodeBeginExceptionBlock tryBlock;  // start of enclosing try block
		                                               // valid in the try section
		                                               // null in the catch/finally sections
		                                               // null outside of try block
		                                               // for the try node itself, links to outer try block
		public GraphNodeBeginExceptionBlock excBlock;  // start of enclosing try block
		                                               // valid in the try/catch/finally sections
		                                               // null outside of try/catch/finally block
		                                               // for the try node itself, links to outer try block

		/*
		 * List of nodes in order as originally given.
		 */
		public GraphNode nextLin, prevLin;
		public int linSeqNo;

		/**
		 * @brief Save pointer to collector.
		 */
		public GraphNode (ScriptCollector coll)
		{
			this.coll = coll;
		}

		/**
		 * @brief Chain graph node to end of linear list.
		 */
		public GraphNode ChainLin ()
		{
			coll.lastLin.nextLin = this;
			this.prevLin  = coll.lastLin;
			coll.lastLin  = this;
			this.tryBlock = coll.curTryBlock;
			this.excBlock = coll.curExcBlock;
			return this;
		}

		/**
		 * @brief Append full info to debugging string for printing out the instruction.
		 */
		public void DebStringExt (StringBuilder sb)
		{
			int x = sb.Length;
			sb.Append (this.linSeqNo.ToString ().PadLeft (5));
			sb.Append (": ");
			this.DebString (sb);

			if (this.ReadsLocal  () != null) ScriptCollector.PadToLength (sb, x + 60, " [read]");
			if (this.WritesLocal () != null) ScriptCollector.PadToLength (sb, x + 68, " [write]");
			ScriptCollector.PadToLength (sb, x + 72, " ->");
			bool first = true;
			foreach (GraphNode nn in this.NextNodes) {
				if (first) {
					sb.Append (nn.linSeqNo.ToString ().PadLeft (5));
					first = false;
				} else {
					sb.Append (',');
					sb.Append (nn.linSeqNo);
				}
			}
		}

		/**
		 * @brief Append to debugging string for printing out the instruction.
		 */
		public abstract void DebString (StringBuilder sb);

		/**
		 * @brief See if this instruction reads a local variable.
		 */
		public virtual ScriptMyLocal ReadsLocal  () { return null; }

		/**
		 * @brief See if this instruction writes a local variable.
		 */
		public virtual ScriptMyLocal WritesLocal () { return null; }

		/**
		 * @brief Write this instruction out to the wrapped object file.
		 */
		public abstract void WriteOutOne (ScriptMyILGen ilGen);

		/**
		 * @brief Iterate through all the possible next nodes, including the next inline node, if any.
		 *        The next inline code is excluded if the instruction never falls through, eg, return, unconditional branch.
		 *        It includes a possible conditional branch to the beginning of the corresponding catch/finally of every 
		 *        instruction in a try section.
		 */
		private System.Collections.Generic.IEnumerable<GraphNode> nextNodes, nextNodesCatchFinally;
		public System.Collections.Generic.IEnumerable<GraphNode> NextNodes
		{ get {
			if (nextNodes == null) {
				nextNodes = GetNNEnumerable ();
				nextNodesCatchFinally = new NNEnumerableCatchFinally (this);
			}
			return nextNodesCatchFinally;
		} }

		/**
		 * @brief This acts as a wrapper around all the other NNEnumerable's below.
		 *        It assumes every instruction in a try { } can throw an exception so it 
		 *        says that every instruction in a try { } can conditionally branch to 
		 *        the beginning of the corresponding catch { } or finally { }.
		 */
		private class NNEnumerableCatchFinally : System.Collections.Generic.IEnumerable<GraphNode> {
			private GraphNode gn;
			public NNEnumerableCatchFinally (GraphNode gn)
			{
				this.gn = gn;
			}
			System.Collections.Generic.IEnumerator<GraphNode> System.Collections.Generic.IEnumerable<GraphNode>.GetEnumerator ()
			{
				return new NNEnumeratorCatchFinally (gn);
			}
			System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator ()
			{
				return new NNEnumeratorCatchFinally (gn);
			}
		}
		private class NNEnumeratorCatchFinally : System.Collections.Generic.IEnumerator<GraphNode> {
			private GraphNode gn, nn;
			private int index = 0;
			private System.Collections.Generic.IEnumerator<GraphNode> realEnumerator;
			public NNEnumeratorCatchFinally (GraphNode gn)
			{
				this.gn = gn;
				this.realEnumerator = gn.nextNodes.GetEnumerator ();
			}
			public bool MoveNext ()
			{
				/*
				 * First off, return any targets the instruction can come up with.
				 */
				if (realEnumerator.MoveNext ()) {
					nn = realEnumerator.Current;
					return true;
				}

				/*
				 * Then if this instruction is in a try section, say this instruction 
				 * can potentially branch to the beginning of the corresponding 
				 * catch/finally.
				 */
				if ((index == 0) && (gn.tryBlock != null)) {
					index ++;
					nn = gn.tryBlock.catchFinallyBlock;
					return true;
				}

				/*
				 * That's all we can do.
				 */
				nn = null;
				return false;
			}
			public void Reset ()
			{
				realEnumerator.Reset ();
				index = 0;
				nn = null;
			}
			BOILERPLATE_NNENUMERATOR_CURRENT_DISPOSE
		}

		/**
		 * @brief This default iterator always returns the next inline node as the one-and-only next node.
		 *        Other instructions need to override it if they can possibly do other than that.
		 */
		BOILERPLATE_GETNNENUMERABLE(virtual,GraphNode)
		private class NNEnumerator : System.Collections.Generic.IEnumerator<GraphNode> {
			private GraphNode gn;
			private GraphNode nn;
			private int index;
			public NNEnumerator (GraphNode gn)
			{
				this.gn = gn;
			}
			public bool MoveNext ()
			{
				switch (index) {
					case 0: {
						index ++;
						nn = gn.nextLin;
						return nn != null;
					}
					case 1: {
						nn = null;
						return false;
					}
				}
				throw new Exception ();
			}
			public void Reset ()
			{
				index = 0;
				nn = null;
			}
			BOILERPLATE_NNENUMERATOR_CURRENT_DISPOSE
		}
	}

	/**
	 * @brief Things that derive from this are the beginning of a block.
	 *        A block of code is that which begins with a label or is the beginning of all code
	 *        and it contains no labels, ie, it can't be jumped into other than at its beginning.
	 */
	public abstract class GraphNodeBlock : GraphNode {
		public List<ScriptMyLocal> localsWrittenBeforeRead = new List<ScriptMyLocal> ();
		public List<ScriptMyLocal> localsReadBeforeWritten = new List<ScriptMyLocal> ();
		public int hasBeenResolved;
		public GraphNodeBlock (ScriptCollector coll) : base (coll) { }
	}

	/**
	 * @brief This placeholder is at the beginning of the code so the first few instructions 
	 *        belong to some block.
	 */
	public class GraphNodeBegin : GraphNodeBlock {
		public GraphNodeBegin (ScriptCollector coll) : base (coll) { }
		public override void DebString (StringBuilder sb) { sb.Append ("begin"); }
		public override void WriteOutOne (ScriptMyILGen ilGen) { }
	}

	/**
	 * @brief Beginning of try block.
	 */
	public class GraphNodeBeginExceptionBlock : GraphNodeBlock {
		public GraphNodeBeginExceptionBlock outerTryBlock;      // next outer try opcode or null
		public GraphNodeCatchFinallyBlock   catchFinallyBlock;  // start of associated catch or finally
		public GraphNodeEndExceptionBlock   endExcBlock;        // end of associated catch or finally
		public int excBlkSeqNo;                                 // debugging

		public GraphNodeBeginExceptionBlock (ScriptCollector coll) : base (coll)
		{ }

		public override void DebString (StringBuilder sb)
		{
			sb.Append ("  beginexceptionblock_");
			sb.Append (excBlkSeqNo);
		}

		public override void WriteOutOne (ScriptMyILGen ilGen)
		{
			ilGen.BeginExceptionBlock ();
		}
	}

	/**
	 * @brief Beginning of catch or finally block.
	 */
	public abstract class GraphNodeCatchFinallyBlock : GraphNodeBlock {
		public GraphNodeCatchFinallyBlock (ScriptCollector coll) : base (coll)
		{ }
	}

	/**
	 * @brief Beginning of catch block.
	 */
	public class GraphNodeBeginCatchBlock : GraphNodeCatchFinallyBlock {
		public Type excType;

		public GraphNodeBeginCatchBlock (ScriptCollector coll, Type excType) : base (coll)
		{
			this.excType = excType;
		}

		public override void DebString (StringBuilder sb)
		{
			sb.Append ("  begincatchblock_");
			sb.Append (excBlock.excBlkSeqNo);
		}

		public override void WriteOutOne (ScriptMyILGen ilGen)
		{
			ilGen.BeginCatchBlock (excType);
		}

		/**
		 * @brief The beginning of every catch { } conditinally branches to the beginning 
		 *        of all outer catch { }s up to and including the next outer finally { }.
		 */
		BOILERPLATE_GETNNENUMERABLE(override,GraphNodeBeginCatchBlock)
		private class NNEnumerator : System.Collections.Generic.IEnumerator<GraphNode> {
			private GraphNodeBeginCatchBlock gn;
			private GraphNode nn;
			private int index;
			public NNEnumerator (GraphNodeBeginCatchBlock gn)
			{
				this.gn = gn;
			}
			public bool MoveNext ()
			{
				while (true) {
					switch (index) {
						case 0: {
							// start with the fallthru
							nn = gn.nextLin;
							index ++;
							return true;
						}

						case 1: {
							// get the first outer catch { } or finally { }
							// pretend we last returned beginning of this catch { }
							// then loop back to get next outer catch { } or finally { }
							nn = gn;
							break;
						}

						case 2: {
							// nn points to a catch { } previously returned
							// get the corresponding try { }
							GraphNodeBeginExceptionBlock nntry = nn.excBlock;

							// step out to next outer try { }
							nntry = nntry.excBlock;
							if (nntry == null) break;

							// return corresponding catch { } or finally { }
							nn = nntry.catchFinallyBlock;

							// if it's a finally { } we don't do anything after that
							if (nn is GraphNodeBeginFinallyBlock) index ++;
							return true;
						}

						case 3: {
							// we've returned the fallthru, catches and one finally
							// so there's nothing more to say
							nn = null;
							return false;
						}

						default: throw new Exception ();
					}
					index ++;
				}
			}
			public void Reset ()
			{
				index = 0;
				nn = null;
			}
			BOILERPLATE_NNENUMERATOR_CURRENT_DISPOSE
		}
	}

	/**
	 * @brief Beginning of finally block.
	 */
	public class GraphNodeBeginFinallyBlock : GraphNodeCatchFinallyBlock {

		// leaveTargets has a list of all the targets of any contained 
		// leave instructions, ie, where an endfinally can possibly jump.
		// But only those targets within the next outer finally { }, we 
		// don't contain any targets outside of that, those targets are 
		// stored in the actual finally that will jump to the target.
		// The endfinally enumerator assumes that it is always possible 
		// for it to jump to the next outer finally (as would happen for
		// an uncaught exception), so no need to do anything special.
		public List<GraphNodeBlock> leaveTargets = new List<GraphNodeBlock> ();

		public GraphNodeBeginFinallyBlock (ScriptCollector coll) : base (coll)
		{ }

		public override void DebString (StringBuilder sb)
		{
			sb.Append ("  beginfinallyblock_");
			sb.Append (excBlock.excBlkSeqNo);
		}

		public override void WriteOutOne (ScriptMyILGen ilGen)
		{
			ilGen.BeginFinallyBlock ();
		}
	}

	/**
	 * @brief End of try/catch/finally block.
	 */
	public class GraphNodeEndExceptionBlock : GraphNode {
		public GraphNodeEndExceptionBlock (ScriptCollector coll) : base (coll)
		{ }

		public override void DebString (StringBuilder sb)
		{
			sb.Append ("  endexceptionblock_");
			sb.Append (excBlock.excBlkSeqNo);
		}

		public override void WriteOutOne (ScriptMyILGen ilGen)
		{
			ilGen.EndExceptionBlock ();
		}
	}

	/**
	 * @brief Actual instruction emits...
	 */
	public abstract class GraphNodeEmit : GraphNode {
		public OpCode opcode;

		public GraphNodeEmit (ScriptCollector coll, OpCode opcode) : base (coll)
		{
			this.opcode = opcode;
		}

		// if followed by OpCodes.Pop, it can be discarded
		public bool isPoppable
		{ get {
			return
			    ((opcode.StackBehaviourPop  == StackBehaviour.Pop0) &&    // ldarg,ldloc,ldsfld
			     (opcode.StackBehaviourPush == StackBehaviour.Push1)) || 
			    ((opcode.StackBehaviourPop  == StackBehaviour.Pop0) &&    // ldarga,ldloca,ldc,ldsflda,...
			     (opcode.StackBehaviourPush == StackBehaviour.Pushi)) || 
			    (opcode == OpCodes.Ldnull) || 
			    (opcode == OpCodes.Ldc_R4) || 
			    (opcode == OpCodes.Ldc_R8) || 
			    (opcode == OpCodes.Ldstr)  || 
			    (opcode == OpCodes.Ldc_I8) || 
			    (opcode == OpCodes.Dup);
		} }

		public override void DebString (StringBuilder sb)
		{
			sb.Append ("".PadRight (OPINDENT));
			sb.Append (opcode.ToString ().PadRight (OPDEBLEN));
		}

		private bool CanFallThrough ()
		{
			switch (opcode.FlowControl) {
				case FlowControl.Branch:      return false;  // unconditional branch
				case FlowControl.Break:       return false;  // break
				case FlowControl.Call:        return true;   // call
				case FlowControl.Cond_Branch: return true;   // conditional branch
				case FlowControl.Next:        return true;   // falls through to next instruction
				case FlowControl.Return:      return false;  // return
				case FlowControl.Throw:       return false;  // throw
				default: throw new Exception ("unknown flow control " + opcode.FlowControl);
			}
		}

		/**
		 * @brief If instruction is terminating, we say there is nothing following (eg, return).
		 *        Otherwise, say the one-and-only next instruction is the next instruction inline.
		 */
		BOILERPLATE_GETNNENUMERABLE(override,GraphNodeEmit)
		private class NNEnumerator : System.Collections.Generic.IEnumerator<GraphNode> {
			private GraphNodeEmit gn;
			private GraphNode nn;
			private int index;
			public NNEnumerator (GraphNodeEmit gn)
			{
				this.gn = gn;
			}
			public bool MoveNext ()
			{
				switch (index) {
					case 0: {
						if (gn.CanFallThrough ()) {
							index ++;
							nn = gn.nextLin;
							return nn != null;
						}
						return false;
					}
					case 1: {
						nn = null;
						return false;
					}
				}
				throw new Exception ();
			}
			public void Reset ()
			{
				index = 0;
				nn = null;
			}
			BOILERPLATE_NNENUMERATOR_CURRENT_DISPOSE
		}
	}

	public class GraphNodeEmitNull : GraphNodeEmit {
		public GraphNodeEmitNull (ScriptCollector coll, OpCode opcode) : base (coll, opcode)
		{ }

		public override void WriteOutOne (ScriptMyILGen ilGen)
		{
			ilGen.Emit (opcode);
		}
	}

	public class GraphNodeEmitNullEndfinally : GraphNodeEmitNull {
		public GraphNodeEmitNullEndfinally (ScriptCollector coll) : base (coll, OpCodes.Endfinally)
		{ }

		/**
		 * @brief Endfinally can branch to:
		 *          1) the corresponding EndExceptionBlock
		 *          2) any of the corresponding BeginFinallyBlock's leaveTargets
		 *          3) the next outer BeginFinallyBlock
		 */
		BOILERPLATE_GETNNENUMERABLE(override,GraphNodeEmitNullEndfinally)
		private class NNEnumerator : System.Collections.Generic.IEnumerator<GraphNode> {
			private GraphNodeEmitNullEndfinally gn;
			private GraphNode nn;
			private IEnumerator<GraphNodeBlock> leaveTargetEnumerator;
			private int index;
			public NNEnumerator (GraphNodeEmitNullEndfinally gn)
			{
				this.gn = gn;

				// endfinally instruction must be within some try/catch/finally mess
				GraphNodeBeginExceptionBlock thistry = gn.excBlock;

				// endfinally instruction must be within some finally { } mess
				GraphNodeBeginFinallyBlock thisfin = (GraphNodeBeginFinallyBlock)thistry.catchFinallyBlock;

				// get the list of the finally { } leave instruction targets
				this.leaveTargetEnumerator = thisfin.leaveTargets.GetEnumerator ();
			}
			public bool MoveNext ()
			{
				while (true) {
					switch (index) {

						// to start, return end of our finally { }
						case 0: {
							GraphNodeBeginExceptionBlock thistry = gn.excBlock;
							nn = thistry.endExcBlock;
							index ++;
							return true;
						}

						// return next one of our finally { }'s leave targets
						// ie, where any leave instructions in the try { } want 
						// the finally { } to go to when it finishes
						case 1: {
							if (this.leaveTargetEnumerator.MoveNext ()) {
								nn = this.leaveTargetEnumerator.Current;
								return true;
							}
							break;
						}

						// return beginning of next outer finally { }
						case 2: {
							GraphNodeBeginExceptionBlock nntry = gn.excBlock;
							while ((nntry = nntry.excBlock) != null) {
								if (nntry.catchFinallyBlock is GraphNodeBeginFinallyBlock) {
									nn = nntry.catchFinallyBlock;
									index ++;
									return true;
								}
							}
							break;
						}

						// got nothing more
						case 3: {
							return false;
						}

						default: throw new Exception ();
					}
					index ++;
				}
			}
			public void Reset ()
			{
				leaveTargetEnumerator.Reset ();
				index = 0;
				nn = null;
			}
			BOILERPLATE_NNENUMERATOR_CURRENT_DISPOSE
		}
	}

	public class GraphNodeEmitField : GraphNodeEmit {
		public FieldInfo field;

		public GraphNodeEmitField (ScriptCollector coll, OpCode opcode, FieldInfo field) : base (coll, opcode)
		{
			this.field = field;
		}

		public override void DebString (StringBuilder sb)
		{
			base.DebString (sb);
			sb.Append (field.Name);
		}

		public override void WriteOutOne (ScriptMyILGen ilGen)
		{
			ilGen.Emit (opcode, field);
		}
	}

	public class GraphNodeEmitLocal : GraphNodeEmit {
		public ScriptMyLocal myLocal;

		public GraphNodeEmitLocal (ScriptCollector coll, OpCode opcode, ScriptMyLocal myLocal) : base (coll, opcode)
		{
			this.myLocal = myLocal;
		}

		public override void DebString (StringBuilder sb)
		{
			base.DebString (sb);
			sb.Append (myLocal.name);
		}

		public override ScriptMyLocal ReadsLocal  ()
		{
			if (opcode == OpCodes.Ldloc)  return myLocal;
			if (opcode == OpCodes.Ldloca) return myLocal;
			if (opcode == OpCodes.Stloc)  return null;
			throw new Exception ("unknown opcode " + opcode);
		}
		public override ScriptMyLocal WritesLocal ()
		{
			if (opcode == OpCodes.Ldloc)  return null;
			if (opcode == OpCodes.Ldloca) return myLocal;
			if (opcode == OpCodes.Stloc)  return myLocal;
			throw new Exception ("unknown opcode " + opcode);
		}

		public override void WriteOutOne (ScriptMyILGen ilGen)
		{
			ilGen.Emit (opcode, myLocal);
		}
	}

	public class GraphNodeEmitType : GraphNodeEmit {
		public Type type;

		public GraphNodeEmitType (ScriptCollector coll, OpCode opcode, Type type) : base (coll, opcode)
		{
			this.type = type;
		}

		public override void DebString (StringBuilder sb)
		{
			base.DebString (sb);
			sb.Append (type.Name);
		}

		public override void WriteOutOne (ScriptMyILGen ilGen)
		{
			ilGen.Emit (opcode, type);
		}
	}

	public class GraphNodeEmitLabel : GraphNodeEmit {
		public ScriptMyLabel myLabel;

		public GraphNodeEmitLabel (ScriptCollector coll, OpCode opcode, ScriptMyLabel myLabel) : base (coll, opcode)
		{
			this.myLabel = myLabel;
		}

		public override void DebString (StringBuilder sb)
		{
			base.DebString (sb);
			sb.Append (myLabel.name);
		}

		public override void WriteOutOne (ScriptMyILGen ilGen)
		{
			ilGen.Emit (opcode, myLabel);
		}

		/**
		 * @brief Conditional branches return the next inline followed by the branch target
		 *        Unconditional branches return only the branch target
		 *        But if the target is outside our scope (eg __retlbl), omit it from the list
		 */
		BOILERPLATE_GETNNENUMERABLE(override,GraphNodeEmitLabel)
		private class NNEnumerator : System.Collections.Generic.IEnumerator<GraphNode> {
			private GraphNodeEmitLabel gn;
			private GraphNode nn;
			private int index;
			public NNEnumerator (GraphNodeEmitLabel gn)
			{
				this.gn = gn;
			}
			public bool MoveNext ()
			{
				switch (gn.opcode.FlowControl) {
					case FlowControl.Branch: {
						// unconditional branch just goes to target and nothing else
						switch (index) {
							case 0: {
								nn = gn.myLabel.whereAmI;
								index ++;
								return nn != null;
							}
							case 1: {
								return false;
							}
						}
						throw new Exception ();
					}
					case FlowControl.Cond_Branch: {
						// conditional branch goes inline and to target
						switch (index) {
							case 0: {
								nn = gn.nextLin;
								index ++;
								return true;
							}
							case 1: {
								nn = gn.myLabel.whereAmI;
								index ++;
								return nn != null;
							}
							case 2: {
								return false;
							}
						}
						throw new Exception ();
					}
					default: throw new Exception ("unknown flow control " + gn.opcode.FlowControl.ToString () + 
					                              " of " + gn.opcode.ToString ());
				}
			}
			public void Reset ()
			{
				index = 0;
				nn = null;
			}
			BOILERPLATE_NNENUMERATOR_CURRENT_DISPOSE
		}
	}

	public class GraphNodeEmitLabelLeave : GraphNodeEmitLabel {
		public GraphNodeBlock unwindTo;  // if unwinding, innermost finally block being unwound
		                                 //         else, same as myTarget.whereAmI
		                                 // null if unwinding completely out of scope, eg, __retlbl

		public GraphNodeEmitLabelLeave (ScriptCollector coll, ScriptMyLabel myLabel) : base (coll, OpCodes.Leave, myLabel)
		{ }

		/**
		 * @brief Leave instructions have exactly one unconditional next node.
		 *        Either the given target if within the same try block 
		 *        or the beginning of the intervening finally block.
		 */
		BOILERPLATE_GETNNENUMERABLE(override,GraphNodeEmitLabelLeave)
		private class NNEnumerator : System.Collections.Generic.IEnumerator<GraphNode> {
			private GraphNodeEmitLabelLeave gn;
			private GraphNode nn;
			private int index;
			public NNEnumerator (GraphNodeEmitLabelLeave gn)
			{
				this.gn = gn;
			}
			public bool MoveNext ()
			{
				if (index == 0) {
					nn = gn.unwindTo;
					index ++;
					return nn != null;
				}
				nn = null;
				return false;
			}
			public void Reset ()
			{
				index = 0;
				nn = null;
			}
			BOILERPLATE_NNENUMERATOR_CURRENT_DISPOSE
		}
	}

	public class GraphNodeEmitLabels : GraphNodeEmit {
		public ScriptMyLabel[] myLabels;

		public GraphNodeEmitLabels (ScriptCollector coll, OpCode opcode, ScriptMyLabel[] myLabels) : base (coll, opcode)
		{
			this.myLabels = myLabels;
		}

		public override void DebString (StringBuilder sb)
		{
			base.DebString (sb);
			bool first = true;
			foreach (ScriptMyLabel lbl in myLabels) {
				if (!first) sb.Append (',');
				sb.Append (lbl.name);
				first = false;
			}
		}

		public override void WriteOutOne (ScriptMyILGen ilGen)
		{
			ilGen.Emit (opcode, myLabels);
		}

		/**
		 * @brief Return list of all labels followed by the next linear instruction
		 *        But if the target is outside our scope (eg __retlbl), omit it from the list
		 */
		BOILERPLATE_GETNNENUMERABLE(override,GraphNodeEmitLabels)
		private class NNEnumerator : System.Collections.Generic.IEnumerator<GraphNode> {
			private GraphNodeEmitLabels gn;
			private GraphNode nn;
			private int index;
			public NNEnumerator (GraphNodeEmitLabels gn)
			{
				this.gn = gn;
			}
			public bool MoveNext ()
			{
				/*
				 * Return next from list of switch case labels.
				 */
				while (index < gn.myLabels.Length) {
					nn = gn.myLabels[index++].whereAmI;
					if (nn != null) return true;
				}

				/*
				 * If all ran out, the switch instruction falls through.
				 */
				if (index == gn.myLabels.Length) {
					index ++;
					nn = gn.nextLin;
					return true;
				}

				/*
				 * Even ran out of that, say there's nothing more.
				 */
				nn = null;
				return false;
			}
			public void Reset ()
			{
				index = 0;
				nn = null;
			}
			BOILERPLATE_NNENUMERATOR_CURRENT_DISPOSE
		}
	}

	public class GraphNodeEmitIntMeth : GraphNodeEmit {
		public ScriptMyILGen method;

		public GraphNodeEmitIntMeth (ScriptCollector coll, OpCode opcode, ScriptMyILGen method) : base (coll, opcode)
		{
			this.method = method;
		}

		public override void DebString (StringBuilder sb)
		{
			base.DebString (sb);
			sb.Append (method.methName);
		}

		public override void WriteOutOne (ScriptMyILGen ilGen)
		{
			ilGen.Emit (opcode, method);
		}
	}

	public class GraphNodeEmitExtMeth : GraphNodeEmit {
		public MethodInfo method;

		public GraphNodeEmitExtMeth (ScriptCollector coll, OpCode opcode, MethodInfo method) : base (coll, opcode)
		{
			this.method = method;
		}

		public override void DebString (StringBuilder sb)
		{
			base.DebString (sb);
			sb.Append (method.Name);
		}

		public override void WriteOutOne (ScriptMyILGen ilGen)
		{
			ilGen.Emit (opcode, method);
		}
	}

	public class GraphNodeEmitCtor : GraphNodeEmit {
		public ConstructorInfo ctor;

		public GraphNodeEmitCtor (ScriptCollector coll, OpCode opcode, ConstructorInfo ctor) : base (coll, opcode)
		{
			this.ctor = ctor;
		}

		public override void DebString (StringBuilder sb)
		{
			base.DebString (sb);
			sb.Append (ctor.ReflectedType.Name);
		}

		public override void WriteOutOne (ScriptMyILGen ilGen)
		{
			ilGen.Emit (opcode, ctor);
		}
	}

	public class GraphNodeEmitDouble : GraphNodeEmit {
		public double value;

		public GraphNodeEmitDouble (ScriptCollector coll, OpCode opcode, double value) : base (coll, opcode)
		{
			this.value = value;
		}

		public override void DebString (StringBuilder sb)
		{
			base.DebString (sb);
			sb.Append (value);
		}

		public override void WriteOutOne (ScriptMyILGen ilGen)
		{
			ilGen.Emit (opcode, value);
		}
	}

	public class GraphNodeEmitFloat : GraphNodeEmit {
		public float value;

		public GraphNodeEmitFloat (ScriptCollector coll, OpCode opcode, float value) : base (coll, opcode)
		{
			this.value = value;
		}

		public override void DebString (StringBuilder sb)
		{
			base.DebString (sb);
			sb.Append (value);
		}

		public override void WriteOutOne (ScriptMyILGen ilGen)
		{
			ilGen.Emit (opcode, value);
		}
	}

	public class GraphNodeEmitInt : GraphNodeEmit {
		public int value;

		public GraphNodeEmitInt (ScriptCollector coll, OpCode opcode, int value) : base (coll, opcode)
		{
			this.value = value;
		}

		public override void DebString (StringBuilder sb)
		{
			base.DebString (sb);
			sb.Append (value);
		}

		public override void WriteOutOne (ScriptMyILGen ilGen)
		{
			ilGen.Emit (opcode, value);
		}
	}

	public class GraphNodeEmitString : GraphNodeEmit {
		public string value;

		public GraphNodeEmitString (ScriptCollector coll, OpCode opcode, string value) : base (coll, opcode)
		{
			this.value = value;
		}

		public override void DebString (StringBuilder sb)
		{
			base.DebString (sb);
			sb.Append ("\"");
			sb.Append (value);
			sb.Append ("\"");
		}

		public override void WriteOutOne (ScriptMyILGen ilGen)
		{
			ilGen.Emit (opcode, value);
		}
	}

	public class GraphNodeMarkLabel : GraphNodeBlock {
		public ScriptMyLabel myLabel;

		public GraphNodeMarkLabel (ScriptCollector coll, ScriptMyLabel myLabel) : base (coll)
		{
			this.myLabel = myLabel;
		}

		public override void DebString (StringBuilder sb)
		{
			sb.Append (myLabel.name);
			sb.Append (":");
		}

		public override void WriteOutOne (ScriptMyILGen ilGen)
		{
			ilGen.MarkLabel (myLabel);
		}
	}


	public class ScriptCollector : ScriptMyILGen {

		private ScriptObjWriter wrapped;
		public GraphNode firstLin, lastLin;
		private bool resolvedSomething;
		private int resolveSequence;
		private int excBlkSeqNos;
		public GraphNodeBeginExceptionBlock curTryBlock = null;  // pushed at beginning of try
		                                                         // popped at BEGINNING of catch/finally
		public GraphNodeBeginExceptionBlock curExcBlock = null;  // pushed at beginning of try
		                                                         // popped at END of catch/finally

		private List<ScriptMyLocal> declaredLocals = new List<ScriptMyLocal> ();
		private List<ScriptMyLabel> definedLabels  = new List<ScriptMyLabel> ();

		public override string methName { get { return wrapped.methName; } }

		/**
		 * @brief Wrap the optimizer around the ScriptObjWriter to collect the instruction stream.
		 *        All stream-writing calls get saved to our graph nodes instead of being written to object file.
		 */
		public ScriptCollector (ScriptObjWriter wrapped)
		{
			this.wrapped       = wrapped;
			GraphNodeBegin gnb = new GraphNodeBegin (this);
			this.firstLin      = gnb;
			this.lastLin       = gnb;
		}

		public override ScriptMyLocal DeclareLocal (Type type, string name)
		{
			ScriptMyLocal loc = new ScriptMyLocal ();
			loc.name   = name;
			loc.type   = type;
			loc.number = wrapped.localNumber ++;
			declaredLocals.Add (loc);
			return loc;
		}

		public override ScriptMyLabel DefineLabel (string name)
		{
			ScriptMyLabel lbl = new ScriptMyLabel ();
			lbl.name   = name;
			lbl.number = wrapped.labelNumber ++;
			definedLabels.Add (lbl);
			return lbl;
		}

		public override void BeginExceptionBlock ()
		{
			GraphNodeBeginExceptionBlock tryBlock = new GraphNodeBeginExceptionBlock (this);
			tryBlock.ChainLin ();
			tryBlock.excBlkSeqNo = ++ this.excBlkSeqNos;
			this.curExcBlock = tryBlock;
			this.curTryBlock = tryBlock;
		}

		public override void BeginCatchBlock (Type excType)
		{
			GraphNodeBeginCatchBlock catchBlock = new GraphNodeBeginCatchBlock (this, excType);
			catchBlock.ChainLin ();
			if (curExcBlock.catchFinallyBlock != null) throw new Exception ("only one catch/finally allowed per try");
			curExcBlock.catchFinallyBlock = catchBlock;
			curTryBlock = curExcBlock.tryBlock;
		}

		public override void BeginFinallyBlock ()
		{
			GraphNodeBeginFinallyBlock finallyBlock = new GraphNodeBeginFinallyBlock (this);
			finallyBlock.ChainLin ();
			if (curExcBlock.catchFinallyBlock != null) throw new Exception ("only one catch/finally allowed per try");
			curExcBlock.catchFinallyBlock = finallyBlock;
			curTryBlock = curExcBlock.tryBlock;
		}

		public override void EndExceptionBlock ()
		{
			GraphNodeEndExceptionBlock endExcBlock = new GraphNodeEndExceptionBlock (this);
			endExcBlock.ChainLin ();
			curExcBlock.endExcBlock = endExcBlock;
			curTryBlock = curExcBlock.tryBlock;
			curExcBlock = curExcBlock.excBlock;
		}

		public override void Emit (OpCode opcode)
		{
			if (opcode == OpCodes.Endfinally) {
				new GraphNodeEmitNullEndfinally (this).ChainLin ();
			} else {
				new GraphNodeEmitNull (this, opcode).ChainLin ();
			}
		}

		public override void Emit (OpCode opcode, FieldInfo field)
		{
			new GraphNodeEmitField (this, opcode, field).ChainLin ();
		}

		public override void Emit (OpCode opcode, ScriptMyLocal myLocal)
		{
			new GraphNodeEmitLocal (this, opcode, myLocal).ChainLin ();
		}

		public override void Emit (OpCode opcode, Type type)
		{
			new GraphNodeEmitType (this, opcode, type).ChainLin ();
		}

		public override void Emit (OpCode opcode, ScriptMyLabel myLabel)
		{
			if (opcode == OpCodes.Leave) {
				new GraphNodeEmitLabelLeave (this, myLabel).ChainLin ();
			} else {
				new GraphNodeEmitLabel (this, opcode, myLabel).ChainLin ();
			}
		}

		public override void Emit (OpCode opcode, ScriptMyLabel[] myLabels)
		{
			new GraphNodeEmitLabels (this, opcode, myLabels).ChainLin ();
		}

		public override void Emit (OpCode opcode, ScriptMyILGen method)
		{
			new GraphNodeEmitIntMeth (this, opcode, method).ChainLin ();
		}

		public override void Emit (OpCode opcode, MethodInfo method)
		{
			new GraphNodeEmitExtMeth (this, opcode, method).ChainLin ();
		}

		public override void Emit (OpCode opcode, ConstructorInfo ctor)
		{
			new GraphNodeEmitCtor (this, opcode, ctor).ChainLin ();
		}

		public override void Emit (OpCode opcode, double value)
		{
			new GraphNodeEmitDouble (this, opcode, value).ChainLin ();
		}

		public override void Emit (OpCode opcode, float value)
		{
			new GraphNodeEmitFloat (this, opcode, value).ChainLin ();
		}

		public override void Emit (OpCode opcode, int value)
		{
			new GraphNodeEmitInt (this, opcode, value).ChainLin ();
		}

		public override void Emit (OpCode opcode, string value)
		{
			new GraphNodeEmitString (this, opcode, value).ChainLin ();
		}

		public override void MarkLabel (ScriptMyLabel myLabel)
		{
			myLabel.whereAmI = new GraphNodeMarkLabel (this, myLabel);
			myLabel.whereAmI.ChainLin ();
		}

		/**
		 * @brief Write the whole graph out to the object file.
		 */
		public ScriptMyILGen WriteOutAll ()
		{
			foreach (ScriptMyLocal loc in declaredLocals) {
				if (loc.isReferenced) wrapped.DeclareLocal (loc);
			}
			foreach (ScriptMyLabel lbl in definedLabels) {
				wrapped.DefineLabel (lbl);
			}
			for (GraphNode gn = firstLin; gn != null; gn = gn.nextLin) {
				gn.WriteOutOne (wrapped);
			}
			return wrapped;
		}

		/**
		 * @brief Perform optimizations.
		 */
		public void Optimize ()
		{
			if (curExcBlock != null) throw new Exception ("exception block still open");

			/*
			 * If an instruction says it doesn't fall through, remove all instructions to
			 * the end of the block.
			 */
			for (GraphNode gn = firstLin; gn != null; gn = gn.nextLin) {
				bool fallsthru = false;
				foreach (GraphNode nn in gn.NextNodes) {
					if (nn == gn.nextLin) {
						fallsthru = true;
						break;
					}
				}
				if (!fallsthru) {
					GraphNode nn;
					while (((nn = gn.nextLin) != null) && !(nn is GraphNodeBlock) && 
					                          !(nn is GraphNodeEndExceptionBlock)) {
						if ((gn.nextLin = nn.nextLin) != null) {
							nn.nextLin.prevLin = gn;
						}
					}
				}
			}

			/*
			 * Scan for OpCodes.Leave instructions.
			 * For each found, its target for flow analysis purposes is the beginning of the corresponding
			 * finally block.  And the end of the finally block gets a conditional branch target of the 
			 * leave instruction's target.  A leave instruction can unwind zero or more finally blocks.
			 */
			for (GraphNode gn = firstLin; gn != null; gn = gn.nextLin) {
				if (gn is GraphNodeEmitLabelLeave) {
					GraphNodeEmitLabelLeave leaveInstr = (GraphNodeEmitLabelLeave)gn;         // the leave instruction
					GraphNodeMarkLabel leaveTarget = leaveInstr.myLabel.whereAmI;             // label being targeted by leave
					GraphNodeBeginExceptionBlock leaveTargetsTryBlock =                       // try block directly enclosing leave target
						(leaveTarget == null) ? null : leaveTarget.tryBlock;              // ...it must not be unwound

					/*
					 * Step through try { }s from the leave instruction towards its target looking for try { }s with finally { }s.
					 * The leave instruction unconditionally branches to the beginning of the innermost one found.
					 * The end of the last one found conditionally branches to the leave instruction's target.
					 * If none found, the leave is a simple unconditional branch to its target.
					 */
					GraphNodeBeginFinallyBlock innerFinallyBlock = null;
					for (GraphNodeBeginExceptionBlock tryBlock = leaveInstr.tryBlock;
					     tryBlock != leaveTargetsTryBlock;
					     tryBlock  = tryBlock.tryBlock) {
						if (tryBlock == null) throw new Exception ("leave target not at or outer to leave instruction");
						GraphNodeCatchFinallyBlock cfb = tryBlock.catchFinallyBlock;
						if (cfb is GraphNodeBeginFinallyBlock) {
							if (innerFinallyBlock == null) {
								leaveInstr.unwindTo = cfb;
							}
							innerFinallyBlock = (GraphNodeBeginFinallyBlock)cfb;
						}
					}

					/*
					 * The end of the outermost finally being unwound can conditionally jump to the target of the leave instruction.
					 * In the case of no finallies being unwound, the leave is just a simple unconditional branch.
					 */
					if (innerFinallyBlock == null) {
						leaveInstr.unwindTo = leaveTarget;
					} else if (!innerFinallyBlock.leaveTargets.Contains (leaveTarget)) {
						innerFinallyBlock.leaveTargets.Add (leaveTarget);
					}
				}
			}

			/*
			 * See which variables a particular block reads before writing.
			 * This just considers the block itself and nothing that it branches to or fallsthru to.
			 */
			GraphNodeBlock currentBlock = null;
			for (GraphNode gn = firstLin; gn != null; gn = gn.nextLin) {
				if (gn is GraphNodeBlock) currentBlock = (GraphNodeBlock)gn;
				ScriptMyLocal rdlcl = gn.ReadsLocal ();
				if ((rdlcl != null) &&
				    !currentBlock.localsWrittenBeforeRead.Contains (rdlcl) && 
				    !currentBlock.localsReadBeforeWritten.Contains (rdlcl)) {
					currentBlock.localsReadBeforeWritten.Add (rdlcl);
				}
				ScriptMyLocal wrlcl = gn.WritesLocal ();
				if ((wrlcl != null) &&
				    !currentBlock.localsWrittenBeforeRead.Contains (wrlcl) && 
				    !currentBlock.localsReadBeforeWritten.Contains (wrlcl)) {
					currentBlock.localsWrittenBeforeRead.Add (wrlcl);
				}
			}

			/*
			 * For every block we branch to, add that blocks readables to our list of readables,
			 * because we need to have those values valid on entry to our block.  But if we write the 
			 * variable before we can possibly branch to that block, then we don't need to have it valid 
			 * on entry to our block.  So basically it looks like the branch instruction is reading 
			 * everything required by any blocks it can branch to.
			 */
			do {
				this.resolvedSomething = false;
				this.resolveSequence ++;
				this.ResolveBlock ((GraphNodeBlock)firstLin);
			} while (this.resolvedSomething);

			/*
			 * Repeat the cutting loops as long as we keep finding stuff.
			 */
			bool didSomething;
			do {
				didSomething = false;

				/*
				 * Strip out ldc.i4.1/xor/ldc.i4.1/xor
				 */
				for (GraphNode gn = firstLin; gn != null; gn = gn.nextLin) {
					if (!(gn is GraphNodeEmit)) continue;
					GraphNodeEmit xor2 = (GraphNodeEmit)gn;
					if (xor2.opcode != OpCodes.Xor) continue;
					if (!(xor2.prevLin is GraphNodeEmit)) continue;
					GraphNodeEmit ld12 = (GraphNodeEmit)xor2.prevLin;
					if (ld12.opcode != OpCodes.Ldc_I4_1) continue;
					if (!(ld12.prevLin is GraphNodeEmit)) continue;
					GraphNodeEmit xor1 = (GraphNodeEmit)ld12.prevLin;
					if (xor1.opcode != OpCodes.Xor) continue;
					if (!(xor2.prevLin is GraphNodeEmit)) continue;
					GraphNodeEmit ld11 = (GraphNodeEmit)xor1.prevLin;
					if (ld11.opcode != OpCodes.Ldc_I4_1) continue;
					ld11.prevLin.nextLin = xor2.nextLin;
					xor2.nextLin.prevLin = ld11.prevLin;
					didSomething = true;
				}

				/*
				 * Replace c{cond}/ldc.i4.1/xor/br{false,true} -> c{cond}/br{true,false}
				 */
				for (GraphNode gn = firstLin; gn != null; gn = gn.nextLin) {
					if (!(gn is GraphNodeEmit)) continue;
					GraphNodeEmit brft = (GraphNodeEmit)gn;
					if ((brft.opcode != OpCodes.Brfalse) && (brft.opcode != OpCodes.Brtrue)) continue;
					if (!(brft.prevLin is GraphNodeEmit)) continue;
					GraphNodeEmit xor = (GraphNodeEmit)brft.prevLin;
					if (xor.opcode != OpCodes.Xor) continue;
					if (!(xor.prevLin is GraphNodeEmit)) continue;
					GraphNodeEmit ldc = (GraphNodeEmit)xor.prevLin;
					if (ldc.opcode != OpCodes.Ldc_I4_1) continue;
					if (!(ldc.prevLin is GraphNodeEmit)) continue;
					GraphNodeEmit cmp = (GraphNodeEmit)ldc.prevLin;
					if (cmp.opcode.StackBehaviourPop  != StackBehaviour.Pop1_pop1) continue;
					if (cmp.opcode.StackBehaviourPush != StackBehaviour.Pushi) continue;
					cmp.nextLin  = brft;
					brft.prevLin = cmp;
					brft.opcode  = (brft.opcode == OpCodes.Brfalse) ? OpCodes.Brtrue : OpCodes.Brfalse;
					didSomething = true;
				}

				/*
				 * Replace c{cond}/br{false,true} -> b{!,}{cond}
				 */
				for (GraphNode gn = firstLin; gn != null; gn = gn.nextLin) {
					if (!(gn is GraphNodeEmit)) continue;
					GraphNodeEmit brft = (GraphNodeEmit)gn;
					if ((brft.opcode != OpCodes.Brfalse) && (brft.opcode != OpCodes.Brtrue)) continue;
					if (!(brft.prevLin is GraphNodeEmit)) continue;
					GraphNodeEmit cmp = (GraphNodeEmit)brft.prevLin;
					if (cmp.opcode.StackBehaviourPop  != StackBehaviour.Pop1_pop1) continue;
					if (cmp.opcode.StackBehaviourPush != StackBehaviour.Pushi) continue;
					cmp.prevLin.nextLin = brft;
					brft.prevLin = cmp.prevLin;
					bool brtru = (brft.opcode == OpCodes.Brtrue);
					     if (cmp.opcode == OpCodes.Ceq)    brft.opcode = brtru ? OpCodes.Beq    : OpCodes.Bne_Un;
					else if (cmp.opcode == OpCodes.Cgt)    brft.opcode = brtru ? OpCodes.Bgt    : OpCodes.Ble;
					else if (cmp.opcode == OpCodes.Cgt_Un) brft.opcode = brtru ? OpCodes.Bgt_Un : OpCodes.Ble_Un;
					else if (cmp.opcode == OpCodes.Clt)    brft.opcode = brtru ? OpCodes.Blt    : OpCodes.Bge;
					else if (cmp.opcode == OpCodes.Clt_Un) brft.opcode = brtru ? OpCodes.Blt_Un : OpCodes.Bge_Un;
					else throw new Exception ();
					didSomething = true;
				}

				/*
				 * Replace ld{c.i4.0,null}/br{ne.un,eq} -> br{true,false}
				 */
				for (GraphNode gn = firstLin; gn != null; gn = gn.nextLin) {
					if (!(gn is GraphNodeEmit)) continue;
					GraphNodeEmit brcc = (GraphNodeEmit)gn;
					if ((brcc.opcode != OpCodes.Bne_Un) && (brcc.opcode != OpCodes.Beq)) continue;
					if (!(brcc.prevLin is GraphNodeEmit)) continue;
					GraphNodeEmit ldc0 = (GraphNodeEmit)brcc.prevLin;
					if ((ldc0.opcode != OpCodes.Ldc_I4_0) && (ldc0.opcode != OpCodes.Ldnull)) continue;
					ldc0.prevLin.nextLin = brcc;
					brcc.prevLin = ldc0.prevLin;
					brcc.opcode  = (brcc.opcode == OpCodes.Bne_Un) ? OpCodes.Brtrue : OpCodes.Brfalse;
					didSomething = true;
				}

				/*
				 * Remove all the stloc/ldloc that are back-to-back without the local
				 * being needed afterwards.  If it is needed afterwards, replace the 
				 * stloc/ldloc with dup/stloc.
				 */
				for (GraphNode gn = firstLin; gn != null; gn = gn.nextLin) {
					if ((gn is GraphNodeEmitLocal) && 
					    (gn.prevLin is GraphNodeEmitLocal)) {
						GraphNodeEmitLocal stloc = (GraphNodeEmitLocal)gn.prevLin;
						GraphNodeEmitLocal ldloc = (GraphNodeEmitLocal)gn;
						if ((stloc.opcode  == OpCodes.Stloc) && 
						    (ldloc.opcode  == OpCodes.Ldloc) && 
						    (stloc.myLocal == ldloc.myLocal)) {
							if (IsLocalNeededAfterThis (ldloc, ldloc.myLocal)) {
								GraphNodeEmitNull dup = new GraphNodeEmitNull (this, OpCodes.Dup);
								dup.nextLin   = stloc;
								dup.prevLin   = stloc.prevLin;
								stloc.nextLin = ldloc.nextLin;
								stloc.prevLin = dup;
								dup.prevLin.nextLin   = dup;
								stloc.nextLin.prevLin = stloc;
								gn = stloc;
							} else {
								stloc.prevLin.nextLin = ldloc.nextLin;
								ldloc.nextLin.prevLin = stloc.prevLin;
								gn = stloc.prevLin;
							}
							didSomething = true;
						}
					}
				}

				/*
				 * Remove all write-only local variables, ie, those with no ldloc[a] references.
				 * Replace any stloc instructions with pops.
				 */
				for (GraphNode gn = firstLin; gn != null; gn = gn.nextLin) {
					ScriptMyLocal rdlcl = gn.ReadsLocal ();
					if (rdlcl != null) rdlcl.isReferenced = true;
				}
				for (GraphNode gn = firstLin; gn != null; gn = gn.nextLin) {
					ScriptMyLocal wrlcl = gn.WritesLocal ();
					if ((wrlcl != null) && !wrlcl.isReferenced) {
						if (!(gn is GraphNodeEmitLocal) || (((GraphNodeEmitLocal)gn).opcode != OpCodes.Stloc)) {
							throw new Exception ("expecting stloc");
						}
						GraphNodeEmitNull pop = new GraphNodeEmitNull (this, OpCodes.Pop);
						pop.nextLin = gn.nextLin;
						pop.prevLin = gn.prevLin;
						gn.nextLin.prevLin = pop;
						gn.prevLin.nextLin = pop;
						gn = pop;
						didSomething = true;
					}
				}

				/*
				 * Remove any Ld<const>/Dup,Pop.
				 */
				for (GraphNode gn = firstLin; gn != null; gn = gn.nextLin) {
					if ((gn is GraphNodeEmit) && 
					    (gn.nextLin is GraphNodeEmit)) {
						GraphNodeEmit gne = (GraphNodeEmit)gn;
						GraphNodeEmit nne = (GraphNodeEmit)gn.nextLin;
						if (gne.isPoppable && (nne.opcode == OpCodes.Pop)) {
							gne.prevLin.nextLin = nne.nextLin;
							nne.nextLin.prevLin = gne.prevLin;
							gn = gne.prevLin;
							didSomething = true;
						}
					}
				}
			} while (didSomething);

			/*
			 * Dump out the results.
			 */
#if DEBUG
			Console.WriteLine ("");
			Console.WriteLine (methName);
			Console.WriteLine ("  resolveSequence=" + this.resolveSequence);

			Console.WriteLine ("  Locals:");
			foreach (ScriptMyLocal loc in declaredLocals) {
				Console.WriteLine ("    " + loc.type.Name + "  " + loc.name);
			}

			Console.WriteLine ("  Labels:");
			foreach (ScriptMyLabel lbl in definedLabels) {
				Console.WriteLine ("    " + lbl.name);
			}

			Console.WriteLine ("  Code:");
			DumpCode ();
#endif
		}

		private void DumpCode ()
		{
			int linSeqNos = 0;
			for (GraphNode gn = firstLin; gn != null; gn = gn.nextLin) {
				gn.linSeqNo = ++ linSeqNos;
			}
			for (GraphNode gn = firstLin; gn != null; gn = gn.nextLin) {
				StringBuilder sb = new StringBuilder ();
				gn.DebStringExt (sb);
				Console.WriteLine (sb.ToString ());
				if (gn is GraphNodeBlock) {
					GraphNodeBlock gnb = (GraphNodeBlock)gn;
					foreach (ScriptMyLocal lcl in gnb.localsReadBeforeWritten) {
						Console.WriteLine ("         reads " + lcl.name);
					}
				}
			}
		}

		/**
		 * @brief Scan the given block for branches to other blocks.
		 *        For any locals read by those blocks, mark them as being read by this block, 
		 *        provided this block has not written them by that point.  This makes it look 
		 *        as though the branch instruction is reading all the locals needed by any 
		 *        target blocks.
		 */
		private void ResolveBlock (GraphNodeBlock currentBlock)
		{
			if (currentBlock.hasBeenResolved == this.resolveSequence) return;

			/*
			 * So we don't recurse forever on a backward branch.
			 */
			currentBlock.hasBeenResolved = this.resolveSequence;

			/*
			 * Assume we haven't written any locals yet.
			 */
			List<ScriptMyLocal> localsWrittenSoFar = new List<ScriptMyLocal> ();

			/*
			 * Scan through the instructions in this block.
			 */
			for (GraphNode gn = currentBlock; gn != null;) {

				/*
				 * See if the instruction writes a local we don't know about yet.
				 */
				ScriptMyLocal wrlcl = gn.WritesLocal ();
				if ((wrlcl != null) && !localsWrittenSoFar.Contains (wrlcl)) {
					localsWrittenSoFar.Add (wrlcl);
				}

				/*
				 * Scan through all the possible next instructions after this.
				 * Note that if we are in the first part of a try/catch/finally block, 
				 * every instruction conditionally branches to the beginning of the 
				 * second part (the catch/finally block).
				 */
				GraphNode nextFallthruNode = null;
				foreach (GraphNode nn in gn.NextNodes) {
					if (nn is GraphNodeBlock) {

						/*
						 * Start of a block, go through all locals needed by that block on entry.
						 */
						GraphNodeBlock nextBlock = (GraphNodeBlock)nn;
						ResolveBlock (nextBlock);
						foreach (ScriptMyLocal readByNextBlock in nextBlock.localsReadBeforeWritten) {

							/*
							 * If this block hasn't written it by now and this block doesn't already
							 * require it on entry, say this block requires it on entry.
							 */
							if (!localsWrittenSoFar.Contains (readByNextBlock) && 
							    !currentBlock.localsReadBeforeWritten.Contains (readByNextBlock)) {
								currentBlock.localsReadBeforeWritten.Add (readByNextBlock);
								this.resolvedSomething = true;
							}
						}
					} else {

						/*
						 * Not start of a block, should be normal fallthru instruction.
						 */
						if (nextFallthruNode != null) throw new Exception ("more than one fallthru");
						nextFallthruNode = nn;
					}
				}

				/*
				 * Process next instruction if it isn't the start of a block.
				 */
				if (nextFallthruNode == gn) throw new Exception ("can't fallthru to self");
				gn = nextFallthruNode;
			}
		}

		/**
		 * @brief Figure out whether the value in a local var is needed after the given instruction.
		 *        True if we reach the end of the program on all branches before reading it
		 *        True if we write the local var on all branches before reading it
		 *        False otherwise
		 */
		private bool IsLocalNeededAfterThis (GraphNode node, ScriptMyLocal local)
		{
			do {
				GraphNode nextFallthruNode = null;
				foreach (GraphNode nn in node.NextNodes) {
					if (nn is GraphNodeBlock) {
						if (((GraphNodeBlock)nn).localsReadBeforeWritten.Contains (local)) {
							return true;
						}
					} else {
						nextFallthruNode = nn;
					}
				}
				node = nextFallthruNode;
				if (node == null) return false;
				if (node.ReadsLocal () == local) return true;
			} while (node.WritesLocal () != local);
			return false;
		}

		public static void PadToLength (StringBuilder sb, int len, string str)
		{
			int pad = len - sb.Length;
			if (pad < 0) pad = 0;
			sb.Append (str.PadLeft (pad));
		}
	}
}
