/***************************************************\
 *  COPYRIGHT 2009, Mike Rieker, Beverly, MA, USA  *
 *  All rights reserved.                           *
\***************************************************/

using OpenSim.Region.ScriptEngine.Shared.ScriptBase;
using OpenSim.Region.ScriptEngine.XMREngine;
using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Reflection.Emit;

#include "lsltypes.h"

/**
 * @brief Compute values used during code generation to keep track of where computed values are stored.
 *
 *        Conceptually holds the memory address and type of the value
 *        such as that used for a local variable, global variable, temporary variable.
 *        Also used for things like constants and function/method entrypoints,
 *        they are basically treated as read-only variables.
 *
 *            cv.type - type of the value
 *
 *            cv.PushVal() - pushes the value on the CIL stack
 *            cv.PushRef() - pushes address of the value on the CIL stack
 *
 *            cv.PopPre()  - gets ready to pop from the CIL stack
 *                           ...by possibly pushing something
 *                <push value to be popped>
 *            cv.PushPre() - pops value from the CIL stack
 *
 *        If the type is a TokenTypeSDTypeDelegate, the location is callable, 
 *        so you get these additional functions:
 *
 *            cv.GetRetType()  - gets function/method's return value type
 *                               TokenTypeVoid if void
 *                               null if not a delegate
 *            cv.GetArgTypes() - gets array of argument types
 *                               as seen by script level, ie, 
 *                               does not include any hidden 'this' type
 *            cv.GetArgSig()   - gets argument signature eg, "(integer,list)"
 *                               null if not a delegate
 *
 *            cv.CallPre()     - gets ready to call the function/method
 *                               ...by possibly pushing something
 *                                  such as a 'this' pointer
 *                <push call args left-to-right>
 *            cv.CallPost()    - calls the function/method
 */

namespace OpenSim.Region.ScriptEngine.XMREngine
{

	/**
	 * @brief Location of a value
	 *        Includes constants, expressions and temp variables.
	 */
	public abstract class CompValu {
		protected static readonly MethodInfo gsmdMethodInfo = 
				typeof (XMRInstAbstract).GetMethod ("GetScriptMethodDelegate", 
				                                    new Type[] { typeof (string), typeof (string), typeof (object) });

		public TokenType type;        // type of the value and where in the source it was used
		public bool isFinal;          // true iff value cannot be changed by any side effects
		                              // - ie, PushVal() is idempotent (no calls, autoincrements, assignment, etc)
		                              // - temps do not change because we allocate a new one each time
		                              // - constants never change because they are constant
		                              // - expressions consisting of all isFinal operands are final

		public CompValu (TokenType type)
		{
			this.type    = type;
			this.isFinal = true;
		}

		public CompValu (TokenType type, bool isFinal)
		{
			this.type    = type;
			this.isFinal = isFinal;
		}

		public Type ToSysType()
		{
			return (type.ToLSLWrapType () != null) ? type.ToLSLWrapType () : type.ToSysType ();
		}

		// emit code to push value onto stack
		public void PushVal (ScriptCodeGen scg, TokenType stackType)
		{
			this.PushVal (scg, stackType, false);
		}
		public void PushVal (ScriptCodeGen scg, TokenType stackType, bool explicitAllowed)
		{
			this.PushVal (scg);
			TypeCast.CastTopOfStack (scg, this.type, stackType, explicitAllowed);
		}
		public abstract void PushVal (ScriptCodeGen scg);
		public abstract void PushRef (ScriptCodeGen scg);

		// emit code to pop value from stack
		public void PopPost (ScriptCodeGen scg, TokenType stackType)
		{
			TypeCast.CastTopOfStack (scg, stackType, this.type, false);
			this.PopPost (scg);
		}
		public virtual void PopPre (ScriptCodeGen scg) { }  // call this before pushing value to be popped
		public abstract void PopPost (ScriptCodeGen scg);   // call this after pushing value to be popped

		/*
		 * These additional functions are available if the type is a delegate
		 */
		public TokenType GetRetType ()
		{
			if (!(type is TokenTypeSDTypeDelegate)) return null;
			return ((TokenTypeSDTypeDelegate)type).decl.GetRetType ();
		}
		public TokenType[] GetArgTypes ()
		{
			if (!(type is TokenTypeSDTypeDelegate)) return null;
			return ((TokenTypeSDTypeDelegate)type).decl.GetArgTypes ();
		}
		public string GetArgSig ()
		{
			if (!(type is TokenTypeSDTypeDelegate)) return null;
			return ((TokenTypeSDTypeDelegate)type).decl.GetArgSig ();
		}

		// These are used only if type is a delegate too
		// - but it is a real delegate pointer in a global or local variable
		//   ie, so PushVal() pushes a delegate pointer
		// - so we must have CallPre() push the delegate pointer as a 'this' for this.Invoke(...)
		// - and CallPost() call the delegate's Invoke() method
		public virtual void CallPre (ScriptCodeGen scg)   // call this before pushing arguments
		{
			this.PushVal (scg);
		}
		public virtual void CallPost (ScriptCodeGen scg)  // call this after pushing arguments
		{
			TokenTypeSDTypeDelegate ttd = (TokenTypeSDTypeDelegate)type;
			MethodInfo invokeMethodInfo = ttd.decl.GetInvokerInfo ();
			scg.ilGen.Emit (OpCodes.Callvirt, invokeMethodInfo);
		}

		/*
		 * Utilities used by CompValuGlobalVar and CompValuInstField
		 * where the value is located in a type-dependent array.
		 */
		protected void EmitFieldPushVal (ScriptCodeGen scg, TokenDeclVar var)
		{
			scg.ilGen.Emit (OpCodes.Ldfld, var.vTableArray);  // which array
			scg.PushConstantI4 (var.vTableIndex);             // which array element
			if (type is TokenTypeFloat) {
#define double Ldelem_R8
#define float  Ldelem_R4
				scg.ilGen.Emit (OpCodes.SCRIPTFLOAT);
#undef double
#undef float
			} else if (type is TokenTypeInt) {
				scg.ilGen.Emit (OpCodes.Ldelem_I4);
			} else if (type is TokenTypeSDTypeDelegate) {
				scg.ilGen.Emit (OpCodes.Ldelem, typeof (object));
				scg.ilGen.Emit (OpCodes.Castclass, ToSysType ());
			} else {
				scg.ilGen.Emit (OpCodes.Ldelem, ToSysType ());
			}
		}

		protected void EmitFieldPushRef (ScriptCodeGen scg, TokenDeclVar var)
		{
			scg.ilGen.Emit (OpCodes.Ldfld, var.vTableArray);
			scg.PushConstantI4 (var.vTableIndex);
			scg.ilGen.Emit (OpCodes.Ldelema, ToSysType());
		}

		protected void EmitFieldPopPre (ScriptCodeGen scg, TokenDeclVar var)
		{
			scg.ilGen.Emit (OpCodes.Ldfld, var.vTableArray);
			scg.PushConstantI4 (var.vTableIndex);
		}

		protected void EmitFieldPopPost (ScriptCodeGen scg, TokenDeclVar var)
		{
			if (type is TokenTypeFloat) {
#define double Stelem_R8
#define float  Stelem_R4
				scg.ilGen.Emit (OpCodes.SCRIPTFLOAT);
#undef double
#undef float
			} else if (type is TokenTypeInt) {
				scg.ilGen.Emit (OpCodes.Stelem_I4);
			} else if (type is TokenTypeSDTypeDelegate) {
				scg.ilGen.Emit (OpCodes.Stelem, typeof (object));
			} else {
				scg.ilGen.Emit (OpCodes.Stelem, ToSysType ());
			}
		}
	}

	// The value is kept in an (XMR_Array) array element
	public class CompValuArEle : CompValu {
		public  CompValu arr;
		private CompValu idx;
		private TokenTypeObject tto;

		private static readonly MethodInfo getByKeyMethodInfo = typeof (XMR_Array).GetMethod ("GetByKey", 
		                                                                                      new Type[] { typeof (object) });
		private static readonly MethodInfo setByKeyMethodInfo = typeof (XMR_Array).GetMethod ("SetByKey", 
		                                                                                      new Type[] { typeof (object),
		                                                                                                   typeof (object), 
		                                                                                                   typeof (int), 
		                                                                                                   typeof (int) });

		// type = TokenTypeObject always, as our array elements are always of type 'object'
		// arr  = where the array object itself is stored
		// idx  = where the index value is stored
		public CompValuArEle (TokenType type, CompValu arr, CompValu idx) : base (type)
		{
			this.arr = arr;
			this.idx = idx;
			this.tto = new TokenTypeObject (this.type);
		}
		public override void PushVal (ScriptCodeGen scg)
		{
			arr.PushVal (scg);            // array
			idx.PushVal (scg, this.tto);  // key
			scg.ilGen.Emit (OpCodes.Call, getByKeyMethodInfo);
		}
		public override void PushRef (ScriptCodeGen scg)
		{
			scg.ErrorMsg (this.type, "array element not allowed here");
			scg.ilGen.Emit (OpCodes.Ldnull);
		}
		public override void PopPre (ScriptCodeGen scg)
		{
			arr.PushVal (scg);            // array
			idx.PushVal (scg, this.tto);  // key
		}
		public override void PopPost (ScriptCodeGen scg)
		{
			scg.PushConstantI4 (type.line);
			scg.PushConstantI4 (type.posn);
			scg.ilGen.Emit (OpCodes.Call, setByKeyMethodInfo);
		}
	}

	// The value is kept in the current function's argument list
	public class CompValuArg : CompValu {
		public int index;
		public bool readOnly;

		private static OpCode[] ldargs = { OpCodes.Ldarg_0, OpCodes.Ldarg_1, 
		                                   OpCodes.Ldarg_2, OpCodes.Ldarg_3 };

		public CompValuArg (TokenType type, int index) : base (type)
		{
			this.index = index;
		}
		public CompValuArg (TokenType type, int index, bool ro) : base (type)
		{
			this.index = index;
			this.readOnly = ro;
		}
		public override void PushVal (ScriptCodeGen scg)
		{
			     if (index < ldargs.Length) scg.ilGen.Emit (ldargs[index]);
			else if (index <= 255) scg.ilGen.Emit (OpCodes.Ldarg_S, index);
			                    else scg.ilGen.Emit (OpCodes.Ldarg, index);
		}
		public override void PushRef (ScriptCodeGen scg)
		{
			if (readOnly) {
				scg.ErrorMsg (type, "location cannot be written to");
			}
			if (index <= 255) scg.ilGen.Emit (OpCodes.Ldarga_S, index);
			               else scg.ilGen.Emit (OpCodes.Ldarga, index);
		}
		public override void PopPost (ScriptCodeGen scg)
		{
			if (readOnly) {
				scg.ErrorMsg (type, "location cannot be written to");
			}
			scg.ilGen.Emit (OpCodes.Starg, index);
		}
	}

	// The value is kept in a struct/class field
	public class CompValuField : CompValu {
		CompValu obj;
		FieldInfo field;

		public CompValuField (TokenType type, CompValu obj, FieldInfo field) : base (type)
		{
			this.obj   = obj;
			this.field = field;
		}
		public override void PushVal (ScriptCodeGen scg)
		{
			if (field.ReflectedType.IsValueType) {
				obj.PushRef (scg);
			} else {
				obj.PushVal (scg);
			}
			scg.ilGen.Emit (OpCodes.Ldfld, field);
		}
		public override void PushRef (ScriptCodeGen scg)
		{
			if (field.ReflectedType.IsValueType) {
				obj.PushRef (scg);
			} else {
				obj.PushVal (scg);
			}
			scg.ilGen.Emit (OpCodes.Ldflda, field);
		}
		public override void PopPre (ScriptCodeGen scg)
		{
			if (field.ReflectedType.IsValueType) {
				obj.PushRef (scg);
			} else {
				obj.PushVal (scg);
			}
		}
		public override void PopPost (ScriptCodeGen scg)
		{
			scg.ilGen.Emit (OpCodes.Stfld, field);
		}
	}

	// The value is a float constant
	public class CompValuFloat : CompValu {
		public SCRIPTFLOAT x;

		public CompValuFloat (TokenType type, SCRIPTFLOAT x) : base (type)
		{
			if (!(this.type is TokenTypeFloat)) {
				this.type = new TokenTypeFloat (this.type);
			}
			this.x = x;
		}
		public override void PushVal (ScriptCodeGen scg)
		{
#define double Ldc_R8
#define float  Ldc_R4
			scg.ilGen.Emit (OpCodes.SCRIPTFLOAT, x);
#undef double
#undef float
		}
		public override void PushRef (ScriptCodeGen scg)
		{
			throw new Exception ("cannot get constant's address");
		}
		public override void PopPost (ScriptCodeGen scg)
		{
			throw new Exception ("cannot store into constant");
		}
	}

	// The value is the entrypoint of a script-defined global function.
	// These are also used for script-defined type static methods as the calling convention is the same,
	// ie, the XMRInstance pointer is a hidden first argument.
	// There is just one of these created when the function is being compiled as there is only one value
	// of the function.
	public class CompValuGlobalMeth : CompValu {
		private TokenDeclVar func;

		public CompValuGlobalMeth (TokenDeclVar declFunc) : base (declFunc.GetDelType ())
		{
			this.func = declFunc;
		}

		/**
		 * @brief PushVal for a function/method means push a delegate on the stack.
		 *        We build a call to the DynamicMethod's CreateDelegate() function 
		 *        to create the delegate.  Slip the scriptinstance pointer as the 
		 *        function's arg 0 so it will get passed to the function when called.
		 */
		public override void PushVal (ScriptCodeGen scg)
		{
			string dtn = type.ToString ();
			if (dtn.StartsWith ("delegate ")) dtn = dtn.Substring (9);

			// delegateinstance = (signature)scriptinstance.GetScriptMethodDelegate (methName, signature, arg0);
			//   where methName = __fun_[<sdtclass>.]<methname>(<argtypes>)
			//        signature = <rettype>(<argtypes>)
			//             arg0 = scriptinstance (XMRInstance)
			scg.PushXMRInst ();                                     // [0] scriptinstance
			scg.ilGen.Emit (OpCodes.Ldstr, func.ilGen.methName);    // [1] method name
			scg.ilGen.Emit (OpCodes.Ldstr, dtn);                    // [2] delegate type name
			scg.PushXMRInst ();                                     // [3] scriptinstance
			scg.ilGen.Emit (OpCodes.Callvirt, gsmdMethodInfo);      // [0] delegate instance
			scg.ilGen.Emit (OpCodes.Castclass, type.ToSysType ());  // [0] cast to correct delegate class
		}
		public override void PushRef (ScriptCodeGen scg)
		{
			throw new Exception ("cannot get ref to global method");
		}
		public override void PopPost (ScriptCodeGen scg)
		{
			throw new Exception ("cannot store into global method");
		}

		/**
		 * @brief A direct call is much simpler than pushing a delegate.
		 *        Just push the XMRInstance pointer, push the args and finally call the function.
		 */
		public override void CallPre (ScriptCodeGen scg)
		{
			// all script-defined global functions are static methods created by DynamicMethod()
			// and the first argument is always the XMR_Instance pointer
			scg.PushXMRInst ();
		}
		public override void CallPost (ScriptCodeGen scg)
		{
			scg.ilGen.Emit (OpCodes.Call, func.ilGen);
		}
	}

	// The value is in a script-global variable = ScriptModule instance variable
	public class CompValuGlobalVar : CompValu {
		private TokenDeclVar declVar;

		public CompValuGlobalVar (TokenDeclVar declVar, ScriptObjCode scriptObjCode) : base (declVar.type)
		{
			this.declVar = declVar;
			declVar.type.AssignGlobalVarSlot (declVar, scriptObjCode);
		}
		public override void PushVal (ScriptCodeGen scg)
		{
			scg.PushXMRInst ();
			EmitFieldPushVal (scg, declVar);
		}
		public override void PushRef (ScriptCodeGen scg)
		{
			scg.PushXMRInst ();
			EmitFieldPushRef (scg, declVar);
		}
		public override void PopPre (ScriptCodeGen scg)
		{
			scg.PushXMRInst ();
			EmitFieldPopPre (scg, declVar);
		}
		public override void PopPost (ScriptCodeGen scg)
		{
			EmitFieldPopPost (scg, declVar);
		}
	}

	// This represents the type and location of an internally-defined function
	// that a script can call
	public class CompValuInline : CompValu {
		public TokenDeclInline declInline;

		public CompValuInline (TokenDeclInline declInline) : base (declInline.GetDelType ())
		{
			this.declInline = declInline;
		}

		public override void PushVal (ScriptCodeGen scg)
		{
			scg.ErrorMsg (declInline, "cannot use built-in for delegate, wrap it");
			scg.ilGen.Emit (OpCodes.Ldnull);
		}
		public override void PushRef (ScriptCodeGen scg)
		{
			scg.ErrorMsg (declInline, "cannot use built-in for delegate, wrap it");
			scg.ilGen.Emit (OpCodes.Ldnull);
		}
		public override void PopPre (ScriptCodeGen scg)
		{
			scg.ErrorMsg (declInline, "cannot use built-in for delegate, wrap it");
		}
		public override void PopPost (ScriptCodeGen scg)
		{
			scg.ErrorMsg (declInline, "cannot use built-in for delegate, wrap it");
			scg.ilGen.Emit (OpCodes.Pop);
		}
	}

	// The value is the entrypoint of a script-defined type's instance method combined with
	// the pointer used to access the method.  Thus there is one of these per call site.
	public class CompValuInstMeth : CompValu {
		private TokenDeclVar func;
		private CompValu baseRVal;
		private bool ignVirt;

		private static FieldInfo vTableFieldInfo = typeof (XMRSDTypeClassInstance).GetField ("sdtcVTable");

		public CompValuInstMeth (TokenDeclVar declFunc, CompValu baseRVal, bool ignVirt) : base (declFunc.GetDelType ())
		{
			this.func     = declFunc;
			this.baseRVal = baseRVal;
			this.ignVirt  = ignVirt;
		}

		public override void PushVal (ScriptCodeGen scg)
		{
			if ((func.sdtFlags & ScriptReduce.SDT_STATIC) != 0) throw new Exception ("dont use for statics");

			if (ignVirt || (func.vTableIndex < 0)) {

				/*
				 * Non-virtual instance method, create a delegate that references the method.
				 */
				string dtn = type.ToString ();
				if (dtn.StartsWith ("delegate ")) dtn = dtn.Substring (9);

				// delegateinstance = (signature)scriptinstance.GetScriptMethodDelegate (methName, signature, arg0);
				//   where methName = __fun_<sdtclass>.<methname>(<argtypes>)
				//        signature = <rettype>(<argtypes>)
				//             arg0 = sdt istance (XMRSDTypeClassInstance) 'this' value
				scg.PushXMRInst ();                                     // [0] scriptinstance
				scg.ilGen.Emit (OpCodes.Ldstr, func.ilGen.methName);    // [1] method name
				scg.ilGen.Emit (OpCodes.Ldstr, dtn);                    // [2] delegate type name
				baseRVal.PushVal (scg);                                 // [3] sdtinstance
				scg.ilGen.Emit (OpCodes.Callvirt, gsmdMethodInfo);      // [0] delegate instance
				scg.ilGen.Emit (OpCodes.Castclass, type.ToSysType ());  // [0] cast to correct delegate class
			} else {

				/*
				 * Virtual instance method, get the delegate from the vtable.
				 */
				baseRVal.PushVal (scg);                                 // 'this' selecting the instance
				scg.ilGen.Emit (OpCodes.Ldfld, vTableFieldInfo);        // get pointer to instance's vtable array
				scg.PushConstantI4 (func.vTableIndex);                  // select vtable element
				scg.ilGen.Emit (OpCodes.Ldelem, typeof (Delegate));     // get delegate pointer = 'this' for 'Invoke()'
				scg.ilGen.Emit (OpCodes.Castclass, type.ToSysType ());  // cast to correct delegate class
			}
		}
		public override void PushRef (ScriptCodeGen scg)
		{
			throw new Exception ("cannot get ref to instance method");
		}
		public override void PopPost (ScriptCodeGen scg)
		{
			throw new Exception ("cannot store into instance method");
		}

		public override void CallPre (ScriptCodeGen scg)
		{
			if ((func.sdtFlags & ScriptReduce.SDT_STATIC) != 0) throw new Exception ("dont use for statics");

			if (ignVirt || (func.vTableIndex < 0)) {
				baseRVal.PushVal (scg);                                 // 'this' being passed directly to method
			} else {
				baseRVal.PushVal (scg);                                 // 'this' selecting the instance
				scg.ilGen.Emit (OpCodes.Ldfld, vTableFieldInfo);        // get pointer to instance's vtable array
				scg.PushConstantI4 (func.vTableIndex);                  // select vtable element
				scg.ilGen.Emit (OpCodes.Ldelem, typeof (Delegate));     // get delegate pointer = 'this' for 'Invoke()'
				scg.ilGen.Emit (OpCodes.Castclass, type.ToSysType ());  // cast to correct delegate class
			}
		}
		public override void CallPost (ScriptCodeGen scg)
		{
			if (ignVirt || (func.vTableIndex < 0)) {
				// non-virt instance, just call function directly
				scg.ilGen.Emit (OpCodes.Call, func.ilGen);
			} else {
				// virtual, call via delegate Invoke(...) method
				TokenTypeSDTypeDelegate ttd = (TokenTypeSDTypeDelegate)type;
				MethodInfo invokeMethodInfo = ttd.decl.GetInvokerInfo ();
				scg.ilGen.Emit (OpCodes.Callvirt, invokeMethodInfo);
			}
		}
	}

	// The value is the entrypoint of a script-defined type's interface method combined with
	// the pointer used to access the method.  Thus there is one of these per call site.
	public class CompValuIntfMeth : CompValu {
		private TokenDeclVar func;
		private CompValu baseRVal;

		public CompValuIntfMeth (TokenDeclVar declFunc, CompValu baseRVal) : base (declFunc.GetDelType ())
		{
			this.func     = declFunc;  // which element of the baseRVal vector to be accessed
			this.baseRVal = baseRVal;  // the vector of delegates implementing the interface
		}

		public override void PushVal (ScriptCodeGen scg)
		{
			baseRVal.PushVal (scg);                                 // push pointer to delegate array on stack
			scg.PushConstantI4 (func.vTableIndex);                  // select which delegate to access
			scg.ilGen.Emit (OpCodes.Ldelem, typeof (Delegate));     // push delegate on stack
			scg.ilGen.Emit (OpCodes.Castclass, type.ToSysType ());  // cast to correct delegate class
		}
		public override void PushRef (ScriptCodeGen scg)
		{
			throw new Exception ("cannot get ref to interface method");
		}
		public override void PopPost (ScriptCodeGen scg)
		{
			throw new Exception ("cannot store into interface method");
		}

		public override void CallPre (ScriptCodeGen scg)
		{
			// push interface method's delegate on stack
			this.PushVal (scg);
		}
		public override void CallPost (ScriptCodeGen scg)
		{
			// call via delegate Invoke(...) method
			TokenTypeSDTypeDelegate ttd = (TokenTypeSDTypeDelegate)type;
			MethodInfo invokeMethodInfo = ttd.decl.GetInvokerInfo ();
			scg.ilGen.Emit (OpCodes.Callvirt, invokeMethodInfo);
		}
	}

	// The value is the entrypoint of an internal instance method
	// such as XMR_Array.index()
	public class CompValuIntInstMeth : CompValu {
		private CompValu baseRVal;
		private MethodInfo mi;

		public CompValuIntInstMeth (TokenTypeSDTypeDelegate type, CompValu baseRVal, MethodInfo mi) : base (type)
		{
			this.baseRVal = baseRVal;
			this.mi = mi;
		}

		public override void PushVal (ScriptCodeGen scg)
		{
			baseRVal.PushVal (scg);
			scg.ilGen.Emit (OpCodes.Ldftn, mi);
			scg.ilGen.Emit (OpCodes.Newobj, ((TokenTypeSDTypeDelegate)type).decl.GetConstructorInfo ());
		}
		public override void PushRef (ScriptCodeGen scg)
		{
			throw new Exception ("cannot get ref to instance method");
		}
		public override void PopPost (ScriptCodeGen scg)
		{
			throw new Exception ("cannot store into instance method");
		}

		public override void CallPre (ScriptCodeGen scg)
		{
			baseRVal.PushVal (scg);
		}
		public override void CallPost (ScriptCodeGen scg)
		{
			scg.ilGen.Emit (OpCodes.Call, mi);
		}
	}

	// The value is fetched by calling an internal instance method
	// such as XMR_Array.count
	public class CompValuIntInstROProp : CompValu {
		private CompValu baseRVal;
		private MethodInfo mi;

		public CompValuIntInstROProp (TokenType type, CompValu baseRVal, MethodInfo mi) : base (type)
		{
			this.baseRVal = baseRVal;
			this.mi = mi;
		}

		public override void PushVal (ScriptCodeGen scg)
		{
			baseRVal.PushVal (scg);
			scg.ilGen.Emit (OpCodes.Call, mi);
		}
		public override void PushRef (ScriptCodeGen scg)
		{
			scg.ErrorMsg (type, "cannot get ref to read-only property");
			scg.ilGen.Emit (OpCodes.Ldnull);
		}
		public override void PopPost (ScriptCodeGen scg)
		{
			scg.ErrorMsg (type, "cannot store into read-only property");
			scg.ilGen.Emit (OpCodes.Pop);
		}
	}

	// The value is in a script-defined type class instance, ie, 
	// one of the arrays contained within XMRSDTypeClassInstance
	public class CompValuInstField : CompValu {
		private TokenDeclVar declVar;
		private CompValu baseRVal;

		public CompValuInstField (TokenDeclVar declVar, CompValu baseRVal) : base (declVar.type)
		{
			this.declVar  = declVar;
			this.baseRVal = baseRVal;
		}

		public override void PushVal (ScriptCodeGen scg)
		{
			baseRVal.PushVal (scg);
			EmitFieldPushVal (scg, declVar);
		}
		public override void PushRef (ScriptCodeGen scg)
		{
			baseRVal.PushVal (scg);
			EmitFieldPushRef (scg, declVar);
		}
		public override void PopPre (ScriptCodeGen scg)
		{
			baseRVal.PushVal (scg);
			EmitFieldPopPre (scg, declVar);
		}
		public override void PopPost (ScriptCodeGen scg)
		{
			EmitFieldPopPost (scg, declVar);
		}
	}

	// The value is an integer constant
	public class CompValuInteger : CompValu {
		public int x;

		public CompValuInteger (TokenType type, int x) : base (type)
		{
			if (!(this.type is TokenTypeInt)) {
				this.type = new TokenTypeInt (this.type);
			}
			this.x = x;
		}
		public override void PushVal (ScriptCodeGen scg)
		{
			scg.PushConstantI4 (x);
		}
		public override void PushRef (ScriptCodeGen scg)
		{
			throw new Exception ("cannot get constant's address");
		}
		public override void PopPost (ScriptCodeGen scg)
		{
			throw new Exception ("cannot store into contant");
		}
	}

	// The value is a null
	public class CompValuNull : CompValu {
		public CompValuNull (TokenType type) : base (type) { }
		public override void PushVal (ScriptCodeGen scg)
		{
			scg.ilGen.Emit (OpCodes.Ldnull);
		}
		public override void PushRef (ScriptCodeGen scg)
		{
			throw new Exception ("cannot get null's address");
		}
		public override void PopPost (ScriptCodeGen scg)
		{
			throw new Exception ("cannot store into null");
		}
	}

	// The value is a rotation
	public class CompValuRot : CompValu {
		public CompValu x;
		public CompValu y;
		public CompValu z;
		public CompValu w;

		private static readonly ConstructorInfo lslRotConstructorInfo = 
				typeof (LSL_Rotation).GetConstructor (new Type[] { typeof (SCRIPTFLOAT), 
				                                                   typeof (SCRIPTFLOAT), 
				                                                   typeof (SCRIPTFLOAT), 
				                                                   typeof (SCRIPTFLOAT) });

		public CompValuRot (TokenType type, CompValu x, CompValu y, CompValu z, CompValu w) :
				base (type)
		{
			if (!(type is TokenTypeRot)) {
				this.type = new TokenTypeRot (type);
			}
			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;
		}
		public override void PushVal (ScriptCodeGen scg)
		{
			this.x.PushVal (scg, new TokenTypeFloat (this.x.type));
			this.y.PushVal (scg, new TokenTypeFloat (this.y.type));
			this.z.PushVal (scg, new TokenTypeFloat (this.z.type));
			this.w.PushVal (scg, new TokenTypeFloat (this.w.type));
			scg.ilGen.Emit (OpCodes.Newobj, lslRotConstructorInfo);
		}
		public override void PushRef (ScriptCodeGen scg)
		{
			throw new Exception ("cannot get constant's address");
		}
		public override void PopPost (ScriptCodeGen scg)
		{
			throw new Exception ("cannot store into constant");
		}
	}

	// The value is in a static field of a class
	public class CompValuSField : CompValu {
		public FieldInfo field;

		public CompValuSField (TokenType type, FieldInfo field) : base (type)
		{
			this.field = field;
		}
		public override void PushVal (ScriptCodeGen scg)
		{
			if ((field.Attributes & FieldAttributes.Literal) == 0) {
				scg.ilGen.Emit (OpCodes.Ldsfld, field);
				return;
			}
			if (field.FieldType == typeof (LSL_Rotation)) {
				LSL_Rotation rot = (LSL_Rotation)field.GetValue (null);
				scg.ilGen.Emit (OpCodes.Ldc_R8, rot.x);
				scg.ilGen.Emit (OpCodes.Ldc_R8, rot.y);
				scg.ilGen.Emit (OpCodes.Ldc_R8, rot.z);
				scg.ilGen.Emit (OpCodes.Ldc_R8, rot.s);
				scg.ilGen.Emit (OpCodes.Newobj, ScriptCodeGen.lslRotationConstructorInfo);
				return;
			}
			if (field.FieldType == typeof (LSL_Vector)) {
				LSL_Vector vec = (LSL_Vector)field.GetValue (null);
				scg.ilGen.Emit (OpCodes.Ldc_R8, vec.x);
				scg.ilGen.Emit (OpCodes.Ldc_R8, vec.y);
				scg.ilGen.Emit (OpCodes.Ldc_R8, vec.z);
				scg.ilGen.Emit (OpCodes.Newobj, ScriptCodeGen.lslRotationConstructorInfo);
				return;
			}
			if (field.FieldType == typeof (string)) {
				string str = (string)field.GetValue (null);
				scg.ilGen.Emit (OpCodes.Ldstr, str);
				return;
			}
			throw new Exception ("unsupported literal type " + field.FieldType.Name);
		}
		public override void PushRef (ScriptCodeGen scg)
		{
			if ((field.Attributes & FieldAttributes.Literal) != 0) {
				throw new Exception ("can't write a constant");
			}
			scg.ilGen.Emit (OpCodes.Ldflda, field);
		}
		public override void PopPre (ScriptCodeGen scg)
		{
		}
		public override void PopPost (ScriptCodeGen scg)
		{
			if ((field.Attributes & FieldAttributes.Literal) != 0) {
				throw new Exception ("can't write a constant");
			}
			scg.ilGen.Emit (OpCodes.Stsfld, field);
		}
	}

	// The value is a string constant
	public class CompValuString : CompValu {
		public string x;

		public CompValuString (TokenType type, string x) : base (type)
		{
			if (!(this.type is TokenTypeStr)) {
				this.type = new TokenTypeStr (this.type);
			}
			this.x = x;
		}
		public override void PushVal (ScriptCodeGen scg)
		{
			scg.ilGen.Emit (OpCodes.Ldstr, x);
		}
		public override void PushRef (ScriptCodeGen scg)
		{
			throw new Exception ("cannot get constant's address");
		}
		public override void PopPost (ScriptCodeGen scg)
		{
			throw new Exception ("cannot store into constant");
		}
	}

	// The value is kept in a temp local variable
	public class CompValuTemp : CompValu {
		private ScriptMyLocal localBuilder;

		public CompValuTemp (TokenType type, string name, ScriptCodeGen scg) : base (type)
		{
			if (name == null) {
				name = "__tmp_" + (++ scg.tempCompValuNum);
			}
			this.localBuilder = scg.ilGen.DeclareLocal (ToSysType(), name);
			scg.activeTemps.AddLast (this);
		}
		public override void PushVal (ScriptCodeGen scg)
		{
			scg.ilGen.Emit (OpCodes.Ldloc, localBuilder);
		}
		public override void PushRef (ScriptCodeGen scg)
		{
			scg.ilGen.Emit (OpCodes.Ldloca, localBuilder);
		}
		public override void PopPost (ScriptCodeGen scg)
		{
			scg.ilGen.Emit (OpCodes.Stloc, localBuilder);
		}
	}

	// The value is a vector
	public class CompValuVec : CompValu {
		public CompValu x;
		public CompValu y;
		public CompValu z;

		private static readonly ConstructorInfo lslVecConstructorInfo = 
				typeof (LSL_Vector).GetConstructor (new Type[] { typeof (SCRIPTFLOAT), 
				                                                 typeof (SCRIPTFLOAT), 
				                                                 typeof (SCRIPTFLOAT) });

		public CompValuVec (TokenType type, CompValu x, CompValu y, CompValu z) : base (type)
		{
			if (!(type is TokenTypeVec)) {
				this.type = new TokenTypeVec (type);
			}
			this.x = x;
			this.y = y;
			this.z = z;
		}
		public override void PushVal (ScriptCodeGen scg)
		{
			this.x.PushVal (scg, new TokenTypeFloat (this.x.type));
			this.y.PushVal (scg, new TokenTypeFloat (this.y.type));
			this.z.PushVal (scg, new TokenTypeFloat (this.z.type));
			scg.ilGen.Emit (OpCodes.Newobj, lslVecConstructorInfo);
		}
		public override void PushRef (ScriptCodeGen scg)
		{
			throw new Exception ("cannot get constant's address");
		}
		public override void PopPost (ScriptCodeGen scg)
		{
			throw new Exception ("cannot store into constant");
		}
	}

	// Used to indicate value will be discarded (eg, where to put return value from a call)
	public class CompValuVoid : CompValu {
		public CompValuVoid (Token token) : base (null)
		{
			if (token is TokenTypeVoid) {
				this.type = (TokenTypeVoid)token;
			} else {
				this.type = new TokenTypeVoid (type);
			}
		}
		public override void PushVal (ScriptCodeGen scg) { }
		public override void PushRef (ScriptCodeGen scg)
		{
			throw new Exception ("cannot get void address");
		}
		public override void PopPost (ScriptCodeGen scg) { }
	}
}
