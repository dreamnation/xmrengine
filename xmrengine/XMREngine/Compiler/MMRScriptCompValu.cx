/***************************************************\
 *  COPYRIGHT 2009, Mike Rieker, Beverly, MA, USA  *
 *  All rights reserved.                           *
\***************************************************/

using OpenSim.Region.ScriptEngine.Shared.ScriptBase;
using OpenSim.Region.ScriptEngine.XMREngine;
using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Reflection.Emit;

#include "lsltypes.h"

/**
 * @brief Compute values used during code generation to keep track of where computed values are stored.
 *
 *        Conceptually holds the memory address and type of the value
 *        such as that used for a local variable, global variable, temporary variable.
 *        Also used for things like constants and function/method entrypoints,
 *        they are basically treated as read-only variables.
 *
 *            cv.type - type of the value
 *
 *            cv.PushVal() - pushes the value on the CIL stack
 *            cv.PushRef() - pushes address of the value on the CIL stack
 *
 *            cv.PopPre()  - gets ready to pop from the CIL stack
 *                           ...by possibly pushing something
 *                <push value to be popped>
 *            cv.PushPre() - pops value from the CIL stack
 *
 *        If the type is a TokenTypeSDTypeDelegate, the location is callable, 
 *        so you get these additional functions:
 *
 *            cv.GetRetType()  - gets function/method's return value type
 *                               TokenTypeVoid if void
 *                               null if not a delegate
 *            cv.GetArgTypes() - gets array of argument types
 *                               as seen by script level, ie, 
 *                               does not include any hidden 'this' type
 *            cv.GetArgSig()   - gets argument signature eg, "(integer,list)"
 *                               null if not a delegate
 *
 *            cv.CallPre()     - gets ready to call the function/method
 *                               ...by possibly pushing something
 *                                  such as a 'this' pointer
 *                <push call args left-to-right>
 *            cv.CallPost()    - calls the function/method
 */

namespace OpenSim.Region.ScriptEngine.XMREngine
{

	/**
	 * @brief Location of a value
	 *        Includes constants, expressions and temp variables.
	 */
	public abstract class CompValu {
		protected static readonly MethodInfo gsmdMethodInfo = 
				typeof (XMRInstAbstract).GetMethod ("GetScriptMethodDelegate", 
				                                    new Type[] { typeof (string), typeof (string), typeof (object) });

		public TokenType type;        // type of the value and where in the source it was used

		public CompValu (TokenType type)
		{
			this.type = type;
		}

		public Type ToSysType()
		{
			return (type.ToLSLWrapType () != null) ? type.ToLSLWrapType () : type.ToSysType ();
		}

		// emit code to push value onto stack
		public void PushVal (ScriptCodeGen scg, Token errorAt, TokenType stackType)
		{
			this.PushVal (scg, errorAt, stackType, false);
		}
		public void PushVal (ScriptCodeGen scg, Token errorAt, TokenType stackType, bool explicitAllowed)
		{
			this.PushVal (scg, errorAt);
			TypeCast.CastTopOfStack (scg, errorAt, this.type, stackType, explicitAllowed);
		}
		public abstract void PushVal (ScriptCodeGen scg, Token errorAt);
		public abstract void PushRef (ScriptCodeGen scg, Token errorAt);

		// emit code to pop value from stack
		public void PopPost (ScriptCodeGen scg, Token errorAt, TokenType stackType)
		{
			TypeCast.CastTopOfStack (scg, errorAt, stackType, this.type, false);
			this.PopPost (scg, errorAt);
		}
		public virtual void PopPre (ScriptCodeGen scg, Token errorAt) { }  // call this before pushing value to be popped
		public abstract void PopPost (ScriptCodeGen scg, Token errorAt);   // call this after pushing value to be popped

		/*
		 * These additional functions are available if the type is a delegate
		 */
		public TokenType GetRetType ()
		{
			if (!(type is TokenTypeSDTypeDelegate)) return null;
			return ((TokenTypeSDTypeDelegate)type).decl.GetRetType ();
		}
		public TokenType[] GetArgTypes ()
		{
			if (!(type is TokenTypeSDTypeDelegate)) return null;
			return ((TokenTypeSDTypeDelegate)type).decl.GetArgTypes ();
		}
		public string GetArgSig ()
		{
			if (!(type is TokenTypeSDTypeDelegate)) return null;
			return ((TokenTypeSDTypeDelegate)type).decl.GetArgSig ();
		}

		// These are used only if type is a delegate too
		// - but it is a real delegate pointer in a global or local variable
		//   ie, so PushVal() pushes a delegate pointer
		// - so we must have CallPre() push the delegate pointer as a 'this' for this.Invoke(...)
		// - and CallPost() call the delegate's Invoke() method
		public virtual void CallPre (ScriptCodeGen scg, Token errorAt)   // call this before pushing arguments
		{
			this.PushVal (scg, errorAt);;
		}
		public virtual void CallPost (ScriptCodeGen scg, Token errorAt)  // call this after pushing arguments
		{
			TokenTypeSDTypeDelegate ttd = (TokenTypeSDTypeDelegate)type;
			MethodInfo invokeMethodInfo = ttd.decl.GetInvokerInfo ();
			scg.ilGen.Emit (OpCodes.Callvirt, invokeMethodInfo);
		}

		/**
		 * @brief See if the method that would be called is known to be trivial.
		 *        If unknown, such as calling via a delegate, return false.
		 */
		public virtual bool IsCallTrivial (ScriptCodeGen scg)
		{
			return false;
		}

		/*
		 * Utilities used by CompValuGlobalVar and CompValuInstField
		 * where the value is located in a type-dependent array.
		 */
		protected void EmitFieldPushVal (ScriptCodeGen scg, TokenDeclVar var)
		{
			scg.ilGen.Emit (OpCodes.Ldfld, var.vTableArray);  // which array
			scg.ilGen.PushInt (var.vTableIndex);              // which array element
			if (type is TokenTypeFloat) {
#define double Ldelem_R8
#define float  Ldelem_R4
				scg.ilGen.Emit (OpCodes.SCRIPTFLOAT);
#undef double
#undef float
			} else if (type is TokenTypeInt) {
				scg.ilGen.Emit (OpCodes.Ldelem_I4);
			} else if (type is TokenTypeSDTypeDelegate) {
				scg.ilGen.Emit (OpCodes.Ldelem, typeof (object));
				scg.ilGen.Emit (OpCodes.Castclass, ToSysType ());
			} else {
				scg.ilGen.Emit (OpCodes.Ldelem, ToSysType ());
			}
		}

		protected void EmitFieldPushRef (ScriptCodeGen scg, TokenDeclVar var)
		{
			scg.ilGen.Emit (OpCodes.Ldfld, var.vTableArray);
			scg.ilGen.PushInt (var.vTableIndex);
			scg.ilGen.Emit (OpCodes.Ldelema, ToSysType());
		}

		protected void EmitFieldPopPre (ScriptCodeGen scg, TokenDeclVar var)
		{
			scg.ilGen.Emit (OpCodes.Ldfld, var.vTableArray);
			scg.ilGen.PushInt (var.vTableIndex);
		}

		protected void EmitFieldPopPost (ScriptCodeGen scg, TokenDeclVar var)
		{
			if (type is TokenTypeFloat) {
#define double Stelem_R8
#define float  Stelem_R4
				scg.ilGen.Emit (OpCodes.SCRIPTFLOAT);
#undef double
#undef float
			} else if (type is TokenTypeInt) {
				scg.ilGen.Emit (OpCodes.Stelem_I4);
			} else if (type is TokenTypeSDTypeDelegate) {
				scg.ilGen.Emit (OpCodes.Stelem, typeof (object));
			} else {
				scg.ilGen.Emit (OpCodes.Stelem, ToSysType ());
			}
		}
	}

	// The value is kept in an (XMR_Array) array element
	public class CompValuArEle : CompValu {
		public  CompValu arr;
		private CompValu idx;
		private TokenTypeObject tto;

		private static readonly MethodInfo getByKeyMethodInfo = typeof (XMR_Array).GetMethod ("GetByKey", 
		                                                                                      new Type[] { typeof (object) });
		private static readonly MethodInfo setByKeyMethodInfo = typeof (XMR_Array).GetMethod ("SetByKey", 
		                                                                                      new Type[] { typeof (object),
		                                                                                                   typeof (object), 
		                                                                                                   typeof (int), 
		                                                                                                   typeof (int) });

		// type = TokenTypeObject always, as our array elements are always of type 'object'
		// arr  = where the array object itself is stored
		// idx  = where the index value is stored
		public CompValuArEle (TokenType type, CompValu arr, CompValu idx) : base (type)
		{
			this.arr = arr;
			this.idx = idx;
			this.tto = new TokenTypeObject (this.type);
		}
		public override void PushVal (ScriptCodeGen scg, Token errorAt)
		{
			arr.PushVal (scg, errorAt);   // array
			idx.PushVal (scg, errorAt, this.tto);  // key
			scg.ilGen.Emit (OpCodes.Call, getByKeyMethodInfo);
		}
		public override void PushRef (ScriptCodeGen scg, Token errorAt)
		{
			scg.ErrorMsg (errorAt, "array element not allowed here");
			scg.ilGen.Emit (OpCodes.Ldnull);
		}
		public override void PopPre (ScriptCodeGen scg, Token errorAt)
		{
			arr.PushVal (scg, errorAt);   // array
			idx.PushVal (scg, errorAt, this.tto);  // key
		}
		public override void PopPost (ScriptCodeGen scg, Token errorAt)
		{
			scg.ilGen.PushInt (type.line);
			scg.ilGen.PushInt (type.posn);
			scg.ilGen.Emit (OpCodes.Call, setByKeyMethodInfo);
		}
	}

	// The value is kept in the current function's argument list
	public class CompValuArg : CompValu {
		public int index;
		public bool readOnly;

		private static OpCode[] ldargs = { OpCodes.Ldarg_0, OpCodes.Ldarg_1, 
		                                   OpCodes.Ldarg_2, OpCodes.Ldarg_3 };

		public CompValuArg (TokenType type, int index) : base (type)
		{
			this.index = index;
		}
		public CompValuArg (TokenType type, int index, bool ro) : base (type)
		{
			this.index = index;
			this.readOnly = ro;
		}
		public override void PushVal (ScriptCodeGen scg, Token errorAt)
		{
			     if (index < ldargs.Length) scg.ilGen.Emit (ldargs[index]);
			else if (index <= 255) scg.ilGen.Emit (OpCodes.Ldarg_S, index);
			                    else scg.ilGen.Emit (OpCodes.Ldarg, index);
		}
		public override void PushRef (ScriptCodeGen scg, Token errorAt)
		{
			if (readOnly) {
				scg.ErrorMsg (errorAt, "location cannot be written to");
			}
			if (index <= 255) scg.ilGen.Emit (OpCodes.Ldarga_S, index);
			               else scg.ilGen.Emit (OpCodes.Ldarga, index);
		}
		public override void PopPost (ScriptCodeGen scg, Token errorAt)
		{
			if (readOnly) {
				scg.ErrorMsg (errorAt, "location cannot be written to");
			}
			scg.ilGen.Emit (OpCodes.Starg, index);
		}
	}

	// The value is a character constant
	public class CompValuChar : CompValu {
		public char x;

		public CompValuChar (TokenType type, char x) : base (type)
		{
			if (!(this.type is TokenTypeChar)) {
				this.type = new TokenTypeChar (this.type);
			}
			this.x = x;
		}
		public override void PushVal (ScriptCodeGen scg, Token errorAt)
		{
			scg.ilGen.PushInt ((int)x);
		}
		public override void PushRef (ScriptCodeGen scg, Token errorAt)
		{
			throw new Exception ("cannot get constant's address");
		}
		public override void PopPost (ScriptCodeGen scg, Token errorAt)
		{
			throw new Exception ("cannot store into contant");
		}
	}

	// The value is kept in a struct/class field
	public class CompValuField : CompValu {
		CompValu obj;
		FieldInfo field;

		public CompValuField (TokenType type, CompValu obj, FieldInfo field) : base (type)
		{
			this.obj   = obj;
			this.field = field;
		}
		public override void PushVal (ScriptCodeGen scg, Token errorAt)
		{
			if (field.ReflectedType.IsValueType) {
				obj.PushRef (scg, errorAt);
			} else {
				obj.PushVal (scg, errorAt);
			}
			scg.ilGen.Emit (OpCodes.Ldfld, field);
		}
		public override void PushRef (ScriptCodeGen scg, Token errorAt)
		{
			if (field.ReflectedType.IsValueType) {
				obj.PushRef (scg, errorAt);
			} else {
				obj.PushVal (scg, errorAt);
			}
			scg.ilGen.Emit (OpCodes.Ldflda, field);
		}
		public override void PopPre (ScriptCodeGen scg, Token errorAt)
		{
			if (field.ReflectedType.IsValueType) {
				obj.PushRef (scg, errorAt);
			} else {
				obj.PushVal (scg, errorAt);
			}
		}
		public override void PopPost (ScriptCodeGen scg, Token errorAt)
		{
			scg.ilGen.Emit (OpCodes.Stfld, field);
		}
	}

	// Accessing an element of a fixed-dimension array
	public class CompValuFixArEl : CompValu {
		private CompValu   baseRVal;
		private CompValu[] subRVals;

		private int nSubs;
		private TokenDeclVar getFunc;
		private TokenDeclVar setFunc;
		private TokenTypeInt tokenTypeInt;

		/**
		 * @brief Set up to access an element of an array.
		 * @param scg = what script we are compiling
		 * @param baseRVal = what array we are accessing
		 * @param subRVals = the subscripts being applied
		 */
		public CompValuFixArEl (ScriptCodeGen scg, CompValu baseRVal, CompValu[] subRVals) : base (GetElementType (scg, baseRVal, subRVals))
		{
			this.baseRVal = baseRVal;  // location of the array itself
			this.subRVals = subRVals;  // subscript values
			this.nSubs    = subRVals.Length;

			TokenTypeSDTypeClass sdtType = (TokenTypeSDTypeClass)baseRVal.type;
			TokenDeclSDTypeClass sdtDecl = sdtType.decl;
			tokenTypeInt = new TokenTypeInt (sdtType);

			TokenName name = new TokenName (sdtType, "Get");
			TokenType[] argsig = new TokenType[nSubs];
			for (int i = 0; i < nSubs; i ++) {
				argsig[i] = tokenTypeInt;
			}
			getFunc = scg.FindThisMember (sdtDecl, name, argsig);

			name = new TokenName (sdtType, "Set");
			argsig = new TokenType[nSubs+1];
			for (int i = 0; i < nSubs; i ++) {
				argsig[i] = tokenTypeInt;
			}
			argsig[nSubs] = getFunc.retType;
			setFunc = scg.FindThisMember (sdtDecl, name, argsig);
		}

		/**
		 * @brief Read array element and push value on stack.
		 */
		public override void PushVal (ScriptCodeGen scg, Token errorAt)
		{
			// call script-defined class' Get() method to fetch the value
			baseRVal.PushVal (scg, errorAt);
			for (int i = 0; i < nSubs; i ++) {
				subRVals[i].PushVal (scg, errorAt, tokenTypeInt);
			}
			scg.ilGen.Emit (OpCodes.Call, getFunc.ilGen);
		}

		/**
		 * @brief Push address of array element on stack.
		 */
		public override void PushRef (ScriptCodeGen scg, Token errorAt)
		{
			throw new Exception ("tu stOOpid to get array element address");
		}

		/**
		 * @brief Prepare to write array element.
		 */
		public override void PopPre (ScriptCodeGen scg, Token errorAt)
		{
			// set up call to script-defined class' Set() method to write the value
			baseRVal.PushVal (scg, errorAt);
			for (int i = 0; i < nSubs; i ++) {
				subRVals[i].PushVal (scg, errorAt, tokenTypeInt);
			}
		}

		/**
		 * @brief Pop value from stack and write array element.
		 */
		public override void PopPost (ScriptCodeGen scg, Token errorAt)
		{
			// call script-defined class' Set() method to write the value
			scg.ilGen.Emit (OpCodes.Call, setFunc.ilGen);
		}

		/**
		 * @brief Get the array element type by getting the Get() functions return type.
		 *        Crude but effective.
		 * @param scg = what script we are compiling
		 * @param baseRVal = what array we are accessing
		 * @param subRVals = the subscripts being applied
		 * @returns array element type
		 */
		private static TokenType GetElementType (ScriptCodeGen scg, CompValu baseRVal, CompValu[] subRVals)
		{
			TokenTypeSDTypeClass sdtType = (TokenTypeSDTypeClass)baseRVal.type;
			TokenDeclSDTypeClass sdtDecl = sdtType.decl;
			TokenName name = new TokenName (sdtType, "Get");
			int nSubs = subRVals.Length;
			TokenType[] argsig = new TokenType[nSubs];
			argsig[0] = new TokenTypeInt (sdtType);
			for (int i = 0; ++ i < nSubs;) {
				argsig[i] = argsig[0];
			}
			TokenDeclVar getFunc = scg.FindThisMember (sdtDecl, name, argsig);
			return getFunc.retType;
		}
	}

	// The value is a float constant
	public class CompValuFloat : CompValu {
		public SCRIPTFLOAT x;

		public CompValuFloat (TokenType type, SCRIPTFLOAT x) : base (type)
		{
			if (!(this.type is TokenTypeFloat)) {
				this.type = new TokenTypeFloat (this.type);
			}
			this.x = x;
		}
		public override void PushVal (ScriptCodeGen scg, Token errorAt)
		{
#define double Ldc_R8
#define float  Ldc_R4
			scg.ilGen.Emit (OpCodes.SCRIPTFLOAT, x);
#undef double
#undef float
		}
		public override void PushRef (ScriptCodeGen scg, Token errorAt)
		{
			throw new Exception ("cannot get constant's address");
		}
		public override void PopPost (ScriptCodeGen scg, Token errorAt)
		{
			throw new Exception ("cannot store into constant");
		}
	}

	// The value is the entrypoint of a script-defined global function.
	// These are also used for script-defined type static methods as the calling convention is the same,
	// ie, the XMRInstance pointer is a hidden first argument.
	// There is just one of these created when the function is being compiled as there is only one value
	// of the function.
	public class CompValuGlobalMeth : CompValu {
		private TokenDeclVar func;

		public CompValuGlobalMeth (TokenDeclVar declFunc) : base (declFunc.GetDelType ())
		{
			this.func = declFunc;
		}

		/**
		 * @brief PushVal for a function/method means push a delegate on the stack.
		 *        We build a call to the DynamicMethod's CreateDelegate() function 
		 *        to create the delegate.  Slip the scriptinstance pointer as the 
		 *        function's arg 0 so it will get passed to the function when called.
		 */
		public override void PushVal (ScriptCodeGen scg, Token errorAt)
		{
			string dtn = type.ToString ();
			if (dtn.StartsWith ("delegate ")) dtn = dtn.Substring (9);

			// delegateinstance = (signature)scriptinstance.GetScriptMethodDelegate (methName, signature, arg0);
			//   where methName = __fun_[<sdtclass>.]<methname>(<argtypes>)
			//        signature = <rettype>(<argtypes>)
			//             arg0 = scriptinstance (XMRInstance)
			scg.PushXMRInst ();                                     // [0] scriptinstance
			scg.ilGen.Emit (OpCodes.Ldstr, func.ilGen.methName);    // [1] method name
			scg.ilGen.Emit (OpCodes.Ldstr, dtn);                    // [2] delegate type name
			scg.PushXMRInst ();                                     // [3] scriptinstance
			scg.ilGen.Emit (OpCodes.Callvirt, gsmdMethodInfo);      // [0] delegate instance
			scg.ilGen.Emit (OpCodes.Castclass, type.ToSysType ());  // [0] cast to correct delegate class
		}
		public override void PushRef (ScriptCodeGen scg, Token errorAt)
		{
			throw new Exception ("cannot get ref to global method");
		}
		public override void PopPost (ScriptCodeGen scg, Token errorAt)
		{
			throw new Exception ("cannot store into global method");
		}

		/**
		 * @brief A direct call is much simpler than pushing a delegate.
		 *        Just push the XMRInstance pointer, push the args and finally call the function.
		 */
		public override void CallPre (ScriptCodeGen scg, Token errorAt)
		{
			// all script-defined global functions are static methods created by DynamicMethod()
			// and the first argument is always the XMR_Instance pointer
			scg.PushXMRInst ();
		}
		public override void CallPost (ScriptCodeGen scg, Token errorAt)
		{
			scg.ilGen.Emit (OpCodes.Call, func.ilGen);
		}

		public override bool IsCallTrivial (ScriptCodeGen scg)
		{
			return this.func.IsFuncTrivial (scg);
		}
	}

	// The value is in a script-global variable = ScriptModule instance variable
	public class CompValuGlobalVar : CompValu {
		private static readonly FieldInfo glblVarsFieldInfo = typeof (XMRInstAbstract).GetField ("glblVars");

		private TokenDeclVar declVar;

		public CompValuGlobalVar (TokenDeclVar declVar, ScriptObjCode scriptObjCode) : base (declVar.type)
		{
			this.declVar = declVar;
			declVar.type.AssignVarSlot (declVar, ref scriptObjCode.glblSizes);
		}
		public override void PushVal (ScriptCodeGen scg, Token errorAt)
		{
			scg.PushXMRInst ();
			scg.ilGen.Emit (OpCodes.Ldfld, glblVarsFieldInfo);
			EmitFieldPushVal (scg, declVar);
		}
		public override void PushRef (ScriptCodeGen scg, Token errorAt)
		{
			scg.PushXMRInst ();
			scg.ilGen.Emit (OpCodes.Ldfld, glblVarsFieldInfo);
			EmitFieldPushRef (scg, declVar);
		}
		public override void PopPre (ScriptCodeGen scg, Token errorAt)
		{
			scg.PushXMRInst ();
			scg.ilGen.Emit (OpCodes.Ldfld, glblVarsFieldInfo);
			EmitFieldPopPre (scg, declVar);
		}
		public override void PopPost (ScriptCodeGen scg, Token errorAt)
		{
			EmitFieldPopPost (scg, declVar);
		}
	}

	// This represents the type and location of an internally-defined function
	// that a script can call
	public class CompValuInline : CompValu {
		public TokenDeclInline declInline;

		public CompValuInline (TokenDeclInline declInline) : base (declInline.GetDelType ())
		{
			this.declInline = declInline;
		}

		public override void PushVal (ScriptCodeGen scg, Token errorAt)
		{
			scg.ErrorMsg (errorAt, "cannot use built-in for delegate, wrap it");
			scg.ilGen.Emit (OpCodes.Ldnull);
		}
		public override void PushRef (ScriptCodeGen scg, Token errorAt)
		{
			scg.ErrorMsg (errorAt, "cannot use built-in for delegate, wrap it");
			scg.ilGen.Emit (OpCodes.Ldnull);
		}
		public override void PopPre (ScriptCodeGen scg, Token errorAt)
		{
			scg.ErrorMsg (errorAt, "cannot use built-in for delegate, wrap it");
		}
		public override void PopPost (ScriptCodeGen scg, Token errorAt)
		{
			scg.ErrorMsg (errorAt, "cannot use built-in for delegate, wrap it");
			scg.ilGen.Emit (OpCodes.Pop);
		}
	}

	// The value is the entrypoint of a script-defined type's interface method combined with
	// the pointer used to access the method.  Thus there is one of these per call site.
	public class CompValuIntfMeth : CompValu {
		private TokenDeclVar func;
		private CompValu baseRVal;

		public CompValuIntfMeth (TokenDeclVar declFunc, CompValu baseRVal) : base (declFunc.GetDelType ())
		{
			this.func     = declFunc;  // which element of the baseRVal vector to be accessed
			this.baseRVal = baseRVal;  // the vector of delegates implementing the interface
		}

		public override void PushVal (ScriptCodeGen scg, Token errorAt)
		{
			baseRVal.PushVal (scg, errorAt);                        // push pointer to delegate array on stack
			scg.ilGen.PushInt (func.vTableIndex);                   // select which delegate to access
			scg.ilGen.Emit (OpCodes.Ldelem, typeof (Delegate));     // push delegate on stack
			scg.ilGen.Emit (OpCodes.Castclass, type.ToSysType ());  // cast to correct delegate class
		}
		public override void PushRef (ScriptCodeGen scg, Token errorAt)
		{
			throw new Exception ("cannot get ref to interface method");
		}
		public override void PopPost (ScriptCodeGen scg, Token errorAt)
		{
			throw new Exception ("cannot store into interface method");
		}

		public override void CallPre (ScriptCodeGen scg, Token errorAt)
		{
			// push interface method's delegate on stack
			this.PushVal (scg, errorAt);
		}
		public override void CallPost (ScriptCodeGen scg, Token errorAt)
		{
			// call via delegate Invoke(...) method
			TokenTypeSDTypeDelegate ttd = (TokenTypeSDTypeDelegate)type;
			MethodInfo invokeMethodInfo = ttd.decl.GetInvokerInfo ();
			scg.ilGen.Emit (OpCodes.Callvirt, invokeMethodInfo);
		}
	}

	// The value is the entrypoint of an internal instance method
	// such as XMR_Array.index()
	public class CompValuIntInstMeth : CompValu {
		private TokenTypeSDTypeDelegate delType;
		private CompValu baseRVal;
		private MethodInfo methInfo;

		public CompValuIntInstMeth (TokenTypeSDTypeDelegate delType, CompValu baseRVal, MethodInfo methInfo) : base (delType)
		{
			this.delType  = delType;
			this.baseRVal = baseRVal;
			this.methInfo = methInfo;
		}

		public override void PushVal (ScriptCodeGen scg, Token errorAt)
		{
			// its value, ie, without applying the (arglist), is a delegate...
			baseRVal.PushVal (scg, errorAt);
			scg.ilGen.Emit (OpCodes.Ldftn, methInfo);
			scg.ilGen.Emit (OpCodes.Newobj, delType.decl.GetConstructorInfo ());
		}
		public override void PushRef (ScriptCodeGen scg, Token errorAt)
		{
			throw new Exception ("cannot get ref to instance method");
		}
		public override void PopPost (ScriptCodeGen scg, Token errorAt)
		{
			throw new Exception ("cannot store into instance method");
		}

		public override void CallPre (ScriptCodeGen scg, Token errorAt)
		{
			baseRVal.PushVal (scg, errorAt);
		}
		public override void CallPost (ScriptCodeGen scg, Token errorAt)
		{
			scg.ilGen.Emit (OpCodes.Call, methInfo);
		}

		public override bool IsCallTrivial (ScriptCodeGen scg)
		{
			return true;
		}
	}

	// The value is fetched by calling an internal instance method
	// such as XMR_Array.count
	public class CompValuIntInstROProp : CompValu {
		private CompValu baseRVal;
		private MethodInfo methInfo;

		public CompValuIntInstROProp (TokenType valType, CompValu baseRVal, MethodInfo methInfo) : base (valType)
		{
			this.baseRVal = baseRVal;
			this.methInfo = methInfo;
		}

		public override void PushVal (ScriptCodeGen scg, Token errorAt)
		{
			baseRVal.PushVal (scg, errorAt);
			scg.ilGen.Emit (OpCodes.Call, methInfo);
		}
		public override void PushRef (ScriptCodeGen scg, Token errorAt)
		{
			scg.ErrorMsg (errorAt, "cannot get ref to read-only property");
			scg.ilGen.Emit (OpCodes.Ldnull);
		}
		public override void PopPost (ScriptCodeGen scg, Token errorAt)
		{
			scg.ErrorMsg (errorAt, "cannot store into read-only property");
			scg.ilGen.Emit (OpCodes.Pop);
		}
	}

	// The value is in a member of a script-defined type class instance.
	//       field: value is in one of the arrays contained within XMRSDTypeClObj.instVars
	//      method: value is a delegate; can be called
	//    property: reading and writing is via a method call
	public class CompValuInstMember : CompValu {
		private static readonly FieldInfo instVarsFieldInfo = typeof (XMRSDTypeClObj).GetField ("instVars");
		private static readonly FieldInfo vTableFieldInfo   = typeof (XMRSDTypeClObj).GetField ("sdtcVTable");

		private TokenDeclVar declVar;  // member being accessed
		private CompValu baseRVal;     // pointer to particular object instance
		private bool ignoreVirt;       // ignore virtual attribute; use declVar's non-virtual method/property

		private CompValu setProp;

		public CompValuInstMember (TokenDeclVar declVar, CompValu baseRVal, bool ignoreVirt) : base (declVar.type)
		{
			this.declVar    = declVar;
			this.baseRVal   = baseRVal;
			this.ignoreVirt = ignoreVirt;
		}

		public override void PushVal (ScriptCodeGen scg, Token errorAt)
		{
			if (declVar.retType != null) {
				// a method's value, ie, without applying the (arglist), is a delegate...
				PushValMethod (scg, errorAt);
			} else if (declVar.vTableArray != null) {
				// a field's value is its XMRSDTypeClObj.instVars array element
				baseRVal.PushVal (scg, errorAt);
				scg.ilGen.Emit (OpCodes.Ldfld, instVarsFieldInfo);
				EmitFieldPushVal (scg, declVar);
			} else if (declVar.getProp != null) {
				// a property's value is calling its get method with no arguments
				if (!declVar.getProp.IsFuncTrivial (scg)) {
					throw new Exception ("should have been wrapped by AccessInstanceMember()");
				}
				CompValu getProp = new CompValuInstMember (declVar.getProp, baseRVal, ignoreVirt);
				getProp.CallPre  (scg, errorAt);
				getProp.CallPost (scg, errorAt);
			} else {
				// write-only property
				scg.ErrorMsg (errorAt, "member not readable");
				scg.PushDefaultValue (declVar.type);
			}
		}
		public override void PushRef (ScriptCodeGen scg, Token errorAt)
		{
			if (declVar.vTableArray != null) {
				// a field's value is its XMRSDTypeClObj.instVars array element
				baseRVal.PushVal (scg, errorAt);
				scg.ilGen.Emit (OpCodes.Ldfld, instVarsFieldInfo);
				EmitFieldPushRef (scg, declVar);
			} else {
				scg.ErrorMsg (errorAt, "member has no address");
				scg.ilGen.Emit (OpCodes.Ldnull);
			}
		}
		public override void PopPre (ScriptCodeGen scg, Token errorAt)
		{
			if (declVar.vTableArray != null) {
				// a field's value is its XMRSDTypeClObj.instVars array element
				baseRVal.PushVal (scg, errorAt);
				scg.ilGen.Emit (OpCodes.Ldfld, instVarsFieldInfo);
				EmitFieldPopPre (scg, declVar);
			} else if (declVar.setProp != null) {
				// a property's value is calling its set method with the value as the argument
				if (!declVar.setProp.IsFuncTrivial (scg)) new ScriptCodeGen.CallLabel (scg);
				this.setProp = new CompValuInstMember (declVar.setProp, baseRVal, ignoreVirt);
				this.setProp.CallPre  (scg, errorAt);
			} else {
				// write-only property
				scg.ErrorMsg (errorAt, "member not writable");
			}
		}
		public override void PopPost (ScriptCodeGen scg, Token errorAt)
		{
			if (declVar.vTableArray != null) {
				EmitFieldPopPost (scg, declVar);
			} else if (declVar.setProp != null) {
				this.setProp.CallPost (scg, errorAt);
			} else {
				scg.ilGen.Emit (OpCodes.Pop);
			}
		}

		public override void CallPre (ScriptCodeGen scg, Token errorAt)
		{
			if (declVar.retType != null) {
				CallPreMethod (scg, errorAt);
			} else {
				base.CallPre (scg, errorAt);
			}
		}
		public override void CallPost (ScriptCodeGen scg, Token errorAt)
		{
			if (declVar.retType != null) {
				CallPostMethod (scg, errorAt);
			} else {
				base.CallPost (scg, errorAt);
			}
		}

		public override bool IsCallTrivial (ScriptCodeGen scg)
		{
			// if not a method, it's a call via delegate, which we assume to be non-trivial
			if (declVar.retType == null) return false;

			// otherwise, ask that method if calling it is trivial
			return this.declVar.IsFuncTrivial (scg);
		}

		/**
		 * @brief A PushVal() for a method means to push a delegate for the method on the stack.
		 */
		private void PushValMethod (ScriptCodeGen scg, Token errorAt)
		{
			if ((declVar.sdtFlags & ScriptReduce.SDT_STATIC) != 0) throw new Exception ("dont use for statics");

			if (ignoreVirt || (declVar.vTableIndex < 0)) {

				/*
				 * Non-virtual instance method, create a delegate that references the method.
				 */
				string dtn = type.ToString ();

				// delegateinstance = (signature)scriptinstance.GetScriptMethodDelegate (methName, signature, arg0);
				//   where methName = __fun_<sdtclass>.<methname>(<argtypes>)
				//        signature = <rettype>(<argtypes>)
				//             arg0 = sdt istance (XMRSDTypeClObj) 'this' value
				scg.PushXMRInst ();                                     // [0] scriptinstance
				scg.ilGen.Emit (OpCodes.Ldstr, declVar.ilGen.methName); // [1] method name
				scg.ilGen.Emit (OpCodes.Ldstr, dtn);                    // [2] delegate type name
				baseRVal.PushVal (scg, errorAt);                        // [3] sdtinstance
				scg.ilGen.Emit (OpCodes.Callvirt, gsmdMethodInfo);      // [0] delegate instance
				scg.ilGen.Emit (OpCodes.Castclass, type.ToSysType ());  // [0] cast to correct delegate class
			} else {

				/*
				 * Virtual instance method, get the delegate from the vtable.
				 */
				baseRVal.PushVal (scg, errorAt);                        // 'this' selecting the instance
				scg.ilGen.Emit (OpCodes.Ldfld, vTableFieldInfo);        // get pointer to instance's vtable array
				scg.ilGen.PushInt (declVar.vTableIndex);                // select vtable element
				scg.ilGen.Emit (OpCodes.Ldelem, typeof (Delegate));     // get delegate pointer = 'this' for 'Invoke()'
				scg.ilGen.Emit (OpCodes.Castclass, type.ToSysType ());  // cast to correct delegate class
			}
		}

		private void CallPreMethod (ScriptCodeGen scg, Token errorAt)
		{
			if ((declVar.sdtFlags & ScriptReduce.SDT_STATIC) != 0) throw new Exception ("dont use for statics");

			if (ignoreVirt || (declVar.vTableIndex < 0)) {
				baseRVal.PushVal (scg, errorAt);                        // 'this' being passed directly to method
			} else {
				baseRVal.PushVal (scg, errorAt);                        // 'this' selecting the instance
				scg.ilGen.Emit (OpCodes.Ldfld, vTableFieldInfo);        // get pointer to instance's vtable array
				scg.ilGen.PushInt (declVar.vTableIndex);                // select vtable element
				scg.ilGen.Emit (OpCodes.Ldelem, typeof (Delegate));     // get delegate pointer = 'this' for 'Invoke()'
				scg.ilGen.Emit (OpCodes.Castclass, type.ToSysType ());  // cast to correct delegate class
			}
		}
		private void CallPostMethod (ScriptCodeGen scg, Token errorAt)
		{
			if (ignoreVirt || (declVar.vTableIndex < 0)) {
				// non-virt instance, just call function directly
				scg.ilGen.Emit (OpCodes.Call, declVar.ilGen);
			} else {
				// virtual, call via delegate Invoke(...) method
				TokenTypeSDTypeDelegate ttd = (TokenTypeSDTypeDelegate)type;
				MethodInfo invokeMethodInfo = ttd.decl.GetInvokerInfo ();
				scg.ilGen.Emit (OpCodes.Callvirt, invokeMethodInfo);
			}
		}
	}

	// The value is an integer constant
	public class CompValuInteger : CompValu {
		public int x;

		public CompValuInteger (TokenType type, int x) : base (type)
		{
			if (!(this.type is TokenTypeInt)) {
				this.type = new TokenTypeInt (this.type);
			}
			this.x = x;
		}
		public override void PushVal (ScriptCodeGen scg, Token errorAt)
		{
			scg.ilGen.PushInt (x);
		}
		public override void PushRef (ScriptCodeGen scg, Token errorAt)
		{
			throw new Exception ("cannot get constant's address");
		}
		public override void PopPost (ScriptCodeGen scg, Token errorAt)
		{
			throw new Exception ("cannot store into constant");
		}
	}

	// The value is an element of a list
	public class CompValuListEl : CompValu {
		private static readonly MethodInfo getElementFromListMethodInfo = 
				 typeof (CompValuListEl).GetMethod ("GetElementFromList", new Type[] { typeof (LSL_List), typeof (int) });

		private CompValu theList;
		private CompValu subscript;

		public CompValuListEl (TokenType type, CompValu theList, CompValu subscript) : base (type)
		{
			this.theList   = theList;
			this.subscript = subscript;
		}
		public override void PushVal (ScriptCodeGen scg, Token errorAt)
		{
			theList.PushVal (scg, errorAt, new TokenTypeList (type));
			subscript.PushVal (scg, errorAt, new TokenTypeInt (type));
			scg.ilGen.Emit (OpCodes.Call, getElementFromListMethodInfo);
		}
		public override void PushRef (ScriptCodeGen scg, Token errorAt)
		{
			throw new Exception ("cannot get list element's address");
		}
		public override void PopPost (ScriptCodeGen scg, Token errorAt)
		{
			scg.ErrorMsg (errorAt, "cannot store into list element");
			scg.ilGen.Emit (OpCodes.Pop);
		}

		public static object GetElementFromList (LSL_List lis, int idx)
		{
			object element = lis.Data[idx];
			if (element is LSL_Float)                return TypeCast.EHArgUnwrapFloat    (element);
			if (element is LSL_Integer)              return TypeCast.EHArgUnwrapInteger  (element);
			if (element is LSL_String)               return TypeCast.EHArgUnwrapString   (element);
			if (element is OpenMetaverse.Quaternion) return TypeCast.EHArgUnwrapRotation (element);
			if (element is OpenMetaverse.Vector3)    return TypeCast.EHArgUnwrapVector   (element);
			return element;
		}
	}

	// The value is a null
	public class CompValuNull : CompValu {
		public CompValuNull (TokenType type) : base (type) { }
		public override void PushVal (ScriptCodeGen scg, Token errorAt)
		{
			scg.ilGen.Emit (OpCodes.Ldnull);
		}
		public override void PushRef (ScriptCodeGen scg, Token errorAt)
		{
			throw new Exception ("cannot get null's address");
		}
		public override void PopPost (ScriptCodeGen scg, Token errorAt)
		{
			throw new Exception ("cannot store into null");
		}
	}

	// The value is a rotation
	public class CompValuRot : CompValu {
		public CompValu x;
		public CompValu y;
		public CompValu z;
		public CompValu w;

		private static readonly ConstructorInfo lslRotConstructorInfo = 
				typeof (LSL_Rotation).GetConstructor (new Type[] { typeof (SCRIPTFLOAT), 
				                                                   typeof (SCRIPTFLOAT), 
				                                                   typeof (SCRIPTFLOAT), 
				                                                   typeof (SCRIPTFLOAT) });

		public CompValuRot (TokenType type, CompValu x, CompValu y, CompValu z, CompValu w) :
				base (type)
		{
			if (!(type is TokenTypeRot)) {
				this.type = new TokenTypeRot (type);
			}
			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;
		}
		public override void PushVal (ScriptCodeGen scg, Token errorAt)
		{
			this.x.PushVal (scg, errorAt, new TokenTypeFloat (this.x.type));
			this.y.PushVal (scg, errorAt, new TokenTypeFloat (this.y.type));
			this.z.PushVal (scg, errorAt, new TokenTypeFloat (this.z.type));
			this.w.PushVal (scg, errorAt, new TokenTypeFloat (this.w.type));
			scg.ilGen.Emit (OpCodes.Newobj, lslRotConstructorInfo);
		}
		public override void PushRef (ScriptCodeGen scg, Token errorAt)
		{
			throw new Exception ("cannot get constant's address");
		}
		public override void PopPost (ScriptCodeGen scg, Token errorAt)
		{
			throw new Exception ("cannot store into constant");
		}
	}

	// The value is in a static field of a class
	public class CompValuSField : CompValu {
		public FieldInfo field;

		public CompValuSField (TokenType type, FieldInfo field) : base (type)
		{
			this.field = field;
		}
		public override void PushVal (ScriptCodeGen scg, Token errorAt)
		{
			if ((field.Attributes & FieldAttributes.Literal) == 0) {
				scg.ilGen.Emit (OpCodes.Ldsfld, field);
				return;
			}
			if (field.FieldType == typeof (LSL_Rotation)) {
				LSL_Rotation rot = (LSL_Rotation)field.GetValue (null);
				scg.ilGen.Emit (OpCodes.Ldc_R8, rot.x);
				scg.ilGen.Emit (OpCodes.Ldc_R8, rot.y);
				scg.ilGen.Emit (OpCodes.Ldc_R8, rot.z);
				scg.ilGen.Emit (OpCodes.Ldc_R8, rot.s);
				scg.ilGen.Emit (OpCodes.Newobj, ScriptCodeGen.lslRotationConstructorInfo);
				return;
			}
			if (field.FieldType == typeof (LSL_Vector)) {
				LSL_Vector vec = (LSL_Vector)field.GetValue (null);
				scg.ilGen.Emit (OpCodes.Ldc_R8, vec.x);
				scg.ilGen.Emit (OpCodes.Ldc_R8, vec.y);
				scg.ilGen.Emit (OpCodes.Ldc_R8, vec.z);
				scg.ilGen.Emit (OpCodes.Newobj, ScriptCodeGen.lslRotationConstructorInfo);
				return;
			}
			if (field.FieldType == typeof (string)) {
				string str = (string)field.GetValue (null);
				scg.ilGen.Emit (OpCodes.Ldstr, str);
				return;
			}
			throw new Exception ("unsupported literal type " + field.FieldType.Name);
		}
		public override void PushRef (ScriptCodeGen scg, Token errorAt)
		{
			if ((field.Attributes & FieldAttributes.Literal) != 0) {
				throw new Exception ("can't write a constant");
			}
			scg.ilGen.Emit (OpCodes.Ldflda, field);
		}
		public override void PopPre (ScriptCodeGen scg, Token errorAt)
		{
		}
		public override void PopPost (ScriptCodeGen scg, Token errorAt)
		{
			if ((field.Attributes & FieldAttributes.Literal) != 0) {
				throw new Exception ("can't write a constant");
			}
			scg.ilGen.Emit (OpCodes.Stsfld, field);
		}
	}

	// The value is a character within a string
	public class CompValuStrChr : CompValu {
		private static readonly MethodInfo getCharFromStringMethodInfo = 
				 typeof (CompValuStrChr).GetMethod ("GetCharFromString", new Type[] { typeof (string), typeof (int) });

		private CompValu theString;
		private CompValu subscript;

		public CompValuStrChr (TokenType type, CompValu theString, CompValu subscript) : base (type)
		{
			this.theString = theString;
			this.subscript = subscript;
		}
		public override void PushVal (ScriptCodeGen scg, Token errorAt)
		{
			theString.PushVal (scg, errorAt, new TokenTypeStr (type));
			subscript.PushVal (scg, errorAt, new TokenTypeInt (type));
			scg.ilGen.Emit (OpCodes.Call, getCharFromStringMethodInfo);
		}
		public override void PushRef (ScriptCodeGen scg, Token errorAt)
		{
			throw new Exception ("cannot get string character's address");
		}
		public override void PopPost (ScriptCodeGen scg, Token errorAt)
		{
			scg.ErrorMsg (errorAt, "cannot store into string character");
			scg.ilGen.Emit (OpCodes.Pop);
		}

		public static char GetCharFromString (string s, int i)
		{
			return s[i];
		}
	}

	// The value is a string constant
	public class CompValuString : CompValu {
		public string x;

		public CompValuString (TokenType type, string x) : base (type)
		{
			if (!(this.type is TokenTypeStr)) {
				this.type = new TokenTypeStr (this.type);
			}
			this.x = x;
		}
		public override void PushVal (ScriptCodeGen scg, Token errorAt)
		{
			scg.ilGen.Emit (OpCodes.Ldstr, x);
		}
		public override void PushRef (ScriptCodeGen scg, Token errorAt)
		{
			throw new Exception ("cannot get constant's address");
		}
		public override void PopPost (ScriptCodeGen scg, Token errorAt)
		{
			throw new Exception ("cannot store into constant");
		}
	}

	// The value is kept in a temp local variable
	public class CompValuTemp : CompValu {
		public ScriptMyLocal localBuilder;

		public CompValuTemp (TokenType type, string name, ScriptCodeGen scg) : base (type)
		{
			if (!(type is TokenTypeVoid)) {
				if (name == null) {
					name = "__tmp_" + (++ scg.tempCompValuNum);
				}
				this.localBuilder = scg.ilGen.DeclareLocal (ToSysType(), name);
			}
		}
		public override void PushVal (ScriptCodeGen scg, Token errorAt)
		{
			if (localBuilder != null) {
				scg.ilGen.Emit (OpCodes.Ldloc, localBuilder);
			}
		}
		public override void PushRef (ScriptCodeGen scg, Token errorAt)
		{
			if (localBuilder != null) {
				scg.ilGen.Emit (OpCodes.Ldloca, localBuilder);
			} else {
				throw new Exception ("cannot get void address");
			}
		}
		public override void PopPost (ScriptCodeGen scg, Token errorAt)
		{
			if (localBuilder != null) {
				scg.ilGen.Emit (OpCodes.Stloc, localBuilder);
			}
		}

		public void Pop (ScriptCodeGen scg, Token errorAt, TokenType stackType)
		{
			TypeCast.CastTopOfStack (scg, errorAt, stackType, this.type, false);
			this.Pop (scg, errorAt);
		}
		public void Pop (ScriptCodeGen scg, Token errorAt)
		{
			if (localBuilder != null) {
				scg.ilGen.Emit (OpCodes.Stloc, localBuilder);
			}
		}
	}

	// The value is a vector
	public class CompValuVec : CompValu {
		public CompValu x;
		public CompValu y;
		public CompValu z;

		private static readonly ConstructorInfo lslVecConstructorInfo = 
				typeof (LSL_Vector).GetConstructor (new Type[] { typeof (SCRIPTFLOAT), 
				                                                 typeof (SCRIPTFLOAT), 
				                                                 typeof (SCRIPTFLOAT) });

		public CompValuVec (TokenType type, CompValu x, CompValu y, CompValu z) : base (type)
		{
			if (!(type is TokenTypeVec)) {
				this.type = new TokenTypeVec (type);
			}
			this.x = x;
			this.y = y;
			this.z = z;
		}
		public override void PushVal (ScriptCodeGen scg, Token errorAt)
		{
			this.x.PushVal (scg, errorAt, new TokenTypeFloat (this.x.type));
			this.y.PushVal (scg, errorAt, new TokenTypeFloat (this.y.type));
			this.z.PushVal (scg, errorAt, new TokenTypeFloat (this.z.type));
			scg.ilGen.Emit (OpCodes.Newobj, lslVecConstructorInfo);
		}
		public override void PushRef (ScriptCodeGen scg, Token errorAt)
		{
			throw new Exception ("cannot get constant's address");
		}
		public override void PopPost (ScriptCodeGen scg, Token errorAt)
		{
			throw new Exception ("cannot store into constant");
		}
	}

	// Used to indicate value will be discarded (eg, where to put return value from a call)
	public class CompValuVoid : CompValu {
		public CompValuVoid (Token token) : base (null)
		{
			if (token is TokenTypeVoid) {
				this.type = (TokenTypeVoid)token;
			} else {
				this.type = new TokenTypeVoid (type);
			}
		}
		public override void PushVal (ScriptCodeGen scg, Token errorAt) { }
		public override void PushRef (ScriptCodeGen scg, Token errorAt)
		{
			throw new Exception ("cannot get void address");
		}
		public override void PopPost (ScriptCodeGen scg, Token errorAt) { }
	}
}
