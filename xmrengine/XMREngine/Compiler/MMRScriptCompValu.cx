/***************************************************\
 *  COPYRIGHT 2009, Mike Rieker, Beverly, MA, USA  *
 *  All rights reserved.                           *
\***************************************************/

using OpenSim.Region.ScriptEngine.Shared.ScriptBase;
using OpenSim.Region.ScriptEngine.XMREngine;
using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Reflection.Emit;

#include "lsltypes.h"

/**
 * @brief Compute values used during code generation to keep track of where computed values are stored.
 */

namespace OpenSim.Region.ScriptEngine.XMREngine
{

	/**
	 * @brief Location of a value
	 *        Includes constants, expressions and temp variables.
	 */
	public abstract class CompValu {
		public TokenType type;        // type of the value and where in the source it was used
		public bool isFinal;          // true iff value cannot be changed by any side effects
		                              // - ie, PushVal() is idempotent (no calls, autoincrements, assignment, etc)
		                              // - temps do not change because we allocate a new one each time
		                              // - constants never change because they are constant
		                              // - expressions consisting of all isFinal operands are final
		public CompValu heapTracker;  // var to keep track of any heap use by this var
		                              // - only applies to global and local vars holding lists and strings
		                              // - temp lists and strings are not tracked because they are hopefully temporary
		                              // - arrays keep track of their own heap usage
		                              // - global value types are tracked by a static amount
		                              // - local & temp value types are tracked by the amount of stack they use

		public CompValu (TokenType type)
		{
			this.type    = type;
			this.isFinal = true;
		}

		public CompValu (TokenType type, bool isFinal)
		{
			this.type    = type;
			this.isFinal = isFinal;
		}

		public Type ToSysType()
		{
			return (type.ToLSLWrapType () != null) ? type.ToLSLWrapType () : type.ToSysType ();
		}

		// emit code to push value onto stack
		public void PushVal (ScriptCodeGen scg, TokenType stackType)
		{
			this.PushVal (scg, stackType, false);
		}
		public void PushVal (ScriptCodeGen scg, TokenType stackType, bool explicitAllowed)
		{
			this.PushVal (scg);
			TypeCast.CastTopOfStack (scg, this.type, stackType, explicitAllowed);
		}
		public abstract void PushVal (ScriptCodeGen scg);
		public abstract void PushByRef (ScriptCodeGen scg);

		// emit code to pop value from stack
		public void PopPost (ScriptCodeGen scg, TokenType stackType)
		{
			TypeCast.CastTopOfStack (scg, stackType, this.type, false);
			this.PopPost (scg);
		}
		public virtual void PopPre (ScriptCodeGen scg) { }  // call this before pushing value to be popped
		public abstract void PopPost (ScriptCodeGen scg);   // call this after pushing value to be popped

		// These additional functions are available if the type is a delegate
		public TokenType GetRetType ()
		{
			if (!(type is TokenTypeDelegate)) return null;
			return ((TokenTypeDelegate)type).retType;
		}
		public TokenType[] GetArgTypes ()
		{
			if (!(type is TokenTypeDelegate)) return null;
			return ((TokenTypeDelegate)type).argTypes;
		}

		public virtual void CallPre (ScriptCodeGen scg)   // call this before pushing arguments
		{
			this.PushVal (scg);  // push pointer to delegate object
		}
		public virtual void CallPost (ScriptCodeGen scg)  // call this after pushing arguments
		{
			TokenTypeDelegate ttd = (TokenTypeDelegate)type;
			MethodInfo invokeMethodInfo = ttd.GetInvokerInfo ();
			scg.ilGen.Emit (OpCodes.Callvirt, invokeMethodInfo);
		}
	}

	// The value is kept in an (XMR_Array) array element
	public class CompValuArEle : CompValu {
		public  CompValu arr;
		private CompValu idx;
		private TokenTypeObject tto;

		private static readonly MethodInfo getByKeyMethodInfo = typeof (XMR_Array).GetMethod ("GetByKey", 
		                                                                                      new Type[] { typeof (object) });
		private static readonly MethodInfo setByKeyMethodInfo = typeof (XMR_Array).GetMethod ("SetByKey", 
		                                                                                      new Type[] { typeof (object),
		                                                                                                   typeof (object), 
		                                                                                                   typeof (int), 
		                                                                                                   typeof (int) });

		// type = TokenTypeObject always, as our array elements are always of type 'object'
		// arr  = where the array object itself is stored
		// idx  = where the index value is stored
		public CompValuArEle (TokenType type, CompValu arr, CompValu idx) : base (type)
		{
			this.arr = arr;
			this.idx = idx;
			this.tto = new TokenTypeObject (this.type);
		}
		public override void PushVal (ScriptCodeGen scg)
		{
			arr.PushVal (scg);            // array
			idx.PushVal (scg, this.tto);  // key
			scg.ilGen.Emit (OpCodes.Call, getByKeyMethodInfo);
		}
		public override void PushByRef (ScriptCodeGen scg)
		{
			scg.ErrorMsg (this.type, "array element not allowed here");
			scg.ilGen.Emit (OpCodes.Ldnull);
		}
		public override void PopPre (ScriptCodeGen scg)
		{
			arr.PushVal (scg);            // array
			idx.PushVal (scg, this.tto);  // key
		}
		public override void PopPost (ScriptCodeGen scg)
		{
			scg.PushConstantI4 (type.line);
			scg.PushConstantI4 (type.posn);
			scg.ilGen.Emit (OpCodes.Call, setByKeyMethodInfo);
		}
	}

	// The value is kept in the current function's argument list
	public class CompValuArg : CompValu {
		public int index;

		public CompValuArg (TokenType type, int index) : base (type)
		{
			this.index = index;
		}
		public override void PushVal (ScriptCodeGen scg)
		{
			scg.ilGen.Emit (OpCodes.Ldarg, index);
		}
		public override void PushByRef (ScriptCodeGen scg)
		{
			scg.ilGen.Emit (OpCodes.Ldarga, index);
		}
		public override void PopPost (ScriptCodeGen scg)
		{
			scg.ilGen.Emit (OpCodes.Starg, index);
		}
	}

	// The value is kept in a struct/class field
	public class CompValuField : CompValu {
		CompValu obj;
		FieldInfo field;

		public CompValuField (TokenType type, CompValu obj, FieldInfo field) : base (type)
		{
			this.obj   = obj;
			this.field = field;
		}
		public override void PushVal (ScriptCodeGen scg)
		{
			if (field.ReflectedType.IsValueType) {
				obj.PushByRef (scg);
			} else {
				obj.PushVal (scg);
			}
			scg.ilGen.Emit (OpCodes.Ldfld, field);
		}
		public override void PushByRef (ScriptCodeGen scg)
		{
			if (field.ReflectedType.IsValueType) {
				obj.PushByRef (scg);
			} else {
				obj.PushVal (scg);
			}
			scg.ilGen.Emit (OpCodes.Ldflda, field);
		}
		public override void PopPre (ScriptCodeGen scg)
		{
			if (field.ReflectedType.IsValueType) {
				obj.PushByRef (scg);
			} else {
				obj.PushVal (scg);
			}
		}
		public override void PopPost (ScriptCodeGen scg)
		{
			scg.ilGen.Emit (OpCodes.Stfld, field);
		}
	}

	// The value is a float constant
	public class CompValuFloat : CompValu {
		public SCRIPTFLOAT x;

		public CompValuFloat (TokenType type, SCRIPTFLOAT x) : base (type)
		{
			if (!(this.type is TokenTypeFloat)) {
				this.type = new TokenTypeFloat (this.type);
			}
			this.x = x;
		}
		public override void PushVal (ScriptCodeGen scg)
		{
#define double OpCodes.Ldc_R8
#define float  OpCodes.Ldc_R4
			scg.ilGen.Emit (SCRIPTFLOAT, x);
#undef double
#undef float
		}
		public override void PushByRef (ScriptCodeGen scg)
		{
			throw new Exception ("cannot get float address");
		}
		public override void PopPost (ScriptCodeGen scg)
		{
			throw new Exception ("cannot store into float");
		}
	}

	// The value is the entrypoint of a script-defined global function/method
	public class CompValuGlobalMeth : CompValu {
		private TokenDeclFunc func;

		public CompValuGlobalMeth (TokenDeclFunc declFunc, TokenTypeDelegate type) : base (type)
		{
			this.func = declFunc;
		}

		public override void PushVal (ScriptCodeGen scg)
		{
			this.CallPre (scg);
			scg.ilGen.Emit (OpCodes.Ldftn, func.ilGen);
			scg.ilGen.Emit (OpCodes.Newobj, ((TokenTypeDelegate)type).GetConstructorInfo ());
		}
		public override void PushByRef (ScriptCodeGen scg)
		{
			throw new Exception ("cannot get ref to global method");
		}
		public override void PopPost (ScriptCodeGen scg)
		{
			throw new Exception ("cannot store into global method");
		}

		public override void CallPre (ScriptCodeGen scg)
		{
			// all script-defined global functions/methods are static methods created by DynamicMethod()
			// and the first argument is always the XMR_Instance pointer
			// so we always can simply forward it from one function/method to the next
			scg.ilGen.Emit (OpCodes.Ldarg_0);
		}
		public override void CallPost (ScriptCodeGen scg)
		{
			scg.ilGen.Emit (OpCodes.Call, func.ilGen);
		}
	}

	// The value is the entrypoint of an internal instance method
	// such as XMR_Array.index()
	public class CompValuIntInstMeth : CompValu {
		private CompValu baseRVal;
		private MethodInfo mi;

		public CompValuIntInstMeth (TokenTypeDelegate type, CompValu baseRVal, MethodInfo mi) : base (type)
		{
			this.baseRVal = baseRVal;
			this.mi = mi;
		}

		public override void PushVal (ScriptCodeGen scg)
		{
			baseRVal.PushVal (scg);
			scg.ilGen.Emit (OpCodes.Ldftn, mi);
			scg.ilGen.Emit (OpCodes.Newobj, ((TokenTypeDelegate)type).GetConstructorInfo ());
		}
		public override void PushByRef (ScriptCodeGen scg)
		{
			throw new Exception ("cannot get ref to instance method");
		}
		public override void PopPost (ScriptCodeGen scg)
		{
			throw new Exception ("cannot store into instance method");
		}

		public override void CallPre (ScriptCodeGen scg)
		{
			baseRVal.PushVal (scg);
		}
		public override void CallPost (ScriptCodeGen scg)
		{
			scg.ilGen.Emit (OpCodes.Call, mi);
		}
	}

	// The value is fetched by calling an internal instance method
	// such as XMR_Array.count
	public class CompValuIntInstROProp : CompValu {
		private CompValu baseRVal;
		private MethodInfo mi;

		public CompValuIntInstROProp (TokenType type, CompValu baseRVal, MethodInfo mi) : base (type)
		{
			this.baseRVal = baseRVal;
			this.mi = mi;
		}

		public override void PushVal (ScriptCodeGen scg)
		{
			baseRVal.PushVal (scg);
			scg.ilGen.Emit (OpCodes.Call, mi);
		}
		public override void PushByRef (ScriptCodeGen scg)
		{
			scg.ErrorMsg (type, "cannot get ref to read-only property");
			scg.ilGen.Emit (OpCodes.Ldnull);
		}
		public override void PopPost (ScriptCodeGen scg)
		{
			scg.ErrorMsg (type, "cannot store into read-only property");
			scg.ilGen.Emit (OpCodes.Pop);
		}
	}

	// The value is in a script-global variable = ScriptModule instance variable
	public class CompValuGlobalVar : CompValu {
		public FieldInfo field;
		public int index;

		private static readonly FieldInfo gblArraysFieldInfo    = typeof (XMRInstAbstract).GetField ("gblArrays");
		private static readonly FieldInfo gblFloatsFieldInfo    = typeof (XMRInstAbstract).GetField ("gblFloats");
		private static readonly FieldInfo gblIntegersFieldInfo  = typeof (XMRInstAbstract).GetField ("gblIntegers");
		private static readonly FieldInfo gblListsFieldInfo     = typeof (XMRInstAbstract).GetField ("gblLists");
		private static readonly FieldInfo gblObjectsFieldInfo   = typeof (XMRInstAbstract).GetField ("gblObjects");
		private static readonly FieldInfo gblRotationsFieldInfo = typeof (XMRInstAbstract).GetField ("gblRotations");
		private static readonly FieldInfo gblStringsFieldInfo   = typeof (XMRInstAbstract).GetField ("gblStrings");
		private static readonly FieldInfo gblVectorsFieldInfo   = typeof (XMRInstAbstract).GetField ("gblVectors");

		public CompValuGlobalVar (TokenDeclVar declVar, ScriptObjCode scriptObjCode) : base (declVar.type)
		{
			if (type is TokenTypeArray) {
				this.field = gblArraysFieldInfo;
				this.index = scriptObjCode.numGblArrays ++;
			}
			if (type is TokenTypeFloat) {
				this.field = gblFloatsFieldInfo;
				this.index = scriptObjCode.numGblFloats ++;
			}
			if (type is TokenTypeInt) {
				this.field = gblIntegersFieldInfo;
				this.index = scriptObjCode.numGblIntegers ++;
			}
			if (type is TokenTypeList) {
				this.field = gblListsFieldInfo;
				this.index = scriptObjCode.numGblLists ++;
			}
			if (type is TokenTypeObject) {
				this.field = gblObjectsFieldInfo;
				this.index = scriptObjCode.numGblObjects ++;
			}
			if (type is TokenTypeRot) {
				this.field = gblRotationsFieldInfo;
				this.index = scriptObjCode.numGblRotations ++;
			}
			if (type is TokenTypeStr) {
				this.field = gblStringsFieldInfo;
				this.index = scriptObjCode.numGblStrings ++;
			}
			if (type is TokenTypeVec) {
				this.field = gblVectorsFieldInfo;
				this.index = scriptObjCode.numGblVectors ++;
			}
			if (this.field == null) {
				throw new Exception ("unsupported type " + type.GetType ().ToString ());
			}
		}
		public override void PushVal (ScriptCodeGen scg)
		{
			scg.ilGen.Emit (OpCodes.Ldarg_0);            // xmrinstance
			scg.ilGen.Emit (OpCodes.Ldfld, field);       // xmrinstance.gbl<Type>s
			scg.PushConstantI4 (index);
			if (type is TokenTypeFloat) {
				if (typeof (SCRIPTFLOAT) == typeof (float)) {
					scg.ilGen.Emit (OpCodes.Ldelem_R4);
				} else if (typeof (SCRIPTFLOAT) == typeof (double)) {
					scg.ilGen.Emit (OpCodes.Ldelem_R8);
				} else {
					throw new Exception ("unknown type");
				}
			} else if (type is TokenTypeInt) {
				scg.ilGen.Emit (OpCodes.Ldelem_I4);
			} else {
				scg.ilGen.Emit (OpCodes.Ldelem, ToSysType());
			}
		}
		public override void PushByRef (ScriptCodeGen scg)
		{
			scg.ilGen.Emit (OpCodes.Ldarg_0);            // xmrinstance
			scg.ilGen.Emit (OpCodes.Ldfld, field);       // xmrinstance.gbl<Type>s
			scg.PushConstantI4 (index);
			scg.ilGen.Emit (OpCodes.Ldelema, ToSysType());
		}
		public override void PopPre (ScriptCodeGen scg)
		{
			scg.ilGen.Emit (OpCodes.Ldarg_0);            // xmrinstance
			scg.ilGen.Emit (OpCodes.Ldfld, field);       // xmrinstance.gbl<Type>s
			scg.PushConstantI4 (index);
		}
		public override void PopPost (ScriptCodeGen scg)
		{
			if (type is TokenTypeFloat) {
				if (typeof (SCRIPTFLOAT) == typeof (float)) {
					scg.ilGen.Emit (OpCodes.Stelem_R4);
				} else if (typeof (SCRIPTFLOAT) == typeof (double)) {
					scg.ilGen.Emit (OpCodes.Stelem_R8);
				} else {
					throw new Exception ("unknown type");
				}
			} else if (type is TokenTypeInt) {
				scg.ilGen.Emit (OpCodes.Stelem_I4);
			} else {
				scg.ilGen.Emit (OpCodes.Stelem, ToSysType());
			}
		}
	}

	// The value is an integer constant
	public class CompValuInteger : CompValu {
		public int x;

		public CompValuInteger (TokenType type, int x) : base (type)
		{
			if (!(this.type is TokenTypeInt)) {
				this.type = new TokenTypeInt (this.type);
			}
			this.x = x;
		}
		public override void PushVal (ScriptCodeGen scg)
		{
			scg.PushConstantI4 (x);
		}
		public override void PushByRef (ScriptCodeGen scg)
		{
			throw new Exception ("cannot get integer address");
		}
		public override void PopPost (ScriptCodeGen scg)
		{
			throw new Exception ("cannot store into integer");
		}
	}

	// The value is a null
	public class CompValuNull : CompValu {
		public CompValuNull (TokenType type) : base (type) { }
		public override void PushVal (ScriptCodeGen scg)
		{
			scg.ilGen.Emit (OpCodes.Ldnull);
		}
		public override void PushByRef (ScriptCodeGen scg)
		{
			throw new Exception ("cannot get null address");
		}
		public override void PopPost (ScriptCodeGen scg)
		{
			throw new Exception ("cannot store into null");
		}
	}

	// The value is a rotation
	public class CompValuRot : CompValu {
		public CompValu x;
		public CompValu y;
		public CompValu z;
		public CompValu w;

		private static readonly ConstructorInfo lslRotConstructorInfo = 
				typeof (LSL_Rotation).GetConstructor (new Type[] { typeof (SCRIPTFLOAT), 
				                                                   typeof (SCRIPTFLOAT), 
				                                                   typeof (SCRIPTFLOAT), 
				                                                   typeof (SCRIPTFLOAT) });

		public CompValuRot (TokenType type, CompValu x, CompValu y, CompValu z, CompValu w) :
				base (type)
		{
			if (!(type is TokenTypeRot)) {
				this.type = new TokenTypeRot (type);
			}
			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;
		}
		public override void PushVal (ScriptCodeGen scg)
		{
			this.x.PushVal (scg, new TokenTypeFloat (this.x.type));
			this.y.PushVal (scg, new TokenTypeFloat (this.y.type));
			this.z.PushVal (scg, new TokenTypeFloat (this.z.type));
			this.w.PushVal (scg, new TokenTypeFloat (this.w.type));
			scg.ilGen.Emit (OpCodes.Newobj, lslRotConstructorInfo);
		}
		public override void PushByRef (ScriptCodeGen scg)
		{
			throw new Exception ("cannot get rotation address");
		}
		public override void PopPost (ScriptCodeGen scg)
		{
			throw new Exception ("cannot store into rotation");
		}
	}

	// The value is in a static field of a class
	public class CompValuSField : CompValu {
		public FieldInfo field;

		public CompValuSField (TokenType type, FieldInfo field) : base (type)
		{
			this.field = field;
		}
		public override void PushVal (ScriptCodeGen scg)
		{
			if ((field.Attributes & FieldAttributes.Literal) == 0) {
				scg.ilGen.Emit (OpCodes.Ldsfld, field);
				return;
			}
			if (field.FieldType == typeof (LSL_Rotation)) {
				LSL_Rotation rot = (LSL_Rotation)field.GetValue (null);
				scg.ilGen.Emit (OpCodes.Ldc_R8, rot.x);
				scg.ilGen.Emit (OpCodes.Ldc_R8, rot.y);
				scg.ilGen.Emit (OpCodes.Ldc_R8, rot.z);
				scg.ilGen.Emit (OpCodes.Ldc_R8, rot.s);
				scg.ilGen.Emit (OpCodes.Newobj, ScriptCodeGen.lslRotationConstructorInfo);
				return;
			}
			if (field.FieldType == typeof (LSL_Vector)) {
				LSL_Vector vec = (LSL_Vector)field.GetValue (null);
				scg.ilGen.Emit (OpCodes.Ldc_R8, vec.x);
				scg.ilGen.Emit (OpCodes.Ldc_R8, vec.y);
				scg.ilGen.Emit (OpCodes.Ldc_R8, vec.z);
				scg.ilGen.Emit (OpCodes.Newobj, ScriptCodeGen.lslRotationConstructorInfo);
				return;
			}
			if (field.FieldType == typeof (string)) {
				string str = (string)field.GetValue (null);
				scg.ilGen.Emit (OpCodes.Ldstr, str);
				return;
			}
			throw new Exception ("unsupported literal type " + field.FieldType.Name);
		}
		public override void PushByRef (ScriptCodeGen scg)
		{
			if ((field.Attributes & FieldAttributes.Literal) != 0) {
				throw new Exception ("can't write a constant");
			}
			scg.ilGen.Emit (OpCodes.Ldflda, field);
		}
		public override void PopPre (ScriptCodeGen scg)
		{
		}
		public override void PopPost (ScriptCodeGen scg)
		{
			if ((field.Attributes & FieldAttributes.Literal) != 0) {
				throw new Exception ("can't write a constant");
			}
			scg.ilGen.Emit (OpCodes.Stsfld, field);
		}
	}

	// The value is a string constant
	public class CompValuString : CompValu {
		public string x;

		public CompValuString (TokenType type, string x) : base (type)
		{
			if (!(this.type is TokenTypeStr)) {
				this.type = new TokenTypeStr (this.type);
			}
			this.x = x;
		}
		public override void PushVal (ScriptCodeGen scg)
		{
			scg.ilGen.Emit (OpCodes.Ldstr, x);
		}
		public override void PushByRef (ScriptCodeGen scg)
		{
			throw new Exception ("cannot get string address");
		}
		public override void PopPost (ScriptCodeGen scg)
		{
			throw new Exception ("cannot store into string");
		}
	}

	// The value is kept in a temp local variable
	public class CompValuTemp : CompValu {
		private ScriptMyLocal localBuilder;

		public CompValuTemp (TokenType type, string name, ScriptCodeGen scg) : base (type)
		{
			if (name == null) {
				name = "__tmp_" + (++ scg.tempCompValuNum);
			}
			this.localBuilder = scg.ilGen.DeclareLocal (ToSysType(), name);
			scg.activeTemps.AddLast (this);
		}
		public override void PushVal (ScriptCodeGen scg)
		{
			scg.ilGen.Emit (OpCodes.Ldloc, localBuilder);
		}
		public override void PushByRef (ScriptCodeGen scg)
		{
			scg.ilGen.Emit (OpCodes.Ldloca, localBuilder);
		}
		public override void PopPost (ScriptCodeGen scg)
		{
			scg.ilGen.Emit (OpCodes.Stloc, localBuilder);
		}
	}

	// The value is a vector
	public class CompValuVec : CompValu {
		public CompValu x;
		public CompValu y;
		public CompValu z;

		private static readonly ConstructorInfo lslVecConstructorInfo = 
				typeof (LSL_Vector).GetConstructor (new Type[] { typeof (SCRIPTFLOAT), 
				                                                 typeof (SCRIPTFLOAT), 
				                                                 typeof (SCRIPTFLOAT) });

		public CompValuVec (TokenType type, CompValu x, CompValu y, CompValu z) : base (type)
		{
			if (!(type is TokenTypeVec)) {
				this.type = new TokenTypeVec (type);
			}
			this.x = x;
			this.y = y;
			this.z = z;
		}
		public override void PushVal (ScriptCodeGen scg)
		{
			this.x.PushVal (scg, new TokenTypeFloat (this.x.type));
			this.y.PushVal (scg, new TokenTypeFloat (this.y.type));
			this.z.PushVal (scg, new TokenTypeFloat (this.z.type));
			scg.ilGen.Emit (OpCodes.Newobj, lslVecConstructorInfo);
		}
		public override void PushByRef (ScriptCodeGen scg)
		{
			throw new Exception ("cannot get vector address");
		}
		public override void PopPost (ScriptCodeGen scg)
		{
			throw new Exception ("cannot store into vector");
		}
	}

	// Used to indicate value will be discarded (eg, where to put return value from a call)
	public class CompValuVoid : CompValu {
		public CompValuVoid (Token token) : base (null)
		{
			if (token is TokenTypeVoid) {
				this.type = (TokenTypeVoid)token;
			} else {
				this.type = new TokenTypeVoid (type);
			}
		}
		public override void PushVal (ScriptCodeGen scg) { }
		public override void PushByRef (ScriptCodeGen scg)
		{
			throw new Exception ("cannot get void address");
		}
		public override void PopPost (ScriptCodeGen scg) { }
	}
}
