/***************************************************\
 *  COPYRIGHT 2012, Mike Rieker, Beverly, MA, USA  *
 *  All rights reserved.                           *
\***************************************************/

#include "lsltypes.h"

using System;
using System.Reflection.Emit;

namespace OpenSim.Region.ScriptEngine.XMREngine
{
    public class XMRSDTypeClObj
    {
        /*
         * Which script instance we are part of so we can access
         * the script's global variables and functions.
         */
        public XMRInstAbstract xmrInst;

        /*
         * What class we actually are in the hierarchy
         * used for casting.
         */
        public TokenDeclSDTypeClass sdtcClass;

        /*
         * Our VTable array, used for calling virtual functions.
         * And ITable array, used for calling our implementation of interface functions.
         */
        public Delegate[]   sdtcVTable;
        public Delegate[][] sdtcITable;

        /*
         * These arrays hold the insance variable values.
         * The array lengths are determined by the script compilation,
         * and are found in TokenDeclSDTypeClass.instSizes.
         */
        public XMRInstArrays instVars;

        /**
         * @brief Called by script's $new() to initialize a new object.
         */
        public XMRSDTypeClObj (XMRInstAbstract inst, int classindex)
        {
            Construct (inst, classindex);
            instVars.AllocVarArrays (ref sdtcClass.instSizes);
        }

        /**
         * @brief Set up everything except the instVars arrays.
         * @param inst = script instance this object is part of
         * @param classindex = which script-defined type class this object is an onstance of
         * @returns with the vtables filled in
         */
        private void Construct (XMRInstAbstract inst, int classindex)
        {
            Delegate[] thisMid = null;
            TokenDeclSDTypeClass clas = (TokenDeclSDTypeClass)inst.m_ObjCode.sdObjTypesIndx[classindex];

            xmrInst   = inst;
            sdtcClass = clas;

            /*
             * VTable consists of delegates built from DynamicMethods and the 'this' pointer.
             * Yes, yes, lots of shitty little mallocs.
             */
            DynamicMethod[] vDynMeths = clas.vDynMeths;
            if (vDynMeths != null) {
                int n = vDynMeths.Length;
                Type[] vMethTypes = clas.vMethTypes;
                sdtcVTable = new Delegate[n];
                for (int i = 0; i < n; i ++) {
                    sdtcVTable[i] = vDynMeths[i].CreateDelegate (vMethTypes[i], this);
                }
            }

            /*
             * Fill in interface vtables.
             * There is one array of delegates for each implemented interface.
             * The array of delegates IS the interface's object, ie, the 'this' value of the interface.
             * To cast from the class type to the interface type, just get the correct array from the table.
             * To cast from the interface type to the class type, just get Target of entry 0.
             *
             * So we end up with this:
             *    sdtcITable[interfacenumber][methodofintfnumber] = delegate of this.ourimplementationofinterfacesmethod
             */
            if (clas.iDynMeths != null) {
                int nIFaces = clas.iDynMeths.Length;
                sdtcITable = new Delegate[nIFaces][];
                for (int i = 0; i < nIFaces; i ++) {

                    // get vector of entrypoints of our instance methods that implement that interface
                    DynamicMethod[] iDynMeths = clas.iDynMeths[i];
                    Type[]         iMethTypes = clas.iMethTypes[i];

                    // allocate an array with a slot for each method the interface defines
                    int nMeths = iDynMeths.Length;
                    Delegate[] ivec;
                    if (nMeths > 0) {
                        // fill in the array with delegates that reference back to this class instance
                        ivec = new Delegate[nMeths];
                        for (int j = 0; j < nMeths; j ++) {
                            ivec[j] = iDynMeths[j].CreateDelegate (iMethTypes[j], this);
                        }
                    } else {
                        // just a marker interface with no methods,
                        // allocate a one-element array and fill
                        // with a dummy entry.  this will allow casting
                        // back to the original class instance (this)
                        // by reading Target of entry 0.
                        if (thisMid == null) {
                            thisMid = new Delegate[1];
                            thisMid[0] = markerInterfaceDummy.CreateDelegate (typeof (MarkerInterfaceDummy), this);
                        }
                        ivec = thisMid;
                    }

                    // save whatever we ended up allocating
                    sdtcITable[i] = ivec;
                }
            }
        }

        private delegate void MarkerInterfaceDummy ();
        private static DynamicMethod markerInterfaceDummy = MakeMarkerInterfaceDummy ();
        private static DynamicMethod MakeMarkerInterfaceDummy ()
        {
            DynamicMethod dm = new DynamicMethod ("XMRSDTypeClObj.MarkerInterfaceDummy", null, null);
            ILGenerator ilGen = dm.GetILGenerator ();
            ilGen.Emit (OpCodes.Ret);
            return dm;
        }

        /**
         * @brief Perform runtime casting of script-defined interface object to
         *        its corresponding script-defined class object.
         * @param da = interface object (array of delegates pointing to class's implementations of interface's methods)
         * @param classindex = what class those implementations are supposedly part of
         * @returns original script-defined class object
         */
        public static XMRSDTypeClObj CastIFace2Class (Delegate[] da, int classindex)
        {
            return CastClass2Class (da[0].Target, classindex);
        }

        /**
         * @brief Perform runtime casting of XMRSDTypeClObj's.
         * @param ob = XMRSDTypeClObj of unknown script-defined class to cast
         * @param classindex = script-defined class to cast it to
         * @returns ob is a valid instance of classindex; else exception thrown
         */
        public static XMRSDTypeClObj CastClass2Class (object ob, int classindex)
        {
            /*
             * Let mono check to see if we at least have an XMRSDTypeClObj.
             */
            XMRSDTypeClObj ci = (XMRSDTypeClObj)ob;
            if (ci != null) {

                /*
                 * This is the target class, ie, what we are hoping the object can cast to.
                 */
                TokenDeclSDTypeClass tc = (TokenDeclSDTypeClass)ci.xmrInst.m_ObjCode.sdObjTypesIndx[classindex];

                /*
                 * Step from the object's actual class rootward.
                 * If we find the target class along the way, the cast is valid.
                 * If we run off the end of the root, the cast is not valid.
                 */
                for (TokenDeclSDTypeClass ac = ci.sdtcClass; ac != tc; ac = ac.extends) {
                    if (ac == null) throw new InvalidCastException ("invalid cast from " + ci.sdtcClass.longName.val + 
                                                                                  " to " + tc.longName.val);
                }

                /*
                 * The target class is at or rootward of the actual class,
                 * so the cast is valid.
                 */
            }
            return ci;
        }

        /**
         * @brief Cast an arbitrary object to the given interface.
         * @param ob = object to be cast of unknown type
         * @returns ob cast to the interface type
         */
        public static Delegate[] CastObj2IFace (object ob, string ifacename)
        {
            if (ob == null) return null;

            /*
             * If it is already one of our interfaces, extract the script-defined class object from it.
             */
            if (ob is Delegate[]) {
                Delegate[] da = (Delegate[])ob;
                ob = da[0].Target;
            }

            /*
             * Now that we have a presumed script-defined class object, cast that to the requested interface
             * by picking the array of delegates that corresponds to the requested interface.
             */
            XMRSDTypeClObj ci = (XMRSDTypeClObj)ob;
            int iFaceIndex = ci.sdtcClass.intfIndices[ifacename];
            return ci.sdtcITable[iFaceIndex];
        }

        /**
         * @brief Copy from one script-defined array to another.
         * @param srcobj = source script-defined array class object pointer
         * @param srcstart = offset in source array to start copying from
         * @param dstobj = destination script-defined array class object pointer
         * @param dststart = offset in destination arry to start copying to
         * @param count = number of elements to copy
         */
        public static void XMRArrayCopy (object srcobj, int srcstart, object dstobj, int dststart, int count)
        {
            /*
             * The script writer should only pass us script-defined class objects.
             * Throw exception otherwise.
             */
            XMRSDTypeClObj srcsdt = (XMRSDTypeClObj)srcobj;
            XMRSDTypeClObj dstsdt = (XMRSDTypeClObj)dstobj;

            /*
             * Get the script-visible type name of the arrays, brackets and all.
             */
            string srctypename = srcsdt.sdtcClass.longName.val;
            string dsttypename = dstsdt.sdtcClass.longName.val;

            /*
             * The part before the first '[' of each should match exactly,
             * meaning the basic data type (eg, float, List<string>) is the same.
             * And there must be a '[' in each meaning that it is a script-defined array type.
             */
            int i = srctypename.IndexOf ('[');
            int j = dsttypename.IndexOf ('[');
            if ((i < 0) || (j < 0)) throw new InvalidCastException ("non-array passed: " + srctypename + " and/or " + dsttypename);
            if ((i != j) || !srctypename.StartsWith (dsttypename.Substring (0, j))) {
                throw new ArrayTypeMismatchException (srctypename + " vs " + dsttypename);
            }

            /*
             * The number of brackets must match exactly.
             * This permits copying from something like a float[,][] to something like a float[][].
             * But you cannot copy from a float[][] to a float[] or wisa wersa.
             * Counting either '[' or ']' would work equally well.
             */
            int srclen  = srctypename.Length;
            int dstlen  = dsttypename.Length;
            int srcjags = 0;
            int dstjags = 0;
            while (++ i < srclen) if (srctypename[i] == ']') srcjags ++;
            while (++ j < dstlen) if (dsttypename[j] == ']') dstjags ++;
            if (dstjags != srcjags) {
                throw new ArrayTypeMismatchException (srctypename + " vs " + dsttypename);
            }

            /*
             * Perform the copy.
             */
            Array srcarray = (Array)srcsdt.instVars.iarObjects[0];
            Array dstarray = (Array)dstsdt.instVars.iarObjects[0];
            Array.Copy (srcarray, srcstart, dstarray, dststart, count);
        }

        /**
         * @brief Write the whole thing out to a stream.
         */
        public void Capture (XMRInstArrays.Sender sendValue)
        {
            sendValue (this.sdtcClass.sdTypeIndex);
            this.instVars.SendArrays (sendValue);
        }

        /**
         * @brief Read the whole thing in from a stream.
         */
        public XMRSDTypeClObj () { }
        public void Restore (XMRInstAbstract inst, XMRInstArrays.Recver recvValue)
        {
            int classindex = (int)recvValue ();
            Construct (inst, classindex);
            this.instVars.RecvArrays (recvValue);
        }
    }
}
