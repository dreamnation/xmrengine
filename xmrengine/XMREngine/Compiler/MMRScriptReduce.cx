/***************************************************\
 *  COPYRIGHT 2009, Mike Rieker, Beverly, MA, USA  *
 *  All rights reserved.                           *
\***************************************************/

/**
 * @brief Reduce raw tokens to a single script token.
 * 
 * Usage:
 *
 *  tokenBegin = returned by TokenBegin.Analyze ()
 *               representing the whole script source
 *               as a flat list of tokens
 *
 *  TokenScript tokenScript = Reduce.Analyze (TokenBegin tokenBegin);
 *  
 *  tokenScript = represents the whole script source
 *                as a tree of tokens
 *
 * Any of the tokens can be disassembled with ToString ().
 * To get the entire source disassembled, do this:
 *  string scriptSource = tokenScript.toString ();
 */

using System;
using System.Collections.Generic;
using System.Reflection;
using System.Reflection.Emit;

#include "lsltypes.h"

namespace OpenSim.Region.ScriptEngine.XMREngine {

	public class ScriptReduce {

		private static Dictionary<Type, int> precedence = PrecedenceInit ();

		private Type[] brkCloseOnly     = new Type[] { typeof (TokenKwBrkClose) };
		private Type[] cmpGTOnly        = new Type[] { typeof (TokenKwCmpGT)    };
		private Type[] colonOnly        = new Type[] { typeof (TokenKwColon)    };
		private Type[] colonOrDotDotDot = new Type[] { typeof (TokenKwColon),   typeof (TokenKwDotDotDot) };
		private Type[] parCloseOnly     = new Type[] { typeof (TokenKwParClose) };
		private Type[] semiOnly         = new Type[] { typeof (TokenKwSemi)     };

		/**
		 * @brief Initialize operator precedence table
		 * @returns with precedence table pointer
		 */
		private static Dictionary<Type, int> PrecedenceInit ()
		{
			Dictionary<Type, int> p = new Dictionary<Type, int> ();

			// http://www.lslwiki.net/lslwiki/wakka.php?wakka=operators

			p.Add (typeof (TokenKwComma),   30);

#define ASNPR 50
			p.Add (typeof (TokenKwAsnLSh), ASNPR);  // all assignment operators of equal precedence
			p.Add (typeof (TokenKwAsnRSh), ASNPR);  // ... so they get processed strictly right-to-left
			p.Add (typeof (TokenKwAsnAdd), ASNPR);
			p.Add (typeof (TokenKwAsnAnd), ASNPR);
			p.Add (typeof (TokenKwAsnSub), ASNPR);
			p.Add (typeof (TokenKwAsnMul), ASNPR);
			p.Add (typeof (TokenKwAsnDiv), ASNPR);
			p.Add (typeof (TokenKwAsnMod), ASNPR);
			p.Add (typeof (TokenKwAsnOr),  ASNPR);
			p.Add (typeof (TokenKwAsnXor), ASNPR);
			p.Add (typeof (TokenKwAssign), ASNPR);

			p.Add (typeof (TokenKwOrOr),   100);

			p.Add (typeof (TokenKwAndAnd), 120);

			p.Add (typeof (TokenKwOr),     140);

			p.Add (typeof (TokenKwXor),    160);

			p.Add (typeof (TokenKwAnd),    180);

			p.Add (typeof (TokenKwCmpEQ),  200);
			p.Add (typeof (TokenKwCmpNE),  200);

			p.Add (typeof (TokenKwCmpLT),  240);
			p.Add (typeof (TokenKwCmpLE),  240);
			p.Add (typeof (TokenKwCmpGT),  240);
			p.Add (typeof (TokenKwCmpGE),  240);

			p.Add (typeof (TokenKwRSh),    260);
			p.Add (typeof (TokenKwLSh),    260);

			p.Add (typeof (TokenKwAdd),    280);
			p.Add (typeof (TokenKwSub),    280);

			p.Add (typeof (TokenKwMul),    320);
			p.Add (typeof (TokenKwDiv),    320);
			p.Add (typeof (TokenKwMod),    320);

			return p;
		}

		/**
		 * @brief Reduce raw token stream to a single script token.
		 *        Performs a little semantic testing, ie, undefined variables, etc.
		 * @param tokenBegin = points to a TokenBegin
		 *                     followed by raw tokens
		 *                     and last token is a TokenEnd
		 * @returns null: not a valid script, error messages have been output
		 *          else: valid script top token
		 */
		public static TokenScript Reduce (TokenBegin tokenBegin)
		{
			return new ScriptReduce (tokenBegin.nextToken).tokenScript;
		}

		/*
		 * Instance variables.
		 */
		private bool errors = false;
		private TokenDeclFunc currentDeclFunc = null;
		private TokenScript tokenScript;
		private TokenStmtBlock currentStmtBlock = null;

		/**
		 * @brief the constructor does all the processing.
		 * @param token = first token of script after the TokenBegin token
		 * @returns tokenScript = null: there were errors
		 *                        else: successful
		 */
		private ScriptReduce (Token token)
		{
			/*
			 * Create a place to put the top-level script components,
			 * eg, state bodies, functions, global variables.
			 */
			tokenScript = new TokenScript (token);

			/*
			 * Scan through the tokens until we reach the end.
			 */
			while (!(token is TokenEnd)) {

				/*
				 * constant <name> = <rval> ;
				 */
				if (token is TokenKwConst) {
					ParseDeclVar (ref token, tokenScript.vars);
					continue;
				}

				/*
				 * <type> <name> ;
				 * <type> <name> = <rval> ;
				 */
				if ((token is TokenType) &&
				    (token.nextToken is TokenName) &&
				    ((token.nextToken.nextToken is TokenKwSemi) || 
				     (token.nextToken.nextToken is TokenKwAssign))) {
					ParseDeclVar (ref token, tokenScript.vars);
					continue;
				}

				/*
				 * <type> <name> <funcargs> <funcbody>
				 */
				if (token is TokenType) {
					TokenType tokenType = (TokenType)token;

					token = token.nextToken;
					if (!(token is TokenName)) {
						ErrorMsg (token, "expecting variable/function name");
						token = SkipPastSemi (token);
						continue;
					}
					TokenName tokenName = (TokenName)token;
					token = token.nextToken;
					if (token is TokenKwParOpen) {

						/*
						 * <type> <name> (
						 * global function definition
						 */
						token = tokenType;
						TokenDeclFunc tokenDeclFunc = ParseDeclFunc (ref token);
						if (tokenDeclFunc == null) continue;
						if (tokenScript.funcs.ContainsKey (tokenName.val)) {
							ErrorMsg (tokenName, "duplicate function name");
							continue;
						}
						tokenScript.funcs.Add (tokenName.val, tokenDeclFunc);
						continue;
					}
					ErrorMsg (token, "<type> <name> must be followed by ; = or (");
					token = SkipPastSemi (token);
					continue;
				}

				/*
				 * <name> <funcargs> <funcbody>
				 * global function returning void
				 */
				if (token is TokenName) {
					TokenName tokenName = (TokenName)token;
					token = token.nextToken;
					if (!(token is TokenKwParOpen)) {
						ErrorMsg (token, "looking for open paren after assuming " + 
						                 tokenName.val + " is a function name");
						token = SkipPastSemi (token);
						continue;
					}
					token = tokenName;
					TokenDeclFunc tokenDeclFunc = ParseDeclFunc (ref token);
					if (tokenDeclFunc == null) continue;
					tokenDeclFunc.retType = new TokenTypeVoid (tokenName);
					if (tokenScript.funcs.ContainsKey (tokenName.val)) {
						ErrorMsg (tokenName, "duplicate function name");
						continue;
					}
					tokenScript.funcs.Add (tokenDeclFunc.funcName.val, tokenDeclFunc);
					continue;
				}

				/*
				 * default <statebody>
				 */
				if (token is TokenKwDefault) {
					TokenDeclState tokenDeclState = new TokenDeclState (token);
					token = token.nextToken;
					tokenDeclState.body = ParseStateBody (ref token);
					if (tokenDeclState.body == null) continue;
					if (tokenScript.defaultState != null) {
						ErrorMsg (tokenDeclState, "default state already declared");
						continue;
					}
					tokenScript.defaultState = tokenDeclState;
					continue;
				}

				/*
				 * state <name> <statebody>
				 */
				if (token is TokenKwState) {
					TokenDeclState tokenDeclState = new TokenDeclState (token);
					token = token.nextToken;
					if (!(token is TokenName)) {
						ErrorMsg (token, "state must be followed by state name");
						token = SkipPastSemi (token);
						continue;
					}
					tokenDeclState.name = (TokenName)token;
					token = token.nextToken;
					tokenDeclState.body = ParseStateBody (ref token);
					if (tokenDeclState.body == null) continue;
					if (tokenScript.states.ContainsKey (tokenDeclState.name.val)) {
						ErrorMsg (tokenDeclState.name, "duplicate state definition");
						continue;
					}
					tokenScript.states.Add (tokenDeclState.name.val, tokenDeclState);
					continue;
				}

				/*
				 * Doesn't fit any of those forms, output message and skip to next statement.
				 */
				ErrorMsg (token, "looking for var name, type, state or default");
				token = SkipPastSemi (token);
				continue;
			}

			/*
			 * Must have a default state to start in.
			 */
			if (!errors && (tokenScript.defaultState == null)) {
				ErrorMsg (tokenScript, "no default state defined");
			}

			/*
			 * If any error messages were written out, set return value to null.
			 */
			if (errors) tokenScript = null;
		}

		/**
		 * @brief parse state body (including all its event handlers)
		 * @param token = points to TokenKwBrcOpen
		 * @returns null: state body parse error
		 *          else: token representing state
		 *          token = points past close brace
		 */
		private TokenStateBody ParseStateBody (ref Token token)
		{
			TokenStateBody tokenStateBody = new TokenStateBody (token);

			if (!(token is TokenKwBrcOpen)) {
				ErrorMsg (token, "expecting { at beg of state");
				token = SkipPastSemi (token);
				return null;
			}

			token = token.nextToken;
			while (!(token is TokenKwBrcClose)) {
				if (token is TokenEnd) {
					ErrorMsg (tokenStateBody, "eof parsing state body");
					return null;
				}
				TokenDeclFunc tokenDeclFunc = ParseDeclFunc (ref token);
				if (tokenDeclFunc == null) return null;
				if (!(tokenDeclFunc.retType is TokenTypeVoid)) {
					ErrorMsg (tokenDeclFunc.retType, "event handlers don't have return types");
					return null;
				}
				tokenDeclFunc.nextToken = tokenStateBody.eventFuncs;
				tokenStateBody.eventFuncs = tokenDeclFunc;
			}
			token = token.nextToken;
			return tokenStateBody;
		}

		/**
		 * @brief parse a function declaration, including its arg list and body
		 * @param token = points to function type token (or function name token if void)
		 * @returns null: error parsing function definition
		 *          else: function declaration
		 *          token = advanced just past function, ie, just past the closing brace
		 */
		private TokenDeclFunc ParseDeclFunc (ref Token token)
		{
			TokenType tokenType;
			if (token is TokenType) {
				tokenType = (TokenType)token;
				token = token.nextToken;
			} else {
				tokenType = new TokenTypeVoid (token);
			}
			if (!(token is TokenName)) {
				ErrorMsg (token, "expecting function name");
				token = SkipPastSemi (token);
				return null;
			}
			TokenName tokenName = (TokenName)token;
			token = token.nextToken;
			TokenDeclFunc tokenDeclFunc = new TokenDeclFunc (tokenName);
			tokenDeclFunc.retType  = tokenType;
			tokenDeclFunc.funcName = tokenName;
			tokenDeclFunc.argDecl  = ParseFuncArgs (ref token);

			TokenDeclFunc saveDeclFunc = currentDeclFunc;
			currentDeclFunc = tokenDeclFunc;
			tokenDeclFunc.body = ParseStmtBlock (ref token);
			currentDeclFunc = saveDeclFunc;

			if ((tokenDeclFunc.argDecl == null) || (tokenDeclFunc.body == null)) return null;
			return tokenDeclFunc;
		}

		/**
		 * @brief Parse statement
		 * @param token = first token of statement
		 * @returns null: parse error
		 *          else: token representing whole statement
		 *          token = points past statement
		 */
		private TokenStmt ParseStmt (ref Token token)
		{
			/*
			 * Statements that begin with a specific keyword.
			 */
			if (token is TokenKwAt)      return ParseStmtLabel   (ref token);
			if (token is TokenKwBrcOpen) return ParseStmtBlock   (ref token);
			if (token is TokenKwBreak)   return ParseStmtBreak   (ref token);
			if (token is TokenKwCont)    return ParseStmtCont    (ref token);
			if (token is TokenKwDo)      return ParseStmtDo      (ref token);
			if (token is TokenKwFor)     return ParseStmtFor     (ref token);
			if (token is TokenKwForEach) return ParseStmtForEach (ref token);
			if (token is TokenKwIf)      return ParseStmtIf      (ref token);
			if (token is TokenKwJump)    return ParseStmtJump    (ref token);
			if (token is TokenKwRet)     return ParseStmtRet     (ref token);
			if (token is TokenKwSemi)    return ParseStmtNull    (ref token);
			if (token is TokenKwState)   return ParseStmtState   (ref token);
			if (token is TokenKwSwitch)  return ParseStmtSwitch  (ref token);
			if (token is TokenKwThrow)   return ParseStmtThrow   (ref token);
			if (token is TokenKwTry)     return ParseStmtTry     (ref token);
			if (token is TokenKwWhile)   return ParseStmtWhile   (ref token);

			/*
			 * Try to parse anything else as an expression, possibly calling
			 * something and/or writing to a variable.
			 */
			TokenRVal tokenRVal = ParseRVal (ref token, semiOnly);
			if (tokenRVal != null) {
				TokenStmtRVal tokenStmtRVal = new TokenStmtRVal (tokenRVal);
				tokenStmtRVal.rVal = tokenRVal;
				return tokenStmtRVal;
			}

			/*
			 * Who knows what it is...
			 */
			ErrorMsg (token, "unknown statement");
			token = SkipPastSemi (token);
			return null;
		}

		/**
		 * @brief parse a statement block, ie, group of statements between braces
		 * @param token = points to { token
		 * @returns null: error parsing
		 *          else: statements bundled in this token
		 *          token = advanced just past the } token
		 */
		private TokenStmtBlock ParseStmtBlock (ref Token token)
		{
			if (!(token is TokenKwBrcOpen)) {
				ErrorMsg (token, "statement block body must begin with a {");
				token = SkipPastSemi (token);
				return null;
			}
			TokenStmtBlock tokenStmtBlock = new TokenStmtBlock (token);
			tokenStmtBlock.function = currentDeclFunc;
			tokenStmtBlock.outerStmtBlock = currentStmtBlock;
			currentStmtBlock = tokenStmtBlock;
			Token prevStmt = null;
			token = token.nextToken;
			while (!(token is TokenKwBrcClose)) {
				if (token is TokenEnd) {
					ErrorMsg (tokenStmtBlock, "missing }");
					currentStmtBlock = tokenStmtBlock.outerStmtBlock;
					return null;
				}
				Token thisStmt;
				if ((token is TokenType) || (token is TokenKwConst)) {
					thisStmt = ParseDeclVar (ref token, currentStmtBlock.variables);
				} else {
					thisStmt = ParseStmt (ref token);
				}
				if (thisStmt == null) return null;
				if (prevStmt == null) tokenStmtBlock.statements = thisStmt;
				                 else prevStmt.nextToken = thisStmt;
				prevStmt = thisStmt;
			}
			token = token.nextToken;
			currentStmtBlock = tokenStmtBlock.outerStmtBlock;
			return tokenStmtBlock;
		}

		/**
		 * @brief parse a 'break' statement
		 * @param token = points to break keyword token
		 * @returns null: error parsing
		 *          else: statements bundled in this token
		 *          token = advanced just past the ; token
		 */
		private TokenStmtBreak ParseStmtBreak (ref Token token)
		{
			TokenStmtBreak tokenStmtBreak = new TokenStmtBreak (token);
			token = token.nextToken;
			if (!(token is TokenKwSemi)) {
				ErrorMsg (token, "expecting ;");
				token = SkipPastSemi (token);
				return null;
			}
			token = token.nextToken;
			return tokenStmtBreak;
		}

		/**
		 * @brief parse a 'continue' statement
		 * @param token = points to continue keyword token
		 * @returns null: error parsing
		 *          else: statements bundled in this token
		 *          token = advanced just past the ; token
		 */
		private TokenStmtCont ParseStmtCont (ref Token token)
		{
			TokenStmtCont tokenStmtCont = new TokenStmtCont (token);
			token = token.nextToken;
			if (!(token is TokenKwSemi)) {
				ErrorMsg (token, "expecting ;");
				token = SkipPastSemi (token);
				return null;
			}
			token = token.nextToken;
			return tokenStmtCont;
		}

		/**
		 * @brief parse a 'do' statement
		 * @params token = points to 'do' keyword token
		 * @returns null: parse error
		 *          else: pointer to token encapsulating the do statement, including body
		 *          token = advanced just past the body statement
		 */
		private TokenStmtDo ParseStmtDo (ref Token token)
		{
			TokenStmtDo tokenStmtDo = new TokenStmtDo (token);
			token = token.nextToken;
			tokenStmtDo.bodyStmt = ParseStmt (ref token);
			if (tokenStmtDo.bodyStmt == null) return null;
			if (!(token is TokenKwWhile)) {
				ErrorMsg (token, "expecting while clause");
				return null;
			}
			token = token.nextToken;
			tokenStmtDo.testRVal = ParseRValParen (ref token);
			if (tokenStmtDo.testRVal == null) return null;
			if (!(token is TokenKwSemi)) {
				ErrorMsg (token, "while clause must terminate on semicolon");
				token = SkipPastSemi (token);
				return null;
			}
			token = token.nextToken;
			return tokenStmtDo;
		}

		/**
		 * @brief parse a for statement
		 * @param token = points to 'for' keyword token
		 * @returns null: parse error
		 *          else: pointer to encapsulated for statement token
		 *          token = advanced just past for body statement
		 */
		private TokenStmt ParseStmtFor (ref Token token)
		{

			/*
			 * Create encapsulating token and skip past 'for ('
			 */
			TokenStmtFor tokenStmtFor = new TokenStmtFor (token);
			token = token.nextToken;
			if (!(token is TokenKwParOpen)) {
				ErrorMsg (token, "for must be followed by (");
				return null;
			}
			token = token.nextToken;

			/*
			 * If a plain for, ie, not declaring a variable, it's straightforward.
			 */
			if (!(token is TokenType)) {
				tokenStmtFor.initStmt = ParseStmt (ref token);
				if (tokenStmtFor.initStmt == null) return null;
				return ParseStmtFor2 (tokenStmtFor, ref token) ? tokenStmtFor : null;
			}

			/*
			 * Initialization declares a variable, so encapsulate it in a block so
			 * variable has scope only in the for statement, including its body.
			 */
			TokenStmtBlock forStmtBlock = new TokenStmtBlock (tokenStmtFor);
			forStmtBlock.outerStmtBlock = currentStmtBlock;
			forStmtBlock.function       = currentDeclFunc;

			TokenDeclVar tokenDeclVar   = ParseDeclVar (ref token, currentStmtBlock.variables);
			if (tokenDeclVar == null) {
				currentStmtBlock    = forStmtBlock.outerStmtBlock;
				return null;
			}

			forStmtBlock.statements     = tokenDeclVar;
			tokenDeclVar.nextToken      = tokenStmtFor;

			bool ok                     = ParseStmtFor2 (tokenStmtFor, ref token);
			currentStmtBlock            = forStmtBlock.outerStmtBlock;
			return ok ? forStmtBlock : null;
		}

		/**
		 * @brief parse rest of 'for' statement starting with the test expression.
		 * @param tokenStmtFor = token encapsulating the for statement
		 * @param token = points to test expression
		 * @returns false: parse error
		 *           true: successful
		 *          token = points just past body statement
		 */
		private bool ParseStmtFor2 (TokenStmtFor tokenStmtFor, ref Token token)
		{
			if (token is TokenKwSemi) {
				token = token.nextToken;
			} else {
				tokenStmtFor.testRVal = ParseRVal (ref token, semiOnly);
				if (tokenStmtFor.testRVal == null) return false;
			}
			if (token is TokenKwParClose) {
				token = token.nextToken;
			} else {
				tokenStmtFor.incrRVal = ParseRVal (ref token, parCloseOnly);
				if (tokenStmtFor.incrRVal == null) return false;
			}
			tokenStmtFor.bodyStmt = ParseStmt (ref token);
			return tokenStmtFor.bodyStmt != null;
		}

		/**
		 * @brief parse a foreach statement
		 * @param token = points to 'foreach' keyword token
		 * @returns null: parse error
		 *          else: pointer to encapsulated foreach statement token
		 *          token = advanced just past for body statement
		 */
		private TokenStmt ParseStmtForEach (ref Token token)
		{

			/*
			 * Create encapsulating token and skip past 'foreach ('
			 */
			TokenStmtForEach tokenStmtForEach = new TokenStmtForEach (token);
			token = token.nextToken;
			if (!(token is TokenKwParOpen)) {
				ErrorMsg (token, "foreach must be followed by (");
				return null;
			}
			token = token.nextToken;

			if (token is TokenName) {
				tokenStmtForEach.keyLVal = new TokenLValName ((TokenName)token);
				token = token.nextToken;
			}
			if (!(token is TokenKwComma)) {
				ErrorMsg (token, "expecting comma");
				token = SkipPastSemi (token);
				return null;
			}
			token = token.nextToken;
			if (token is TokenName) {
				tokenStmtForEach.valLVal = new TokenLValName ((TokenName)token);
				token = token.nextToken;
			}
			if (!(token is TokenKwIn)) {
				ErrorMsg (token, "expecting 'in'");
				token = SkipPastSemi (token);
				return null;
			}
			token = token.nextToken;
			tokenStmtForEach.arrayLVal = ParseLVal (ref token);
			if (tokenStmtForEach.arrayLVal == null) return null;
			if (!(token is TokenKwParClose)) {
				ErrorMsg (token, "expecting )");
				token = SkipPastSemi (token);
				return null;
			}
			token = token.nextToken;
			tokenStmtForEach.bodyStmt = ParseStmt (ref token);
			if (tokenStmtForEach.bodyStmt == null) return null;
			return tokenStmtForEach;
		}

		private TokenStmtIf ParseStmtIf (ref Token token)
		{
			TokenStmtIf tokenStmtIf = new TokenStmtIf (token);
			token = token.nextToken;
			tokenStmtIf.testRVal = ParseRValParen (ref token);
			if (tokenStmtIf.testRVal == null) return null;
			tokenStmtIf.trueStmt = ParseStmt (ref token);
			if (tokenStmtIf.trueStmt == null) return null;
			if (token is TokenKwElse) {
				token = token.nextToken;
				tokenStmtIf.elseStmt = ParseStmt (ref token);
				if (tokenStmtIf.elseStmt == null) return null;
			}
			return tokenStmtIf;
		}

		private TokenStmtJump ParseStmtJump (ref Token token)
		{

			/*
			 * Create jump statement token to encapsulate the whole statement.
			 */
			TokenStmtJump tokenStmtJump = new TokenStmtJump (token);
			token = token.nextToken;
			if (!(token is TokenName) || !(token.nextToken is TokenKwSemi)) {
				ErrorMsg (token, "expecting label;");
				token = SkipPastSemi (token);
				return null;
			}
			tokenStmtJump.label = (TokenName)token;
			token = token.nextToken.nextToken;

			/*
			 * If label is already defined, it means this is a backward (looping)
			 * jump, so remember the label has backward jump references.
			 */
			if (currentDeclFunc.labels.ContainsKey (tokenStmtJump.label.val)) {
				currentDeclFunc.labels[tokenStmtJump.label.val].hasBkwdRefs = true;
			}

			return tokenStmtJump;
		}

		/**
		 * @brief parse a jump target label statement
		 * @param token = points to the '@' token
		 * @returns null: error parsing
		 *          else: the label
		 *          token = advanced just past the ;
		 */
		private TokenStmtLabel ParseStmtLabel (ref Token token)
		{
			if (!(token.nextToken is TokenName) ||
			    !(token.nextToken.nextToken is TokenKwSemi)) {
				ErrorMsg (token, "invalid label");
				token = SkipPastSemi (token);
				return null;
			}
			TokenStmtLabel stmtLabel = new TokenStmtLabel (token);
			stmtLabel.name  = (TokenName)token.nextToken;
			stmtLabel.block = currentStmtBlock;
			if (currentDeclFunc.labels.ContainsKey (stmtLabel.name.val)) {
				ErrorMsg (token.nextToken, "duplicate label");
				ErrorMsg (currentDeclFunc.labels[stmtLabel.name.val], "previously defined here");
				token = SkipPastSemi (token);
				return null;
			}
			currentDeclFunc.labels.Add (stmtLabel.name.val, stmtLabel);
			token = token.nextToken.nextToken.nextToken;
			return stmtLabel;
		}

		private TokenStmtNull ParseStmtNull (ref Token token)
		{
			TokenStmtNull tokenStmtNull = new TokenStmtNull (token);
			token = token.nextToken;
			return tokenStmtNull;
		}

		private TokenStmtRet ParseStmtRet (ref Token token)
		{
			TokenStmtRet tokenStmtRet = new TokenStmtRet (token);
			token = token.nextToken;
			if (token is TokenKwSemi) {
				token = token.nextToken;
			} else {
				tokenStmtRet.rVal = ParseRVal (ref token, semiOnly);
				if (tokenStmtRet.rVal == null) return null;
			}
			return tokenStmtRet;
		}

		private TokenStmtSwitch ParseStmtSwitch (ref Token token)
		{
			TokenStmtSwitch tokenStmtSwitch = new TokenStmtSwitch (token);
			token = token.nextToken;
			tokenStmtSwitch.testRVal = ParseRValParen (ref token);
			if (tokenStmtSwitch.testRVal == null) return null;
			if (!(token is TokenKwBrcOpen)) {
				ErrorMsg (token, "expecting open brace");
				token = SkipPastSemi (token);
				return null;
			}
			token = token.nextToken;
			TokenSwitchCase tokenSwitchCase = null;
			bool haveComplained = false;
			while (!(token is TokenKwBrcClose)) {
				if (token is TokenKwCase) {
					tokenSwitchCase = new TokenSwitchCase (token);
					if (tokenStmtSwitch.lastCase == null) {
						tokenStmtSwitch.cases = tokenSwitchCase;
					} else {
						tokenStmtSwitch.lastCase.nextCase = tokenSwitchCase;
					}
					tokenStmtSwitch.lastCase =  tokenSwitchCase;

					token = token.nextToken;
					tokenSwitchCase.rVal1 = ParseRVal (ref token, colonOrDotDotDot);
					if (tokenSwitchCase.rVal1 == null) return null;
					if (token is TokenKwDotDotDot) {
						token = token.nextToken;
						tokenSwitchCase.rVal2 = ParseRVal (ref token, colonOnly);
						if (tokenSwitchCase.rVal2 == null) return null;
					} else {
						if (!(token is TokenKwColon)) {
							ErrorMsg (token, "expecting : or ...");
							token = SkipPastSemi (token);
							return null;
						}
						token = token.nextToken;
					}
				} else if (token is TokenKwDefault) {
					tokenSwitchCase = new TokenSwitchCase (token);
					if (tokenStmtSwitch.lastCase == null) {
						tokenStmtSwitch.cases = tokenSwitchCase;
					} else {
						tokenStmtSwitch.lastCase.nextCase = tokenSwitchCase;
					}
					tokenStmtSwitch.lastCase =  tokenSwitchCase;

					token = token.nextToken;
					if (!(token is TokenKwColon)) {
						ErrorMsg (token, "expecting :");
						token = SkipPastSemi (token);
						return null;
					}
					token = token.nextToken;
				} else if (tokenSwitchCase != null) {
					TokenStmt bodyStmt = ParseStmt (ref token);
					if (bodyStmt == null) return null;
					if (tokenSwitchCase.lastStmt == null) {
						tokenSwitchCase.stmts = bodyStmt;
					} else {
						tokenSwitchCase.lastStmt.nextToken = bodyStmt;
					}
					tokenSwitchCase.lastStmt = bodyStmt;
					bodyStmt.nextToken = null;
				} else if (!haveComplained) {
					ErrorMsg (token, "expecting case or default label");
					token = SkipPastSemi (token);
					haveComplained = true;
				}
			}
			token = token.nextToken;
			return tokenStmtSwitch;
		}

		private TokenStmtState ParseStmtState (ref Token token)
		{
			TokenStmtState tokenStmtState = new TokenStmtState (token);
			token = token.nextToken;
			if ((!(token is TokenName) && !(token is TokenKwDefault)) || !(token.nextToken is TokenKwSemi)) {
				ErrorMsg (token, "expecting state;");
				token = SkipPastSemi (token);
				return null;
			}
			if (token is TokenName) {
				tokenStmtState.state = (TokenName)token;
			}
			token = token.nextToken.nextToken;
			return tokenStmtState;
		}

		private TokenStmtThrow ParseStmtThrow (ref Token token)
		{
			TokenStmtThrow tokenStmtThrow = new TokenStmtThrow (token);
			token = token.nextToken;
			if (token is TokenKwSemi) {
				token = token.nextToken;
			} else {
				tokenStmtThrow.rVal = ParseRVal (ref token, semiOnly);
				if (tokenStmtThrow.rVal == null) return null;
			}
			return tokenStmtThrow;
		}

		private TokenStmtTry ParseStmtTry (ref Token token)
		{
			TokenStmtTry tokenStmtTry = new TokenStmtTry (token);
			token = token.nextToken;
			tokenStmtTry.tryStmt = ParseStmtBlock (ref token);
			if (tokenStmtTry.tryStmt == null) return null;
			if (token is TokenKwCatch) {
				if (!(token.nextToken is TokenKwParOpen) ||
				    !(token.nextToken.nextToken is TokenTypeStr) ||
				    !(token.nextToken.nextToken.nextToken is TokenName) ||
				    !(token.nextToken.nextToken.nextToken.nextToken is TokenKwParClose)) {
					ErrorMsg (token, "catch must be followed by ( string <varname> ) <statement>");
					return null;
				}
				tokenStmtTry.catchVar = (TokenName) token.nextToken.nextToken.nextToken;
				token = token.nextToken.nextToken.nextToken.nextToken.nextToken;
				tokenStmtTry.catchStmt = ParseStmtBlock (ref token);
				if (tokenStmtTry.catchStmt == null) return null;
			}
			if (token is TokenKwFinally) {
				token = token.nextToken;
				tokenStmtTry.finallyStmt = ParseStmtBlock (ref token);
				if (tokenStmtTry.finallyStmt == null) return null;
			}
			if ((tokenStmtTry.catchStmt == null) && (tokenStmtTry.finallyStmt == null)) {
				ErrorMsg (tokenStmtTry, "try must have a matching catch and/or finally");
				return null;
			}
			return tokenStmtTry;
		}

		private TokenStmtWhile ParseStmtWhile (ref Token token)
		{
			TokenStmtWhile tokenStmtWhile = new TokenStmtWhile (token);
			token = token.nextToken;
			tokenStmtWhile.testRVal = ParseRValParen (ref token);
			if (tokenStmtWhile.testRVal == null) return null;
			tokenStmtWhile.bodyStmt = ParseStmt (ref token);
			if (tokenStmtWhile.bodyStmt == null) return null;
			return tokenStmtWhile;
		}

		/**
		 * @brief parse a variable declaration statement, including init value if any.
		 * @param token = points to type or 'constant' token
		 * @param variables = list of variables to insert it in
		 * @returns null: parsing error
		 *          else: variable declaration encapulating token
		 *          token = advanced just past semi-colon
		 *          variables = modified to include the new variable
		 */
		private TokenDeclVar ParseDeclVar (ref Token token, Dictionary<string, TokenDeclVar> variables)
		{
			TokenDeclVar tokenDeclVar = new TokenDeclVar (token.nextToken, currentDeclFunc);

			/*
			 * Handle constant declaration.
			 * It ends up in the declared variables list for the statement block just like
			 * any other variable, except it has .constant = true and its value is an
			 * TokenRValConst.
			 *
			 * 	constant <name> = <value> ;
			 */
			if (token is TokenKwConst) {
				token = token.nextToken;
				if (!(token is TokenName)) {
					ErrorMsg (token, "expecting constant name");
					token = SkipPastSemi (token);
					return null;
				}
				tokenDeclVar.name = (TokenName)token;
				token = token.nextToken;
				if (!(token is TokenKwAssign)) {
					ErrorMsg (token, "expecting =");
					token = SkipPastSemi (token);
					return null;
				}
				token = token.nextToken;
				TokenRVal rVal = ParseRVal (ref token, semiOnly);
				if (rVal == null) return null;
				if (!(rVal is TokenRValConst)) {
					ErrorMsg (tokenDeclVar, "constant value not constant float,integer,string");
					token = SkipPastSemi (token);
					return null;
				}
				tokenDeclVar.type = TokenType.FromSysType (tokenDeclVar, 
				                                           ((TokenRValConst)rVal).val.GetType ());
				tokenDeclVar.init = rVal;
				tokenDeclVar.constant = true;
			}

			/*
			 * Otherwise, normal variable declaration with optional initialization value.
			 */
			else {
				/*
				 * Build basic encapsulating token with type and name.
				 */
				tokenDeclVar.type = (TokenType)token;
				token = token.nextToken;
				if (!(token is TokenName)) {
					ErrorMsg (token, "expecting variable name");
					token = SkipPastSemi (token);
					return null;
				}
				tokenDeclVar.name = (TokenName)token;
				token = token.nextToken;

				/*
				 * If just a ;, there is no explicit initialization value.
				 * Otherwise, look for an =RVal; expression that has init value.
				 */
				if (token is TokenKwSemi) {
					token = token.nextToken;
				} else if (token is TokenKwAssign) {
					token = token.nextToken;
					tokenDeclVar.init = ParseRVal (ref token, semiOnly);
					if (tokenDeclVar.init == null) return null;
				} else {
					ErrorMsg (token, "expecting = or ;");
					token = SkipPastSemi (token);
					return null;
				}
			}

			/*
			 * Can't be same name already in block.
			 */
			TokenDeclVar bad;
			if (variables.TryGetValue (tokenDeclVar.name.val, out bad)) {
				ErrorMsg (tokenDeclVar, "duplicate variable definition");
				ErrorMsg (bad.name, "previously defined here");
				return null;
			}
			variables.Add (tokenDeclVar.name.val, tokenDeclVar);

			return tokenDeclVar;
		}

		/**
		 * @brief parse function declaration argument list
		 * @param token = points to TokenKwParOpen
		 * @returns null: parse error
		 *          else: points to token with types and names
		 *          token = updated past the TokenKwParClose
		 */
		private TokenArgDecl ParseFuncArgs (ref Token token)
		{
			int nArgs = 0;
			LinkedList<TokenName> nameList = new LinkedList<TokenName> ();
			LinkedList<TokenType> typeList = new LinkedList<TokenType> ();
			TokenArgDecl tokenArgDecl = new TokenArgDecl (token);

			do {
				token = token.nextToken;
				if ((nArgs == 0) && (token is TokenKwParClose)) break;
				if (!(token is TokenType)) {
					ErrorMsg (token, "expecting arg type");
					token = SkipPastSemi (token);
					return null;
				}
				typeList.AddLast ((TokenType)token);

				token = token.nextToken;
				if (!(token is TokenName)) {
					ErrorMsg (token, "expecting arg name");
					token = SkipPastSemi (token);
					return null;
				}
				foreach (TokenName dupCheck in nameList) {
					if (dupCheck.val == ((TokenName)token).val) {
						ErrorMsg (token, "duplicate arg name");
						break;
					}
				}
				nameList.AddLast ((TokenName)token);
				nArgs ++;

				token = token.nextToken;
			} while (token is TokenKwComma);
			if (!(token is TokenKwParClose)) {
				ErrorMsg (token, "expecting comma or close paren");
				token = SkipPastSemi (token);
				return null;
			}
			token = token.nextToken;

			tokenArgDecl.types = System.Linq.Enumerable.ToArray (typeList);
			tokenArgDecl.names = System.Linq.Enumerable.ToArray (nameList);
			tokenArgDecl.locns = new CompValu[nArgs];
			return tokenArgDecl;
		}

		/**
		 * @brief parse right-hand value expression
		 *        this is where arithmetic-like expressions are processed
		 * @param token = points to first token expression
		 * @param termTokenType = expression termination token type
		 * @returns null: not an RVal
		 *          else: single token representing whole expression
		 *          token = if termTokenType.Length == 1, points just past terminating token
		 *                                          else, points right at terminating token
		 */
		public TokenRVal ParseRVal (ref Token token, Type[] termTokenTypes)
		{
			/*
			 * Start with pushing the first operand on operand stack.
			 */
			BinOp binOps = null;
			TokenRVal operands = GetOperand (ref token);
			if (operands == null) return null;

			/*
			 * Keep scanning until we hit the termination token.
			 */
			while (true) {
				Type tokType = token.GetType();
				for (int i = termTokenTypes.Length; -- i >= 0;) {
					if (tokType == termTokenTypes[i]) goto done;
				}

				/*
				 * Special form:
				 *   <operand> is <typeexp>
				 */
				if (token is TokenKwIs) {
					TokenRValIsType tokenRValIsType = new TokenRValIsType (token);
					token = token.nextToken;

					/*
					 * Parse the <typeexp>.
					 */
					tokenRValIsType.typeExp = ParseTypeExp (ref token);
					if (tokenRValIsType.typeExp == null) return null;

					/*
					 * Replace top operand with result of <operand> is <typeexp>
					 */
					tokenRValIsType.rValExp   = operands;
					tokenRValIsType.nextToken = operands.nextToken;
					operands = tokenRValIsType;

					/*
					 * token points just past <typeexp> so see if it is another operator.
					 */
					continue;
				}

				/*
				 * Peek at next operator.
				 */
				BinOp binOp = GetOperator (ref token);
				if (binOp == null) return null;

				/*
				 * If there are stacked operators of higher or same precedence than new one,
				 * perform their computation then push result back on operand stack.
				 *
				 *  higher or same = left-to-right application of operators
				 *                   eg, a - b - c becomes (a - b) - c
				 *
				 *  higher precedence = right-to-left application of operators
				 *                      eg, a - b - c becomes a - (b - c)
				 *
				 * Now of course, there is some ugliness necessary:
				 *      we want:  a  - b - c  =>  (a - b) - c    so we do 'higher or same'
				 *  but we want:  a += b = c  =>  a += (b = c)   so we do 'higher only'
				 *
				 * binOps is the first operator (or null if only one)
				 * binOp is the second operator (or first if only one)
				 */
				while (binOps != null) {
					if (binOps.preced < binOp.preced) break;       // 1st operator lower than 2nd, so leave 1st on stack to do later
					if (binOps.preced > binOp.preced) goto do1st;  // 1st op higher than 2nd, so we always do 1st op first
					if (binOps.preced == ASNPR) break;             // equal preced, if assignment type, leave 1st on stack to do later
					                                               //               if non-asn type, do 1st op first (ie left-to-right)
				do1st:
					TokenRVal result = PerformBinOp ((TokenRVal)operands.prevToken, binOps, (TokenRVal)operands);
					result.prevToken = operands.prevToken.prevToken;
					operands = result;
					binOps   = binOps.pop;
				}

				/*
				 * Push new operator on its stack.
				 */
				binOp.pop = binOps;
				binOps = binOp;

				/*
				 * Push next operand on its stack.
				 */
				TokenRVal operand = GetOperand (ref token);
				if (operand == null) return null;
				operand.prevToken = operands;
				operands = operand;
			}
		done:

			/*
			 * At end of expression, perform any stacked computations.
			 */
			while (binOps != null) {
				TokenRVal result = PerformBinOp ((TokenRVal)operands.prevToken, binOps, (TokenRVal)operands);
				result.prevToken = operands.prevToken.prevToken;
				operands = result;
				binOps   = binOps.pop;
			}

			/*
			 * There should be exactly one remaining operand on the stack which is our final result.
			 */
			if (operands.prevToken != null) throw new Exception ("too many operands");

			/*
			 * If only one terminator type possible, advance past the terminator.
			 */
			if (termTokenTypes.Length == 1) token = token.nextToken;

			return operands;
		}

		private TokenTypeExp ParseTypeExp (ref Token token)
		{
			TokenTypeExp leftOperand = GetTypeExp (ref token);
			if (leftOperand == null) return null;

			while ((token is TokenKwAnd) || (token is TokenKwOr)) {
				Token typeBinOp = token;
				token = token.nextToken;
				TokenTypeExp rightOperand = GetTypeExp (ref token);
				if (rightOperand == null) return null;
				TokenTypeExpBinOp typeExpBinOp = new TokenTypeExpBinOp (typeBinOp);
				typeExpBinOp.leftOp  = leftOperand;
				typeExpBinOp.binOp   = typeBinOp;
				typeExpBinOp.rightOp = rightOperand;
				leftOperand = typeExpBinOp;
			}
			return leftOperand;
		}

		private TokenTypeExp GetTypeExp (ref Token token)
		{
			if (token is TokenKwTilde) {
				TokenTypeExpNot typeExpNot = new TokenTypeExpNot (token);
				token = token.nextToken;
				typeExpNot.typeExp = GetTypeExp (ref token);
				if (typeExpNot.typeExp == null) return null;
				return typeExpNot;
			}
			if (token is TokenKwParOpen) {
				TokenTypeExpPar typeExpPar = new TokenTypeExpPar (token);
				token = token.nextToken;
				typeExpPar.typeExp = GetTypeExp (ref token);
				if (typeExpPar.typeExp == null) return null;
				if (!(token is TokenKwParClose)) {
					ErrorMsg (token, "expected close parenthesis");
					token = SkipPastSemi (token);
					return null;
				}
				return typeExpPar;
			}
			if (token is TokenKwUndef) {
				TokenTypeExpUndef typeExpUndef = new TokenTypeExpUndef (token);
				token = token.nextToken;
				return typeExpUndef;
			}
			if (token is TokenType) {
				TokenTypeExpType typeExpType = new TokenTypeExpType (token);
				typeExpType.typeToken = (TokenType)token;
				token = token.nextToken;
				return typeExpType;
			}
			ErrorMsg (token, "expected type");
			token = SkipPastSemi (token);
			return null;
		}

		/**
		 * @brief get a right-hand operand expression token
		 * @param token = first token of operand to parse
		 * @returns null: invalid operand
		 *          else: token that bundles or wraps the operand
		 *          token = points to token following last operand token
		 */
		private TokenRVal GetOperand (ref Token token)
		{
			TokenRVal operand = GetOperandNoCall (ref token);
			if (operand == null) return null;

			/*
			 * If not followed by a (, it isn't a function call.
			 */
			if (!(token is TokenKwParOpen)) return operand;

			/*
			 * Function call, make sure thing before ( is a name or a field.
			 */
			TokenLVal meth = null;
			if (operand is TokenRValLVal) {
				TokenRValLVal op = (TokenRValLVal)operand;
				if (op.lvToken is TokenLValName)  meth = op.lvToken;
				if (op.lvToken is TokenLValField) meth = op.lvToken;
			}
			if (meth == null) {
				ErrorMsg (token, "invalid function reference or missing operator");
				return null;
			}

			/*
			 * Set up basic function call struct with function name.
			 */
			TokenRValCall rValCall = new TokenRValCall (token);
			rValCall.meth = meth;
			token = token.nextToken;

			/*
			 * Parse the call parameters, if any.
			 */
			if (token is TokenKwParClose) {
				token = token.nextToken;
			} else {
				rValCall.args = ParseRVal (ref token, parCloseOnly);
				if (rValCall.args == null) return null;
				rValCall.nArgs = SplitCommaRVals (rValCall.args, out rValCall.args, ref rValCall.sideEffects);
			}

			/*
			 * If calling a function (not a method), rememeber the called function.
			 */
			if (meth is TokenLValName) {
				TokenLValName methName = (TokenLValName)meth;
				if (!currentDeclFunc.calledFuncs.ContainsKey (methName.name.val)) {
					currentDeclFunc.calledFuncs[methName.name.val] = methName.name;
				}
			}

			return rValCall;
		}

		/**
		 * @brief same as GetOperand() except doesn't check for a function call
		 */
		private TokenRVal GetOperandNoCall (ref Token token)
		{
			TokenLVal lVal;

			/*
			 * Simple unary operators.
			 */
			if ((token is TokenKwSub) || 
			    (token is TokenKwTilde) ||
			    (token is TokenKwExclam)) {
				Token uop = token;
				token = token.nextToken;
				TokenRVal rVal = GetOperand (ref token);
				if (rVal == null) return null;
				return PerformUnOp (uop, rVal);
			}

			/*
			 * Prefix unary operators requiring an L-value.
			 */
			if ((token is TokenKwIncr) || (token is TokenKwDecr)) {
				TokenRValAsnPre asnPre = new TokenRValAsnPre (token);
				asnPre.prefix = token;
				token = token.nextToken;
				asnPre.lVal = ParseLVal (ref token);
				if (asnPre.lVal == null) return null;
				return asnPre;
			}

			/*
			 * Type casting.
			 */
			if ((token is TokenKwParOpen) &&
			    (token.nextToken is TokenType) &&
			    (token.nextToken.nextToken is TokenKwParClose)) {
				TokenType type = (TokenType)token.nextToken;
				token = token.nextToken.nextToken.nextToken;
				TokenRVal rVal = GetOperand (ref token);
				if (rVal == null) return null;
				return new TokenRValCast (type, rVal);
			}

			/*
			 * Parenthesized expression.
			 */
			if (token is TokenKwParOpen) {
				return ParseRValParen (ref token);
			}

			/*
			 * Constants.
			 */
			if (token is TokenFloat) {
				TokenRValConst rValConst = new TokenRValConst (token, ((TokenFloat)token).val);
				token = token.nextToken;
				return rValConst;
			}
			if (token is TokenInt) {
				TokenRValConst rValConst = new TokenRValConst (token, ((TokenInt)token).val);
				token = token.nextToken;
				return rValConst;
			}
			if (token is TokenStr) {
				TokenRValConst rValConst = new TokenRValConst (token, ((TokenStr)token).val);
				token = token.nextToken;
				return rValConst;
			}
			if (token is TokenKwUndef) {
				TokenRValUndef rValUndef = new TokenRValUndef ((TokenKwUndef)token);
				token = token.nextToken;
				return rValUndef;
			}

			/*
			 * '<'value,...'>', ie, rotation or vector
			 */
			if (token is TokenKwCmpLT) {
				Token openBkt = token;
				token = token.nextToken;
				TokenRVal rValAll = ParseRVal (ref token, cmpGTOnly);
				if (rValAll == null) return null;
				TokenRVal rVals;
				bool sideEffects = false;
				int nVals = SplitCommaRVals (rValAll, out rVals, ref sideEffects);
				switch (nVals) {
					case 3: {
						TokenRValVec rValVec = new TokenRValVec (openBkt);
						rValVec.xRVal = rVals;
						rValVec.yRVal = (TokenRVal)rVals.nextToken;
						rValVec.zRVal = (TokenRVal)rVals.nextToken.nextToken;
						rValVec.sideEffects = sideEffects;
						return rValVec;
					}
					case 4: {
						TokenRValRot rValRot = new TokenRValRot (openBkt);
						rValRot.xRVal = rVals;
						rValRot.yRVal = (TokenRVal)rVals.nextToken;
						rValRot.zRVal = (TokenRVal)rVals.nextToken.nextToken;
						rValRot.wRVal = (TokenRVal)rVals.nextToken.nextToken.nextToken;
						rValRot.sideEffects = sideEffects;
						return rValRot;
					}
					default: {
						ErrorMsg (openBkt, "bad rotation/vector");
						token = SkipPastSemi (token);
						return null;
					}
				}
			}

			/*
			 * '['value,...']', ie, list
			 */
			if (token is TokenKwBrkOpen) {
				TokenRValList rValList = new TokenRValList (token);
				token = token.nextToken;
				if (token is TokenKwBrkClose) {
					token = token.nextToken;  // empty list
				} else {
					TokenRVal rValAll = ParseRVal (ref token, brkCloseOnly);
					if (rValAll == null) return null;
					rValList.nItems = SplitCommaRVals (rValAll, out rValList.rVal, ref rValList.sideEffects);
				}
				return rValList;
			}

			/*
			 * Reference to such as 'integer constant <name> = <value> ;'
			 */
			if (token is TokenName) {
				TokenRValConst rValConst = TryUserDefConst (ref token);
				if (rValConst != null) return rValConst;
			}

			/*
			 * Built-in symbolic constants.
			 */
			if (token is TokenName) {
				ScriptConst scriptConst = ScriptConst.Lookup (((TokenName)token).val);
				if (scriptConst != null) {
					CompValu val = scriptConst.rVal;
					TokenRVal rVal = null;

					/*
					 * Decode these types as TokenRValConst's so they will combine with other constants at
					 * compile time.
					 */
					if (val is CompValuFloat)   rVal = new TokenRValConst (token, ((CompValuFloat)val).x);
					if (val is CompValuInteger) rVal = new TokenRValConst (token, ((CompValuInteger)val).x);
					if (val is CompValuString)  rVal = new TokenRValConst (token, ((CompValuString)val).x);

					/*
					 * If tere is no TokenRValConst equivalent for this one, just keep the CompValu as is.
					 */
					if (val is CompValuSField) {
						object v = ((CompValuSField)val).field.GetValue(null);

						// Handle the basic types LSL_Constants contains
						if (v is string)
							rVal =  new TokenRValConst (token, v);
						else if (v is float)
							rVal =  new TokenRValConst (token, v);
						else if (v is int)
							rVal =  new TokenRValConst (token, v);
						else if (v is LSL_Vector)
                        {
                            LSL_Vector vec = (LSL_Vector)v;
							TokenRValVec rValVec =  new TokenRValVec (token);
                            rValVec.xRVal = new TokenRValConst(token, vec.x);
                            rValVec.yRVal = new TokenRValConst(token, vec.y);
                            rValVec.zRVal = new TokenRValConst(token, vec.z);
                            rVal = rValVec;
                        }
						else if (v is LSL_Rotation)
                        {
                            LSL_Rotation rot = (LSL_Rotation)v;
							TokenRValRot rValRot =  new TokenRValRot (token);
                            rValRot.xRVal = new TokenRValConst(token, rot.x);
                            rValRot.yRVal = new TokenRValConst(token, rot.y);
                            rValRot.zRVal = new TokenRValConst(token, rot.z);
                            rValRot.wRVal = new TokenRValConst(token, rot.s);
                            rVal = rValRot;
                        }
						else
                        {
                            //ErrorMsg (token, "unhandled type for "+((CompValuSField)val).field.Name);
                            
							rVal = new TokenRValCVSField (token, (CompValuSField)val);
                        }
					}

					/*
					 * We should have been able to decode it somehow!
					 */
					if (rVal == null) {
						throw new Exception ("unhandled ScriptConst type " + val.GetType());
					}

					/*
					 * Advance pointer past the name token and return ref to the constant.
					 */
					token = token.nextToken;
					return rVal;
				}
			}

			/*
			 * L-value being used as an R-value is all we got left to try.
			 */
			lVal = ParseLVal (ref token);
			if (lVal == null) return null;

			/*
			 * Maybe the L-value is followed by a postfix operator.
			 */
			if ((token is TokenKwIncr) || (token is TokenKwDecr)) {
				TokenRValAsnPost asnPost = new TokenRValAsnPost (token);
				asnPost.lVal = lVal;
				asnPost.postfix = token;
				token = token.nextToken;
				return asnPost;
			}

			/*
			 * Just a simple L-value being used as an R-value.
			 */
			return new TokenRValLVal (lVal);
		}

		/**
		 * @brief See if the given token (already known to be a TokenName) references a user-defined constant,
		 *        eg, something declared like 'integer constant FOO = 3;'
		 * @param token = points to the TokenName
		 * @returns null: it's not such a constant
		 *          else: corresponding constant value
		 *                token advanced past the name
		 */
		private TokenRValConst TryUserDefConst (ref Token token)
		{
			string name = ((TokenName)token).val;
			TokenDeclVar declVar = null;

			for (TokenStmtBlock stmtBlock = currentStmtBlock; stmtBlock != null; stmtBlock = stmtBlock.outerStmtBlock) {
				if (stmtBlock.variables.TryGetValue (name, out declVar)) goto found;
			}
			if (tokenScript.vars.TryGetValue (name, out declVar)) goto found;
			return null;
		found:
			if (!declVar.constant) return null;
			token = token.nextToken;
			return (TokenRValConst)(declVar.init);
		}

		/**
		 * @brief decode binary operator token
		 * @param token = points to token to decode
		 * @returns null: invalid operator token
		 *          else: operator token and precedence
		 */
		private BinOp GetOperator (ref Token token)
		{
			BinOp binOp = new BinOp ();
			if (precedence.TryGetValue (token.GetType (), out binOp.preced)) {
				binOp.token = (TokenKw)token;
				token = token.nextToken;
				return binOp;
			}

			if ((token is TokenKwSemi) || (token is TokenKwBrcOpen) || (token is TokenKwBrcClose)) {
				ErrorMsg (token, "premature expression end");
			} else {
				ErrorMsg (token, "invalid operator");
			}
			token = SkipPastSemi (token);
			return null;
		}

		private class BinOp {
			public BinOp pop;
			public TokenKw token;
			public int preced;
		}

		/**
		 * @brief If the operands are constants and the operator can do it here, perform the operation and return the
		 *        result as a new constant token.  Otherwise, return an R-value expression token that will be used to
		 *        generate code to perform the operation at runtime.
		 * @param left  = left-hand operand
		 * @param binOp = operator
		 * @param right = right-hand operand
		 * @returns resultant constant or expression
		 */
		private TokenRVal PerformBinOp (TokenRVal left, BinOp binOp, TokenRVal right)
		{
			/*
			 * Maybe both operands are constants and the operator knows how to handle them.
			 * If so, perform computation and return the resultant constant.
			 */
			if ((left is TokenRValConst) && (right is TokenRValConst)) {
				object val;
				try {
					val = binOp.token.binOpConst (((TokenRValConst)left).val, ((TokenRValConst)right).val);
				} catch {
					val = null;
				}
				if (val != null) {
					return new TokenRValConst (binOp.token, val);
				}
				////???? throw exception or print warning ????////
			}

			/*
			 * Otherwise, output token that encapsulates the expression for code generation.
			 */
			return new TokenRValOpBin (left, binOp.token, right);
		}

		/**
		 * @brief If the operand is a constant and the operator can do it here, perform the operation and return the
		 *        result as a new constant token.  Otherwise, return an R-value expression token that will be used to
		 *        generate code to perform the operation at runtime.
		 * @param unOp  = operator
		 * @param right = right-hand operand
		 * @returns resultant constant or expression
		 */
		private TokenRVal PerformUnOp (Token unOp, TokenRVal right)
		{
			/*
			 * Maybe the operand is a constant and the operator knows how to handle them.
			 * If so, perform computation and return the resultant constant.
			 */
			if (right is TokenRValConst) {
				object val;
				try {
					val = ((TokenKw)unOp).unOpConst (((TokenRValConst)right).val);
				} catch {
					val = null;
				}
				if (val != null) {
					return new TokenRValConst (unOp, val);
				}
				////???? throw exception or print warning ????////
			}

			/*
			 * Otherwise, output token that encapsulates the expression for code generation.
			 */
			return new TokenRValOpUn (unOp, right);
		}

		/**
		 * @brief parse out a parenthesized expression.
		 * @param token = points to open parenthesis
		 * @returns null: invalid expression
		 *          else: parenthesized expression token or constant token
		 *          token = points past the close parenthesis
		 */
		private TokenRVal ParseRValParen (ref Token token)
		{
			if (!(token is TokenKwParOpen)) {
				ErrorMsg (token, "expecting (");
				token = SkipPastSemi (token);
				return null;
			}
			TokenRValParen tokenRValParen = new TokenRValParen (token);
			token = token.nextToken;
			tokenRValParen.rVal = ParseRVal (ref token, parCloseOnly);
			if (tokenRValParen.rVal == null) return null;
			if (tokenRValParen.rVal is TokenRValConst) return tokenRValParen.rVal;
			tokenRValParen.sideEffects = tokenRValParen.rVal.sideEffects;
			return tokenRValParen;
		}

		/**
		 * @brief Split a comma'd RVal into separate expressions
		 * @param rValAll = expression containing commas
		 * @returns number of comma separated values
		 *          rVals = values in a null-terminated list linked by rVals.nextToken
		 *          sideEffects |= some of the values have side effects
		 */
		private int SplitCommaRVals (TokenRVal rValAll, out TokenRVal rVals, ref bool sideEffects)
		{
			if (!(rValAll is TokenRValOpBin) || !(((TokenRValOpBin)rValAll).opcode is TokenKwComma)) {
				rVals = rValAll;
				if (rVals.nextToken != null) throw new Exception ("expected null");
				sideEffects |= rValAll.sideEffects;
				return 1;
			}
			TokenRValOpBin opBin = (TokenRValOpBin)rValAll;
			TokenRVal rValLeft, rValRight;
			bool sel = false;
			bool ser = false;
			int leftCount  = SplitCommaRVals (opBin.rValLeft,  out rValLeft,  ref sel);
			int rightCount = SplitCommaRVals (opBin.rValRight, out rValRight, ref ser);
			rVals = rValLeft;
			while (rValLeft.nextToken != null) rValLeft = (TokenRVal)rValLeft.nextToken;
			rValLeft.nextToken = rValRight;
			sideEffects |= sel | ser;
			return leftCount + rightCount;
		}

		/**
		 * @brief parse a L-value, ie, something that can be used on left side of '='
		 * @param token = points to first token to check
		 * @returns encapsulation of L-value expression
		 *          token = advanced past L-value expression
		 */
		private TokenLVal ParseLVal (ref Token token)
		{
			/*
			 * L-values always start with a name
			 */
			if (!(token is TokenName)) {
				ErrorMsg (token, "invalid L-value, expect name");
				token = SkipPastSemi (token);
				return null;
			}
			TokenLVal tokenLVal = new TokenLValName ((TokenName)token);
			token = token.nextToken;

			while (true) {

				/*
				 * They may be followed by .fieldname
				 */
				if (token is TokenKwDot) {
					TokenLValField tokenLValField = new TokenLValField (token);
					token = token.nextToken;
					if (!(token is TokenName)) {
						ErrorMsg (token, "invalid field name");
						token = SkipPastSemi (token);
						return null;
					}
					tokenLValField.baseLVal = tokenLVal;
					tokenLValField.field = (TokenName)token;
					tokenLVal = tokenLValField;
					token = token.nextToken;
					continue;
				}

				/*
				 * They may be followed by [subscript(s)]
				 */
				if (token is TokenKwBrkOpen) {
					TokenLValArEle tokenLValArEle = new TokenLValArEle (token);
					token = token.nextToken;

					/*
					 * Parse subscript(s) expression.
					 */
					tokenLValArEle.subRVal = ParseRVal (ref token, brkCloseOnly);
					if (tokenLValArEle.subRVal == null) {
						ErrorMsg (tokenLValArEle, "invalid subscript");
						return null;
					}

					/*
					 * See if comma-separated list of values.
					 */
					bool sideEffects = false;
					TokenRVal subscriptRVals;
					int numSubscripts = SplitCommaRVals (tokenLValArEle.subRVal, out subscriptRVals, ref sideEffects);
					if (numSubscripts > 1) {

						/*
						 * If so, put the values in an LSL_List object.
						 */
						TokenRValList rValList = new TokenRValList (tokenLValArEle);
						rValList.rVal = subscriptRVals;
						rValList.nItems = numSubscripts;
						rValList.sideEffects = sideEffects;
						tokenLValArEle.subRVal = rValList;
					}

					/*
					 * Either way, save array variable name
					 * and substitute whole reference for L-value
					 */
					tokenLValArEle.baseLVal = tokenLVal;
					tokenLVal = tokenLValArEle;
					continue;
				}

				/*
				 * No modifier we recognize, done parsing.
				 */
				return tokenLVal;
			}
		}

		/**
		 * @brief output error message and remember that there is an error.
		 * @param token = what token is associated with the error
		 * @param message = error message string
		 */
		private void ErrorMsg (Token token, string message)
		{
			errors = true;
			token.ErrorMsg (message);
		}

		/**
		 * @brief Skip past the next semicolon (or matched braces)
		 * @param token = points to token to skip over
		 * @returns token just after the semicolon or close brace
		 */
		private Token SkipPastSemi (Token token)
		{
			int braceLevel = 0;

			while (!(token is TokenEnd)) {
				if ((token is TokenKwSemi) && (braceLevel == 0)) {
					return token.nextToken;
				}
				if (token is TokenKwBrcOpen) {
					braceLevel ++;
				}
				if ((token is TokenKwBrcClose) && (-- braceLevel <= 0)) {
					return token.nextToken;
				}
				token = token.nextToken;
			}
			return token;
		}
	}


	/**
	 * @brief function argument list declaration
	 */
	public class TokenArgDecl : Token
	{
		public TokenType[] types;
		public TokenName[] names;
		public CompValu[]  locns;  // used by codegen to keep track of locations

		public TokenArgDecl (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			int n = types.Length;
			writer.Write (n);
			for (int i = 0; i < n; i ++) {
				writer.Write (types[i]);
				writer.Write (names[i]);
			}
		}

		public override void ReadIn (TokenReader reader)
		{
			int n = reader.ReadInt ();
			types = new TokenType[n];
			names = new TokenName[n];
			for (int i = 0; i < n; i ++) {
				types[i] = (TokenType)reader.ReadToken ();
				names[i] = (TokenName)reader.ReadToken ();
			}
		}
	}

	/**
	 * @brief encapsulates a function definition
	 */
	public class TokenDeclFunc : Token {

		public TokenType retType;            // new TokenTypeVoid (token) if void; NEVER null
		public TokenName funcName;           // function name
		public TokenArgDecl argDecl;         // argument list prototypes
		public TokenStmtBlock body;          // statements
		public Dictionary<string, TokenStmtLabel> labels = new Dictionary<string, TokenStmtLabel> ();
		                                     // all labels defined in the function
		public Dictionary<string, TokenName> calledFuncs = new Dictionary<string, TokenName> ();
		                                     // all functions called by this function
		public LinkedList<TokenDeclVar> localVars = new LinkedList<TokenDeclVar> ();
		                                     // all local variables declared by this function
		                                     // - doesn't include argument variables

		public ScriptMyILGen ilGen;          // codegen stores emitted code here

		public TokenDeclFunc (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (retType);
			writer.Write (funcName);
			writer.Write (argDecl);
			writer.Write (body);

			// the below probably should be rederived when reconstructed
			writer.Write (labels.Count);
			foreach (KeyValuePair<string, TokenStmtLabel> kvp in labels) {
				writer.Write (kvp.Value);
			}
			writer.Write (calledFuncs.Count);
			foreach (KeyValuePair<string, TokenName> kvp in calledFuncs) {
				writer.Write (kvp.Value);
			}
			writer.Write (localVars.Count);
			foreach (TokenDeclVar val in localVars) {
				writer.Write (val);
			}
		}

		public override void ReadIn (TokenReader reader)
		{
			retType  = (TokenType)     reader.ReadToken ();
			funcName = (TokenName)     reader.ReadToken ();
			argDecl  = (TokenArgDecl)  reader.ReadToken ();
			body     = (TokenStmtBlock)reader.ReadToken ();

			// the below probably should be rederived when reconstructed

			int nLabels = reader.ReadInt ();
			while (-- nLabels >= 0) {
				TokenStmtLabel label = (TokenStmtLabel)reader.ReadToken ();
				labels[label.name.val] = label;
			}
			int nFuncs = reader.ReadInt ();
			while (-- nFuncs >= 0) {
				TokenName func = (TokenName)reader.ReadToken ();
				calledFuncs[func.val] = func;
			}
			int nLocals = reader.ReadInt ();
			while (-- nLocals >= 0) {
				TokenDeclVar local = (TokenDeclVar)reader.ReadToken ();
				localVars.AddLast (local);
			}
		}
	}

	/**
	 * @brief encapsulate a state declaration in a single token
	 */
	public class TokenDeclState : Token {

		public TokenName name;  // null for default state
		public TokenStateBody body;

		public TokenDeclState (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (name);
			writer.Write (body);
		}

		public override void ReadIn (TokenReader reader)
		{
			name = (TokenName)     reader.ReadToken ();
			body = (TokenStateBody)reader.ReadToken ();
		}
	}

	public class TokenDeclVar : Token {

		public TokenType type;
		public TokenName name;
		public TokenRVal init;  // null if none
		public bool constant;

		public bool preDefd;    // used by codegen
		                        // false: normal in-order definition
		                        //  true: var was defined at top of block
		                        //        just set initialization value

		public CompValu location;  // used by codegen to keep track of location

		/**
		 * @brief Set up a variable declaration statement token.
		 * @param original = original source token that triggered definition
		 *                   (for error messages)
		 * @param func = null: global variable
		 *               else: local to the given function
		 */
		public TokenDeclVar (Token original, TokenDeclFunc func) : base (original)
		{
			if (func != null) {
				func.localVars.AddLast (this);
			}
		}

		/**
		 * @brief Serialization/Deserialization.
		 */
		public TokenDeclVar (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (type);
			writer.Write (name);
			writer.Write (init);
		}

		public override void ReadIn (TokenReader reader)
		{
			type = (TokenType)reader.ReadToken ();
			name = (TokenName)reader.ReadToken ();
			init = (TokenRVal)reader.ReadToken ();
		}
	}


	/**
	 * @brief any expression that can go on left side of an "="
	 */
	public class TokenLVal : Token {

		public TokenLVal (Token original) : base (original) { }
	}

	/**
	 * @brief an element of an L-value array is an L-value
	 */
	public class TokenLValArEle : TokenLVal {
		public TokenLVal baseLVal;
		public TokenRVal subRVal;

		public TokenLValArEle (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (baseLVal);
			writer.Write (subRVal);
		}

		public override void ReadIn (TokenReader reader)
		{
			baseLVal = (TokenLVal)reader.ReadToken ();
			subRVal  = (TokenRVal)reader.ReadToken ();
		}
	}

	/**
	 * @brief a field within an L-value struct is an L-value
	 */
	public class TokenLValField : TokenLVal {
		public TokenLVal baseLVal;
		public TokenName field;

		public TokenLValField (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (baseLVal);
			writer.Write (field);
		}

		public override void ReadIn (TokenReader reader)
		{
			baseLVal = (TokenLVal)reader.ReadToken ();
			field    = (TokenName)reader.ReadToken ();
		}
	}

	/**
	 * @brief a name is being used as an L-value
	 */
	public class TokenLValName : TokenLVal {
		public TokenName name;

		public TokenLValName (TokenName original) : base (original)
		{
			this.name = original;
		}

		/**
		 * @brief Serialization/Deserialization.
		 */
		public TokenLValName (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (name);
		}

		public override void ReadIn (TokenReader reader)
		{
			name = (TokenName)reader.ReadToken ();
		}
	}

	/**
	 * @brief any expression that can go on right side of "="
	 */
	public class TokenRVal : Token {
		public bool sideEffects = false;  // the value (or some sub-value) has side effects
		                                  // - constants are always false
		                                  // - we assume calls always have side effects
		                                  // - post increment/decrement are always true
		                                  // - any assignment operator (=, +=, etc) always true
		                                  // - all others inherit from their operands
		public TokenRVal (Token original) : base (original) { }
	}

	/**
	 * @brief a postfix operator and corresponding L-value
	 */
	public class TokenRValAsnPost : TokenRVal {
		public TokenLVal lVal;
		public Token postfix;

		public TokenRValAsnPost (Token original) : base (original) {
			sideEffects = true;
		}

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (lVal);
			writer.Write (postfix);
		}

		public override void ReadIn (TokenReader reader)
		{
			lVal = (TokenLVal)reader.ReadToken ();
			postfix = reader.ReadToken ();
		}
	}

	/**
	 * @brief a prefix operator and corresponding L-value
	 */
	public class TokenRValAsnPre : TokenRVal {
		public Token prefix;
		public TokenLVal lVal;

		public TokenRValAsnPre (Token original) : base (original) {
			sideEffects = true;
		}

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (prefix);
			writer.Write (lVal);
		}

		public override void ReadIn (TokenReader reader)
		{
			prefix = reader.ReadToken ();
			lVal = (TokenLVal)reader.ReadToken ();
		}
	}

	/**
	 * @brief calling a function, ie, may have side-effects
	 */
	public class TokenRValCall : TokenRVal {

		public TokenLVal meth;  // TokenLValName or TokenLValField
		public TokenRVal args;  // null-terminated TokenRVal list
		public int nArgs;       // number of elements in args

		public TokenRValCall (Token original) : base (original) {
			sideEffects = true;
		}

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (meth);
			writer.Write (nArgs);
			TokenRVal arg = args;
			for (int i = 0; i < nArgs; i ++) {
				writer.Write (arg);
				arg = (TokenRVal)arg.nextToken;
			}
		}

		public override void ReadIn (TokenReader reader)
		{
			meth  = (TokenLVal)reader.ReadToken ();
			nArgs = reader.ReadInt ();
			Token lastArg = null;
			for (int i = 0; i < nArgs; i ++) {
				TokenRVal arg = (TokenRVal)reader.ReadToken ();
				if (lastArg == null) {
					args = arg;
				} else {
					lastArg.nextToken = arg;
				}
				lastArg = arg;
			}
		}
	}

	/**
	 * @brief encapsulates a typecast, ie, (type)
	 */
	public class TokenRValCast : TokenRVal {
		public TokenType castTo;
		public TokenRVal rVal;

		public TokenRValCast (TokenType type, TokenRVal value) : base (type)
		{
			castTo = type;
			rVal   = value;
			sideEffects = value.sideEffects;
		}

		/**
		 * @brief Serialization/Deserialization.
		 */
		public TokenRValCast (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (castTo);
			writer.Write (rVal);
		}

		public override void ReadIn (TokenReader reader)
		{
			castTo = (TokenType)reader.ReadToken ();
			rVal   = (TokenRVal)reader.ReadToken ();
		}
	}

	/**
	 * @brief all constants supposed to end up here
	 */
	public enum TokenRValConstType : byte { FLOAT = 0, INT = 1, STRING = 2 };
	public class TokenRValConst : TokenRVal {
		public object val;	// always a system type (int, SCRIPTFLOAT, string)
		public TokenRValConstType type;
		public TokenRValConst (Token original, object value) : base (original) {
			val = value;
			     if (val is int) type = TokenRValConstType.INT;
			else if (val is SCRIPTFLOAT) type = TokenRValConstType.FLOAT;
			else if (val is string) type = TokenRValConstType.STRING;
			else throw new Exception ("invalid constant type " + val.GetType ());
		}

		public TokenRValConst (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write ((byte)type);
			switch (type) {
				case TokenRValConstType.FLOAT:  { writer.Write ((SCRIPTFLOAT)val); break; }
				case TokenRValConstType.INT:    { writer.Write ((int)val);         break; }
				case TokenRValConstType.STRING: { writer.Write ((string)val);      break; }
				default: throw new Exception ("unknown type");
			}
		}

		public override void ReadIn (TokenReader reader)
		{
			type = (TokenRValConstType)reader.ReadByte ();
			switch (type) {
				case TokenRValConstType.FLOAT:  { val = reader.ReadScriptFloat (); break; }
				case TokenRValConstType.INT:    { val = reader.ReadInt ();         break; }
				case TokenRValConstType.STRING: { val = reader.ReadString ();      break; }
				default: throw new Exception ("unknown type");
			}
		}
	}

	public class TokenRValCVSField : TokenRVal {
		public CompValuSField cvsf;
		public TokenRValCVSField (Token original, CompValuSField cvsf) : base (original) {
			this.cvsf = cvsf;
		}
	}

	/**
	 * @brief encapsulation of <rval> is <typeexp>
	 */
	public class TokenRValIsType : TokenRVal {
		public TokenRVal    rValExp;
		public TokenTypeExp typeExp;

		public TokenRValIsType (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (rValExp);
			writer.Write (typeExp);
		}

		public override void ReadIn (TokenReader reader)
		{
			rValExp = (TokenRVal)   reader.ReadToken ();
			typeExp = (TokenTypeExp)reader.ReadToken ();
		}
	}

	/**
	 * @brief an R-value enclosed in brackets is an LSLList
	 */
	public class TokenRValList : TokenRVal {

		public TokenRVal rVal;  // null-terminated list of TokenRVal objects
		public int nItems;

		public TokenRValList (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (nItems);
			Token t = rVal;
			for (int i = 0; i < nItems; i ++) {
				writer.Write (t);
				t = t.nextToken;
			}
		}

		public override void ReadIn (TokenReader reader)
		{
			nItems = reader.ReadInt ();
			Token lastRVal = null;
			for (int i = 0; i < nItems; i ++) {
				TokenRVal thisRVal = (TokenRVal)reader.ReadToken ();
				if (lastRVal == null) {
					rVal = thisRVal;
				} else {
					lastRVal.nextToken = thisRVal;
				}
				lastRVal = thisRVal;
			}
		}
	}

	/**
	 * @brief an L-value is being used as an R-value
	 */
	public class TokenRValLVal : TokenRVal {
		public TokenLVal lvToken;
		public TokenRValLVal (TokenLVal original) : base (original)
		{
			this.lvToken = original;
		}

		/**
		 * @brief Serialization/Deserialization.
		 */
		public TokenRValLVal (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (lvToken);
		}

		public override void ReadIn (TokenReader reader)
		{
			lvToken = (TokenLVal)reader.ReadToken ();
		}
	}

	/**
	 * @brief a binary operator and its two operands
	 */
	public class TokenRValOpBin : TokenRVal {
		public TokenRVal rValLeft;
		public Token opcode;
		public TokenRVal rValRight;

		public TokenRValOpBin (TokenRVal left, Token op, TokenRVal right) : base (op)
		{
			rValLeft  = left;
			opcode    = op;
			rValRight = right;

			CalcSideEffects();
		}

		/**
		 * @brief Serialization/Deserialization.
		 */
		public TokenRValOpBin (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (rValLeft);
			writer.Write (opcode);
			writer.Write (rValRight);
		}

		public override void ReadIn (TokenReader reader)
		{
			rValLeft  = (TokenRVal)reader.ReadToken ();
			opcode    =            reader.ReadToken ();
			rValRight = (TokenRVal)reader.ReadToken ();

			CalcSideEffects();
		}

		private void CalcSideEffects()
		{
			sideEffects = rValLeft.sideEffects || rValRight.sideEffects;
			if (!sideEffects) {
				string opStr = opcode.ToString ();
				sideEffects = opStr.EndsWith ("=") && (opStr != ">=") && 
				              (opStr != "<=") && (opStr != "!=") && (opStr != "==");
			}
		}
	}

	/**
	 * @brief an unary operator and its one operand
	 */
	public class TokenRValOpUn : TokenRVal {
		public Token opcode;
		public TokenRVal rVal;

		public TokenRValOpUn (Token op, TokenRVal right) : base (op)
		{
			opcode      = op;
			rVal        = right;
			sideEffects = right.sideEffects;
		}

		/**
		 * @brief Serialization/Deserialization.
		 */
		public TokenRValOpUn (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (opcode);
			writer.Write (rVal);
		}

		public override void ReadIn (TokenReader reader)
		{
			opcode      = reader.ReadToken ();
			rVal        = (TokenRVal)reader.ReadToken ();
			sideEffects = rVal.sideEffects;
		}
	}

	/**
	 * @brief an R-value enclosed in parentheses
	 */
	public class TokenRValParen : TokenRVal {

		public TokenRVal rVal;

		public TokenRValParen (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (rVal);
		}

		public override void ReadIn (TokenReader reader)
		{
			rVal = (TokenRVal)reader.ReadToken ();
		}
	}

	public class TokenRValRot : TokenRVal {

		public TokenRVal xRVal;
		public TokenRVal yRVal;
		public TokenRVal zRVal;
		public TokenRVal wRVal;

		public TokenRValRot (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (xRVal);
			writer.Write (yRVal);
			writer.Write (zRVal);
			writer.Write (wRVal);
		}

		public override void ReadIn (TokenReader reader)
		{
			xRVal = (TokenRVal)reader.ReadToken ();
			yRVal = (TokenRVal)reader.ReadToken ();
			zRVal = (TokenRVal)reader.ReadToken ();
			wRVal = (TokenRVal)reader.ReadToken ();
		}
	}

	/**
	 * @brief the 'undef' keyword is being used as a value in an expression.
	 */
	public class TokenRValUndef : TokenRVal {
		public TokenRValUndef (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
		}

		public override void ReadIn (TokenReader reader)
		{
		}
	}

	/**
	 * @brief put 3 RVals together as a Vector value.
	 */
	public class TokenRValVec : TokenRVal {

		public TokenRVal xRVal;
		public TokenRVal yRVal;
		public TokenRVal zRVal;

		public TokenRValVec (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (xRVal);
			writer.Write (yRVal);
			writer.Write (zRVal);
		}

		public override void ReadIn (TokenReader reader)
		{
			xRVal = (TokenRVal)reader.ReadToken ();
			yRVal = (TokenRVal)reader.ReadToken ();
			zRVal = (TokenRVal)reader.ReadToken ();
		}
	}
	
	/**
	 * @brief encapsulates the whole script in a single token
	 */
	public class TokenScript : Token {
		public Dictionary<string, TokenDeclVar>   vars   = new Dictionary<string, TokenDeclVar>   ();
		public Dictionary<string, TokenDeclFunc>  funcs  = new Dictionary<string, TokenDeclFunc>  ();
		public TokenDeclState defaultState;
		public Dictionary<string, TokenDeclState> states = new Dictionary<string, TokenDeclState> ();

		public TokenScript (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			int numVars = 0;
			foreach (KeyValuePair<string, TokenDeclVar> kvp in vars) {
				if (!kvp.Value.constant) numVars ++;
			}
			writer.Write (numVars);
			foreach (KeyValuePair<string, TokenDeclVar> kvp in vars) {
				if (!kvp.Value.constant) writer.Write (kvp.Value);
			}
			writer.Write (funcs.Count);
			foreach (KeyValuePair<string, TokenDeclFunc> kvp in funcs) {
				writer.Write (kvp.Value);
			}
			writer.Write (defaultState);
			writer.Write (states.Count);
			foreach (KeyValuePair<string, TokenDeclState> kvp in states) {
				writer.Write (kvp.Value);
			}
		}

		public override void ReadIn (TokenReader reader)
		{
			int nVars = reader.ReadInt ();
			while (-- nVars >= 0) {
				TokenDeclVar var = (TokenDeclVar)reader.ReadToken ();
				vars[var.name.val] = var;
			}
			int nFuncs = reader.ReadInt ();
			while (-- nFuncs >= 0) {
				TokenDeclFunc func = (TokenDeclFunc)reader.ReadToken ();
				funcs[func.funcName.val] = func;
			}
			defaultState = (TokenDeclState)reader.ReadToken ();
			int nStates = reader.ReadInt ();
			while (-- nStates >= 0) {
				TokenDeclState state = (TokenDeclState)reader.ReadToken ();
				states[state.name.val] = state;
			}
		}
	}

	/**
	 * @brief state body declaration
	 */
	public class TokenStateBody : Token {

		public TokenDeclFunc eventFuncs;

		public int index = -1;  // (codegen) row in ScriptHandlerEventTable (0=default)

		public TokenStateBody (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			Token t;
			for (t = eventFuncs; t != null; t = t.nextToken) {
				writer.Write (t);
			}
			writer.Write (t);
		}

		public override void ReadIn (TokenReader reader)
		{
			TokenDeclFunc lastT, thisT;

			lastT = null;
			while ((thisT = (TokenDeclFunc)reader.ReadToken ()) != null) {
				if (lastT == null) {
					eventFuncs = thisT;
				} else {
					lastT.nextToken = thisT;
				}
				lastT = thisT;
			}
		}
	}

	/**
	 * @brief a single statement, such as ending on a semicolon or enclosed in braces
	 * TokenStmt includes the terminating semicolon or the enclosing braces
	 * Also includes @label: for jump targets.
	 * Also includes stray ; null statements.
	 */
	public class TokenStmt : Token {

		public TokenStmt (Token original) : base (original) { }
	}

	/**
	 * @brief a group of statements enclosed in braces
	 */
	public class TokenStmtBlock : TokenStmt {

		public Token statements;               // null-terminated list of statements, can also have TokenDeclVar's in here
		public TokenStmtBlock outerStmtBlock;  // next outer stmtBlock or null if top-level, ie, function definition
		public TokenDeclFunc function;         // function it is part of
		public Dictionary<string, TokenDeclVar> variables = new Dictionary<string, TokenDeclVar> ();  // variables declared herein
		public bool isTry;                     // true iff it's a try statement block
		public bool isCatch;                   // true iff it's a catch statement block
		public bool isFinally;                 // true iff it's a finally statement block

		public TokenStmtBlock (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			Token t;
			for (t = statements; t != null; t = t.nextToken) {
				writer.Write (t);
			}
			writer.Write (t);
			writer.Write (outerStmtBlock);
			writer.Write (function);
			writer.Write (variables.Count);
			foreach (KeyValuePair<string, TokenDeclVar> kvp in variables) {
				writer.Write (kvp.Value);
			}
		}

		public override void ReadIn (TokenReader reader)
		{
			Token lastT, thisT;

			lastT = null;
			while ((thisT = reader.ReadToken ()) != null) {
				if (lastT == null) {
					statements = thisT;
				} else {
					lastT.nextToken = thisT;
				}
				lastT = thisT;
			}
			outerStmtBlock = (TokenStmtBlock)reader.ReadToken ();
			function = (TokenDeclFunc)reader.ReadToken ();
			int nVars = reader.ReadInt ();
			while (-- nVars >= 0) {
				TokenDeclVar var = (TokenDeclVar)reader.ReadToken ();
				variables[var.name.val] = var;
			}
		}
	}

	/**
	 * @brief definition of branch target name
	 */
	public class TokenStmtLabel : TokenStmt {

		public TokenName name;        // the label's name
		public TokenStmtBlock block;  // which block it is defined in
		public bool hasBkwdRefs = false;

		public bool labelTagged;      // code gen: location of label
		public ScriptMyLabel labelStruct;

		public TokenStmtLabel (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (name);
			writer.Write (block);
			writer.Write (hasBkwdRefs);  ///??? recompute on readin
		}

		public override void ReadIn (TokenReader reader)
		{
			name        = (TokenName)reader.ReadToken ();
			block       = (TokenStmtBlock)reader.ReadToken ();
			hasBkwdRefs = reader.ReadBool ();
		}
	}

	/**
	 * @brief those types of RVals with a semi-colon on the end
	 *        that are allowed to stand alone as statements
	 */
	public class TokenStmtRVal : TokenStmt {
		public TokenRVal rVal;

		public TokenStmtRVal (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (rVal);
		}

		public override void ReadIn (TokenReader reader)
		{
			rVal = (TokenRVal)reader.ReadToken ();
		}
	}

	public class TokenStmtBreak : TokenStmt {
		public TokenStmtBreak (Token original) : base (original) { }
		public override void WriteOut (TokenWriter writer) { }
		public override void ReadIn (TokenReader reader) { }
	}

	public class TokenStmtCont : TokenStmt {
		public TokenStmtCont (Token original) : base (original) { }
		public override void WriteOut (TokenWriter writer) { }
		public override void ReadIn (TokenReader reader) { }
	}

	/**
	 * @brief "do" statement
	 */
	public class TokenStmtDo : TokenStmt {

		public TokenStmt bodyStmt;
		public TokenRVal testRVal;

		public TokenStmtDo (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (bodyStmt);
			writer.Write (testRVal);
		}

		public override void ReadIn (TokenReader reader)
		{
			bodyStmt = (TokenStmt)reader.ReadToken ();
			testRVal = (TokenRVal)reader.ReadToken ();
		}
	}

	/**
	 * @brief "for" statement
	 */
	public class TokenStmtFor : TokenStmt {

		public TokenStmt initStmt;  // there is always an init statement, though it may be a null statement
		public TokenRVal testRVal;  // there may or may not be a test (null if not)
		public TokenRVal incrRVal;  // there may or may not be an increment (null if not)
		public TokenStmt bodyStmt;  // there is always a body statement, though it may be a null statement

		public TokenStmtFor (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (initStmt);
			writer.Write (testRVal);
			writer.Write (incrRVal);
			writer.Write (bodyStmt);
		}

		public override void ReadIn (TokenReader reader)
		{
			initStmt = (TokenStmt)reader.ReadToken ();
			testRVal = (TokenRVal)reader.ReadToken ();
			incrRVal = (TokenRVal)reader.ReadToken ();
			bodyStmt = (TokenStmt)reader.ReadToken ();
		}
	}

	/**
	 * @brief "foreach" statement
	 */
	public class TokenStmtForEach : TokenStmt {

		public TokenLVal keyLVal;
		public TokenLVal valLVal;
		public TokenLVal arrayLVal;
		public TokenStmt bodyStmt;  // there is always a body statement, though it may be a null statement

		public TokenStmtForEach (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (keyLVal);
			writer.Write (valLVal);
			writer.Write (arrayLVal);
			writer.Write (bodyStmt);
		}

		public override void ReadIn (TokenReader reader)
		{
			keyLVal   = (TokenLVal)reader.ReadToken ();
			valLVal   = (TokenLVal)reader.ReadToken ();
			arrayLVal = (TokenLVal)reader.ReadToken ();
			bodyStmt  = (TokenStmt)reader.ReadToken ();
		}
	}

	public class TokenStmtIf : TokenStmt {

		public TokenRVal testRVal;
		public TokenStmt trueStmt;
		public TokenStmt elseStmt;

		public TokenStmtIf (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (testRVal);
			writer.Write (trueStmt);
			writer.Write (elseStmt);
		}

		public override void ReadIn (TokenReader reader)
		{
			testRVal = (TokenRVal)reader.ReadToken ();
			trueStmt = (TokenStmt)reader.ReadToken ();
			elseStmt = (TokenStmt)reader.ReadToken ();
		}
	}

	public class TokenStmtJump : TokenStmt {

		public TokenName label;

		public TokenStmtJump (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (label);
		}

		public override void ReadIn (TokenReader reader)
		{
			label = (TokenName)reader.ReadToken ();
		}
	}

	public class TokenStmtNull : TokenStmt {

		public TokenStmtNull (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
		}

		public override void ReadIn (TokenReader reader)
		{
		}
	}

	public class TokenStmtRet : TokenStmt {

		public TokenRVal rVal;  // null if void

		public TokenStmtRet (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (rVal);
		}

		public override void ReadIn (TokenReader reader)
		{
			rVal = (TokenRVal)reader.ReadToken ();
		}
	}

	/**
	 * @brief statement that changes the current state.
	 */
	public class TokenStmtState : TokenStmt {

		public TokenName state;  // null for default

		public TokenStmtState (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (state);
		}

		public override void ReadIn (TokenReader reader)
		{
			state = (TokenName)reader.ReadToken ();
		}
	}

	/**
	 * @brief Encapsulates a whole switch statement including the body and all cases.
	 */
	public class TokenStmtSwitch : TokenStmt {

		public TokenRVal testRVal;               // the integer index expression
		public TokenSwitchCase cases = null;     // list of all cases, linked by .nextCase
		public TokenSwitchCase lastCase = null;  // used during reduce to point to last in 'cases' list

		public TokenStmtSwitch (Token original) : base (original) { }

		/**
		 * @brief Write abstract syntax tree representation
		 */
		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (testRVal);
			for (TokenSwitchCase thisCase = cases; thisCase != null; thisCase = thisCase.nextCase) {
				writer.Write (thisCase);
			}
			writer.Write ((Token)null);
		}

		/**
		 * @brief Read abstract syntax tree representation
		 */
		public override void ReadIn (TokenReader reader)
		{
			TokenSwitchCase thisCase;

			testRVal = (TokenRVal)reader.ReadToken ();
			while ((thisCase = (TokenSwitchCase)reader.ReadToken ()) != null) {
				if (lastCase == null) {
					cases = thisCase;
				} else {
					lastCase.nextCase = thisCase;
				}
				lastCase = thisCase;
			}
		}
	}

	/**
	 * @brief Encapsulates a case/default clause from a switch statement including the
	 *        two values and the corresponding body statements.
	 */
	public class TokenSwitchCase : Token {
		public TokenSwitchCase nextCase;  // next case in source-code order
		public TokenRVal rVal1;           // null means 'default', else 'case'
		public TokenRVal rVal2;           // null means 'case expr:', else 'case expr ... expr:'
		public TokenStmt stmts;           // statements associated with the case
		public TokenStmt lastStmt;        // used during reduce for building statement list

		public int val1;                        // codegen: value of rVal1 here
		public int val2;                        // codegen: value of rVal2 here
		public ScriptMyLabel label;             // codegen: target label here
		public TokenSwitchCase nextSortedCase;  // codegen: next case in ascending val order

		public TokenSwitchCase (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (rVal1);
			writer.Write (rVal2);
			for (TokenStmt stmt = stmts; stmt != null; stmt = (TokenStmt)stmt.nextToken) {
				writer.Write (stmt);
			}
			writer.Write ((Token)null);
		}

		public override void ReadIn (TokenReader reader)
		{
			TokenStmt stmt;

			rVal1 = (TokenRVal)reader.ReadToken ();
			rVal2 = (TokenRVal)reader.ReadToken ();
			while ((stmt = (TokenStmt)reader.ReadToken ()) != null) {
				if (lastStmt == null) {
					stmts = stmt;
				} else {
					lastStmt.nextToken = stmt;
				}
				lastStmt = stmt;
			}
		}
	}

	public class TokenStmtThrow : TokenStmt {

		public TokenRVal rVal;  // null if rethrow style

		public TokenStmtThrow (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (rVal);
		}

		public override void ReadIn (TokenReader reader)
		{
			rVal = (TokenRVal)reader.ReadToken ();
		}
	}

	/**
	 * @brief Encapsulates related try, catch and finally statements.
	 */
	public class TokenStmtTry : TokenStmt {

		public TokenStmtBlock tryStmt;
		public TokenName catchVar;		// null iff catchStmt is null
		public TokenStmtBlock catchStmt;	// can be null
		public TokenStmtBlock finallyStmt;	// can be null

		public TokenStmtTry (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (tryStmt);
			writer.Write (catchVar);
			writer.Write (catchStmt);
			writer.Write (finallyStmt);
		}

		public override void ReadIn (TokenReader reader)
		{
			tryStmt     = (TokenStmtBlock)reader.ReadToken ();
			catchVar    = (TokenName)reader.ReadToken ();
			catchStmt   = (TokenStmtBlock)reader.ReadToken ();
			finallyStmt = (TokenStmtBlock)reader.ReadToken ();
		}
	}

	public class TokenStmtWhile : TokenStmt {

		public TokenRVal testRVal;
		public TokenStmt bodyStmt;

		public TokenStmtWhile (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (testRVal);
			writer.Write (bodyStmt);
		}

		public override void ReadIn (TokenReader reader)
		{
			testRVal = (TokenRVal)reader.ReadToken ();
			bodyStmt = (TokenStmt)reader.ReadToken ();
		}
	}

	/**
	 * @brief type expressions (right-hand of 'is' keyword).
	 */
	public class TokenTypeExp : Token {
		public TokenTypeExp (Token original) : base (original) { }
	}

	public class TokenTypeExpBinOp : TokenTypeExp {
		public TokenTypeExp leftOp;
		public Token        binOp;
		public TokenTypeExp rightOp;

		public TokenTypeExpBinOp (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (leftOp);
			writer.Write (binOp);
			writer.Write (rightOp);
		}

		public override void ReadIn (TokenReader reader)
		{
			leftOp  = (TokenTypeExp)reader.ReadToken ();
			binOp   =               reader.ReadToken ();
			rightOp = (TokenTypeExp)reader.ReadToken ();
		}
	}

	public class TokenTypeExpNot : TokenTypeExp {
		public TokenTypeExp typeExp;

		public TokenTypeExpNot (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (typeExp);
		}

		public override void ReadIn (TokenReader reader)
		{
			typeExp = (TokenTypeExp)reader.ReadToken ();
		}
	}

	public class TokenTypeExpPar : TokenTypeExp {
		public TokenTypeExp typeExp;

		public TokenTypeExpPar (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (typeExp);
		}

		public override void ReadIn (TokenReader reader)
		{
			typeExp = (TokenTypeExp)reader.ReadToken ();
		}
	}

	public class TokenTypeExpType : TokenTypeExp {
		public TokenType typeToken;

		public TokenTypeExpType (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (typeToken);
		}

		public override void ReadIn (TokenReader reader)
		{
			typeToken = (TokenType)reader.ReadToken ();
		}
	}

	public class TokenTypeExpUndef : TokenTypeExp {
		public TokenTypeExpUndef (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
		}

		public override void ReadIn (TokenReader reader)
		{
		}
	}
}
