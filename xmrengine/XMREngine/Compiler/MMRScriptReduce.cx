/***************************************************\
 *  COPYRIGHT 2009, Mike Rieker, Beverly, MA, USA  *
 *  All rights reserved.                           *
\***************************************************/

/**
 * @brief Reduce raw tokens to a single script token.
 * 
 * Usage:
 *
 *  tokenBegin = returned by TokenBegin.Analyze ()
 *               representing the whole script source
 *               as a flat list of tokens
 *
 *  TokenScript tokenScript = Reduce.Analyze (TokenBegin tokenBegin);
 *  
 *  tokenScript = represents the whole script source
 *                as a tree of tokens
 */

using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Reflection.Emit;
using System.Text;

#include "lsltypes.h"

namespace OpenSim.Region.ScriptEngine.XMREngine {

	public class ScriptReduce {
		public const uint SDT_PRIVATE   =   1;
		public const uint SDT_PROTECTED =   2;
		public const uint SDT_PUBLIC    =   4;
		public const uint SDT_ABSTRACT  =   8;
		public const uint SDT_FINAL     =  16;
		public const uint SDT_NEW       =  32;
		public const uint SDT_OVERRIDE  =  64;
		public const uint SDT_STATIC    = 128;
		public const uint SDT_VIRTUAL   = 256;

		private static Dictionary<Type, int> precedence = PrecedenceInit ();

		private Type[] brkCloseOnly     = new Type[] { typeof (TokenKwBrkClose) };
		private Type[] cmpGTOnly        = new Type[] { typeof (TokenKwCmpGT)    };
		private Type[] colonOnly        = new Type[] { typeof (TokenKwColon)    };
		private Type[] colonOrDotDotDot = new Type[] { typeof (TokenKwColon),   typeof (TokenKwDotDotDot) };
		private Type[] parCloseOnly     = new Type[] { typeof (TokenKwParClose) };
		private Type[] semiOnly         = new Type[] { typeof (TokenKwSemi)     };

		/**
		 * @brief Initialize operator precedence table
		 * @returns with precedence table pointer
		 */
		private static Dictionary<Type, int> PrecedenceInit ()
		{
			Dictionary<Type, int> p = new Dictionary<Type, int> ();

			// http://www.lslwiki.net/lslwiki/wakka.php?wakka=operators

			p.Add (typeof (TokenKwComma),   30);

#define ASNPR 50
			p.Add (typeof (TokenKwAsnLSh), ASNPR);  // all assignment operators of equal precedence
			p.Add (typeof (TokenKwAsnRSh), ASNPR);  // ... so they get processed strictly right-to-left
			p.Add (typeof (TokenKwAsnAdd), ASNPR);
			p.Add (typeof (TokenKwAsnAnd), ASNPR);
			p.Add (typeof (TokenKwAsnSub), ASNPR);
			p.Add (typeof (TokenKwAsnMul), ASNPR);
			p.Add (typeof (TokenKwAsnDiv), ASNPR);
			p.Add (typeof (TokenKwAsnMod), ASNPR);
			p.Add (typeof (TokenKwAsnOr),  ASNPR);
			p.Add (typeof (TokenKwAsnXor), ASNPR);
			p.Add (typeof (TokenKwAssign), ASNPR);

			p.Add (typeof (TokenKwOrOr),   100);

			p.Add (typeof (TokenKwAndAnd), 120);

			p.Add (typeof (TokenKwOr),     140);

			p.Add (typeof (TokenKwXor),    160);

			p.Add (typeof (TokenKwAnd),    180);

			p.Add (typeof (TokenKwCmpEQ),  200);
			p.Add (typeof (TokenKwCmpNE),  200);

			p.Add (typeof (TokenKwCmpLT),  240);
			p.Add (typeof (TokenKwCmpLE),  240);
			p.Add (typeof (TokenKwCmpGT),  240);
			p.Add (typeof (TokenKwCmpGE),  240);

			p.Add (typeof (TokenKwRSh),    260);
			p.Add (typeof (TokenKwLSh),    260);

			p.Add (typeof (TokenKwAdd),    280);
			p.Add (typeof (TokenKwSub),    280);

			p.Add (typeof (TokenKwMul),    320);
			p.Add (typeof (TokenKwDiv),    320);
			p.Add (typeof (TokenKwMod),    320);

			return p;
		}

		/**
		 * @brief Reduce raw token stream to a single script token.
		 *        Performs a little semantic testing, ie, undefined variables, etc.
		 * @param tokenBegin = points to a TokenBegin
		 *                     followed by raw tokens
		 *                     and last token is a TokenEnd
		 * @returns null: not a valid script, error messages have been output
		 *          else: valid script top token
		 */
		public static TokenScript Reduce (TokenBegin tokenBegin)
		{
			return new ScriptReduce (tokenBegin).tokenScript;
		}

		/*
		 * Instance variables.
		 */
		private bool errors = false;
		private TokenDeclVar currentDeclFunc = null;
		private TokenDeclSDType currentDeclSDType = null;
		private TokenScript tokenScript;
		private TokenStmtBlock currentStmtBlock = null;

		/**
		 * @brief the constructor does all the processing.
		 * @param token = first token of script after the TokenBegin token
		 * @returns tokenScript = null: there were errors
		 *                        else: successful
		 */
		private ScriptReduce (TokenBegin tokenBegin)
		{
			/*
			 * Create a place to put the top-level script components,
			 * eg, state bodies, functions, global variables.
			 */
			tokenScript = new TokenScript (tokenBegin.nextToken);

			/*
			 * 'XMROption' 'expiryDays' <integer> ';'
			 * Parse and remove from source token stream.
			 */
			for (Token t = tokenBegin; !(t is TokenEnd); t = t.nextToken) {
				if ((t is TokenName) &&
				    (t.nextToken is TokenName) && 
				    (t.nextToken.nextToken is TokenInt) && 
				    (t.nextToken.nextToken.nextToken is TokenKwSemi)) {
					TokenName t1 = (TokenName)t;
					TokenName t2 = (TokenName)t1.nextToken;
					TokenInt  t3 = (TokenInt)t2.nextToken;
					if ((t1.val.ToLower () == "xmroption") && 
					    (t2.val.ToLower () == "expirydays")) {
						tokenScript.expiryDays = t3.val;
						t = t3.nextToken;
						t1.prevToken.nextToken = t.nextToken;
						t.nextToken.prevToken = t1.prevToken;
					}
				}
			}

			/*
			 * 'class', 'delegate', 'instance' all define types.
			 * So we pre-scan the source tokens for those keywords
			 * to build a script-defined type table and substitute
			 * type tokens for those names in the source.  This is
			 * done as a separate scan so they can cross-reference
			 * each other.
			 */
			ParseSDTypePreScanPassOne  (tokenBegin);        // catalog definitions
			ParseSDTypePreScanPassTwo  (tokenBegin);        // substitute references
			ParseSDTypePreScanPassTree (tokenBegin, null);  // instantiate generics

			int braces = 0;
			Token prevTok = null;
			for (Token token = tokenBegin; token != null; token = token.nextToken) {
				if (token is TokenKwParClose) braces -= 2;
				if (token is TokenKwBrcClose) braces -= 4;
				StringBuilder sb = new StringBuilder ("ScriptReduce*: ");
				sb.Append (token.line.ToString ().PadLeft (3));
				sb.Append (".");
				sb.Append (token.posn.ToString ().PadLeft (3));
				sb.Append ("  ");
				sb.Append (token.GetType ().Name.PadRight (24));
				sb.Append (" : ");
				for (int i = 0; i < braces; i ++) sb.Append (' ');
				token.DebString (sb);
				Console.WriteLine (sb.ToString ());
				if (token.prevToken != prevTok) {
					Console.WriteLine ("ScriptReduce*:  -- prevToken link bad");
				}
				if (token is TokenKwBrcOpen) braces += 4;
				if (token is TokenKwParOpen) braces += 2;
				prevTok = token;
			}

			/*
			 * Scan through the tokens until we reach the end.
			 */
			for (Token token = tokenBegin.nextToken; !(token is TokenEnd);) {
				if (token is TokenKwSemi) {
					token = token.nextToken;
					continue;
				}

				/*
				 * Script-defined type declarations.
				 */
				if (ParseDeclSDTypes (ref token, null, SDT_PUBLIC)) continue;

				/*
				 * constant <name> = <rval> ;
				 */
				if (token is TokenKwConst) {
					ParseDeclVar (ref token);
					continue;
				}

				/*
				 * <type> <name> ;
				 * <type> <name> = <rval> ;
				 */
				if ((token is TokenType) &&
				    (token.nextToken is TokenName) &&
				    ((token.nextToken.nextToken is TokenKwSemi) || 
				     (token.nextToken.nextToken is TokenKwAssign))) {
					ParseDeclVar (ref token);
					continue;
				}

				/*
				 * <type> <name> { [ get { <body> } ] [ set { <body> } ] }
				 */
				if ((token is TokenType) &&
				    (token.nextToken is TokenName) &&
				    (token.nextToken.nextToken is TokenKwBrcOpen)) {
					ParseProperty (ref token, false, true);
					continue;
				}

				/*
				 * <type> <name> <funcargs> <funcbody>
				 * global function returning specified type
				 */
				if (token is TokenType) {
					TokenType tokenType = (TokenType)token;

					token = token.nextToken;
					if (!(token is TokenName)) {
						ErrorMsg (token, "expecting variable/function name");
						token = SkipPastSemi (token);
						continue;
					}
					TokenName tokenName = (TokenName)token;
					token = token.nextToken;
					if (!(token is TokenKwParOpen)) {
						ErrorMsg (token, "<type> <name> must be followed by ; = or (");
						token = SkipPastSemi (token);
						continue;
					}
					token = tokenType;
					TokenDeclVar tokenDeclFunc = ParseDeclFunc (ref token, false, false, false);
					if (tokenDeclFunc == null) continue;
					if (!tokenScript.AddVarEntry (tokenDeclFunc)) {
						ErrorMsg (tokenName, "duplicate function " + tokenDeclFunc.funcNameSig.val);
					}
					continue;
				}

				/*
				 * <name> <funcargs> <funcbody>
				 * global function returning void
				 */
				if (token is TokenName) {
					TokenName tokenName = (TokenName)token;
					token = token.nextToken;
					if (!(token is TokenKwParOpen)) {
						ErrorMsg (token, "looking for open paren after assuming " + 
						                 tokenName.val + " is a function name");
						token = SkipPastSemi (token);
						continue;
					}
					token = tokenName;
					TokenDeclVar tokenDeclFunc = ParseDeclFunc (ref token, false, false, false);
					if (tokenDeclFunc == null) continue;
					if (!tokenScript.AddVarEntry (tokenDeclFunc)) {
						ErrorMsg (tokenName, "duplicate function " + tokenDeclFunc.funcNameSig.val);
					}
					continue;
				}

				/*
				 * default <statebody>
				 */
				if (token is TokenKwDefault) {
					TokenDeclState tokenDeclState = new TokenDeclState (token);
					token = token.nextToken;
					tokenDeclState.body = ParseStateBody (ref token);
					if (tokenDeclState.body == null) continue;
					if (tokenScript.defaultState != null) {
						ErrorMsg (tokenDeclState, "default state already declared");
						continue;
					}
					tokenScript.defaultState = tokenDeclState;
					continue;
				}

				/*
				 * state <name> <statebody>
				 */
				if (token is TokenKwState) {
					TokenDeclState tokenDeclState = new TokenDeclState (token);
					token = token.nextToken;
					if (!(token is TokenName)) {
						ErrorMsg (token, "state must be followed by state name");
						token = SkipPastSemi (token);
						continue;
					}
					tokenDeclState.name = (TokenName)token;
					token = token.nextToken;
					tokenDeclState.body = ParseStateBody (ref token);
					if (tokenDeclState.body == null) continue;
					if (tokenScript.states.ContainsKey (tokenDeclState.name.val)) {
						ErrorMsg (tokenDeclState.name, "duplicate state definition");
						continue;
					}
					tokenScript.states.Add (tokenDeclState.name.val, tokenDeclState);
					continue;
				}

				/*
				 * Doesn't fit any of those forms, output message and skip to next statement.
				 */
				ErrorMsg (token, "looking for var name, type, state or default, script-defined type declaration");
				token = SkipPastSemi (token);
				continue;
			}

			/*
			 * Must have a default state to start in.
			 */
			if (!errors && (tokenScript.defaultState == null)) {
				ErrorMsg (tokenScript, "no default state defined");
			}

			/*
			 * If any error messages were written out, set return value to null.
			 */
			if (errors) tokenScript = null;
		}

		/**
		 * @prief Pre-scan the source for class, delegate and interface type definition keywords.
		 *        Clump the keywords and name being defined together.
		 *        In the case of a delegate with an explicit return type, it reverses the name and return type.
		 *        After this completes there shouldn't be any TokenKw{Class,Delegate,Interface} keywords in 
		 *        the source, they are all replaced by TokenDeclSDType{Class,Delegate,Interface} tokens which 
		 *        also encapsulate the name of the type being defined.
		 */
		private void ParseSDTypePreScanPassOne (Token tokenBegin)
		{
			Stack<int> braceLevels = new Stack<int> ();
			Stack<TokenDeclSDType> outerLevels = new Stack<TokenDeclSDType> ();
			braceLevels.Push (-2);
			outerLevels.Push (null);

			int braces = 0;
			for (Token t = tokenBegin; !((t = t.nextToken) is TokenEnd);) {

				/*
				 * Keep track of nested definitions so we can link them up.
				 */
				if (t is TokenKwBrcOpen) {
					braces ++;
					continue;
				}
				if (t is TokenKwBrcClose) {
					if (-- braces < 0) {
						ErrorMsg (t, "{ } mismatch");
						return;
					}
					if (braceLevels.Peek () == braces) {
						braceLevels.Pop ();
						outerLevels.Pop ().endToken = t;
					}
					continue;
				}
				if (t is TokenKwSemi) {
					if (braceLevels.Peek () == -1) {
						braceLevels.Pop ();
						outerLevels.Pop ().endToken = t;
					}
					continue;
				}

				/*
				 * Check for 'class' or 'interface'.
				 * They always define a new class or interface.
				 */
				if ((t is TokenKwClass) || (t is TokenKwInterface)) {
					Token kw = t;
					t = t.nextToken;
					if (!(t is TokenName)) {
						ErrorMsg (t, "expecting class or interface name");
						t = SkipPastSemi (t).prevToken;
						continue;
					}
					TokenName name = (TokenName)t;
					t = t.nextToken;

					/*
					 * Malloc the script-defined type object.
					 */
					TokenDeclSDType decl;
					if (kw is TokenKwClass) decl = new TokenDeclSDTypeClass (name);
					               else decl = new TokenDeclSDTypeInterface (name);
					decl.outerSDType = outerLevels.Peek ();

					/*
					 * Check for generic parameter list.
					 */
					if (!ParseGenProtoParamList (ref t, decl)) continue;

					/*
					 * Enter it in name lists so it can be seen by others.
					 */
					CatalogSDTypeDecl (decl);

					/*
					 * Splice in a TokenDeclSDType token that replaces the keyword and the name tokens.
					 *   kw = points to 'class' or 'interface' keyword.
					 *    t = points to just past last part of class name parsed, hopefully a ':' or '{'.
					 */
					decl.prevToken = kw.prevToken;
					decl.nextToken = t;
					decl.prevToken.nextToken = decl;
					decl.nextToken.prevToken = decl;
					t = decl;  // must be before '{'

					/*
					 * Start inner type definitions.
					 */
					braceLevels.Push (braces);
					outerLevels.Push (decl);
					continue;
				}

				/*
				 * Check for 'delegate'.
				 * It always defines a new delegate.
				 */
				if (t is TokenKwDelegate) {
					Token kw = t;
					t = t.nextToken;

					/*
					 * Next thing might be an explicit return type or the delegate's name.
					 * If it's a type token, then it's the return type, simple enough.
					 * But if it's a name token, it might be the name of some other script-defined type.
					 * The way to tell is that the delegate name is followed by a '(', whereas an 
					 * explicit return type is followed by the delegate name.
					 */
					Token retType = t;
					TokenName delName = null;
					Token u;
					int angles = 0;
					for (u = t; !(u is TokenKwParOpen); u = u.nextToken) {
						if ((u is TokenKwSemi) || (u is TokenEnd)) break;
						if (u is TokenKwCmpLT) angles ++;
						if (u is TokenKwCmpGT) angles --;
						if ((angles == 0) && (u is TokenName)) delName = (TokenName)u;
					}
					if (!(u is TokenKwParOpen)) {
						ErrorMsg (u, "expecting ( for delegate parameter list");
						t = SkipPastSemi (t).prevToken;
						continue;
					}
					if (delName == null) {
						ErrorMsg (u, "expecting delegate name");
						t = SkipPastSemi (t).prevToken;
						continue;
					}
					if (retType == delName) retType = null;

					/*
					 * Malloc the script-defined type object.
					 */
					TokenDeclSDTypeDelegate decl = new TokenDeclSDTypeDelegate (delName);
					decl.outerSDType = outerLevels.Peek ();

					/*
					 * Check for generic parameter list.
					 */
					t = delName.nextToken;
					if (!ParseGenProtoParamList (ref t, decl)) continue;

					/*
					 * Enter it in name lists so it can be seen by others.
					 */
					CatalogSDTypeDecl (decl);

					/*
					 * Splice in the token that replaces the 'delegate' keyword and the whole name 
					 * (including the '<' name ... '>' parts). The return type token(s), if any, 
					 * follow the splice token and come before the '('.
					 */
					decl.prevToken = kw.prevToken;
					kw.prevToken.nextToken = decl;

					if (retType == null) {
						decl.nextToken = t;
						t.prevToken = decl;
					} else {
						decl.nextToken = retType;
						retType.prevToken = decl;
						retType.nextToken = t;
						t.prevToken = retType;
					}
					t = decl;  // must be before ';'

					/*
					 * Start inner type definitions.
					 */
					braceLevels.Push (-1);
					outerLevels.Push (decl);
					continue;
				}
			}
		}

		/**
		 * @brief Parse a possibly generic type definition's parameter list.
		 * @param t = points to the possible opening '<' on entry
		 *            points just past the closing '>' on return
		 * @param decl = the generic type being declared
		 * @returns false: parse error
		 *           true: decl.genParams = filled in with parameter list
		 *                 decl.innerSDTypes = filled in with parameter list
		 */
		private static readonly TokenDeclSDTypeGenParam[] zeroGenParams = new TokenDeclSDTypeGenParam[0];
		private bool ParseGenProtoParamList (ref Token t, TokenDeclSDType decl)
		{
			/*
			 * Maybe there aren't any generic parameters.
			 * But we inherit generic parameters from our outer type.
			 */
			if (!(t is TokenKwCmpLT)) {
				if (decl.outerSDType != null) {
					decl.genParams = decl.outerSDType.genParams;
				} else {
					decl.genParams = zeroGenParams;
				}
				return true;
			}

			/*
			 * Build list of generic parameter names.
			 * Add them as inner types to the defining class.
			 *
			 * The array decl.genParams is added on to from the outer class, so there 
			 * only needs to be one argument array, allowing TokenTypeSDTypeGenParam.ResolveGenParam() 
			 * to get the arg type in one access.
			 *
			 * The decl.innerSDTypes dictionary just gets the defintions for this type.
			 */
			List<TokenDeclSDTypeGenParam> parms = new List<TokenDeclSDTypeGenParam> ();
			if (decl.outerSDType != null) {
				foreach (TokenDeclSDTypeGenParam outerGenParam in decl.outerSDType.genParams) {
					parms.Add (outerGenParam);
				}
			}
			do {
				t = t.nextToken;
				if (!(t is TokenName)) {
					ErrorMsg (t, "expecting generic parameter name");
					break;
				}
				TokenName tn = (TokenName)t;
				TokenDeclSDTypeGenParam ttgp = new TokenDeclSDTypeGenParam (tn, decl, parms.Count);
				ttgp.shortName = tn;
				ttgp.genParams = zeroGenParams;
				parms.Add (ttgp);
				if (decl.innerSDTypes.ContainsKey (tn.val)) {
					ErrorMsg (tn, "duplicate use of generic parameter name");
				} else {
					decl.innerSDTypes.Add (tn.val, ttgp);
				}
				t = t.nextToken;
			} while (t is TokenKwComma);
			if (!(t is TokenKwCmpGT)) {
				ErrorMsg (t, "expecting , for more params or > to end param list");
				return false;
			}
			t = t.nextToken;
			decl.genParams = parms.ToArray ();

			return true;
		}

		/**
		 * @brief Catalog a script-defined type.
		 *        Its short name (eg, 'Node') gets put in the next outer level (eg, 'List')'s inner type definition table.
		 *        Its long name (eg, 'List.Node') gets put in the global type definition table.
		 */
		private void CatalogSDTypeDecl (TokenDeclSDType decl)
		{
			string longName = decl.longName.val;
			TokenDeclSDType dupDecl;
			if (tokenScript.sdSrcTypesTryGetValue (longName, out dupDecl)) {
				ErrorMsg (decl, "duplicate definition of type " + longName);
				ErrorMsg (dupDecl, "previous definition here");
			} else {
				tokenScript.sdSrcTypesAdd (longName, decl);
				if (decl.outerSDType != null) {
					decl.outerSDType.innerSDTypes.Add (decl.shortName.val, decl);
				}
			}
		}

		/**
		 * @brief Replace all TokenName tokens that refer to the script-defined types with 
		 *        corresponding TokenTypeSDType{Class,Delegate,GenParam,Interface} tokens.
		 *        Also handle generic references, ie, recognize that 'List<integer>' is an
		 *        instantiation of 'List<>'.
		 */
		private void ParseSDTypePreScanPassTwo (Token tokenBegin)
		{
			TokenDeclSDType outerSDType = null;

			for (Token t = tokenBegin; !((t = t.nextToken) is TokenEnd);) {

				/*
				 * Maybe it's time to pop out of an outer class definition.
				 */
				if ((outerSDType != null) && (outerSDType.endToken == t)) {
					outerSDType = outerSDType.outerSDType;
					continue;
				}

				/*
				 * Check for beginning of script-defined type definitions.
				 * They can have nested definitions and generic parameters in their innerSDTypes[] 
				 * so add them to the stack.
				 */
				if (t is TokenDeclSDType) {
					outerSDType = (TokenDeclSDType)t;
					continue;
				}

				/*
				 * For names not preceded by a '.', scan the script-defined type definition 
				 * stack for that name.  If found, substitute in a type token for the name token.
				 */
				if ((t is TokenName) && !(t.prevToken is TokenKwDot)) {
					TrySpliceTypeRef (ref t, outerSDType);
				}
			}
		}

		/**
		 * @brief Try to convert the source token string to a type reference
		 *        and splice the type reference into the source token string
		 *        replacing the original tokens.
		 * @param t = points to the initial TokenName token
		 * @param outerSDType = null: this is a top-level code reference
		 *                      else: this code is within outerSDType
		 * @returns false: parse error, message already output
		 *                 t advanced to point of error
		 *           true: no substitution: t points to original TokenName
		 *                 substitution: t updated to spliced-in TokenType
		 */
		private bool TrySpliceTypeRef (ref Token t, TokenDeclSDType outerSDType)
		{
			Token start = t;

			/*
			 * Look for the name as a type defined by outerSDType or anything
			 * even farther out than that.  If not found, simply return true
			 * without updating t, meaning that t isn't the name of a type.
			 */
			TokenName tnametok = (TokenName)t;
			string tnamestr = tnametok.val;

			TokenDeclSDType decl = null;
			for (TokenDeclSDType nt = outerSDType; nt != null; nt = nt.outerSDType) {
				if (nt.innerSDTypes.TryGetValue (tnamestr, out decl)) break;
			}
			if (decl == null) {
				if (!tokenScript.sdSrcTypesTryGetValue (tnamestr, out decl)) return true;
			}

			/*
			 * Build list of generic arguments starting with all this one's outer types as 
			 * arguments.  Eg. in:
			 *    class List<T> {
			 *        ...
			 *        Enumerator x;   <-- we are parsing Enumerator
			 *                            and now decl = List.Enumerator.
			 *                            but it really is List<T>.Enumerator.
			 *                            so we want to start genArgList with T in 
			 *                            it so we end up with same thing as if the 
			 *                            source code had List<T>.Enumerator.
			 *        ...
			 *        class Enumerator {
			 *            ...
			 *        }
			 *    }
			 */
			List<TokenType> genArgList = new List<TokenType> ();
			TokenDeclSDType ot = decl.outerSDType;
			if (ot != null) {
				for (int i = 0; i < ot.genParams.Length; i ++) {
					TokenDeclSDTypeGenParam genParam = ot.genParams[i];
					TokenTypeSDType genArg = genParam.MakeRefToken (start, null);
					genArgList.Add (genArg);
				}
			}

			/*
			 * Pick up generic arguments and subtypes.
			 */
			while (true) {

				/*
				 * Maybe it requires some (more) generic argument types.
				 * Fortunately we know exactly how many.
				 * If so, parse them out.
				 */
				bool first = true;
				while (genArgList.Count < decl.genParams.Length) {
					t = t.nextToken;
					if (first && !(t is TokenKwCmpLT)) {
						ErrorMsg (t, "require < for generic arguments");
						return false;
					}
					if (!first && !(t is TokenKwComma)) {
						ErrorMsg (t, "require , for more generic arguments");
						return false;
					}
					t = t.nextToken;
					if (t is TokenName) {
						if (!TrySpliceTypeRef (ref t, outerSDType)) return false;
					}
					if (!(t is TokenType)) {
						ErrorMsg (t, "expecting type as generic argument");
						return false;
					}
					genArgList.Add ((TokenType)t);
					first = false;
				}
				if (!first) {
					t = t.nextToken;
					if (!(t is TokenKwCmpGT)) {
						ErrorMsg (t, "require > to end generic argumets");
						return false;
					}
				}

				/*
				 * If name<args> is followed by '.' <innername>, try to find
				 * the inner name.  If inner name not found, it is probably 
				 * something like a static field or method name, so leave it 
				 * alone.
				 */
				if (!(t.nextToken is TokenKwDot)) break;
				if (!(t.nextToken.nextToken is TokenName)) break;
				tnametok = (TokenName)t.nextToken.nextToken;
				TokenDeclSDType innerdecl;
				if (!decl.innerSDTypes.TryGetValue (tnametok.val, out innerdecl)) break;
				decl = innerdecl;
				t = tnametok;
			}

			/*
			 * Create a reference in the source to the definition
			 * that encapsulates the long dotted type name given in
			 * the source, and replace the long dotted type name in
			 * the source with the reference token, eg, replace 
			 * 'Dictionary' '<' 'string' ',' 'integer' '>' '.' 'ValueList'
			 * with 'Dictionary<string,integer>.ValueList'.
			 */
			TokenTypeSDType refer = decl.MakeRefToken (start, genArgList.ToArray ());
			refer.prevToken = start.prevToken;  // start points right at the first TokenName
			refer.nextToken = t.nextToken;      // t points at the last TokenName or TokenKwCmpGT
			refer.prevToken.nextToken = refer;
			refer.nextToken.prevToken = refer;
			t = refer;

			return true;
		}

		/**
		 * @brief Replace all TokenName tokens that refer to the script-defined types with 
		 *        corresponding TokenTypeSDType{Class,Delegate,GenParam,Interface} tokens.
		 *        Also handle generic references, ie, recognize that 'List<integer>' is an
		 *        instantiation of 'List<>'.
		 */
		private void ParseSDTypePreScanPassTree (Token tokenBegin, TokenType[] outerGenArgs)
		{
			Token tokenEnd = null;
			if (tokenBegin is TokenDeclSDType) {
				tokenEnd = ((TokenDeclSDType)tokenBegin).endToken;
			}

			for (Token t = tokenBegin; (t = t.nextToken) != tokenEnd;) {

				/*
				 * Completely skip over any generic prototypes, eg, the whole 'class Dictionary<K,V> { ... }' thing.
				 * We deal with their contents when we have the concrete arguments to apply.
				 */
				if (t is TokenDeclSDType) {
					TokenDeclSDType decl = (TokenDeclSDType)t;
					if (decl.genParams.Length > 0) {
						t = decl.endToken;
					}
					continue;
				}

				/*
				 * See if we have a reference to a generic prototype, eg, 'Dictionary<string,integer>'.
				 * If so, make sure we have an instantiation of that generic so code will be generated 
				 * for that instantiation.
				 */
				if (t is TokenTypeSDType) {
					TokenTypeSDType type = (TokenTypeSDType)t;
					if (type.genArgs.Length > 0) {

						/*
						 * Build array of concrete types to pass for generic instantiation.
						 * Also build name of the instantiated type, eg, 'Dictionary<string,integer>.Converter<float>'.
						 * The resultant array for the example will contain [0]'string', [1]'integer', [2]'float'.
						 * The resultant array never contains other generic parameter types, we completely resolve them:
						 *   1) We start with a null outerGenArgs[] so it doesn't have any TokenTypeSDTypeGenParams in it trivially.
						 *   2) So the first innerGenArgs[] can't have any TokenTypeSDTypeGenParams in it because ResolveGenParam()
						 *      doesn't have any TokenTypeSDTypeGenParam to put in it.  It would get a subscript error if type.genArgs[]
						 *      had any TokenTypeSDTypeGenParams in it.
						 *   3) On the next recursive call, outerGenArgs came from the innerGenArgs and so it still doesn't have
						 *      any TokenTypeSDTypeGenParams in it.  So ResolveGenParam() has nothing but non-TokenTypeSDTypeGenParams to 
						 *      substitute in for any TokenTypeSDTypeGenParams in type.genArgs[].  Thus the new innerGenArgs is free of 
						 *      TokenTypeSDTypeGenParams.
						 */
						Stack<TokenDeclSDType> declStack = new Stack<TokenDeclSDType> ();
						for (TokenDeclSDType decl = type.GetDecl (); decl != null; decl = decl.outerSDType) {
							declStack.Push (decl);
						}
						bool first = true;
						int i = 0;
						StringBuilder sb = new StringBuilder ();
						TokenType[] innerGenArgs = new TokenType[type.genArgs.Length];
						while (declStack.Count > 0) {
							TokenDeclSDType decl = declStack.Pop ();
							if (!first) sb.Append ('.');
							sb.Append (decl.shortName.val);
							bool ffirst = true;
							while (i < decl.genParams.Length) {
								sb.Append (ffirst ? '<' : ',');
								innerGenArgs[i] = type.genArgs[i].ResolveGenParam (outerGenArgs);
								sb.Append (innerGenArgs[i++].ToString ());
								ffirst = false;
							}
							if (!ffirst) sb.Append ('>');
							first = false;
						}
						string sbstr = sb.ToString ();

						/*
						 * If we haven't already instantiated that exact type, instantiate it.
						 */
						if (!tokenScript.sdSrcTypesContainsKey (sbstr)) {

							/*
							 * Create a non-generic named eg, 'Dictionary<string,integer>.Converter<float>'
							 * and catalog it so CodeGen will generate its code.
							 * For the example given, type.decl points to the generic prototype for 
							 * 'Dictionary<,>.Converter<>' and innerGenAhrgs has 'string', 'integer', 'float'.
							 */
							TokenDeclSDTypeGenInst instance = new TokenDeclSDTypeGenInst (type.GetDecl ());
							instance.shortName = new TokenName (instance, sbstr);
							instance.instOfGenProto = type.GetDecl ();
							instance.genArgs = innerGenArgs;
							tokenScript.sdSrcTypesAdd (sbstr, instance);

							/*
							 * Now scan through the generic prototype but substitute out its parameters
							 * with the argument list.  So if we just instantiated something like 
							 * 'List<strinng>', this will instantiate things like 'List<string>.Enumerator'.
							 * It will not instantiate G2 in:
							 *    class G1<T,U> ... { ... class G2<V> { ... } ... }
							 * ...unless there is a reference to G2<> giving it a concrete type.
							 */
							ParseSDTypePreScanPassTree (type.GetDecl (), innerGenArgs);
						}
					}
				}
			}
		}

		/**
		 * @brief Parse script-defined type declarations.
		 * @param token = points to possible script-defined type keyword
		 * @param outerSDType = null: top-level type
		 *                      else: sub-type of this type
		 * @param flags = access level (SDT_{PRIVATE,PROTECTED,PUBLIC}
		 * @returns true: something defined; else: not a sd type def
		 */
		private bool ParseDeclSDTypes (ref Token token, TokenDeclSDType outerSDType, uint flags)
		{
			if (!(token is TokenDeclSDType)) return false;

			TokenDeclSDType decl = (TokenDeclSDType)token;

			/*
			 * If declaration of generic type, skip it.
			 * The instantiations get parsed (ie, when we know the concrete types).
			 */
			if (decl.genParams.Length > 0) {
				token = decl.endToken.nextToken;
				return true;
			}

			/*
			 * Non-generic types get parsed inline because we know all their types.
			 */
			if (decl is TokenDeclSDTypeClass) {
				ParseDeclClass (ref token, outerSDType, flags);
				return true;
			}
			if (decl is TokenDeclSDTypeDelegate) {
				ParseDeclDelegate (ref token, outerSDType, flags);
				return true;
			}
			if (decl is TokenDeclSDTypeInterface) {
				ParseDeclInterface (ref token, outerSDType, flags);
				return true;
			}

			throw new Exception ("unhandled token " + token.GetType ().ToString ());
		}

		/**
		 * @brief Parse a class declaration.
		 * @param token = points to TokenDeclSDTypeClass token
		 *                points just past closing '}' on return
		 * @param outerSDType = null: this is a top-level class
		 *                      else: this class is being defined inside this type
		 * @param flags = SDT_{PRIVATE,PROTECTED,PUBLIC}
		 */
		private void ParseDeclClass (ref Token token, TokenDeclSDType outerSDType, uint flags)
		{
			bool haveExplicitConstructor = false;
			Token u = token;
			TokenDeclSDTypeClass tokdeclcl;

			tokdeclcl = (TokenDeclSDTypeClass)u;
			tokdeclcl.outerSDType = outerSDType;
			tokdeclcl.accessLevel = flags;
			u = u.nextToken;

			// make this class the currently compiled class
			// used for retrieving stuff like 'this' possibly
			// in field initialization code
			TokenDeclSDType saveCurSDType = currentDeclSDType;
			currentDeclSDType = tokdeclcl;

			// next can be ':' followed by list of implemented
			// interfaces and one extended class
			if (u is TokenKwColon) {
				u = u.nextToken;
				while (true) {
					if (u is TokenTypeSDTypeClass) {
						TokenDeclSDTypeClass c = ((TokenTypeSDTypeClass)u).decl;
						if (tokdeclcl.extends == null) {
							tokdeclcl.extends = c;
						} else if (tokdeclcl.extends != c) {
							ErrorMsg (u, "can extend from only one class");
						}
					} else if (u is TokenTypeSDTypeInterface) {
						TokenDeclSDTypeInterface i = ((TokenTypeSDTypeInterface)u).decl;
						if (!tokdeclcl.implements.Contains (i)) {
							tokdeclcl.implements.Add (i);
						}
					} else {
						ErrorMsg (u, "expecting class or interface name");
						if (u is TokenKwBrcOpen) break;
					}
					u = u.nextToken;
					if (!(u is TokenKwComma)) break;
					u = u.nextToken;
				}
			}

			// next must be '{' to open class declaration body
			if (!(u is TokenKwBrcOpen)) {
				ErrorMsg (u, "expecting { to open class declaration body");
				token = SkipPastSemi (token);
				goto ret;
			}
			token = u.nextToken;

			// push a var frame to put all the class members in
			tokenScript.PushVarFrame ();
			tokdeclcl.members = tokenScript.variablesStack;

			// process declaration statements until '}'
			while (!(token is TokenKwBrcClose)) {
				if (token is TokenKwSemi) {
					token = token.nextToken;
					continue;
				}

				/*
				 * Check for all qualifiers.
				 */
				flags = ParseQualifierFlags (ref token);

				/*
				 * Parse nested script-defined type definitions.
				 */
				if (ParseDeclSDTypes (ref token, tokdeclcl, flags)) continue;

				/*
				 * constant <name> = <rval> ;
				 */
				if (token is TokenKwConst) {
					if ((flags & (SDT_ABSTRACT | SDT_NEW | SDT_OVERRIDE | SDT_VIRTUAL)) != 0) {
						ErrorMsg (token, "cannot have abstract, new, override or virtual field");
					}
					TokenDeclVar var = ParseDeclVar (ref token);
					if (var != null) {
						var.sdtClass = tokdeclcl;
						var.sdtFlags = flags | SDT_STATIC;
					}
					continue;
				}

				/*
				 * <type> <name> ;
				 * <type> <name> = <rval> ;
				 */
				if ((token is TokenType) &&
				    (token.nextToken is TokenName) &&
				    ((token.nextToken.nextToken is TokenKwSemi) || 
				     (token.nextToken.nextToken is TokenKwAssign))) {
					if ((flags & (SDT_ABSTRACT | SDT_FINAL | SDT_NEW | SDT_OVERRIDE | SDT_VIRTUAL)) != 0) {
						ErrorMsg (token, "cannot have abstract, final, new, override or virtual field");
					}
					TokenDeclVar var = ParseDeclVar (ref token);
					if (var != null) {
						var.sdtClass = tokdeclcl;
						var.sdtFlags = flags;
					}
					continue;
				}

				/*
				 * <type> <name> [ : <implintfs> ] { [ get { <body> } ] [ set { <body> } ] }
				 */
				if ((token is TokenType) &&
				    (token.nextToken is TokenName) &&
				    (token.nextToken.nextToken is TokenKwBrcOpen || 
				     token.nextToken.nextToken is TokenKwColon)) {
					TokenDeclVar var = ParseProperty (ref token, (flags & SDT_ABSTRACT) != 0, true);
					if (var != null) {
						var.sdtClass = tokdeclcl;
						var.sdtFlags = flags;
						if (var.getProp != null) {
							var.getProp.sdtClass = tokdeclcl;
							var.getProp.sdtFlags = flags;
						}
						if (var.setProp != null) {
							var.setProp.sdtClass = tokdeclcl;
							var.setProp.sdtFlags = flags;
						}
					}
					continue;
				}

				/*
				 * 'constructor' '(' arglist ')' [ ':' [ 'base' ] '(' baseconstructorcall ')' ] '{' body '}'
				 */
				if (token is TokenKwConstructor) {
					ParseSDTClassCtorDecl (ref token, flags, tokdeclcl);
					haveExplicitConstructor = true;
					continue;
				}

				/*
				 * <type> <name> <funcargs> <funcbody>
				 * method with explicit return type
				 */
				if (token is TokenType) {
					ParseSDTClassMethodDecl (ref token, flags, tokdeclcl);
					continue;
				}

				/*
				 * <name> <funcargs> <funcbody>
				 * method returning void
				 */
				if ((token is TokenName) || ((token is TokenKw) && ((TokenKw)token).sdtClassOp)) {
					ParseSDTClassMethodDecl (ref token, flags, tokdeclcl);
					continue;
				}

				/*
				 * That's all we support in a class declaration.
				 */
				ErrorMsg (token, "expecting field or method declaration");
				token = SkipPastSemi (token);
			}

			/*
			 * If script didn't specify any constructor, create a default no-argument one.
			 */
			if (!haveExplicitConstructor) {
				TokenDeclVar tokenDeclFunc  = new TokenDeclVar (token, null, tokenScript);
				tokenDeclFunc.retType       = new TokenTypeVoid (token);
				tokenDeclFunc.argDecl       = new TokenArgDecl (token);
				tokenDeclFunc.funcNameSig   = new TokenName (token, "constructor()");
				tokenDeclFunc.sdtClass      = tokdeclcl;
				tokenDeclFunc.sdtFlags      = SDT_PUBLIC | SDT_NEW;
				tokenDeclFunc.body          = new TokenStmtBlock (token);
				tokenDeclFunc.body.function = tokenDeclFunc;

				if (tokdeclcl.extends != null) {
					SetUpDefaultBaseCtorCall (tokenDeclFunc);
				} else {
					// default constructor that doesn't do anything is trivial
					tokenDeclFunc.triviality = Triviality.trivial;
				}

				tokenScript.AddVarEntry (tokenDeclFunc);
			}

			/*
			 * Skip over the closing brace and pop corresponding var frame.
			 */
			token = token.nextToken;
			tokenScript.PopVarFrame ();
		ret:
			currentDeclSDType = saveCurSDType;
		}

		/**
		 * @brief Parse out abstract/override/private/protected/public/static/virtual keywords.
		 */
		private Dictionary<uint, Token> foundFlags = new Dictionary<uint, Token> ();
		private uint ParseQualifierFlags (ref Token token)
		{
			foundFlags.Clear ();
			while (true) {
				if (token is TokenKwPrivate) {
					token = AddQualifierFlag (token, SDT_PRIVATE, SDT_PROTECTED | SDT_PUBLIC);
					continue;
				}
				if (token is TokenKwProtected) {
					token = AddQualifierFlag (token, SDT_PROTECTED, SDT_PRIVATE | SDT_PUBLIC);
					continue;
				}
				if (token is TokenKwPublic) {
					token = AddQualifierFlag (token, SDT_PUBLIC, SDT_PRIVATE | SDT_PROTECTED);
					continue;
				}

				if (token is TokenKwAbstract) {
					token = AddQualifierFlag (token, SDT_ABSTRACT, SDT_FINAL | SDT_STATIC | SDT_VIRTUAL);
					continue;
				}
				if (token is TokenKwFinal) {
					token = AddQualifierFlag (token, SDT_FINAL, SDT_ABSTRACT | SDT_VIRTUAL);
					continue;
				}
				if (token is TokenKwNew) {
					token = AddQualifierFlag (token, SDT_NEW, SDT_OVERRIDE);
					continue;
				}
				if (token is TokenKwOverride) {
					token = AddQualifierFlag (token, SDT_OVERRIDE, SDT_NEW | SDT_STATIC);
					continue;
				}
				if (token is TokenKwStatic) {
					token = AddQualifierFlag (token, SDT_STATIC, SDT_ABSTRACT | SDT_OVERRIDE | SDT_VIRTUAL);
					continue;
				}
				if (token is TokenKwVirtual) {
					token = AddQualifierFlag (token, SDT_VIRTUAL, SDT_ABSTRACT | SDT_NEW | SDT_STATIC);
					continue;
				}
				break;
			}

			uint flags = 0;
			foreach (uint flag in foundFlags.Keys) flags |= flag;
			if ((flags & (SDT_PRIVATE | SDT_PROTECTED | SDT_PUBLIC)) == 0) {
				ErrorMsg (token, "must specify exactly one of private, protected or public");
			}
			return flags;
		}
		private Token AddQualifierFlag (Token token, uint add, uint confs)
		{
			while (confs != 0) {
				uint conf = (uint)(confs & -confs);
				Token confToken;
				if (foundFlags.TryGetValue (conf, out confToken)) {
					ErrorMsg (token, "conflicts with " + confToken.ToString ());
				}
				confs -= conf;
			}
			foundFlags[add] = token;
			return token.nextToken;
		}

		/**
		 * @brief Parse a property declaration.
		 * @param token = points to the property type token on entry
		 *                points just past the closing brace on return
		 * @param abs = true: property is abstract
		 *             false: property is concrete
		 * @param imp = allow implemented interface specs
		 * @returns null: parse failure
		 *          else: property
		 */
		private TokenDeclVar ParseProperty (ref Token token, bool abs, bool imp)
		{
			/*
			 * Parse out the property's type and name.
			 *   <type> <name>
			 */
			TokenType type = (TokenType)token;
			TokenName name = (TokenName)token.nextToken;
			token = token.nextToken.nextToken;

			/*
			 * Maybe it claims to implement some interface properties.
			 *   [ ':' <ifacetype>[.<propname>] ',' ... ]
			 */
			TokenIntfImpl implements = null;
			if (token is TokenKwColon) {
				implements = ParseImplements (ref token, name);
				if (implements == null) return null;
				if (!imp) {
					ErrorMsg (token, "cannot implement interface property");
				}
			}

			/*
			 * Should have an opening brace.
			 */
			if (!(token is TokenKwBrcOpen)) {
				ErrorMsg (token, "expect { to open property definition");
				token = SkipPastSemi (token);
				return null;
			}
			token = token.nextToken;

			/*
			 * Parse out the getter and/or setter.
			 *   'get' { <body> | ';' }
			 *   'set' { <body> | ';' }
			 */
			TokenDeclVar getFunc = null;
			TokenDeclVar setFunc = null;
			while (!(token is TokenKwBrcClose)) {

				/*
				 * Maybe create a getter function.
				 */
				if (token is TokenKwGet) {
					TokenArgDecl argDecl = new TokenArgDecl (token);

					getFunc = new TokenDeclVar (token, null, tokenScript);
					getFunc.retType     = type;
					getFunc.argDecl     = argDecl;
					getFunc.funcNameSig = new TokenName (token, name.val + ".get.()");
					getFunc.implements  = MakePropertyImplements (implements, ".get.");

					token = token.nextToken;
					if (!ParseFunctionBody (ref token, getFunc, abs)) {
						getFunc = null;
					} else if (!tokenScript.AddVarEntry (getFunc)) {
						ErrorMsg (getFunc, "duplicate getter");
					}
					continue;
				}

				/*
				 * Maybe create a setter function.
				 */
				if (token is TokenKwSet) {
					TokenArgDecl argDecl = new TokenArgDecl (token);
					argDecl.AddArg (type, new TokenName (token, "value"));

					setFunc = new TokenDeclVar (token, null, tokenScript);
					setFunc.retType     = new TokenTypeVoid (token);
					setFunc.argDecl     = argDecl;
					setFunc.funcNameSig = new TokenName (token, name.val + ".set.(" + type.ToString () + ")");
					setFunc.implements  = MakePropertyImplements (implements, ".set.");

					token = token.nextToken;
					if (!ParseFunctionBody (ref token, setFunc, abs)) {
						setFunc = null;
					} else if (!tokenScript.AddVarEntry (setFunc)) {
						ErrorMsg (setFunc, "duplicate setter");
					}
					continue;
				}

				ErrorMsg (token, "expecting get or set");
				token = SkipPastSemi (token);
				return null;
			}
			token = token.nextToken;

			if ((getFunc == null) && (setFunc == null)) {
				ErrorMsg (name, "must specify at least one of get, set");
				return null;
			}

			/*
			 * Set up a variable for the property.
			 */
			TokenDeclVar tokenDeclVar = new TokenDeclVar (name, null, tokenScript);
			tokenDeclVar.type    = type;
			tokenDeclVar.name    = name;
			tokenDeclVar.getProp = getFunc;
			tokenDeclVar.setProp = setFunc;

			/*
			 * Can't be same name already in block.
			 */
			if (!tokenScript.AddVarEntry (tokenDeclVar)) {
				ErrorMsg (tokenDeclVar, "duplicate variable " + name.val);
				return null;
			}
			return tokenDeclVar;
		}

		/**
		 * @brief Given a list of implemented interface methods, create a similar list with suffix added to all the names
		 * @param implements = original list of implemented interface methods
		 * @param suffix = string to be added to end of implemented interface method names
		 * @returns list similar to implements with suffix added to end of implemented interface method names
		 */
		private TokenIntfImpl MakePropertyImplements (TokenIntfImpl implements, string suffix)
		{
			TokenIntfImpl gsimpls = null;
			for (TokenIntfImpl impl = implements; impl != null; impl = (TokenIntfImpl)impl.nextToken) {
				TokenIntfImpl gsimpl = new TokenIntfImpl (impl.intfType, 
				                                          new TokenName (impl.methName, impl.methName.val + suffix));
				gsimpl.nextToken = gsimpls;
				gsimpls = gsimpl;
			}
			return gsimpls;
		}

		/**
		 * @brief Parse a constructor definition for a script-defined type class.
		 * @param token = points to 'constructor' keyword
		 * @param flags = abstract/override/static/virtual flags
		 * @param tokdeclcl = which script-defined type class this method is in
		 * @returns with method parsed and cataloged (or error message(s) printed)
		 */
		private void ParseSDTClassCtorDecl (ref Token token, uint flags, TokenDeclSDTypeClass tokdeclcl)
		{
			if ((flags & (SDT_ABSTRACT | SDT_OVERRIDE | SDT_STATIC | SDT_VIRTUAL)) != 0) {
				ErrorMsg (token, "cannot have abstract, override, static or virtual constructor");
			}

			TokenDeclVar tokenDeclFunc = new TokenDeclVar (token, null, tokenScript);
			tokenDeclFunc.retType      = new TokenTypeVoid (token);

			token = token.nextToken;
			if (!(token is TokenKwParOpen)) {
				ErrorMsg (token, "expecting ( for constructor argument list");
				token = SkipPastSemi (token);
				return;
			}

			tokenDeclFunc.argDecl       = ParseFuncArgs (ref token);
			if (tokenDeclFunc.argDecl == null) return;
			string nameSig              = "constructor" + tokenDeclFunc.argDecl.GetArgSig ();

			tokenDeclFunc.funcNameSig   = new TokenName (tokenDeclFunc, nameSig);
			tokenDeclFunc.sdtClass      = tokdeclcl;
			tokenDeclFunc.sdtFlags      = flags | SDT_NEW;

			TokenDeclVar saveDeclFunc = currentDeclFunc;
			currentDeclFunc = tokenDeclFunc;
			tokenScript.PushVarFrame (tokenDeclFunc.argDecl.varDict);
			try {
				/*
				 * Set up reference to base constructor.
				 */
				TokenRValBaseField baseCtor = new TokenRValBaseField (token, 
				                              new TokenName (token, "constructor"), 
				                              tokdeclcl);

				/*
				 * Parse any base constructor call as if it were the first statement of the
				 * constructor itself.
				 */
				if (token is TokenKwColon) {
					token = token.nextToken;
					if (token is TokenKwBase) {
						token = token.nextToken;
					}
					if (!(token is TokenKwParOpen)) {
						ErrorMsg (token, "expecting ( for base constructor call arguments");
						token = SkipPastSemi (token);
						return;
					}
					TokenRValCall rvc = ParseRValCall (ref token, baseCtor);
					if (rvc == null) return;
					if (tokdeclcl.extends != null) {
						tokenDeclFunc.baseCtorCall = rvc;
						tokenDeclFunc.unknownTrivialityCalls.AddLast (rvc);
					} else {
						ErrorMsg (rvc, "base constructor call cannot be specified if not extending anything");
					}
				} else if (tokdeclcl.extends != null) {

					/*
					 * Caller didn't specify a constructor but we are extending, so we will 
					 * call the extended class's default constructor.
					 */
					SetUpDefaultBaseCtorCall (tokenDeclFunc);
				}

				/*
				 * Parse the constructor body.
				 */
				tokenDeclFunc.body = ParseStmtBlock (ref token);
				if (tokenDeclFunc.body == null) return;
				if (tokenDeclFunc.argDecl == null) return;
			} finally {
				tokenScript.PopVarFrame ();
				currentDeclFunc = saveDeclFunc;
			}

			/*
			 * Add to list of methods defined by this class.
			 * It has the name "constructor(argsig)".
			 * Note that script can't call it directly via a call to a method named constructor
			 * because constructor is a keyword.
			 */
			if (!tokenScript.AddVarEntry (tokenDeclFunc)) {
				ErrorMsg (tokenDeclFunc, "duplicate constructor definition");
			}
		}

		/**
		 * @brief Set up a call from a constructor to its default base constructor.
		 */
		private void SetUpDefaultBaseCtorCall (TokenDeclVar thisCtor)
		{
			TokenRValBaseField baseCtor = new TokenRValBaseField (thisCtor, 
			                              new TokenName (thisCtor, "constructor"), 
			                              thisCtor.sdtClass);
			TokenRValCall rvc = new TokenRValCall (thisCtor);
			rvc.meth          = baseCtor;
			thisCtor.baseCtorCall = rvc;
			thisCtor.unknownTrivialityCalls.AddLast (rvc);
		}

		/**
		 * @brief Parse a method definition for a script-defined type class.
		 * @param token = points to return type (or method name for implicit return type of void)
		 * @param flags = abstract/override/static/virtual flags
		 * @param tokdeclcl = which script-defined type class this method is in
		 * @returns with method parsed and cataloged (or error message(s) printed)
		 */
		private void ParseSDTClassMethodDecl (ref Token token, uint flags, TokenDeclSDTypeClass tokdeclcl)
		{
			TokenDeclVar tokenDeclFunc = ParseDeclFunc (ref token, 
			                                            (flags & SDT_ABSTRACT) != 0, 
			                                            (flags & SDT_STATIC) == 0, 
			                                            (flags & SDT_STATIC) == 0);
			if (tokenDeclFunc != null) {
				tokenDeclFunc.sdtClass = tokdeclcl;
				tokenDeclFunc.sdtFlags = flags;
				if (!tokenScript.AddVarEntry (tokenDeclFunc)) {
					string funcNameSig = tokenDeclFunc.funcNameSig.val;
					ErrorMsg (tokenDeclFunc.funcNameSig, "duplicate method name " + funcNameSig);
				}
			}
		}

		/**
		 * @brief Parse a delegate declaration statement.
		 * @param token = points to TokenDeclSDTypeDelegate token on entry
		 *                points just past ';' on return
		 * @param outerSDType = null: this is a top-level delegate
		 *                      else: this delegate is being defined inside this type
		 * @param flags = SDT_{PRIVATE,PROTECTED,PUBLIC}
		 */
		private void ParseDeclDelegate (ref Token token, TokenDeclSDType outerSDType, uint flags)
		{
			Token u = token;
			TokenDeclSDTypeDelegate tokdecldel;
			TokenType retType;

			tokdecldel = (TokenDeclSDTypeDelegate)u;
			tokdecldel.outerSDType = outerSDType;
			tokdecldel.accessLevel = flags;

			// first thing following that should be return type
			// but we will fill in 'void' if it is missing
			u = u.nextToken;
			if (u is TokenType) {
				retType = (TokenType)u;
				u = u.nextToken;
			} else {
				retType = new TokenTypeVoid (u);
			}

			// get list of argument types until we see a ')'
			List<TokenType> args = new List<TokenType> ();
			bool first = true;
			do {
				if (first) {

					// first time should have '(' ')' or '(' <type>
					if (!(u is TokenKwParOpen)) {
						ErrorMsg (u, "expecting ( after delegate name");
						token = SkipPastSemi (token);
						return;
					}
					first = false;
					u = u.nextToken;
					if (u is TokenKwParClose) break;
				} else {

					// other times should have ',' <type>
					if (!(u is TokenKwComma)) {
						ErrorMsg (u, "expecting , separating arg types");
						token = SkipPastSemi (token);
						return;
					}
					u = u.nextToken;
				}
				if (!(u is TokenType)) {
					ErrorMsg (u, "expecting argument type");
					token = SkipPastSemi (token);
					return;
				}
				args.Add ((TokenType)u);
				u = u.nextToken;

				// they can put in a dummy name that we toss out
				if (u is TokenName) u = u.nextToken;

				// scanning ends on a ')'
			} while (!(u is TokenKwParClose));

			// fill in the return type and argment type array
			tokdecldel.SetRetArgTypes (retType, args.ToArray ());

			// and finally must have ';' to finish the delegate declaration statement
			u = u.nextToken;
			if (!(u is TokenKwSemi)) {
				ErrorMsg (u, "expecting ; after ) in delegate");
				token = SkipPastSemi (token);
				return;
			}
			token = u.nextToken;
		}

		/**
		 * @brief Parse an interface declaration.
		 * @param token = points to  ParseDeclInterface keyword on entry
		 *                points just past closing '}' on return
		 * @param outerSDType = null: this is a top-level interface
		 *                      else: this interface is being defined inside this type
		 * @param flags = SDT_{PRIVATE,PROTECTED,PUBLIC}
		 */
		private void ParseDeclInterface (ref Token token, TokenDeclSDType outerSDType, uint flags)
		{
			Token u = token;
			TokenDeclSDTypeInterface tokdeclin;

			tokdeclin = (TokenDeclSDTypeInterface)u;
			tokdeclin.outerSDType = outerSDType;
			tokdeclin.accessLevel = flags;
			u = u.nextToken;

			// next must be '{' to open interface declaration body
			if (!(u is TokenKwBrcOpen)) {
				ErrorMsg (u, "expecting { to open interface declaration body");
				token = SkipPastSemi (token);
				return;
			}
			token = u.nextToken;

			// start a var definition frame to collect the interface members
			tokenScript.PushVarFrame ();
			tokdeclin.methsNProps = tokenScript.variablesStack;

			// process declaration statements until '}'
			while (!(token is TokenKwBrcClose)) {
				if (token is TokenKwSemi) {
					token = token.nextToken;
					continue;
				}

				/*
				 * Parse nested script-defined type definitions.
				 */
				if (ParseDeclSDTypes (ref token, tokdeclin, SDT_PUBLIC)) continue;

				/*
				 * <type> <name> <funcargs> ;
				 * abstract method with explicit return type
				 */
				if ((token is TokenType) && 
				    (token.nextToken is TokenName) && 
				    (token.nextToken.nextToken is TokenKwParOpen)) {
					Token name = token.nextToken;
					TokenDeclVar tokenDeclFunc = ParseDeclFunc (ref token, true, false, false);
					if (tokenDeclFunc == null) continue;
					if (!tokenScript.AddVarEntry (tokenDeclFunc)) {
						ErrorMsg (name, "duplicate method name");
						continue;
					}
					continue;
				}

				/*
				 * <name> <funcargs> ;
				 * abstract method returning void
				 */
				if ((token is TokenName) && 
				    (token.nextToken is TokenKwParOpen)) {
					Token name = token;
					TokenDeclVar tokenDeclFunc = ParseDeclFunc (ref token, true, false, false);
					if (tokenDeclFunc == null) continue;
					if (!tokenScript.AddVarEntry (tokenDeclFunc)) {
						ErrorMsg (name, "duplicate method name");
					}
					continue;
				}

				/*
				 * <type> <name> { [ get ; ] [ set ; ] }
				 * abstract property
				 */
				if ((token is TokenType) &&
				    (token.nextToken is TokenName) &&
				    (token.nextToken.nextToken is TokenKwBrcOpen)) {
					ParseProperty (ref token, true, false);
					continue;
				}

				/*
				 * That's all we support in an interface declaration.
				 */
				ErrorMsg (token, "expecting method or property prototype");
				token = SkipPastSemi (token);
			}

			/*
			 * Skip over the closing brace and pop the corresponding var frame.
			 */
			token = token.nextToken;
			tokenScript.PopVarFrame ();
		}

		/**
		 * @brief parse state body (including all its event handlers)
		 * @param token = points to TokenKwBrcOpen
		 * @returns null: state body parse error
		 *          else: token representing state
		 *          token = points past close brace
		 */
		private TokenStateBody ParseStateBody (ref Token token)
		{
			TokenStateBody tokenStateBody = new TokenStateBody (token);

			if (!(token is TokenKwBrcOpen)) {
				ErrorMsg (token, "expecting { at beg of state");
				token = SkipPastSemi (token);
				return null;
			}

			token = token.nextToken;
			while (!(token is TokenKwBrcClose)) {
				if (token is TokenEnd) {
					ErrorMsg (tokenStateBody, "eof parsing state body");
					return null;
				}
				TokenDeclVar tokenDeclFunc = ParseDeclFunc (ref token, false, false, false);
				if (tokenDeclFunc == null) return null;
				if (!(tokenDeclFunc.retType is TokenTypeVoid)) {
					ErrorMsg (tokenDeclFunc.retType, "event handlers don't have return types");
					return null;
				}
				tokenDeclFunc.nextToken = tokenStateBody.eventFuncs;
				tokenStateBody.eventFuncs = tokenDeclFunc;
			}
			token = token.nextToken;
			return tokenStateBody;
		}

		/**
		 * @brief Parse a function declaration, including its arg list and body
		 * @param token = points to function return type token (or function name token if return type void)
		 * @param abs = false: concrete function; true: abstract declaration
		 * @param imp = allow implemented interface specs
		 * @param ops = accept operators (==, +, etc) for function name
		 * @returns null: error parsing function definition
		 *          else: function declaration
		 *          token = advanced just past function, ie, just past the closing brace
		 */
		private TokenDeclVar ParseDeclFunc (ref Token token, bool abs, bool imp, bool ops)
		{
			TokenType retType;
			if (token is TokenType) {
				retType = (TokenType)token;
				token = token.nextToken;
			} else {
				retType = new TokenTypeVoid (token);
			}

			TokenName simpleName;
			if ((token is TokenKw) && ((TokenKw)token).sdtClassOp) {
				if (!ops) ErrorMsg (token, "operator functions disallowed in static contexts");
				simpleName = new TokenName (token, ".op." + token.ToString ());
			} else if (!(token is TokenName)) {
				ErrorMsg (token, "expecting function name");
				token = SkipPastSemi (token);
				return null;
			} else {
				simpleName = (TokenName)token;
			}
			token = token.nextToken;

			return ParseDeclFunc (ref token, abs, imp, retType, simpleName);
		}

		/**
		 * @brief Parse a function declaration, including its arg list and body
		 *        This version enters with token pointing to the '(' at beginning of arg list
		 * @param token = points to the '(' of the arg list
		 * @param abs = false: concrete function; true: abstract declaration
		 * @param imp = allow implemented interface specs
		 * @param retType = return type (TokenTypeVoid if void, never null)
		 * @param simpleName = function name without any signature
		 * @returns null: error parsing remainder of function definition
		 *          else: function declaration
		 *          token = advanced just past function, ie, just past the closing brace
		 */
		private TokenDeclVar ParseDeclFunc (ref Token token, bool abs, bool imp, TokenType retType, TokenName simpleName)
		{
			TokenDeclVar tokenDeclFunc = new TokenDeclVar (simpleName, null, tokenScript);
			tokenDeclFunc.retType      = retType;
			tokenDeclFunc.argDecl      = ParseFuncArgs (ref token);
			if (tokenDeclFunc.argDecl == null) return null;
			tokenDeclFunc.funcNameSig  = new TokenName (simpleName, 
			                                            simpleName.val + tokenDeclFunc.argDecl.GetArgSig ());

			if (token is TokenKwColon) {
				tokenDeclFunc.implements = ParseImplements (ref token, simpleName);
				if (tokenDeclFunc.implements == null) return null;
				if (!imp) {
					ErrorMsg (tokenDeclFunc.implements, "cannot implement interface method");
					tokenDeclFunc.implements = null;
				}
			}

			if (!ParseFunctionBody (ref token, tokenDeclFunc, abs)) return null;
			if (tokenDeclFunc.argDecl == null) return null;
			return tokenDeclFunc;
		}

		/**
		 * @brief Parse interface implementation list.
		 * @param token = points to ':' on entry
		 *                points just past list on return
		 * @param simpleName = simple name (no arg signature) of method/property that 
		 *                     is implementing the interface method/property
		 * @returns list of implemented interface methods/properties
		 */
		private TokenIntfImpl ParseImplements (ref Token token, TokenName simpleName)
		{
			TokenIntfImpl implements = null;
			do {
				token = token.nextToken;
				if (!(token is TokenTypeSDTypeInterface)) {
					ErrorMsg (token, "expecting interface type");
					token = SkipPastSemi (token);
					return null;
				}
				TokenTypeSDTypeInterface intfType = (TokenTypeSDTypeInterface)token;
				token = token.nextToken;
				TokenName methName = simpleName;
				if ((token is TokenKwDot) && (token.nextToken is TokenName)) {
					methName = (TokenName)token.nextToken;
					token = token.nextToken.nextToken;
				}
				TokenIntfImpl intfImpl = new TokenIntfImpl (intfType, methName);
				intfImpl.nextToken = implements;
				implements = intfImpl;
			} while (token is TokenKwComma);
			return implements;
		}


		/**
		 * @brief Parse function declaration's body
		 * @param token = points to body, ie, ';' or '{'
		 * @param tokenDeclFunc = function being declared
		 * @param abs = false: concrete function; true: abstract declaration
		 * @returns whether or not the function definition parsed correctly
		 */
		private bool ParseFunctionBody (ref Token token, TokenDeclVar tokenDeclFunc, bool abs)
		{
			if (token is TokenKwSemi) {
				if (!abs) {
					ErrorMsg (token, "concrete function must have body");
					token = SkipPastSemi (token);
					return false;
				}
				token = token.nextToken;
				return true;
			}

			/*
			 * Declare this function as being the one currently being processed
			 * for anything that cares.  We also start a variable frame that 
			 * includes all the declared parameters.
			 */
			TokenDeclVar saveDeclFunc = currentDeclFunc;
			currentDeclFunc = tokenDeclFunc;
			tokenScript.PushVarFrame (tokenDeclFunc.argDecl.varDict);

			/*
			 * Now parse the function statement block.
			 */
			tokenDeclFunc.body = ParseStmtBlock (ref token);

			/*
			 * Pop the var frame that contains the arguments.
			 */
			tokenScript.PopVarFrame ();
			currentDeclFunc = saveDeclFunc;

			/*
			 * Check final errors.
			 */
			if (tokenDeclFunc.body == null) return false;
			if (abs) {
				ErrorMsg (tokenDeclFunc.body, "abstract function must not have body");
				tokenDeclFunc.body = null;
				return false;
			}
			return true;
		}


		/**
		 * @brief Parse statement
		 * @param token = first token of statement
		 * @returns null: parse error
		 *          else: token representing whole statement
		 *          token = points past statement
		 */
		private TokenStmt ParseStmt (ref Token token)
		{
			/*
			 * Statements that begin with a specific keyword.
			 */
			if (token is TokenKwAt)      return ParseStmtLabel   (ref token);
			if (token is TokenKwBrcOpen) return ParseStmtBlock   (ref token);
			if (token is TokenKwBreak)   return ParseStmtBreak   (ref token);
			if (token is TokenKwCont)    return ParseStmtCont    (ref token);
			if (token is TokenKwDo)      return ParseStmtDo      (ref token);
			if (token is TokenKwFor)     return ParseStmtFor     (ref token);
			if (token is TokenKwForEach) return ParseStmtForEach (ref token);
			if (token is TokenKwIf)      return ParseStmtIf      (ref token);
			if (token is TokenKwJump)    return ParseStmtJump    (ref token);
			if (token is TokenKwRet)     return ParseStmtRet     (ref token);
			if (token is TokenKwSemi)    return ParseStmtNull    (ref token);
			if (token is TokenKwState)   return ParseStmtState   (ref token);
			if (token is TokenKwSwitch)  return ParseStmtSwitch  (ref token);
			if (token is TokenKwThrow)   return ParseStmtThrow   (ref token);
			if (token is TokenKwTry)     return ParseStmtTry     (ref token);
			if (token is TokenKwWhile)   return ParseStmtWhile   (ref token);

			/*
			 * Try to parse anything else as an expression, possibly calling
			 * something and/or writing to a variable.
			 */
			TokenRVal tokenRVal = ParseRVal (ref token, semiOnly);
			if (tokenRVal != null) {
				TokenStmtRVal tokenStmtRVal = new TokenStmtRVal (tokenRVal);
				tokenStmtRVal.rVal = tokenRVal;
				return tokenStmtRVal;
			}

			/*
			 * Who knows what it is...
			 */
			ErrorMsg (token, "unknown statement");
			token = SkipPastSemi (token);
			return null;
		}

		/**
		 * @brief parse a statement block, ie, group of statements between braces
		 * @param token = points to { token
		 * @returns null: error parsing
		 *          else: statements bundled in this token
		 *          token = advanced just past the } token
		 */
		private TokenStmtBlock ParseStmtBlock (ref Token token)
		{
			if (!(token is TokenKwBrcOpen)) {
				ErrorMsg (token, "statement block body must begin with a {");
				token = SkipPastSemi (token);
				return null;
			}
			TokenStmtBlock tokenStmtBlock = new TokenStmtBlock (token);
			tokenStmtBlock.function = currentDeclFunc;
			tokenStmtBlock.outerStmtBlock = currentStmtBlock;
			currentStmtBlock = tokenStmtBlock;
			tokenScript.PushVarFrame ();
			Token prevStmt = null;
			token = token.nextToken;
			while (!(token is TokenKwBrcClose)) {
				if (token is TokenEnd) {
					ErrorMsg (tokenStmtBlock, "missing }");
					currentStmtBlock = tokenStmtBlock.outerStmtBlock;
					return null;
				}
				Token thisStmt;
				if ((token is TokenType) || (token is TokenKwConst)) {
					thisStmt = ParseDeclVar (ref token);
				} else {
					thisStmt = ParseStmt (ref token);
				}
				if (thisStmt == null) return null;
				if (prevStmt == null) tokenStmtBlock.statements = thisStmt;
				                 else prevStmt.nextToken = thisStmt;
				prevStmt = thisStmt;
			}
			token = token.nextToken;
			tokenScript.PopVarFrame ();
			currentStmtBlock = tokenStmtBlock.outerStmtBlock;
			return tokenStmtBlock;
		}

		/**
		 * @brief parse a 'break' statement
		 * @param token = points to break keyword token
		 * @returns null: error parsing
		 *          else: statements bundled in this token
		 *          token = advanced just past the ; token
		 */
		private TokenStmtBreak ParseStmtBreak (ref Token token)
		{
			TokenStmtBreak tokenStmtBreak = new TokenStmtBreak (token);
			token = token.nextToken;
			if (!(token is TokenKwSemi)) {
				ErrorMsg (token, "expecting ;");
				token = SkipPastSemi (token);
				return null;
			}
			token = token.nextToken;
			return tokenStmtBreak;
		}

		/**
		 * @brief parse a 'continue' statement
		 * @param token = points to continue keyword token
		 * @returns null: error parsing
		 *          else: statements bundled in this token
		 *          token = advanced just past the ; token
		 */
		private TokenStmtCont ParseStmtCont (ref Token token)
		{
			TokenStmtCont tokenStmtCont = new TokenStmtCont (token);
			token = token.nextToken;
			if (!(token is TokenKwSemi)) {
				ErrorMsg (token, "expecting ;");
				token = SkipPastSemi (token);
				return null;
			}
			token = token.nextToken;
			return tokenStmtCont;
		}

		/**
		 * @brief parse a 'do' statement
		 * @params token = points to 'do' keyword token
		 * @returns null: parse error
		 *          else: pointer to token encapsulating the do statement, including body
		 *          token = advanced just past the body statement
		 */
		private TokenStmtDo ParseStmtDo (ref Token token)
		{
			currentDeclFunc.triviality = Triviality.complex;
			TokenStmtDo tokenStmtDo = new TokenStmtDo (token);
			token = token.nextToken;
			tokenStmtDo.bodyStmt = ParseStmt (ref token);
			if (tokenStmtDo.bodyStmt == null) return null;
			if (!(token is TokenKwWhile)) {
				ErrorMsg (token, "expecting while clause");
				return null;
			}
			token = token.nextToken;
			tokenStmtDo.testRVal = ParseRValParen (ref token);
			if (tokenStmtDo.testRVal == null) return null;
			if (!(token is TokenKwSemi)) {
				ErrorMsg (token, "while clause must terminate on semicolon");
				token = SkipPastSemi (token);
				return null;
			}
			token = token.nextToken;
			return tokenStmtDo;
		}

		/**
		 * @brief parse a for statement
		 * @param token = points to 'for' keyword token
		 * @returns null: parse error
		 *          else: pointer to encapsulated for statement token
		 *          token = advanced just past for body statement
		 */
		private TokenStmt ParseStmtFor (ref Token token)
		{
			currentDeclFunc.triviality = Triviality.complex;

			/*
			 * Create encapsulating token and skip past 'for ('
			 */
			TokenStmtFor tokenStmtFor = new TokenStmtFor (token);
			token = token.nextToken;
			if (!(token is TokenKwParOpen)) {
				ErrorMsg (token, "for must be followed by (");
				return null;
			}
			token = token.nextToken;

			/*
			 * If a plain for, ie, not declaring a variable, it's straightforward.
			 */
			if (!(token is TokenType)) {
				tokenStmtFor.initStmt = ParseStmt (ref token);
				if (tokenStmtFor.initStmt == null) return null;
				return ParseStmtFor2 (tokenStmtFor, ref token) ? tokenStmtFor : null;
			}

			/*
			 * Initialization declares a variable, so encapsulate it in a block so
			 * variable has scope only in the for statement, including its body.
			 */
			TokenStmtBlock forStmtBlock = new TokenStmtBlock (tokenStmtFor);
			forStmtBlock.outerStmtBlock = currentStmtBlock;
			forStmtBlock.function       = currentDeclFunc;
			tokenScript.PushVarFrame ();

			TokenDeclVar tokenDeclVar   = ParseDeclVar (ref token);
			if (tokenDeclVar == null) {
				tokenScript.PopVarFrame ();
				currentStmtBlock    = forStmtBlock.outerStmtBlock;
				return null;
			}

			forStmtBlock.statements     = tokenDeclVar;
			tokenDeclVar.nextToken      = tokenStmtFor;

			bool ok                     = ParseStmtFor2 (tokenStmtFor, ref token);
			tokenScript.PopVarFrame ();
			currentStmtBlock            = forStmtBlock.outerStmtBlock;
			return ok ? forStmtBlock : null;
		}

		/**
		 * @brief parse rest of 'for' statement starting with the test expression.
		 * @param tokenStmtFor = token encapsulating the for statement
		 * @param token = points to test expression
		 * @returns false: parse error
		 *           true: successful
		 *          token = points just past body statement
		 */
		private bool ParseStmtFor2 (TokenStmtFor tokenStmtFor, ref Token token)
		{
			if (token is TokenKwSemi) {
				token = token.nextToken;
			} else {
				tokenStmtFor.testRVal = ParseRVal (ref token, semiOnly);
				if (tokenStmtFor.testRVal == null) return false;
			}
			if (token is TokenKwParClose) {
				token = token.nextToken;
			} else {
				tokenStmtFor.incrRVal = ParseRVal (ref token, parCloseOnly);
				if (tokenStmtFor.incrRVal == null) return false;
			}
			tokenStmtFor.bodyStmt = ParseStmt (ref token);
			return tokenStmtFor.bodyStmt != null;
		}

		/**
		 * @brief parse a foreach statement
		 * @param token = points to 'foreach' keyword token
		 * @returns null: parse error
		 *          else: pointer to encapsulated foreach statement token
		 *          token = advanced just past for body statement
		 */
		private TokenStmt ParseStmtForEach (ref Token token)
		{
			/*
			 * Create encapsulating token and skip past 'foreach ('
			 */
			TokenStmtForEach tokenStmtForEach = new TokenStmtForEach (token);
			token = token.nextToken;
			if (!(token is TokenKwParOpen)) {
				ErrorMsg (token, "foreach must be followed by (");
				return null;
			}
			token = token.nextToken;

			if (token is TokenName) {
				tokenStmtForEach.keyLVal = new TokenLValName ((TokenName)token, tokenScript);
				token = token.nextToken;
			}
			if (!(token is TokenKwComma)) {
				ErrorMsg (token, "expecting comma");
				token = SkipPastSemi (token);
				return null;
			}
			token = token.nextToken;
			if (token is TokenName) {
				tokenStmtForEach.valLVal = new TokenLValName ((TokenName)token, tokenScript);
				token = token.nextToken;
			}
			if (!(token is TokenKwIn)) {
				ErrorMsg (token, "expecting 'in'");
				token = SkipPastSemi (token);
				return null;
			}
			token = token.nextToken;
			tokenStmtForEach.arrayRVal = GetOperand (ref token);
			if (tokenStmtForEach.arrayRVal == null) return null;
			if (!(token is TokenKwParClose)) {
				ErrorMsg (token, "expecting )");
				token = SkipPastSemi (token);
				return null;
			}
			token = token.nextToken;
			tokenStmtForEach.bodyStmt = ParseStmt (ref token);
			if (tokenStmtForEach.bodyStmt == null) return null;
			return tokenStmtForEach;
		}

		private TokenStmtIf ParseStmtIf (ref Token token)
		{
			TokenStmtIf tokenStmtIf = new TokenStmtIf (token);
			token = token.nextToken;
			tokenStmtIf.testRVal = ParseRValParen (ref token);
			if (tokenStmtIf.testRVal == null) return null;
			tokenStmtIf.trueStmt = ParseStmt (ref token);
			if (tokenStmtIf.trueStmt == null) return null;
			if (token is TokenKwElse) {
				token = token.nextToken;
				tokenStmtIf.elseStmt = ParseStmt (ref token);
				if (tokenStmtIf.elseStmt == null) return null;
			}
			return tokenStmtIf;
		}

		private TokenStmtJump ParseStmtJump (ref Token token)
		{
			/*
			 * Create jump statement token to encapsulate the whole statement.
			 */
			TokenStmtJump tokenStmtJump = new TokenStmtJump (token);
			token = token.nextToken;
			if (!(token is TokenName) || !(token.nextToken is TokenKwSemi)) {
				ErrorMsg (token, "expecting label;");
				token = SkipPastSemi (token);
				return null;
			}
			tokenStmtJump.label = (TokenName)token;
			token = token.nextToken.nextToken;

			/*
			 * If label is already defined, it means this is a backward (looping)
			 * jump, so remember the label has backward jump references.
			 * We also then assume the function is complex, ie, it has a loop.
			 */
			if (currentDeclFunc.labels.ContainsKey (tokenStmtJump.label.val)) {
				currentDeclFunc.labels[tokenStmtJump.label.val].hasBkwdRefs = true;
				currentDeclFunc.triviality = Triviality.complex;
			}

			return tokenStmtJump;
		}

		/**
		 * @brief parse a jump target label statement
		 * @param token = points to the '@' token
		 * @returns null: error parsing
		 *          else: the label
		 *          token = advanced just past the ;
		 */
		private TokenStmtLabel ParseStmtLabel (ref Token token)
		{
			if (!(token.nextToken is TokenName) ||
			    !(token.nextToken.nextToken is TokenKwSemi)) {
				ErrorMsg (token, "invalid label");
				token = SkipPastSemi (token);
				return null;
			}
			TokenStmtLabel stmtLabel = new TokenStmtLabel (token);
			stmtLabel.name  = (TokenName)token.nextToken;
			stmtLabel.block = currentStmtBlock;
			if (currentDeclFunc.labels.ContainsKey (stmtLabel.name.val)) {
				ErrorMsg (token.nextToken, "duplicate label");
				ErrorMsg (currentDeclFunc.labels[stmtLabel.name.val], "previously defined here");
				token = SkipPastSemi (token);
				return null;
			}
			currentDeclFunc.labels.Add (stmtLabel.name.val, stmtLabel);
			token = token.nextToken.nextToken.nextToken;
			return stmtLabel;
		}

		private TokenStmtNull ParseStmtNull (ref Token token)
		{
			TokenStmtNull tokenStmtNull = new TokenStmtNull (token);
			token = token.nextToken;
			return tokenStmtNull;
		}

		private TokenStmtRet ParseStmtRet (ref Token token)
		{
			TokenStmtRet tokenStmtRet = new TokenStmtRet (token);
			token = token.nextToken;
			if (token is TokenKwSemi) {
				token = token.nextToken;
			} else {
				tokenStmtRet.rVal = ParseRVal (ref token, semiOnly);
				if (tokenStmtRet.rVal == null) return null;
			}
			return tokenStmtRet;
		}

		private TokenStmtSwitch ParseStmtSwitch (ref Token token)
		{
			TokenStmtSwitch tokenStmtSwitch = new TokenStmtSwitch (token);
			token = token.nextToken;
			tokenStmtSwitch.testRVal = ParseRValParen (ref token);
			if (tokenStmtSwitch.testRVal == null) return null;
			if (!(token is TokenKwBrcOpen)) {
				ErrorMsg (token, "expecting open brace");
				token = SkipPastSemi (token);
				return null;
			}
			token = token.nextToken;
			TokenSwitchCase tokenSwitchCase = null;
			bool haveComplained = false;
			while (!(token is TokenKwBrcClose)) {
				if (token is TokenKwCase) {
					tokenSwitchCase = new TokenSwitchCase (token);
					if (tokenStmtSwitch.lastCase == null) {
						tokenStmtSwitch.cases = tokenSwitchCase;
					} else {
						tokenStmtSwitch.lastCase.nextCase = tokenSwitchCase;
					}
					tokenStmtSwitch.lastCase =  tokenSwitchCase;

					token = token.nextToken;
					tokenSwitchCase.rVal1 = ParseRVal (ref token, colonOrDotDotDot);
					if (tokenSwitchCase.rVal1 == null) return null;
					if (token is TokenKwDotDotDot) {
						token = token.nextToken;
						tokenSwitchCase.rVal2 = ParseRVal (ref token, colonOnly);
						if (tokenSwitchCase.rVal2 == null) return null;
					} else {
						if (!(token is TokenKwColon)) {
							ErrorMsg (token, "expecting : or ...");
							token = SkipPastSemi (token);
							return null;
						}
						token = token.nextToken;
					}
				} else if (token is TokenKwDefault) {
					tokenSwitchCase = new TokenSwitchCase (token);
					if (tokenStmtSwitch.lastCase == null) {
						tokenStmtSwitch.cases = tokenSwitchCase;
					} else {
						tokenStmtSwitch.lastCase.nextCase = tokenSwitchCase;
					}
					tokenStmtSwitch.lastCase =  tokenSwitchCase;

					token = token.nextToken;
					if (!(token is TokenKwColon)) {
						ErrorMsg (token, "expecting :");
						token = SkipPastSemi (token);
						return null;
					}
					token = token.nextToken;
				} else if (tokenSwitchCase != null) {
					TokenStmt bodyStmt = ParseStmt (ref token);
					if (bodyStmt == null) return null;
					if (tokenSwitchCase.lastStmt == null) {
						tokenSwitchCase.stmts = bodyStmt;
					} else {
						tokenSwitchCase.lastStmt.nextToken = bodyStmt;
					}
					tokenSwitchCase.lastStmt = bodyStmt;
					bodyStmt.nextToken = null;
				} else if (!haveComplained) {
					ErrorMsg (token, "expecting case or default label");
					token = SkipPastSemi (token);
					haveComplained = true;
				}
			}
			token = token.nextToken;
			return tokenStmtSwitch;
		}

		private TokenStmtState ParseStmtState (ref Token token)
		{
			TokenStmtState tokenStmtState = new TokenStmtState (token);
			token = token.nextToken;
			if ((!(token is TokenName) && !(token is TokenKwDefault)) || !(token.nextToken is TokenKwSemi)) {
				ErrorMsg (token, "expecting state;");
				token = SkipPastSemi (token);
				return null;
			}
			if (token is TokenName) {
				tokenStmtState.state = (TokenName)token;
			}
			token = token.nextToken.nextToken;
			return tokenStmtState;
		}

		private TokenStmtThrow ParseStmtThrow (ref Token token)
		{
			TokenStmtThrow tokenStmtThrow = new TokenStmtThrow (token);
			token = token.nextToken;
			if (token is TokenKwSemi) {
				token = token.nextToken;
			} else {
				tokenStmtThrow.rVal = ParseRVal (ref token, semiOnly);
				if (tokenStmtThrow.rVal == null) return null;
			}
			return tokenStmtThrow;
		}

		private TokenStmtTry ParseStmtTry (ref Token token)
		{
			TokenStmtTry tokenStmtTry = new TokenStmtTry (token);
			token = token.nextToken;
			tokenStmtTry.tryStmt = ParseStmtBlock (ref token);
			if (tokenStmtTry.tryStmt == null) return null;
			if (token is TokenKwCatch) {
				if (!(token.nextToken is TokenKwParOpen) ||
				    !(token.nextToken.nextToken is TokenTypeStr) ||
				    !(token.nextToken.nextToken.nextToken is TokenName) ||
				    !(token.nextToken.nextToken.nextToken.nextToken is TokenKwParClose)) {
					ErrorMsg (token, "catch must be followed by ( string <varname> ) <statement>");
					return null;
				}
				token = token.nextToken.nextToken;      // skip over 'catch' '('
				TokenDeclVar tag = new TokenDeclVar (token.nextToken, currentDeclFunc, tokenScript);
				tag.type = (TokenType)token;
				token = token.nextToken;                // skip over 'string'
				tag.name = (TokenName)token;
				token = token.nextToken.nextToken;      // skip over <varname> ')'
				tokenStmtTry.catchVar = tag;
				tokenScript.PushVarFrame ();
				tokenScript.AddVarEntry (tag);
				tokenStmtTry.catchStmt = ParseStmtBlock (ref token);
				tokenScript.PopVarFrame ();
				if (tokenStmtTry.catchStmt == null) return null;
			}
			if (token is TokenKwFinally) {
				token = token.nextToken;
				tokenStmtTry.finallyStmt = ParseStmtBlock (ref token);
				if (tokenStmtTry.finallyStmt == null) return null;
			}
			if ((tokenStmtTry.catchStmt == null) && (tokenStmtTry.finallyStmt == null)) {
				ErrorMsg (tokenStmtTry, "try must have a matching catch and/or finally");
				return null;
			}
			return tokenStmtTry;
		}

		private TokenStmtWhile ParseStmtWhile (ref Token token)
		{
			currentDeclFunc.triviality = Triviality.complex;
			TokenStmtWhile tokenStmtWhile = new TokenStmtWhile (token);
			token = token.nextToken;
			tokenStmtWhile.testRVal = ParseRValParen (ref token);
			if (tokenStmtWhile.testRVal == null) return null;
			tokenStmtWhile.bodyStmt = ParseStmt (ref token);
			if (tokenStmtWhile.bodyStmt == null) return null;
			return tokenStmtWhile;
		}

		/**
		 * @brief parse a variable declaration statement, including init value if any.
		 * @param token = points to type or 'constant' token
		 * @returns null: parsing error
		 *          else: variable declaration encapulating token
		 *          token = advanced just past semi-colon
		 *          variables = modified to include the new variable
		 */
		private TokenDeclVar ParseDeclVar (ref Token token)
		{
			TokenDeclVar tokenDeclVar = new TokenDeclVar (token.nextToken, currentDeclFunc, tokenScript);

			/*
			 * Handle constant declaration.
			 * It ends up in the declared variables list for the statement block just like
			 * any other variable, except it has .constant = true.
			 * The code generator will test that the initialization expression is constant.
			 *
			 * 	constant <name> = <value> ;
			 */
			if (token is TokenKwConst) {
				token = token.nextToken;
				if (!(token is TokenName)) {
					ErrorMsg (token, "expecting constant name");
					token = SkipPastSemi (token);
					return null;
				}
				tokenDeclVar.name = (TokenName)token;
				token = token.nextToken;
				if (!(token is TokenKwAssign)) {
					ErrorMsg (token, "expecting =");
					token = SkipPastSemi (token);
					return null;
				}
				token = token.nextToken;
				TokenRVal rVal = ParseRVal (ref token, semiOnly);
				if (rVal == null) return null;
				tokenDeclVar.init = rVal;
				tokenDeclVar.constant = true;
			}

			/*
			 * Otherwise, normal variable declaration with optional initialization value.
			 */
			else {
				/*
				 * Build basic encapsulating token with type and name.
				 */
				tokenDeclVar.type = (TokenType)token;
				token = token.nextToken;
				if (!(token is TokenName)) {
					ErrorMsg (token, "expecting variable name");
					token = SkipPastSemi (token);
					return null;
				}
				tokenDeclVar.name = (TokenName)token;
				token = token.nextToken;

				/*
				 * If just a ;, there is no explicit initialization value.
				 * Otherwise, look for an =RVal; expression that has init value.
				 */
				if (token is TokenKwSemi) {
					token = token.nextToken;
				} else if (token is TokenKwAssign) {
					token = token.nextToken;
					tokenDeclVar.init = ParseRVal (ref token, semiOnly);
					if (tokenDeclVar.init == null) return null;
				} else {
					ErrorMsg (token, "expecting = or ;");
					token = SkipPastSemi (token);
					return null;
				}
			}

			/*
			 * Can't be same name already in block.
			 */
			if (!tokenScript.AddVarEntry (tokenDeclVar)) {
				ErrorMsg (tokenDeclVar, "duplicate variable " + tokenDeclVar.name.val);
				return null;
			}
			return tokenDeclVar;
		}

		/**
		 * @brief parse function declaration argument list
		 * @param token = points to TokenKwParOpen
		 * @returns null: parse error
		 *          else: points to token with types and names
		 *          token = updated past the TokenKwParClose
		 */
		private TokenArgDecl ParseFuncArgs (ref Token token)
		{
			TokenArgDecl tokenArgDecl = new TokenArgDecl (token);

			bool first = true;
			do {
				token = token.nextToken;
				if ((token is TokenKwParClose) && first) break;
				if (!(token is TokenType)) {
					ErrorMsg (token, "expecting arg type");
					token = SkipPastSemi (token);
					return null;
				}
				TokenType type = (TokenType)token;
				token = token.nextToken;
				if (!(token is TokenName)) {
					ErrorMsg (token, "expecting arg name");
					token = SkipPastSemi (token);
					return null;
				}
				TokenName name = (TokenName)token;
				token = token.nextToken;

				if (!tokenArgDecl.AddArg (type, name)) {
					ErrorMsg (name, "duplicate arg name");
				}
				first = false;
			} while (token is TokenKwComma);

			if (!(token is TokenKwParClose)) {
				ErrorMsg (token, "expecting comma or close paren");
				token = SkipPastSemi (token);
				return null;
			}
			token = token.nextToken;

			return tokenArgDecl;
		}

		/**
		 * @brief parse right-hand value expression
		 *        this is where arithmetic-like expressions are processed
		 * @param token = points to first token expression
		 * @param termTokenType = expression termination token type
		 * @returns null: not an RVal
		 *          else: single token representing whole expression
		 *          token = if termTokenType.Length == 1, points just past terminating token
		 *                                          else, points right at terminating token
		 */
		public TokenRVal ParseRVal (ref Token token, Type[] termTokenTypes)
		{
			/*
			 * Start with pushing the first operand on operand stack.
			 */
			BinOp binOps = null;
			TokenRVal operands = GetOperand (ref token);
			if (operands == null) return null;

			/*
			 * Keep scanning until we hit the termination token.
			 */
			while (true) {
				Type tokType = token.GetType ();
				for (int i = termTokenTypes.Length; -- i >= 0;) {
					if (tokType == termTokenTypes[i]) goto done;
				}

				/*
				 * Special form:
				 *   <operand> is <typeexp>
				 */
				if (token is TokenKwIs) {
					TokenRValIsType tokenRValIsType = new TokenRValIsType (token);
					token = token.nextToken;

					/*
					 * Parse the <typeexp>.
					 */
					tokenRValIsType.typeExp = ParseTypeExp (ref token);
					if (tokenRValIsType.typeExp == null) return null;

					/*
					 * Replace top operand with result of <operand> is <typeexp>
					 */
					tokenRValIsType.rValExp   = operands;
					tokenRValIsType.nextToken = operands.nextToken;
					operands = tokenRValIsType;

					/*
					 * token points just past <typeexp> so see if it is another operator.
					 */
					continue;
				}

				/*
				 * Peek at next operator.
				 */
				BinOp binOp = GetOperator (ref token);
				if (binOp == null) return null;

				/*
				 * If there are stacked operators of higher or same precedence than new one,
				 * perform their computation then push result back on operand stack.
				 *
				 *  higher or same = left-to-right application of operators
				 *                   eg, a - b - c becomes (a - b) - c
				 *
				 *  higher precedence = right-to-left application of operators
				 *                      eg, a - b - c becomes a - (b - c)
				 *
				 * Now of course, there is some ugliness necessary:
				 *      we want:  a  - b - c  =>  (a - b) - c    so we do 'higher or same'
				 *  but we want:  a += b = c  =>  a += (b = c)   so we do 'higher only'
				 *
				 * binOps is the first operator (or null if only one)
				 * binOp is the second operator (or first if only one)
				 */
				while (binOps != null) {
					if (binOps.preced < binOp.preced) break;       // 1st operator lower than 2nd, so leave 1st on stack to do later
					if (binOps.preced > binOp.preced) goto do1st;  // 1st op higher than 2nd, so we always do 1st op first
					if (binOps.preced == ASNPR) break;             // equal preced, if assignment type, leave 1st on stack to do later
					                                               //               if non-asn type, do 1st op first (ie left-to-right)
				do1st:
					TokenRVal result = PerformBinOp ((TokenRVal)operands.prevToken, binOps, (TokenRVal)operands);
					result.prevToken = operands.prevToken.prevToken;
					operands = result;
					binOps   = binOps.pop;
				}

				/*
				 * Push new operator on its stack.
				 */
				binOp.pop = binOps;
				binOps = binOp;

				/*
				 * Push next operand on its stack.
				 */
				TokenRVal operand = GetOperand (ref token);
				if (operand == null) return null;
				operand.prevToken = operands;
				operands = operand;
			}
		done:

			/*
			 * At end of expression, perform any stacked computations.
			 */
			while (binOps != null) {
				TokenRVal result = PerformBinOp ((TokenRVal)operands.prevToken, binOps, (TokenRVal)operands);
				result.prevToken = operands.prevToken.prevToken;
				operands = result;
				binOps   = binOps.pop;
			}

			/*
			 * There should be exactly one remaining operand on the stack which is our final result.
			 */
			if (operands.prevToken != null) throw new Exception ("too many operands");

			/*
			 * If only one terminator type possible, advance past the terminator.
			 */
			if (termTokenTypes.Length == 1) token = token.nextToken;

			return operands;
		}

		private TokenTypeExp ParseTypeExp (ref Token token)
		{
			TokenTypeExp leftOperand = GetTypeExp (ref token);
			if (leftOperand == null) return null;

			while ((token is TokenKwAnd) || (token is TokenKwOr)) {
				Token typeBinOp = token;
				token = token.nextToken;
				TokenTypeExp rightOperand = GetTypeExp (ref token);
				if (rightOperand == null) return null;
				TokenTypeExpBinOp typeExpBinOp = new TokenTypeExpBinOp (typeBinOp);
				typeExpBinOp.leftOp  = leftOperand;
				typeExpBinOp.binOp   = typeBinOp;
				typeExpBinOp.rightOp = rightOperand;
				leftOperand = typeExpBinOp;
			}
			return leftOperand;
		}

		private TokenTypeExp GetTypeExp (ref Token token)
		{
			if (token is TokenKwTilde) {
				TokenTypeExpNot typeExpNot = new TokenTypeExpNot (token);
				token = token.nextToken;
				typeExpNot.typeExp = GetTypeExp (ref token);
				if (typeExpNot.typeExp == null) return null;
				return typeExpNot;
			}
			if (token is TokenKwParOpen) {
				TokenTypeExpPar typeExpPar = new TokenTypeExpPar (token);
				token = token.nextToken;
				typeExpPar.typeExp = GetTypeExp (ref token);
				if (typeExpPar.typeExp == null) return null;
				if (!(token is TokenKwParClose)) {
					ErrorMsg (token, "expected close parenthesis");
					token = SkipPastSemi (token);
					return null;
				}
				return typeExpPar;
			}
			if (token is TokenKwUndef) {
				TokenTypeExpUndef typeExpUndef = new TokenTypeExpUndef (token);
				token = token.nextToken;
				return typeExpUndef;
			}
			if (token is TokenType) {
				TokenTypeExpType typeExpType = new TokenTypeExpType (token);
				typeExpType.typeToken = (TokenType)token;
				token = token.nextToken;
				return typeExpType;
			}
			ErrorMsg (token, "expected type");
			token = SkipPastSemi (token);
			return null;
		}

		/**
		 * @brief get a right-hand operand expression token
		 * @param token = first token of operand to parse
		 * @returns null: invalid operand
		 *          else: token that bundles or wraps the operand
		 *          token = points to token following last operand token
		 */
		private TokenRVal GetOperand (ref Token token)
		{
			/*
			 * Prefix unary operators (eg ++, --) requiring an L-value.
			 */
			if ((token is TokenKwIncr) || (token is TokenKwDecr)) {
				TokenRValAsnPre asnPre = new TokenRValAsnPre (token);
				asnPre.prefix = token;
				token = token.nextToken;
				TokenRVal op = GetOperand (ref token);
				if (op == null) return null;
				if (!(op is TokenLVal)) {
					ErrorMsg (op, "can pre{in,de}crement only an L-value");
					return null;
				}
				asnPre.lVal = (TokenLVal)op;
				return asnPre;
			}

			/*
			 * Get the bulk of the operand, ie, without any of the below suffixes.
			 */
			TokenRVal operand = GetOperandNoMods (ref token);
			if (operand == null) return null;
		modifiers:

			/*
			 * If followed by '++' or '--', it is post-{in,de}cremented.
			 */
			if ((token is TokenKwIncr) || (token is TokenKwDecr)) {
				TokenRValAsnPost asnPost = new TokenRValAsnPost (token);
				asnPost.postfix = token;
				token = token.nextToken;
				if (!(operand is TokenLVal)) {
					ErrorMsg (operand, "can post{in,de}crement only an L-value");
					return null;
				}
				asnPost.lVal = (TokenLVal)operand;
				return asnPost;
			}

			/*
			 * If followed by a '.', it is an instance field or instance method reference.
			 */
			if (token is TokenKwDot) {
				token = token.nextToken;
				if (!(token is TokenName)) {
					ErrorMsg (token, ". must be followed by field/method name");
					return null;
				}
				TokenLValIField field = new TokenLValIField (token);
				field.baseRVal = operand;
				field.fieldName = (TokenName)token;
				operand = field;
				token = token.nextToken;
				goto modifiers;
			}

			/*
			 * If followed by a '[', it is an array subscript.
			 */
			if (token is TokenKwBrkOpen) {
				TokenLValArEle tokenLValArEle = new TokenLValArEle (token);
				token = token.nextToken;

				/*
				 * Parse subscript(s) expression.
				 */
				tokenLValArEle.subRVal = ParseRVal (ref token, brkCloseOnly);
				if (tokenLValArEle.subRVal == null) {
					ErrorMsg (tokenLValArEle, "invalid subscript");
					return null;
				}

				/*
				 * See if comma-separated list of values.
				 */
				bool sideEffects = false;
				TokenRVal subscriptRVals;
				int numSubscripts = SplitCommaRVals (tokenLValArEle.subRVal, out subscriptRVals, ref sideEffects);
				if (numSubscripts > 1) {

					/*
					 * If so, put the values in an LSL_List object.
					 */
					TokenRValList rValList = new TokenRValList (tokenLValArEle);
					rValList.rVal = subscriptRVals;
					rValList.nItems = numSubscripts;
					rValList.sideEffects = sideEffects;
					tokenLValArEle.subRVal = rValList;
				}

				/*
				 * Either way, save array variable name
				 * and substitute whole reference for L-value
				 */
				tokenLValArEle.baseRVal = operand;
				operand = tokenLValArEle;
				goto modifiers;
			}

			/*
			 * If followed by a '(', it is a function/method call.
			 */
			if (token is TokenKwParOpen) {
				operand = ParseRValCall (ref token, operand);
				goto modifiers;
			}

			return operand;
		}

		/**
		 * @brief same as GetOperand() except doesn't check for any modifiers
		 */
		private TokenRVal GetOperandNoMods (ref Token token)
		{
			/*
			 * Simple unary operators.
			 */
			if ((token is TokenKwSub) || 
			    (token is TokenKwTilde) ||
			    (token is TokenKwExclam)) {
				Token uop = token;
				token = token.nextToken;
				TokenRVal rVal = GetOperand (ref token);
				if (rVal == null) return null;
				return PerformUnOp (uop, rVal);
			}

			/*
			 * Type casting.
			 */
			if ((token is TokenKwParOpen) &&
			    (token.nextToken is TokenType) &&
			    (token.nextToken.nextToken is TokenKwParClose)) {
				TokenType type = (TokenType)token.nextToken;
				token = token.nextToken.nextToken.nextToken;
				TokenRVal rVal = GetOperand (ref token);
				if (rVal == null) return null;
				return new TokenRValCast (type, rVal);
			}

			/*
			 * Parenthesized expression.
			 */
			if (token is TokenKwParOpen) {
				return ParseRValParen (ref token);
			}

			/*
			 * Constants.
			 */
			if (token is TokenFloat) {
				TokenRValConst rValConst = new TokenRValConst (token, ((TokenFloat)token).val);
				token = token.nextToken;
				return rValConst;
			}
			if (token is TokenInt) {
				TokenRValConst rValConst = new TokenRValConst (token, ((TokenInt)token).val);
				token = token.nextToken;
				return rValConst;
			}
			if (token is TokenStr) {
				TokenRValConst rValConst = new TokenRValConst (token, ((TokenStr)token).val);
				token = token.nextToken;
				return rValConst;
			}
			if (token is TokenKwUndef) {
				TokenRValUndef rValUndef = new TokenRValUndef ((TokenKwUndef)token);
				token = token.nextToken;
				return rValUndef;
			}

			/*
			 * '<'value,...'>', ie, rotation or vector
			 */
			if (token is TokenKwCmpLT) {
				Token openBkt = token;
				token = token.nextToken;
				TokenRVal rValAll = ParseRVal (ref token, cmpGTOnly);
				if (rValAll == null) return null;
				TokenRVal rVals;
				bool sideEffects = false;
				int nVals = SplitCommaRVals (rValAll, out rVals, ref sideEffects);
				switch (nVals) {
					case 3: {
						TokenRValVec rValVec = new TokenRValVec (openBkt);
						rValVec.xRVal = rVals;
						rValVec.yRVal = (TokenRVal)rVals.nextToken;
						rValVec.zRVal = (TokenRVal)rVals.nextToken.nextToken;
						rValVec.sideEffects = sideEffects;
						return rValVec;
					}
					case 4: {
						TokenRValRot rValRot = new TokenRValRot (openBkt);
						rValRot.xRVal = rVals;
						rValRot.yRVal = (TokenRVal)rVals.nextToken;
						rValRot.zRVal = (TokenRVal)rVals.nextToken.nextToken;
						rValRot.wRVal = (TokenRVal)rVals.nextToken.nextToken.nextToken;
						rValRot.sideEffects = sideEffects;
						return rValRot;
					}
					default: {
						ErrorMsg (openBkt, "bad rotation/vector");
						token = SkipPastSemi (token);
						return null;
					}
				}
			}

			/*
			 * '['value,...']', ie, list
			 */
			if (token is TokenKwBrkOpen) {
				TokenRValList rValList = new TokenRValList (token);
				token = token.nextToken;
				if (token is TokenKwBrkClose) {
					token = token.nextToken;  // empty list
				} else {
					TokenRVal rValAll = ParseRVal (ref token, brkCloseOnly);
					if (rValAll == null) return null;
					rValList.nItems = SplitCommaRVals (rValAll, out rValList.rVal, ref rValList.sideEffects);
				}
				return rValList;
			}

			/*
			 * Maybe we have <type>.<name> referencing a static field or method of some type.
			 */
			if ((token is TokenType) && (token.nextToken is TokenKwDot) && (token.nextToken.nextToken is TokenName)) {
				TokenLValSField field = new TokenLValSField (token.nextToken.nextToken);
				field.baseType = (TokenType)token;
				field.fieldName = (TokenName)token.nextToken.nextToken;
				token = token.nextToken.nextToken.nextToken;
				return field;
			}

			/*
			 * Maybe we have 'this' referring to the object of the instance method.
			 */
			if (token is TokenKwThis) {
				if ((currentDeclSDType == null) || !(currentDeclSDType is TokenDeclSDTypeClass)) {
					ErrorMsg (token, "using 'this' outside class definition");
					throw new Exception ("BARFING OUT");
					token = SkipPastSemi (token);
					return null;
				}
				TokenRValThis zhis = new TokenRValThis (token, (TokenDeclSDTypeClass)currentDeclSDType);
				token = token.nextToken;
				return zhis;
			}

			/*
			 * Maybe we have 'base' referring to a field/method of the extended class.
			 */
			if (token is TokenKwBase) {
				if ((currentDeclFunc == null) || (currentDeclFunc.sdtClass == null)) {
					ErrorMsg (token, "using 'base' outside method");
					token = SkipPastSemi (token);
					return null;
				}
				if (!(token.nextToken is TokenKwDot) || !(token.nextToken.nextToken is TokenName)) {
					ErrorMsg (token, "base must be followed by . then field or method name");
					TokenRValThis zhis = new TokenRValThis (token, currentDeclFunc.sdtClass);
					token = token.nextToken;
					return zhis;
				}
				TokenRValBaseField baseField = new TokenRValBaseField (token, 
				                               (TokenName)token.nextToken.nextToken, 
				                               currentDeclFunc.sdtClass);
				token = token.nextToken.nextToken.nextToken;
				return baseField;
			}

			/*
			 * Maybe we have 'new <script-defined-type>' saying to create an object instance.
			 * This ends up generating a call to static function <script-defined-type>.new(...)
			 * whose CIL code is generated by GenerateNewobjBody().
			 */
			if (token is TokenKwNew) {
				if (!(token.nextToken is TokenType)) {
					ErrorMsg (token.nextToken, "new must be followed by type");
					token = SkipPastSemi (token);
					return null;
				}
				TokenLValSField field = new TokenLValSField (token.nextToken.nextToken);
				field.baseType  = (TokenType)token.nextToken;
				field.fieldName = new TokenName (token, "new");
				token = token.nextToken.nextToken;
				return field;
			}

			/*
			 * All we got left is <name>, eg, arg, function, global or local variable reference
			 */
			if (token is TokenName) {
				TokenLValName name = new TokenLValName ((TokenName)token, tokenScript);
				token = token.nextToken;
				return name;
			}

			/*
			 * Who knows what it is supposed to be?
			 */
			ErrorMsg (token, "invalid operand token");
			token = SkipPastSemi (token);
			return null;
		}

		/**
		 * @brief Parse a call expression
		 * @param token = points to arg list '('
		 * @param meth = points to method name being called
		 * @returns call expression value
		 *          token = points just past arg list ')'
		 */
		private TokenRValCall ParseRValCall (ref Token token, TokenRVal meth)
		{
			/*
			 * Set up basic function call struct with function name.
			 */
			TokenRValCall rValCall = new TokenRValCall (token);
			rValCall.meth = meth;

			/*
			 * Parse the call parameters, if any.
			 */
			token = token.nextToken;
			if (token is TokenKwParClose) {
				token = token.nextToken;
			} else {
				rValCall.args = ParseRVal (ref token, parCloseOnly);
				if (rValCall.args == null) return null;
				rValCall.nArgs = SplitCommaRVals (rValCall.args, out rValCall.args, ref rValCall.sideEffects);
			}

			currentDeclFunc.unknownTrivialityCalls.AddLast (rValCall);

			return rValCall;
		}

		/**
		 * @brief decode binary operator token
		 * @param token = points to token to decode
		 * @returns null: invalid operator token
		 *          else: operator token and precedence
		 */
		private BinOp GetOperator (ref Token token)
		{
			BinOp binOp = new BinOp ();
			if (precedence.TryGetValue (token.GetType (), out binOp.preced)) {
				binOp.token = (TokenKw)token;
				token = token.nextToken;
				return binOp;
			}

			if ((token is TokenKwSemi) || (token is TokenKwBrcOpen) || (token is TokenKwBrcClose)) {
				ErrorMsg (token, "premature expression end");
			} else {
				ErrorMsg (token, "invalid operator");
			}
			token = SkipPastSemi (token);
			return null;
		}

		private class BinOp {
			public BinOp pop;
			public TokenKw token;
			public int preced;
		}

		/**
		 * @brief Return an R-value expression token that will be used to
		 *        generate code to perform the operation at runtime.
		 * @param left  = left-hand operand
		 * @param binOp = operator
		 * @param right = right-hand operand
		 * @returns resultant expression
		 */
		private TokenRVal PerformBinOp (TokenRVal left, BinOp binOp, TokenRVal right)
		{
			return new TokenRValOpBin (left, binOp.token, right);
		}

		/**
		 * @brief Return an R-value expression token that will be used to
		 *        generate code to perform the operation at runtime.
		 * @param unOp  = operator
		 * @param right = right-hand operand
		 * @returns resultant constant or expression
		 */
		private TokenRVal PerformUnOp (Token unOp, TokenRVal right)
		{
			return new TokenRValOpUn ((TokenKw)unOp, right);
		}

		/**
		 * @brief parse out a parenthesized expression.
		 * @param token = points to open parenthesis
		 * @returns null: invalid expression
		 *          else: parenthesized expression token or constant token
		 *          token = points past the close parenthesis
		 */
		private TokenRVal ParseRValParen (ref Token token)
		{
			if (!(token is TokenKwParOpen)) {
				ErrorMsg (token, "expecting (");
				token = SkipPastSemi (token);
				return null;
			}
			TokenRValParen tokenRValParen = new TokenRValParen (token);
			token = token.nextToken;
			tokenRValParen.rVal = ParseRVal (ref token, parCloseOnly);
			if (tokenRValParen.rVal == null) return null;
			tokenRValParen.sideEffects = tokenRValParen.rVal.sideEffects;
			return tokenRValParen;
		}

		/**
		 * @brief Split a comma'd RVal into separate expressions
		 * @param rValAll = expression containing commas
		 * @returns number of comma separated values
		 *          rVals = values in a null-terminated list linked by rVals.nextToken
		 *          sideEffects |= some of the values have side effects
		 */
		private int SplitCommaRVals (TokenRVal rValAll, out TokenRVal rVals, ref bool sideEffects)
		{
			if (!(rValAll is TokenRValOpBin) || !(((TokenRValOpBin)rValAll).opcode is TokenKwComma)) {
				rVals = rValAll;
				if (rVals.nextToken != null) throw new Exception ("expected null");
				sideEffects |= rValAll.sideEffects;
				return 1;
			}
			TokenRValOpBin opBin = (TokenRValOpBin)rValAll;
			TokenRVal rValLeft, rValRight;
			bool sel = false;
			bool ser = false;
			int leftCount  = SplitCommaRVals (opBin.rValLeft,  out rValLeft,  ref sel);
			int rightCount = SplitCommaRVals (opBin.rValRight, out rValRight, ref ser);
			rVals = rValLeft;
			while (rValLeft.nextToken != null) rValLeft = (TokenRVal)rValLeft.nextToken;
			rValLeft.nextToken = rValRight;
			sideEffects |= sel | ser;
			return leftCount + rightCount;
		}

		/**
		 * @brief output error message and remember that there is an error.
		 * @param token = what token is associated with the error
		 * @param message = error message string
		 */
		private void ErrorMsg (Token token, string message)
		{
			errors = true;
			token.ErrorMsg (message);
		}

		/**
		 * @brief Skip past the next semicolon (or matched braces)
		 * @param token = points to token to skip over
		 * @returns token just after the semicolon or close brace
		 */
		private Token SkipPastSemi (Token token)
		{
			int braceLevel = 0;

			while (!(token is TokenEnd)) {
				if ((token is TokenKwSemi) && (braceLevel == 0)) {
					return token.nextToken;
				}
				if (token is TokenKwBrcOpen) {
					braceLevel ++;
				}
				if ((token is TokenKwBrcClose) && (-- braceLevel <= 0)) {
					return token.nextToken;
				}
				token = token.nextToken;
			}
			return token;
		}
	}

	/**
	 * @brief Script-defined type declarations
	 */
	public abstract class TokenDeclSDType : Token {
		protected const byte CLASS     = 0;
		protected const byte DELEGATE  = 1;
		protected const byte GENINST   = 2;
		protected const byte INTERFACE = 3;

		public TokenDeclSDType outerSDType;          // null if top-level
		                                             // else points to defining script-defined type
		public uint accessLevel;                     // SDT_PRIVATE, SDT_PROTECTED or SDT_PUBLIC
		                                             // ... all top-level types are SDT_PUBLIC
		public Dictionary<string, TokenDeclSDType> innerSDTypes = new Dictionary<string, TokenDeclSDType> ();
		                                             // indexed by shortName
		public Token endToken;                       // the '}' or ';' that ends the definition

		public TokenDeclSDTypeGenParam[] genParams;  // array of parameters for generic prototypes
		                                             // length 0 for non-generic prototypes
		                                             // eg, for 'Dictionary<K,V>'
		                                             //     ...genParams gives 0->K; 1->V
		                                             // cumulative for nested types

		/*
		 * Name of the type.
		 *   shortName = doesn't include outer class type names
		 *               eg, 'Engine' for non-generic
		 *                   'Dictionary<,>' for generic prototype
		 *                   'Dictionary<string,integer>' for generic instantiation
		 *   longName = includes all outer class type names if any
		 */
		private TokenName _shortName;
		private TokenName _longName;

		public TokenName shortName {
			get {
				return _shortName;
			}
			set {
				_shortName = value;
				_longName  = null;
			}
		}

		public TokenName longName {
			get {
				if (_longName == null) {
					_longName = _shortName;
					if (outerSDType != null) {
						_longName = new TokenName (_shortName, outerSDType.longName.val + "." + _shortName.val);
					}
				}
				return _longName;
			}
		}

		/*
		 * Dictionary used when reading from object file that holds all script-defined types.
		 * Not complete though until all types have been read from the object file.
		 */
		private Dictionary<string, TokenDeclSDType> sdTypes;

		public TokenDeclSDType (Token t) : base (t) { }
		public abstract TokenTypeSDType MakeRefToken (Token t, TokenType[] genArgs);
		public abstract Type GetSysType ();
		public abstract void WriteToFile (BinaryWriter objFileWriter);
		public abstract void ReadFromFile (BinaryReader objFileReader, TextWriter asmFileWriter);

		/**
		 * @brief Read one of these in from the object file.
		 * @param sdTypes = dictionary of script-defined types, not yet complete
		 * @param name = script-visible name of this type
		 * @param objFileReader = reads from the object file
		 * @param asmFileWriter = writes to the disassembly file (might be null)
		 */
		public static TokenDeclSDType ReadFromFile (Dictionary<string, TokenDeclSDType> sdTypes, string name, 
		                                            BinaryReader objFileReader, TextWriter asmFileWriter)
		{
			string file = objFileReader.ReadString ();
			int    line = objFileReader.ReadInt32 ();
			int    posn = objFileReader.ReadInt32 ();
			byte   code = objFileReader.ReadByte ();
			TokenName n = new TokenName (null, file, line, posn, name);
			TokenDeclSDType sdt;
			switch (code) {
				case CLASS: {
					sdt = new TokenDeclSDTypeClass (n);
					break;
				}
				case DELEGATE: {
					sdt = new TokenDeclSDTypeDelegate (n);
					break;
				}
				case GENINST: {
					sdt = new TokenDeclSDTypeGenInst (n);
					break;
				}
				case INTERFACE: {
					sdt = new TokenDeclSDTypeInterface (n);
					break;
				}
				default: throw new Exception ();
			}
			sdt.sdTypes = sdTypes;
			sdt.ReadFromFile (objFileReader, asmFileWriter);
			return sdt;
		}

		/**
		 * @brief Convert a typename string to a type token
		 * @param name = script-visible name of token to create, 
		 *               either a script-defined type or an LSL-defined type
		 * @returns type token
		 */
		protected TokenType MakeTypeToken (string name)
		{
			TokenDeclSDType sdtdecl;
			if (sdTypes.TryGetValue (name, out sdtdecl)) return sdtdecl.MakeRefToken (this, null);
			return TokenType.FromLSLType (this, name);
		}
	}

	public class TokenDeclSDTypeClass : TokenDeclSDType {
		public TokenDeclSDTypeClass extends;
		public List<TokenDeclSDTypeInterface> implements = new List<TokenDeclSDTypeInterface> ();
		public VarDict members = new VarDict ();

		public Dictionary<string, int> intfIndices = new Dictionary<string, int> ();  // longname => this.iFaces index
		public TokenDeclSDTypeInterface[] iFaces;  // array of implemented interfaces
		                                           //   low-end entries copied from rootward classes
		public TokenDeclVar[][] iImplFunc;         // iImplFunc[i][j]:
		                                           //   low-end [i] entries copied from rootward classes
		                                           //   i = interface number from this.intfIndices[name]
		                                           //   j = method of interface from iface.methods[name].vTableIndex

		public bool slotsAssigned;    // set true when slots have been assigned...
		public int numInstArrays;     // number of non-static array fields
		public int numInstFloats;     // number of non-static float fields
		public int numInstIntegers;   // number of non-static integer fields
		public int numInstLists;      // number of non-static list fields
		public int numInstObjects;    // number of non-static object fields
		public int numInstRotations;  // number of non-static rotation fields
		public int numInstStrings;    // number of non-static string fields
		public int numInstVectors;    // number of non-static vector fields
		public int numInstSDTClObjs;  // number of non-static sdt-class object fields
		public int numVirtFuncs;      // number of virtual functions
		public int numInterfaces;     // number of implemented interfaces

		private string extendsStr;
		private List<StackedMethod> stackedMethods;
		private List<StackedIFace>  stackedIFaces;

		public DynamicMethod[] vDynMeths;    // virtual method entrypoints
		public Type[] vMethTypes;            // virtual method delegate types
		public DynamicMethod[][] iDynMeths;  // interface method entrypoints
		public Type[][] iMethTypes;          // interface method types
		                                     //   low-end [i] entries copied from rootward classes
		                                     //   i = interface number from this.intfIndices[name]
		                                     //   j = method of interface from iface.methods[name].vTableIndex

		public TokenDeclSDTypeClass (TokenName shortName) : base (shortName)
		{
			this.shortName = shortName;
		}

		public override TokenTypeSDType MakeRefToken (Token t, TokenType[] genArgs)
		{
			TokenTypeSDType sdType = new TokenTypeSDTypeClass (t, this);
			sdType.genArgs = genArgs;
			return sdType;
		}

		public override Type GetSysType ()
		{
			return typeof (XMRSDTypeClassInstance);
		}

		/**
		 * @brief Write enough out so we can reconstruct with ReadFromFile.
		 */
		public override void WriteToFile (BinaryWriter objFileWriter)
		{
			objFileWriter.Write (this.file);
			objFileWriter.Write (this.line);
			objFileWriter.Write (this.posn);
			objFileWriter.Write ((byte)CLASS);

			objFileWriter.Write (numInstArrays);
			objFileWriter.Write (numInstFloats);
			objFileWriter.Write (numInstIntegers);
			objFileWriter.Write (numInstLists);
			objFileWriter.Write (numInstObjects);
			objFileWriter.Write (numInstRotations);
			objFileWriter.Write (numInstStrings);
			objFileWriter.Write (numInstVectors);
			objFileWriter.Write (numInstSDTClObjs);
			objFileWriter.Write (numVirtFuncs);

			if (extends == null) {
				objFileWriter.Write ("");
			} else {
				objFileWriter.Write (extends.longName.val);
			}

			foreach (TokenDeclVar meth in members) {
				if ((meth.retType != null) && (meth.vTableIndex >= 0)) {
					objFileWriter.Write (meth.vTableIndex);
					objFileWriter.Write (meth.GetObjCodeName ());
					objFileWriter.Write (meth.GetDelType ().decl.GetWholeSig ());
				}
			}
			objFileWriter.Write (-1);

			int numIFaces = iImplFunc.Length;
			objFileWriter.Write (numIFaces);
			for (int i = 0; i < numIFaces; i ++) {
				objFileWriter.Write (iFaces[i].longName.val);
				TokenDeclVar[] meths = iImplFunc[i];
				int numMeths = 0;
				if (meths != null) numMeths = meths.Length;
				objFileWriter.Write (numMeths);
				for (int j = 0; j < numMeths; j ++) {
					TokenDeclVar meth = meths[j];
					objFileWriter.Write (meth.GetObjCodeName ());
					objFileWriter.Write (meth.GetDelType ().decl.GetWholeSig ());
				}
			}
		}

		/**
		 * @brief Reconstruct from the file.
		 */
		public override void ReadFromFile (BinaryReader objFileReader, TextWriter asmFileWriter)
		{
			numInstArrays    = objFileReader.ReadInt32 ();
			numInstFloats    = objFileReader.ReadInt32 ();
			numInstIntegers  = objFileReader.ReadInt32 ();
			numInstLists     = objFileReader.ReadInt32 ();
			numInstObjects   = objFileReader.ReadInt32 ();
			numInstRotations = objFileReader.ReadInt32 ();
			numInstStrings   = objFileReader.ReadInt32 ();
			numInstVectors   = objFileReader.ReadInt32 ();
			numInstSDTClObjs = objFileReader.ReadInt32 ();
			numVirtFuncs     = objFileReader.ReadInt32 ();

			extendsStr = objFileReader.ReadString ();

			stackedMethods = new List<StackedMethod> ();
			int vTableIndex;
			while ((vTableIndex = objFileReader.ReadInt32 ()) >= 0) {
				StackedMethod sm;
				sm.methVTI  = vTableIndex;
				sm.methName = objFileReader.ReadString ();
				sm.methSig  = objFileReader.ReadString ();
				stackedMethods.Add (sm);
			}

			int numIFaces = objFileReader.ReadInt32 ();
			if (numIFaces > 0) {
				iDynMeths  = new DynamicMethod[numIFaces][];
				iMethTypes = new Type[numIFaces][];
				stackedIFaces = new List<StackedIFace> ();
				for (int i = 0; i < numIFaces; i ++) {
					string iFaceName = objFileReader.ReadString ();
					intfIndices[iFaceName] = i;
					int numMeths  = objFileReader.ReadInt32 ();
					iDynMeths[i]  = new DynamicMethod[numMeths];
					iMethTypes[i] = new Type[numMeths];
					for (int j = 0; j < numMeths; j ++) {
						StackedIFace si;
						si.iFaceIndex = i;
						si.methIndex  = j;
						si.methName   = objFileReader.ReadString ();
						si.methSig    = objFileReader.ReadString ();
						stackedIFaces.Add (si);
					}
				}
			}
		}

		private struct StackedMethod {
			public int methVTI;
			public string methName;
			public string methSig;
		}

		private struct StackedIFace {
			public int iFaceIndex;
			public int methIndex;
			public string methName;
			public string methSig;
		}

		/**
		 * @brief Called after all dynamic method code has been generated to fill in vDynMeths and vMethTypes
		 *        Also fills in iDynMeths, iMethTypes.
		 */
		public void FillVTables (ScriptObjCode scriptObjCode)
		{
			if (extendsStr != null) {
				if (extendsStr != "") {
					extends = (TokenDeclSDTypeClass)scriptObjCode.sdObjTypes[extendsStr];
					extends.FillVTables (scriptObjCode);
				}
				extendsStr = null;
			}

			if ((numVirtFuncs > 0) && (stackedMethods != null)) {

				/*
				 * Allocate arrays big enough for mine plus type we are extending.
				 */
				vDynMeths  = new DynamicMethod[numVirtFuncs];
				vMethTypes = new Type[numVirtFuncs];

				/*
				 * Fill in low parts from type we are extending.
				 */
				if (extends != null) {
					int n = extends.numVirtFuncs;
					for (int i = 0; i < n; i ++) {
						vDynMeths[i]  = extends.vDynMeths[i];
						vMethTypes[i] = extends.vMethTypes[i];
					}
				}

				/*
				 * Fill in high parts with my own methods.
				 * Might also overwrite lower ones with 'override' methods.
				 */
				foreach (StackedMethod sm in stackedMethods) {
					int i = sm.methVTI;
					string methName  = sm.methName;
					DynamicMethod dm = scriptObjCode.dynamicMethods[methName];
					vDynMeths[i]  = dm;
					vMethTypes[i] = GetDynamicMethodDelegateType (dm, sm.methSig);
				}
				stackedMethods = null;
			}

			if (stackedIFaces != null) {
				foreach (StackedIFace si in stackedIFaces) {
					int i = si.iFaceIndex;
					int j = si.methIndex;
					string methName  = si.methName;
					DynamicMethod dm = scriptObjCode.dynamicMethods[methName];
					iDynMeths[i][j]  = dm;
					iMethTypes[i][j] = GetDynamicMethodDelegateType (dm, si.methSig);
				}
				stackedIFaces = null;
			}
		}

		private Type GetDynamicMethodDelegateType (DynamicMethod dm, string methSig)
		{
			Type retType = dm.ReturnType;
			ParameterInfo[] pi = dm.GetParameters ();
			Type[] argTypes = new Type[pi.Length];
			for (int j = 0; j < pi.Length; j ++) {
				argTypes[j] = pi[j].ParameterType;
			}
			return DelegateCommon.GetType (retType, argTypes, methSig);
		}

		// debugging - returns, eg, 'Dictionary<T,U>.Enumerator.Node'
		public override void DebString (StringBuilder sb)
		{
			// get long name broken down into segments from outermost to this
			Stack<TokenDeclSDType> declStack = new Stack<TokenDeclSDType> ();
			for (TokenDeclSDType decl = this; decl != null; decl = decl.outerSDType) {
				declStack.Push (decl);
			}

			// output each segment's name followed by our args for it
			// starting with outermost and ending with this
			int i = 0;
			while (declStack.Count > 0) {
				TokenDeclSDType decl = declStack.Pop ();
				sb.Append (decl.shortName.val);
				if (i < decl.genParams.Length) {
					sb.Append ('<');
					while (i < decl.genParams.Length) {
						decl.genParams[i].DebString (sb);
						if (++ i < decl.genParams.Length) sb.Append (',');
					}
					sb.Append ('>');
				}
				if (declStack.Count > 0) sb.Append ('.');
			}
		}
	}

	public class TokenDeclSDTypeDelegate : TokenDeclSDType {
		private TokenType retType;
		private TokenType[] argTypes;

		private string argSig;
		private string wholeSig;
		private Type sysType;
		private Type retSysType;
		private Type[] argSysTypes;

		private string retStr;
		private string[] argStrs;

		private static Dictionary<string, TokenDeclSDTypeDelegate> inlines = new Dictionary<string, TokenDeclSDTypeDelegate> ();
		private static Dictionary<Type, string> inlrevs = new Dictionary<Type, string> ();

		public TokenDeclSDTypeDelegate (TokenName shortName) : base (shortName)
		{
			this.shortName = shortName;
		}
		public void SetRetArgTypes (TokenType retType, TokenType[] argTypes)
		{
			this.retType  = retType;
			this.argTypes = argTypes;
		}

		public override TokenTypeSDType MakeRefToken (Token t, TokenType[] genArgs)
		{
			TokenTypeSDType sdType = new TokenTypeSDTypeDelegate (t, this);
			sdType.genArgs = genArgs;
			return sdType;
		}

		/**
		 * @brief Get system type for the whole delegate.
		 */
		public override Type GetSysType ()
		{
			if (sysType == null) FillInStuff ();
			return sysType;
		}

		/**
		 * @brief Get the function's return value type (TokenTypeVoid if void, never null)
		 */
		public TokenType GetRetType ()
		{
			if (retType == null) FillInStuff ();
			return retType;
		}

		/**
		 * @brief Get the function's argument types
		 */
		public TokenType[] GetArgTypes ()
		{
			if (argTypes == null) FillInStuff ();
			return argTypes;
		}

		/**
		 * @brief Get signature for the whole delegate, eg, "void(integer,list)"
		 */
		public string GetWholeSig ()
		{
			if (wholeSig == null) FillInStuff ();
			return wholeSig;
		}

		/**
		 * @brief Get signature for the arguments, eg, "(integer,list)"
		 */
		public string GetArgSig ()
		{
			if (argSig == null) FillInStuff ();
			return argSig;
		}

		/**
		 * @brief Find out how to create one of these delegates.
		 */
		public ConstructorInfo GetConstructorInfo ()
		{
			if (sysType == null) FillInStuff ();
			return sysType.GetConstructor (DelegateCommon.constructorArgTypes);
		}

		/**
		 * @brief Find out how to call what one of these delegates points to.
		 */
		public MethodInfo GetInvokerInfo ()
		{
			if (sysType == null) FillInStuff ();
			return sysType.GetMethod ("Invoke", argSysTypes);
		}

		/**
		 * @brief Write enough out to a file so delegate can be reconstructed in ReadFromFile().
		 */
		public override void WriteToFile (BinaryWriter objFileWriter)
		{
			objFileWriter.Write (this.file);
			objFileWriter.Write (this.line);
			objFileWriter.Write (this.posn);
			objFileWriter.Write ((byte)DELEGATE);

			objFileWriter.Write (retType.ToString ());
			int nArgs = argTypes.Length;
			objFileWriter.Write (nArgs);
			for (int i = 0; i < nArgs; i ++) {
				objFileWriter.Write (argTypes[i].ToString ());
			}
		}

		/**
		 * @brief Read that data from file so we can reconstruct.
		 *        Don't actually reconstruct yet in case any forward-referenced types are undefined.
		 */
		public override void ReadFromFile (BinaryReader objFileReader, TextWriter asmFileWriter)
		{
			retStr = objFileReader.ReadString ();
			int nArgs = objFileReader.ReadInt32 ();
			if (asmFileWriter != null) {
				asmFileWriter.Write ("  delegate " + retStr + " " + longName.val + "(");
			}
			argStrs = new string[nArgs];
			for (int i = 0; i < nArgs; i ++) {
				argStrs[i] = objFileReader.ReadString ();
				if (asmFileWriter != null) {
					if (i > 0) asmFileWriter.Write (",");
					asmFileWriter.Write (argStrs[i]);
				}
			}
			if (asmFileWriter != null) {
				asmFileWriter.WriteLine (");");
			}
		}

		/**
		 * @brief Fill in missing internal data.
		 */
		private void FillInStuff ()
		{
			int nArgs;

			/*
			 * This happens when the node was restored via ReadFromFile().
			 * It leaves the types in retStr/argStrs for resolution after
			 * all definitions have been read from the object file in case
			 * there are forward references.
			 */
			if (retType == null) {
				retType = MakeTypeToken (retStr);
			}
			if (argTypes == null) {
				nArgs = argStrs.Length;
				argTypes = new TokenType[nArgs];
				for (int i = 0; i < nArgs; i ++) {
					argTypes[i] = MakeTypeToken (argStrs[i]);
				}
			}

			/*
			 * Fill in system types from token types.
			 * Might as well build the signature strings too from token types.
			 */
			retSysType = retType.ToSysType();

			nArgs = argTypes.Length;
			StringBuilder sb = new StringBuilder ();
			argSysTypes = new Type[nArgs];
			sb.Append ('(');
			for (int i = 0; i < nArgs; i ++) {
				if (i > 0) sb.Append (',');
				sb.Append (argTypes[i].ToString ());
				argSysTypes[i] = argTypes[i].ToSysType ();
			}
			sb.Append (')');
			argSig = sb.ToString ();
			wholeSig = retType.ToString () + argSig;

			/*
			 * Now we can create a system delegate type from the given
			 * return and argument types.  Give it an unique name using
			 * the whole signature string.
			 */
			sysType = DelegateCommon.GetType (retSysType, argSysTypes, wholeSig);
		}

		/**
		 * @brief create delegate reference token for inline functions.
		 *        there is just one instance of these per inline function
		 *        shared by all scripts, and it is just used when the
		 *        script engine is loaded.
		 */
		public static TokenDeclSDTypeDelegate CreateInline (TokenType retType, TokenType[] argTypes)
		{
			TokenDeclSDTypeDelegate decldel;

			/*
			 * Name it after the whole signature string.
			 */
			StringBuilder sb = new StringBuilder (".inline.");
			sb.Append (retType.ToString ());
			sb.Append ("(");
			bool first = true;
			foreach (TokenType at in argTypes) {
				if (!first) sb.Append (",");
				sb.Append (at.ToString ());
				first = false;
			}
			sb.Append (")");
			string inlname = sb.ToString ();
			if (!inlines.TryGetValue (inlname, out decldel)) {

				/*
				 * Create the corresponding declaration and link to it
				 */
				TokenName name   = new TokenName (null, inlname);
				decldel          = new TokenDeclSDTypeDelegate (name);
				decldel.retType  = retType;
				decldel.argTypes = argTypes;
				inlines.Add (inlname, decldel);
				inlrevs.Add (decldel.GetSysType (), inlname);
			}
			return decldel;
		}

		public static string TryGetInlineName (Type sysType)
		{
			string name;
			if (!inlrevs.TryGetValue (sysType, out name)) return null;
			return name;
		}

		public static Type TryGetInlineSysType (string name)
		{
			TokenDeclSDTypeDelegate decl;
			if (!inlines.TryGetValue (name, out decl)) return null;
			return decl.GetSysType ();
		}
	}

	/**
	 * @brief These are created for each unique instantiation of a generic prototype.
	 *        Eg, there is one for all uses of 'Dictionary<string,integer>.ValueList'.
	 *        They simply wrap the generic prototype with the arg type list.
	 */
	public class TokenDeclSDTypeGenInst : TokenDeclSDType {
		public TokenDeclSDTypeGenInst (Token original) : base (original) { }

		public override TokenTypeSDType MakeRefToken (Token t, TokenType[] genArgs)
		{
			return instOfGenProto.MakeRefToken (t, genArgs);
		}

		public override Type GetSysType ()
		{
			Console.WriteLine ("TokenDeclSDTypeGenInst::GetSysType*: " + this.longName.val);
			if ((instOfGenProto is TokenDeclSDTypeClass) || (instOfGenProto is TokenDeclSDTypeInterface)) {
				return instOfGenProto.GetSysType ();
			}
			if (instOfGenProto is TokenDeclSDTypeDelegate) {
			}
			throw new Exception ("not yet implemented");
		}

		// points to the generic prototype, eg, 'Dictionary.ValueList'
		private TokenDeclSDType _instOfGenProto;
		private string instOfGenProtoName;
		public TokenDeclSDType instOfGenProto {
			get {
				if (_instOfGenProto == null) {
					throw new Exception ("not yet implemented");
				}
				return _instOfGenProto;
			}
			set {
				_instOfGenProto = value;
			}
		}

		// contains the concrete types, eg, 'string', 'integer'
		private TokenType[] _genArgs;
		private string[] genArgNames;
		public TokenType[] genArgs {
			get {
				if (_genArgs == null) {
					throw new Exception ("not yet implemented");
				}
				return _genArgs;
			}
			set {
				_genArgs = value;
			}
		}

		/**
		 * @brief Write to object file.
		 */
		public override void WriteToFile (BinaryWriter objFileWriter)
		{
			objFileWriter.Write (this.file);
			objFileWriter.Write (this.line);
			objFileWriter.Write (this.posn);
			objFileWriter.Write ((byte)GENINST);

			objFileWriter.Write (instOfGenProto.longName.val);
			int nArgs = genArgs.Length;
			objFileWriter.Write (nArgs);
			for (int i = 0; i < nArgs; i ++) {
				objFileWriter.Write (genArgs[i].ToString ());
			}
		}

		/**
		 * @brief Read from object file.
		 */
		public override void ReadFromFile (BinaryReader objFileReader, TextWriter asmFileWriter)
		{
			instOfGenProtoName = objFileReader.ReadString ();
			int nArgs = objFileReader.ReadInt32 ();
			genArgNames = new string[nArgs];
			for (int i = 0; i < nArgs; i ++) {
				genArgNames[i] = objFileReader.ReadString ();
			}
		}
	}

	/**
	 * @brief Generic parameters
	 *        These are the T in the declaration of 'class List<T>'.
	 *        They are pointed to by 'List's innerSDTypes["T"] and genParams[0].
	 */
	public class TokenDeclSDTypeGenParam : TokenDeclSDType {
		public TokenDeclSDType decl;  // points to type that uses this, eg, 'List'
		public int index;             // what position this is in the paramters

		public TokenDeclSDTypeGenParam (Token original, TokenDeclSDType decl, int index) : base (original)
		{
			this.decl  = decl;
			this.index = index;
		}

		public override TokenTypeSDType MakeRefToken (Token t, TokenType[] genArgs)
		{
			TokenTypeSDType sdType = new TokenTypeSDTypeGenParam (t, this);
			sdType.genArgs = genArgs;
			return sdType;
		}

		public override Type GetSysType ()
		{
			throw new Exception ("not yet implemented");
		}
		public override void WriteToFile (BinaryWriter objFileWriter)
		{
			throw new Exception ("not yet implemented");
		}
		public override void ReadFromFile (BinaryReader objFileReader, TextWriter asmFileWriter)
		{
			throw new Exception ("not yet implemented");
		}

		// debugging - get name string
		public override void DebString (StringBuilder sb)
		{
			foreach (KeyValuePair<string, TokenDeclSDType> kvp in decl.innerSDTypes) {
				if (kvp.Value == this) {
					sb.Append (kvp.Key);
					return;
				}
			}
			throw new Exception ("not found");
		}
	}

	public class TokenDeclSDTypeInterface : TokenDeclSDType {
		public VarDict methsNProps = new VarDict ();

		public TokenDeclSDTypeInterface (TokenName shortName) : base (shortName)
		{
			this.shortName = shortName;
		}

		public override TokenTypeSDType MakeRefToken (Token t, TokenType[] genArgs)
		{
			TokenTypeSDType sdType = new TokenTypeSDTypeInterface (t, this);
			sdType.genArgs = genArgs;
			return sdType;
		}

		public override Type GetSysType ()
		{
			// interfaces are implemented as arrays of delegates
			// they are taken from iDynMeths[interfaceIndex] of a script-defined class object
			return typeof (Delegate[]);
		}

		public override void WriteToFile (BinaryWriter objFileWriter)
		{
			objFileWriter.Write (this.file);
			objFileWriter.Write (this.line);
			objFileWriter.Write (this.posn);
			objFileWriter.Write ((byte)INTERFACE);
		}

		public override void ReadFromFile (BinaryReader objFileReader, TextWriter asmFileWriter)
		{ }

		// debugging - returns, eg, 'IEnumerator<T>'
		public override void DebString (StringBuilder sb)
		{
			sb.Append (longName.val);
			if (genParams.Length > 0) {
				sb.Append ('<');
				for (int i = 0; i < genParams.Length; i ++) {
					if (i > 0) sb.Append (',');
					genParams[i].DebString (sb);
				}
				sb.Append ('>');
			}
		}
	}

	/**
	 * @brief Script-defined type references.
	 *        These occur in the source code wherever it specifies (eg, variable declaration) a script-defined type.
	 */
	public abstract class TokenTypeSDType : TokenType {
		public TokenType[] genArgs;

		public TokenTypeSDType (TokenErrorMessage emsg, string file, int line, int posn) : base (emsg, file, line, posn) { }
		public TokenTypeSDType (Token t) : base (t) { }
		public abstract TokenDeclSDType GetDecl ();
	}

	public class TokenTypeSDTypeClass : TokenTypeSDType {
		private static readonly FieldInfo gblSDTClObjsFieldInfo  = typeof (XMRInstAbstract).GetField ("gblSDTClObjs");
		private static readonly FieldInfo sdtcSDTClObjsFieldInfo = typeof (XMRSDTypeClassInstance).GetField ("sdtcSDTClObjs");

		public TokenDeclSDTypeClass decl;
		public TokenTypeSDTypeClass (Token t, TokenDeclSDTypeClass decl) : base (t)
		{
			this.decl = decl;
		}
		public override TokenDeclSDType GetDecl ()
		{
			return decl;
		}
		public override string ToString ()
		{
			return decl.longName.val;
		}
		public override Type ToSysType ()
		{
			return typeof (XMRSDTypeClassInstance);
		}
		public override bool IsAssignableFrom (TokenType src)
		{
			// given type must be a script-defined class to be assignable to this type
			if (!(src is TokenTypeSDTypeClass)) return false;

			// this type must be the same or rootward of given type
			TokenDeclSDTypeClass sd = ((TokenTypeSDTypeClass)src).decl;
			while (sd != null) {
				if (sd == this.decl) return true;
				sd = sd.extends;
			}
			return false;
		}
		public override void AssignGlobalVarSlot (TokenDeclVar declVar, ScriptObjCode scriptObjCode)
		{
			declVar.vTableArray = gblSDTClObjsFieldInfo;
			declVar.vTableIndex = scriptObjCode.numGblSDTClObjs ++;
		}
		public override void AssignSDTClassFieldSlot (TokenDeclVar declVar, TokenDeclSDTypeClass sdtClass)
		{
			declVar.vTableArray = sdtcSDTClObjsFieldInfo;
			declVar.vTableIndex = sdtClass.numInstSDTClObjs ++;
		}

		// debugging
		public override void DebString (StringBuilder sb)
		{
			decl.DebString (sb);

			if ((this.genArgs != null) && (this.genArgs.Length > 0)) {
				sb.Append (" with ");
				for (int i = 0; i < this.genArgs.Length; i ++) {
					if (i > 0) sb.Append (',');
					this.genArgs[i].DebString (sb);
				}
			}
		}
	}

	public class TokenTypeSDTypeDelegate : TokenTypeSDType {
		private static readonly FieldInfo gblObjectsFieldInfo  = typeof (XMRInstAbstract).GetField ("gblObjects");
		private static readonly FieldInfo sdtcObjectsFieldInfo = typeof (XMRSDTypeClassInstance).GetField ("sdtcObjects");

		public TokenDeclSDTypeDelegate decl;

		/**
		 * @brief create a reference to an explicitly declared delegate
		 * @param t = where the reference is being made in the source file
		 * @param decl = the explicit delegate declaration
		 */
		public TokenTypeSDTypeDelegate (Token t, TokenDeclSDTypeDelegate decl) : base (t)
		{
			this.decl = decl;
		}
		public override TokenDeclSDType GetDecl ()
		{
			return decl;
		}

		/**
		 * @brief create a reference to a possibly anonymous delegate
		 * @param t = where the reference is being made in the source file
		 * @param retType = return type (TokenTypeVoid if void, never null)
		 * @param argTypes = script-visible argument types
		 * @param tokenScript = what script this is part of
		 */
		public TokenTypeSDTypeDelegate (Token t, TokenType retType, TokenType[] argTypes, TokenScript tokenScript) : base (t)
		{
			TokenDeclSDTypeDelegate decldel;

			/*
			 * See if we already have a matching declared one cataloged.
			 */
			int nArgs = argTypes.Length;
			foreach (TokenDeclSDType decl in tokenScript.sdSrcTypesValues) {
				if (decl is TokenDeclSDTypeDelegate) {
					decldel         = (TokenDeclSDTypeDelegate)decl;
					TokenType   rt  = decldel.GetRetType  ();
					TokenType[] ats = decldel.GetArgTypes ();
					if ((rt.ToString () == retType.ToString ()) && (ats.Length == nArgs)) {
						for (int i = 0; i < nArgs; i ++) {
							if (ats[i].ToString () != argTypes[i].ToString ()) goto nomatch;
						}
						this.decl = decldel;
						return;
					}
				}
			nomatch:;
			}

			/*
			 * No such luck, create a new anonymous declaration.
			 */
			StringBuilder sb = new StringBuilder (".anon.delegate.");
			sb.Append (retType.ToString ());
			sb.Append ("(");
			bool first = true;
			foreach (TokenType at in argTypes) {
				if (!first) sb.Append (",");
				sb.Append (at.ToString ());
			}
			sb.Append (")");
			TokenName name = new TokenName (t, sb.ToString ());
			decldel        = new TokenDeclSDTypeDelegate (name);
			decldel.SetRetArgTypes (retType, argTypes);
			tokenScript.sdSrcTypesAdd (name.val, decldel);
			this.decl = decldel;
		}

		public override Type ToSysType ()
		{
			return decl.GetSysType ();
		}

		public override bool IsAssignableFrom (TokenType src)
		{
			if (!(src is TokenTypeSDTypeDelegate)) return false;
			TokenTypeSDTypeDelegate sd = (TokenTypeSDTypeDelegate)src;
			return this.decl.GetSysType () == sd.decl.GetSysType ();
		}

		public override string ToString ()
		{
			return decl.longName.val;
		}

		/**
		 * @brief Assign slots in the gblObjects[] array because we have to typecast out in any case.
		 *        Likewise with the sdtcObjects[] array.
		 */
		public override void AssignGlobalVarSlot (TokenDeclVar declVar, ScriptObjCode scriptObjCode)
		{
			declVar.vTableArray = gblObjectsFieldInfo;
			declVar.vTableIndex = scriptObjCode.numGblObjects ++;
		}
		public override void AssignSDTClassFieldSlot (TokenDeclVar declVar, TokenDeclSDTypeClass sdtClass)
		{
			declVar.vTableArray = sdtcObjectsFieldInfo;
			declVar.vTableIndex = sdtClass.numInstObjects ++;
		}

		/**
		 * @brief create delegate reference token for inline functions.
		 */
		public TokenTypeSDTypeDelegate (TokenType retType, TokenType[] argTypes) : base (null)
		{
			this.decl = TokenDeclSDTypeDelegate.CreateInline (retType, argTypes);
		}

		// debugging
		public override void DebString (StringBuilder sb)
		{
			decl.DebString (sb);

			if ((this.genArgs != null) && (this.genArgs.Length > 0)) {
				sb.Append (" with ");
				for (int i = 0; i < this.genArgs.Length; i ++) {
					if (i > 0) sb.Append (',');
					this.genArgs[i].DebString (sb);
				}
			}
		}
	}

	/**
	 * @brief These are the T inside the body of 'class List<T> { ... T x; ... }'
	 *        (and the extends/inherits list as well).
	 *        For delegates, they are found in the return and argument types.
	 */
	public class TokenTypeSDTypeGenParam : TokenTypeSDType {
		public TokenDeclSDTypeGenParam decl;

		public TokenTypeSDTypeGenParam (Token t, TokenDeclSDTypeGenParam decl) : base (t)
		{
			this.decl = decl;
		}
		public override TokenDeclSDType GetDecl ()
		{
			return decl;
		}
		public override Type ToSysType ()
		{
			throw new Exception ("not yet implemented");
		}
		public override bool IsAssignableFrom (TokenType src)
		{
			throw new Exception ("not yet implemented");
		}

		/**
		 * @brief Something wants to know the instantiated type.
		 * @param genArgs = list of generic instantiation argument types
		 *                  eg, if we are getting the type of something in 'Dictionary<T,U>'
		 *                  this = 'T' or 'U' and genArgs[0] = 'string', genArgs[1] = 'integer'
		 * @returns entry from genArgs[]
		 * Note: genArgs[] should always hold concrete types, never another TokenTypeSDTypeGenParam.
		 */
		public override TokenType ResolveGenParam (TokenType[] genArgs)
		{
			TokenType t = genArgs[decl.index];
			if (t is TokenTypeSDTypeGenParam) throw new Exception ("genArgs[] contains a TokenTypeSDTypeGenParam");
			return t;
		}

		// debugging
		public override void DebString (StringBuilder sb)
		{
			decl.DebString (sb);
		}
	}

	public class TokenTypeSDTypeInterface : TokenTypeSDType {
		public TokenDeclSDTypeInterface decl;
		public TokenTypeSDTypeInterface (Token t, TokenDeclSDTypeInterface decl) : base (t)
		{
			this.decl = decl;
		}
		public override TokenDeclSDType GetDecl ()
		{
			return decl;
		}

		public override string ToString ()
		{
			return decl.longName.val;
		}
		public override Type ToSysType ()
		{
			return typeof (Delegate[]);
		}
		public override bool IsAssignableFrom (TokenType src)
		{
			if (src is TokenTypeSDTypeInterface) {
				return this.decl == ((TokenTypeSDTypeInterface)src).decl;
			}
			if (src is TokenTypeSDTypeClass) {
				TokenDeclSDTypeClass sd = ((TokenTypeSDTypeClass)src).decl;
				return sd.implements.Contains (this.decl);
			}
			return false;
		}

		// debugging
		public override void DebString (StringBuilder sb)
		{
			decl.DebString (sb);

			if ((this.genArgs != null) && (this.genArgs.Length > 0)) {
				sb.Append (" with ");
				for (int i = 0; i < this.genArgs.Length; i ++) {
					if (i > 0) sb.Append (',');
					this.genArgs[i].DebString (sb);
				}
			}
		}
	}

	/**
	 * @brief function argument list declaration
	 */
	public class TokenArgDecl : Token
	{
		public VarDict varDict = new VarDict ();

		public TokenArgDecl (Token original) : base (original) { }

		public bool AddArg (TokenType type, TokenName name)
		{
			TokenDeclVar var = new TokenDeclVar (name, null, null);
			var.name = name;
			var.type = type;
			var.vTableIndex = varDict.Count;
			return varDict.AddEntry (var);
		}

		/**
		 * @brief Get an array of the argument types.
		 */
		private TokenType[] _types;
		public TokenType[] types {
			get {
				if (_types == null) {
					_types = new TokenType[varDict.Count];
					foreach (TokenDeclVar var in varDict) {
						_types[var.vTableIndex] = var.type;
					}
				}
				return _types;
			}
		}

		/**
		 * @brief Access the arguments as an array of variables.
		 */
		private TokenDeclVar[] _vars;
		public TokenDeclVar[] vars {
			get {
				if (_vars == null) {
					_vars = new TokenDeclVar[varDict.Count];
					foreach (TokenDeclVar var in varDict) {
						_vars[var.vTableIndex] = var;
					}
				}
				return _vars;
			}
		}

		/**
		 * @brief Get argument signature string, eg, "(list,vector,integer)"
		 */
		private string argSig = null;
		public string GetArgSig ()
		{
			if (argSig == null) {
				argSig = ScriptCodeGen.ArgSigString (types);
			}
			return argSig;
		}
	}

	/**
	 * @brief encapsulate a state declaration in a single token
	 */
	public class TokenDeclState : Token {

		public TokenName name;  // null for default state
		public TokenStateBody body;

		public TokenDeclState (Token original) : base (original) { }
	}

	/**
	 * @brief encapsulate the declaration of a field/function/method/property/variable.
	 */

	public enum Triviality {  // function triviality: has no loops and doesn't call anything that has loops
	                          // such a function does not need all the CheckRun() and stack serialization stuff
		unknown,   // function's Triviality unknown as of yet
		           // - it does not have any loops or backward gotos
		           // - nothing it calls is known to be complex
		trivial,   // function known to be trivial
		           // - it does not have any loops or backward gotos
		           // - everything it calls is known to be trivial
		complex,   // function known to be complex
		           // - it has loops or backward gotos
		           // - something it calls is known to be complex
		analyzing  // triviality is being analyzed (used to detect recursive loops)
	};

	public class TokenDeclVar : Token {
		public TokenName name;                 // vars: name; funcs: bare name, ie, no signature
		public TokenRVal init;                 // vars: null if none; funcs: null
		public bool constant;                  // vars: 'constant'; funcs: false
		public uint sdtFlags;                  // SDT_<*> flags

		public CompValu location;              // used by codegen to keep track of location
		public FieldInfo vTableArray;
		public int vTableIndex = -1;           // local vars: not used (-1)
		                                       // arg vars: index in the arg list
		                                       // global vars: which slot in gbl<Type>s[] array it is stored
		                                       // instance vars: which slot in inst<Types>s[] array it is stored
		                                       // static vars: which slot in gbl<Type>s[] array it is stored
		                                       // global funcs: not used (-1)
		                                       // virt funcs: which slot in vTable[] array it is stored
		                                       // instance func: not used (-1)

		public TokenDeclVar heapTracker;       // shadow variable that keeps track of this var's heap usage
		                                       // ... or null if not necessary

		public TokenScript tokenScript;        // what script this function is part of
		public TokenDeclSDTypeClass sdtClass;  // null: script global member
		                                       // else: member is part of this script-defined type
		public TokenDeclVar getProp;           // property get function
		public TokenDeclVar setProp;           // property set function

		// function-only data:

		public TokenType retType;              // vars: null; funcs: TokenTypeVoid if void
		public TokenArgDecl argDecl;           // vars: null; funcs: argument list prototypes
		public TokenStmtBlock body;            // vars: null; funcs: statements (null iff abstract)
		public Dictionary<string, TokenStmtLabel> labels = new Dictionary<string, TokenStmtLabel> ();
		                                       // all labels defined in the function
		public LinkedList<TokenDeclVar> localVars = new LinkedList<TokenDeclVar> ();
		                                       // all local variables declared by this function
		                                       // - doesn't include argument variables
		public TokenIntfImpl implements;       // if script-defined type method, what interface method(s) this func implements
		public TokenRValCall baseCtorCall;     // if script-defined type constructor, call to base constructor, if any
		public Triviality triviality = Triviality.unknown;
		                                       // vars: unknown (not used for any thing); funcs: unknown/trivial/complex
		public LinkedList<TokenRValCall> unknownTrivialityCalls = new LinkedList<TokenRValCall> ();
		                                       // reduction puts all calls here
		                                       // compilation sorts it all out

		public ScriptMyILGen ilGen;            // codegen stores emitted code here

		/**
		 * @brief Set up a variable declaration token.
		 * @param original = original source token that triggered definition
		 *                   (for error messages)
		 * @param func = null: global variable
		 *               else: local to the given function
		 */
		public TokenDeclVar (Token original, TokenDeclVar func, TokenScript ts) : base (original)
		{
			if (func != null) {
				func.localVars.AddLast (this);
			}
			tokenScript = ts;
		}

		/**
		 * @brief Get/Set overall type
		 *        For vars, this is the type of the location
		 *        For funcs, this is the delegate type
		 */
		private TokenType _type;
		public TokenType type {
			get {
				if (_type == null) {
					GetDelType ();
				}
				return _type;
			}
			set {
				_type = value;
			}
		}

		/**
		 * @brief Full name: <fulltype>.<name>(<argsig>)
		 *        (<argsig>) missing for fields/variables
		 *        <fulltype>. missing for top-level functions/variables
		 */
		public string fullName {
			get {
				if (sdtClass == null) {
					if (retType == null) return name.val;
					return funcNameSig.val;
				}
				string ln = sdtClass.longName.val;
				if (retType == null) return ln + "." + name.val;
				return ln + "." + funcNameSig.val;
			}
		}

		/**
		 * @brief See if reading or writing the variable is trivial.
		 *        Note that for functions, this is reading the function itself, 
		 *        as in 'someDelegate = SomeFunction;', not calling it as such.
		 *        The triviality of actually calling the function is IsFuncTrivial().
		 */
		public bool IsVarTrivial (ScriptCodeGen scg)
		{
			// reading or writing a property involves a function call however
			// so we need to check the triviality of the property functions
			if ((getProp != null) && !getProp.IsFuncTrivial (scg)) return false;
			if ((setProp != null) && !setProp.IsFuncTrivial (scg)) return false;

			// otherwise for variables it is a trivial access
			// and likewise for getting a delegate that points to a function
			return true;
		}

		/***************************\
		 *  FUNCTION-only methods  *
		\***************************/

		private TokenName _funcNameSig;  // vars: null; funcs: function name including argumet signature, eg, "PrintStuff(list,string)"
		public TokenName funcNameSig {
			get {
				return _funcNameSig;
			}
			set {
				_funcNameSig = value;
				int i = value.val.IndexOf ('(');
				name = new TokenName (value, value.val.Substring (0, i));
			}
		}

		/**
		 * @brief The bare function name, ie, without any signature info
		 */
		public string GetSimpleName ()
		{
			return name.val;
		}

		/**
		 * @brief The function name as it appears in the object code,
		 *        ie, including "__fun_", script-defined type name if any,
		 *        bare function name and argument signature, 
		 *        eg, "__fun_MyClass.PrintStuff(string)"
		 */
		public string GetObjCodeName ()
		{
                        string objCodeName  = "__fun_";
                        if (sdtClass != null) {
                                objCodeName += sdtClass.longName.val + ".";
                        }
                        objCodeName += funcNameSig.val;
			return objCodeName;
		}

		/**
		 * @brief Get delegate type.
		 *        This is the function's script-visible type,
		 *        It includes return type and all script-visible argument types.
		 * @returns null for vars; else delegate type for funcs
		 */
		public TokenTypeSDTypeDelegate GetDelType ()
		{
			if (argDecl == null) return null;
			if (_type == null) {
				if (tokenScript == null) {
					// used during startup to define inline function delegate types
					_type = new TokenTypeSDTypeDelegate (retType, argDecl.types);
				} else {
					// used for normal script processing
					_type = new TokenTypeSDTypeDelegate (this, retType, argDecl.types, tokenScript);
				}
			}
			if (!(_type is TokenTypeSDTypeDelegate)) return null;
			return (TokenTypeSDTypeDelegate)_type;
		}

		/**
		 * @brief See if the function's code itself is trivial or not.
		 *        If it contains any loops (calls to CheckRun()), it is not trivial.
		 *        If it calls anything that is not trivial, it is not trivial.
		 *        Otherwise it is trivial.
		 */
		public bool IsFuncTrivial (ScriptCodeGen scg)
		{
			if (retType == null) throw new Exception ("can't call a non-function");

			/*
			 * All virtual functions are non-trivial because although a particular 
			 * one might be trivial, it might be overidden with a non-trivial one.
			 */
			if ((sdtFlags & (ScriptReduce.SDT_ABSTRACT | ScriptReduce.SDT_OVERRIDE | 
			                 ScriptReduce.SDT_VIRTUAL)) != 0) {
				return false;
			}

			/*
			 * Check the triviality status of the function.
			 */
			switch (triviality) {

				/*
				 * Don't yet know if it is trivial.
				 * We know at this point it doesn't have any direct looping.
				 * But if it calls something that has loops, it isn't trivial.
				 * Otherwise it is trivial.
				 */
				case Triviality.unknown: {

					/*
					 * Mark that we are analyzing this function now.  So if there are 
					 * any recursive call loops, that will show that the function is 
					 * non-trivial and the analysis will terminate at that point.
					 */
					triviality = Triviality.analyzing;

					/*
					 * Check out everything else this function calls.  If any say they 
					 * aren't trivial, then we say this function isn't trivial.
					 */
					foreach (TokenRValCall call in unknownTrivialityCalls) {
						if (!call.IsRValTrivial (scg, null)) {
							triviality = Triviality.complex;
							return false;
						}
					}

					/*
					 * All functions called by this function are trivial, and this 
					 * function's code doesn't have any loops, so we can mark this 
					 * function as being trivial.
					 */
					triviality = Triviality.trivial;
					return true;
				}

				/*
				 * We already know that it is trivial.
				 */
				case Triviality.trivial: {
					return true;
				}

				/*
				 * We either know it is complex or are trying to analyze it already.
				 * If we are already analyzing it, it means it has a recursive loop
				 * and we assume those are non-trivial.
				 */
				default: return false;
			}
		}
	}

	/**
	 * @brief Indicates an interface type.method that is implemented by the function
	 */
	public class TokenIntfImpl : Token {
		public TokenTypeSDTypeInterface intfType;
		public TokenName methName;  // simple name, no arg signature
		public TokenIntfImpl (TokenTypeSDTypeInterface intfType, TokenName methName) : base (intfType)
		{
			this.intfType = intfType;
			this.methName = methName;
		}
	}

	/**
	 * @brief any expression that can go on left side of an "="
	 */
	public abstract class TokenLVal : TokenRVal {
		public TokenLVal (Token original) : base (original) { }
		public abstract override TokenType GetRValType (ScriptCodeGen scg, TokenType[] argsig);
		public abstract override bool IsRValTrivial (ScriptCodeGen scg, TokenType[] argsig);
	}

	/**
	 * @brief an element of an array is an L-value
	 */
	public class TokenLValArEle : TokenLVal {
		public TokenRVal baseRVal;
		public TokenRVal subRVal;

		public TokenLValArEle (Token original) : base (original) { }

		public override TokenType GetRValType (ScriptCodeGen scg, TokenType[] argsig)
		{
			return new TokenTypeObject (subRVal);
		}

		public override bool IsRValTrivial (ScriptCodeGen scg, TokenType[] argsig)
		{
			return baseRVal.IsRValTrivial (scg, null) && subRVal.IsRValTrivial (scg, null);
		}
	}

	/**
	 * @brief a field within an L-value struct is an L-value
	 */
	public class TokenLValIField : TokenLVal {
		public TokenRVal baseRVal;
		public TokenName fieldName;

		public TokenLValIField (Token original) : base (original) { }

		public override TokenType GetRValType (ScriptCodeGen scg, TokenType[] argsig)
		{
			TokenType baseType = baseRVal.GetRValType (scg, null);
			if (baseType is TokenTypeSDTypeClass) {
				TokenDeclVar var = scg.FindThisMember ((TokenTypeSDTypeClass)baseType, fieldName, argsig);
				if (var != null) return var.type;
			}
			if (baseType is TokenTypeArray) {
				return XMR_Array.GetRValType (fieldName);
			}
			if ((baseType is TokenTypeRot) || (baseType is TokenTypeVec)) {
				return new TokenTypeFloat (fieldName);
			}
			scg.ErrorMsg (fieldName, "unknown member of " + baseType.ToString ());
			return new TokenTypeVoid (fieldName);
		}

		public override bool IsRValTrivial (ScriptCodeGen scg, TokenType[] argsig)
		{
			/*
			 * If getting pointer to instance isn't trivial, then accessing the member isn't trivial either.
			 */
			if (!baseRVal.IsRValTrivial (scg, null)) return false;

			/*
			 * Accessing a member of a class depends on the member.
			 * In the case of a method, this is accessing it as a delegate, not calling it, and 
			 * argsig simply serves as selecting which of possibly overloaded methods to select.
			 * The case of accessing a property, however, depends on the property implementation, 
			 * as there could be looping inside the property code.
			 */
			TokenType baseType = baseRVal.GetRValType (scg, null);
			if (baseType is TokenTypeSDTypeClass) {
				TokenDeclVar var = scg.FindThisMember ((TokenTypeSDTypeClass)baseType, fieldName, argsig);
				return (var != null) && var.IsVarTrivial (scg);
			}

			/*
			 * Accessing the members of anything else (arrays, rotations, vectors) is always trivial.
			 */
			return true;
		}

		/**
		 * @brief Check to see if the case of calling an instance method of some object is trivial.
		 * @param scg = script making the call
		 * @param argsig = argument types of the call (used to select among overloads)
		 * @returns true iff we can tell at compile time that the call will always call a trivial method
		 */
		public override bool IsCallTrivial (ScriptCodeGen scg, TokenType[] argsig)
		{
			/*
			 * If getting pointer to instance isn't trivial, then calling the method isn't trivial either.
			 */
			if (!baseRVal.IsRValTrivial (scg, null)) return false;

			/*
			 * Calling a method of a class depends on the method.
			 */
			TokenType baseType = baseRVal.GetRValType (scg, null);
			if (baseType is TokenTypeSDTypeClass) {
				TokenDeclVar var = scg.FindThisMember ((TokenTypeSDTypeClass)baseType, fieldName, argsig);
				return (var != null) && var.IsFuncTrivial (scg);
			}

			/*
			 * Calling via a pointer to an interface instance is never trivial.
			 * (It is really a pointer to an array of delegates).
			 * We can't tell for this call site whether the actual method being called is trivial or not,
			 * so we have to assume it isn't.
			 * ??? We could theoretically check to see if *all* implementations of this method of 
			 *     this interface are trivial, then we could conclude that this call is trivial.
			 */
			if (baseType is TokenTypeSDTypeInterface) return false;

			/*
			 * Calling a method of anything else (arrays, rotations, vectors) is always trivial.
			 * Even methods of delegates, such as ".GetArgTypes()" that we may someday do is trivial.
			 */
			return true;
		}

		// debugging
		public override void DebString (StringBuilder sb)
		{
			sb.Append (baseRVal);
			sb.Append (".");
			sb.Append (fieldName.val);
		}
	}

	/**
	 * @brief a name is being used as an L-value
	 */
	public class TokenLValName : TokenLVal {
		public TokenName name;
		public VarDict stack;

		public TokenLValName (TokenName name, TokenScript tokenScript) : base (name)
		{
			this.name  = name;
			this.stack = tokenScript.variablesStack;
		}

		public override TokenType GetRValType (ScriptCodeGen scg, TokenType[] argsig)
		{
			TokenDeclVar var = scg.FindNamedVar (this, argsig);
			if (var != null) return var.type;
			scg.ErrorMsg (name, "undefined name " + name.val + ScriptCodeGen.ArgSigString (argsig));
			return new TokenTypeVoid (name);
		}

		public override bool IsRValTrivial (ScriptCodeGen scg, TokenType[] argsig)
		{
			TokenDeclVar var = scg.FindNamedVar (this, argsig);
			return (var != null) && var.IsVarTrivial (scg);
		}

		/**
		 * @brief Check to see if the case of calling a global method is trivial.
		 * @param scg = script making the call
		 * @param argsig = argument types of the call (used to select among overloads)
		 * @returns true iff we can tell at compile time that the call will always call a trivial method
		 */
		public override bool IsCallTrivial (ScriptCodeGen scg, TokenType[] argsig)
		{
			TokenDeclVar var = scg.FindNamedVar (this, argsig);
			return (var != null) && var.IsFuncTrivial (scg);
		}
	}

	/**
	 * @brief a static field within a struct is an L-value
	 */
	public class TokenLValSField : TokenLVal {
		public TokenType baseType;
		public TokenName fieldName;

		public TokenLValSField (Token original) : base (original) { }

		public override TokenType GetRValType (ScriptCodeGen scg, TokenType[] argsig)
		{
			if (baseType is TokenTypeSDTypeClass) {
				TokenDeclVar var = scg.FindThisMember ((TokenTypeSDTypeClass)baseType, fieldName, argsig);
				if (var != null) return var.type;
			}
			scg.ErrorMsg (fieldName, "unknown member of " + baseType.ToString ());
			return new TokenTypeVoid (fieldName);
		}

		public override bool IsRValTrivial (ScriptCodeGen scg, TokenType[] argsig)
		{
			/*
			 * Accessing a member of a class depends on the member.
			 * In the case of a method, this is accessing it as a delegate, not calling it, and 
			 * argsig simply serves as selecting which of possibly overloaded methods to select.
			 * The case of accessing a property, however, depends on the property implementation, 
			 * as there could be looping inside the property code.
			 */
			if (baseType is TokenTypeSDTypeClass) {
				TokenDeclVar var = scg.FindThisMember ((TokenTypeSDTypeClass)baseType, fieldName, argsig);
				return (var != null) && var.IsVarTrivial (scg);
			}

			/*
			 * Accessing the fields/methods/properties of anything else (arrays, rotations, vectors) is always trivial.
			 */
			return true;
		}

		/**
		 * @brief Check to see if the case of calling a class' static method is trivial.
		 * @param scg = script making the call
		 * @param argsig = argument types of the call (used to select among overloads)
		 * @returns true iff we can tell at compile time that the call will always call a trivial method
		 */
		public override bool IsCallTrivial (ScriptCodeGen scg, TokenType[] argsig)
		{
			/*
			 * Calling a static method of a class depends on the method.
			 */
			if (baseType is TokenTypeSDTypeClass) {
				TokenDeclVar var = scg.FindThisMember ((TokenTypeSDTypeClass)baseType, fieldName, argsig);
				return (var != null) && var.IsFuncTrivial (scg);
			}

			/*
			 * Calling a static method of anything else (arrays, rotations, vectors) is always trivial.
			 */
			return true;
		}
	}

	/**
	 * @brief any expression that can go on right side of "="
	 */
	public delegate TokenRVal TCCLookup (TokenRVal rVal, ref bool didOne);
	public abstract class TokenRVal : Token {
		public bool sideEffects = false;  // the value (or some sub-value) has side effects
		                                  // - constants are always false
		                                  // - we assume calls always have side effects
		                                  // - post increment/decrement are always true
		                                  // - any assignment operator (=, +=, etc) always true
		                                  // - all others inherit from their operands
		public TokenRVal (Token original) : base (original) { }

		/**
		 * @brief Tell us the type of the expression.
		 */
		public abstract TokenType GetRValType (ScriptCodeGen scg, TokenType[] argsig);

		/**
		 * @brief Tell us if reading and writing the value is trivial.
		 *
		 * @param scg = script code generator of script making the access
		 * @param argsig = argument types of the call (used to select among overloads)
		 * @returns true: we can tell at compile time that reading/writing this location
		 *                will always be trivial (no looping or CheckRun() calls possible).
		 *         false: otherwise
		 */
		public abstract bool IsRValTrivial (ScriptCodeGen scg, TokenType[] argsig);

		/**
		 * @brief Tell us if calling the method is trivial.
		 *
		 *        This is the default implementation that returns false.
		 *        It is only used if the location is holding a delegate
		 *        and the method that the delegate is pointing to is being
		 *        called.  Since we can't tell if the actual runtime method
		 *        is trivial or not, we assume it isn't.
		 *
		 *        For the more usual ways of calling functions, see the
		 *        various overrides of IsCallTrivial().
		 *
		 * @param scg = script code generator of script making the call
		 * @param argsig = argument types of the call (used to select among overloads)
		 * @returns true: we can tell at compile time that this call will always
		 *                be to a trivial function/method (no looping or CheckRun() 
		 *                calls possible).
		 *         false: otherwise
		 */
		public virtual bool IsCallTrivial (ScriptCodeGen scg, TokenType[] argsig)
		{
			return false;
		}

		/**
		 * @brief If the result of the expression is a constant,
		 *        create a TokenRValConst equivalent, set didOne, and return that.
		 *        Otherwise, just return the original without changing didOne.
		 */
		public virtual TokenRVal TryComputeConstant (TCCLookup lookup, ref bool didOne)
		{
			return lookup (this, ref didOne);
		}
	}

	/**
	 * @brief a postfix operator and corresponding L-value
	 */
	public class TokenRValAsnPost : TokenRVal {
		public TokenLVal lVal;
		public Token postfix;

		public TokenRValAsnPost (Token original) : base (original) {
			sideEffects = true;
		}

		public override TokenType GetRValType (ScriptCodeGen scg, TokenType[] argsig)
		{
			return lVal.GetRValType (scg, argsig);
		}

		public override bool IsRValTrivial (ScriptCodeGen scg, TokenType[] argsig)
		{
			return lVal.IsRValTrivial (scg, null);
		}
	}

	/**
	 * @brief a prefix operator and corresponding L-value
	 */
	public class TokenRValAsnPre : TokenRVal {
		public Token prefix;
		public TokenLVal lVal;

		public TokenRValAsnPre (Token original) : base (original) {
			sideEffects = true;
		}
		public override TokenType GetRValType (ScriptCodeGen scg, TokenType[] argsig)
		{
			return lVal.GetRValType (scg, argsig);
		}

		public override bool IsRValTrivial (ScriptCodeGen scg, TokenType[] argsig)
		{
			return lVal.IsRValTrivial (scg, null);
		}
	}

	/**
	 * @brief 'base.' being used to reference a field/method of the extended class.
	 */
	public class TokenRValBaseField : TokenRVal {
		public TokenName fieldName;
		private TokenDeclSDTypeClass thisClass;

		public TokenRValBaseField (Token original, TokenName fieldName, TokenDeclSDTypeClass thisClass) : base (original)
		{
			this.fieldName = fieldName;
			this.thisClass = thisClass;
		}

		public override TokenType GetRValType (ScriptCodeGen scg, TokenType[] argsig)
		{
			TokenDeclVar var = scg.FindThisMember (thisClass.extends, fieldName, argsig);
			if (var != null) return var.type;
			scg.ErrorMsg (fieldName, "unknown member for " + thisClass.extends.ToString ());
			return new TokenTypeVoid (fieldName);
		}

		public override bool IsRValTrivial (ScriptCodeGen scg, TokenType[] argsig)
		{
			TokenDeclVar var = scg.FindThisMember (thisClass.extends, fieldName, argsig);
			return (var != null) && var.IsVarTrivial (scg);
		}

		public override bool IsCallTrivial (ScriptCodeGen scg, TokenType[] argsig)
		{
			TokenDeclVar var = scg.FindThisMember (thisClass.extends, fieldName, argsig);
			return (var != null) && var.IsFuncTrivial (scg);
		}
	}

	/**
	 * @brief calling a function or method, ie, may have side-effects
	 */
	public class TokenRValCall : TokenRVal {

		public TokenRVal meth;  // points to the function to be called
		                        // - might be a reference to a global function (TokenLValName)
		                        // - or an instance method of a class (TokenLValIField)
		                        // - or a static method of a class (TokenLValSField)
		                        // - or a delegate stored in a variable (assumption for anything else)
		public TokenRVal args;  // null-terminated TokenRVal list
		public int nArgs;       // number of elements in args

		public TokenRValCall (Token original) : base (original)
		{
			sideEffects = true;
		}

		private TokenType[] myArgSig;

		/**
		 * @brief The type of a call is the type of the return value.
		 */
		public override TokenType GetRValType (ScriptCodeGen scg, TokenType[] argsig)
		{
			/*
			 * Build type signature so we select correct overloaded function.
			 */
			if (myArgSig == null) {
				myArgSig = new TokenType[nArgs];
				int i = 0;
				for (Token t = args; t != null; t = t.nextToken) {
					myArgSig[i++] = ((TokenRVal)t).GetRValType (scg, null);
				}
			}

			/*
			 * Get the type of the method itself.  This should get us a delegate type.
			 */
			TokenType delType = meth.GetRValType (scg, myArgSig);
			if (!(delType is TokenTypeSDTypeDelegate)) {
				scg.ErrorMsg (meth, "must be function or method");
				return new TokenTypeVoid (meth);
			}

			/*
			 * Get the return type from the delegate type.
			 */
			return ((TokenTypeSDTypeDelegate)delType).decl.GetRetType ();
		}

		/**
		 * @brief See if the call to the function/method is trivial.
		 *        It is trivial if all the argument computations are trivial and
		 *        the function is not being called via virtual table or delegate
		 *        and the function body is trivial.
		 */
		public override bool IsRValTrivial (ScriptCodeGen scg, TokenType[] argsig)
		{
			/*
			 * Build type signature so we select correct overloaded function.
			 */
			if (myArgSig == null) {
				myArgSig = new TokenType[nArgs];
				int i = 0;
				for (Token t = args; t != null; t = t.nextToken) {
					myArgSig[i++] = ((TokenRVal)t).GetRValType (scg, null);
				}
			}

			/*
			 * Make sure all arguments can be computed trivially.
			 */
			for (Token t = args; t != null; t = t.nextToken) {
				if (!((TokenRVal)t).IsRValTrivial (scg, null)) return false;
			}

			/*
			 * See if the function call itself and the function body are trivial.
			 */
			return meth.IsCallTrivial (scg, myArgSig);
		}

		// debugging
		public override void DebString (StringBuilder sb)
		{
			meth.DebString (sb);
			sb.Append (" (");
			bool first = true;
			for (Token t = args; t != null; t = t.nextToken) {
				if (!first) sb.Append (", ");
				t.DebString (sb);
			}
			sb.Append (")");
		}
	}

	/**
	 * @brief encapsulates a typecast, ie, (type)
	 */
	public class TokenRValCast : TokenRVal {
		public TokenType castTo;
		public TokenRVal rVal;

		public TokenRValCast (TokenType type, TokenRVal value) : base (type)
		{
			castTo = type;
			rVal   = value;
			sideEffects = value.sideEffects;
		}

		public override TokenType GetRValType (ScriptCodeGen scg, TokenType[] argsig)
		{
			return castTo;
		}

		public override bool IsRValTrivial (ScriptCodeGen scg, TokenType[] argsig)
		{
			argsig = null;
			if (castTo is TokenTypeSDTypeDelegate) {
				argsig = ((TokenTypeSDTypeDelegate)castTo).decl.GetArgTypes ();
			}
			return rVal.IsRValTrivial (scg, argsig);
		}

		/**
		 * @brief If operand is constant, maybe we can say the whole thing is a constant.
		 */
		public override TokenRVal TryComputeConstant (TCCLookup lookup, ref bool didOne)
		{
			rVal = rVal.TryComputeConstant (lookup, ref didOne);
			if (rVal is TokenRValConst) {
				try {
					object val = ((TokenRValConst)rVal).val;
					if (castTo is TokenTypeFloat) {
						if (val is int)         val = (SCRIPTFLOAT)(int)val;
						if (val is string)      val = new LSL_Float ((string)val).value;
					}
					if (castTo is TokenTypeInt) {
						if (val is SCRIPTFLOAT) val = (int)(SCRIPTFLOAT)val;
						if (val is string)      val = new LSL_Integer ((string)val).value;
					}
					if (castTo is TokenTypeStr) {
						if (val is SCRIPTFLOAT) val = TypeCast.FloatToString ((SCRIPTFLOAT)val);
						if (val is int)         val = TypeCast.IntegerToString ((int)val);
					}
					TokenRVal rValConst = new TokenRValConst (castTo, val);
					didOne = true;
					return rValConst;
				} catch {
				}
			}
			return this;
		}
	}

	/**
	 * @brief all constants supposed to end up here
	 */
	public enum TokenRValConstType : byte { FLOAT = 0, INT = 1, STRING = 2 };
	public class TokenRValConst : TokenRVal {
		public object val;	// always a system type (int, SCRIPTFLOAT, string)
		public TokenRValConstType type;
		public TokenType tokType;

		public TokenRValConst (Token original, object value) : base (original) {
			val = value;
			     if (val is int)         { type = TokenRValConstType.INT;    tokType = new TokenTypeInt   (this); }
			else if (val is SCRIPTFLOAT) { type = TokenRValConstType.FLOAT;  tokType = new TokenTypeFloat (this); }
			else if (val is string)      { type = TokenRValConstType.STRING; tokType = new TokenTypeStr   (this); }
			else throw new Exception ("invalid constant type " + val.GetType ());
		}

		public override TokenType GetRValType (ScriptCodeGen scg, TokenType[] argsig)
		{
			return tokType;
		}

		public override bool IsRValTrivial (ScriptCodeGen scg, TokenType[] argsig)
		{
			return true;
		}

		public CompValu GetCompValu ()
		{
			switch (type) {
				case TokenRValConstType.FLOAT:  { return new CompValuFloat   (tokType, (SCRIPTFLOAT)val); }
				case TokenRValConstType.INT:    { return new CompValuInteger (tokType, (int)val);         }
				case TokenRValConstType.STRING: { return new CompValuString  (tokType, (string)val);      }
				default: throw new Exception ("unknown type");
			}
		}

		public override TokenRVal TryComputeConstant (TCCLookup lookup, ref bool didOne)
		{
			// gotta end somewhere
			return this;
		}
	}

	/**
	 * @brief encapsulation of <rval> is <typeexp>
	 */
	public class TokenRValIsType : TokenRVal {
		public TokenRVal    rValExp;
		public TokenTypeExp typeExp;

		public TokenRValIsType (Token original) : base (original) { }

		public override TokenType GetRValType (ScriptCodeGen scg, TokenType[] argsig)
		{
			return new TokenTypeBool (rValExp);
		}

		public override bool IsRValTrivial (ScriptCodeGen scg, TokenType[] argsig)
		{
			return rValExp.IsRValTrivial (scg, argsig);
		}
	}

	/**
	 * @brief an R-value enclosed in brackets is an LSLList
	 */
	public class TokenRValList : TokenRVal {

		public TokenRVal rVal;  // null-terminated list of TokenRVal objects
		public int nItems;

		public TokenRValList (Token original) : base (original) { }

		public override TokenType GetRValType (ScriptCodeGen scg, TokenType[] argsig)
		{
			return new TokenTypeList (rVal);
		}

		public override bool IsRValTrivial (ScriptCodeGen scg, TokenType[] argsig)
		{
			for (Token t = rVal; t != null; t = t.nextToken) {
				if (!((TokenRVal)t).IsRValTrivial (scg, null)) return false;
			}
			return true;
		}
	}

	/**
	 * @brief a binary operator and its two operands
	 */
	public class TokenRValOpBin : TokenRVal {
		public TokenRVal rValLeft;
		public TokenKw opcode;
		public TokenRVal rValRight;

		public TokenRValOpBin (TokenRVal left, TokenKw op, TokenRVal right) : base (op)
		{
			rValLeft  = left;
			opcode    = op;
			rValRight = right;

			CalcSideEffects();
		}

		public override TokenType GetRValType (ScriptCodeGen scg, TokenType[] argsig)
		{
			string key = rValLeft.GetRValType (scg, argsig).ToString () + opcode.ToString () + 
			             rValRight.GetRValType (scg, argsig).ToString ();

			BinOpStr binOpStr;
			if (BinOpStr.defined.TryGetValue (key, out binOpStr)) {
				return TokenType.FromSysType (opcode, binOpStr.outtype);
			}
			scg.ErrorMsg (opcode, "undefined operation " + key);
			return new TokenTypeVoid (opcode);
		}

		public override bool IsRValTrivial (ScriptCodeGen scg, TokenType[] argsig)
		{
			return rValLeft.IsRValTrivial (scg, null) && rValRight.IsRValTrivial (scg, null);
		}

		/**
		 * @brief If both operands are constants, maybe we can say the whole thing is a constant.
		 */
		public override TokenRVal TryComputeConstant (TCCLookup lookup, ref bool didOne)
		{
			rValLeft  = rValLeft.TryComputeConstant  (lookup, ref didOne);
			rValRight = rValRight.TryComputeConstant (lookup, ref didOne);
			if ((rValLeft is TokenRValConst) && (rValRight is TokenRValConst)) {
				try {
					object val = opcode.binOpConst (((TokenRValConst)rValLeft).val, 
					                                ((TokenRValConst)rValRight).val);
					TokenRVal rValConst = new TokenRValConst (opcode, val);
					didOne = true;
					return rValConst;
				} catch {
				}
			}
			return this;
		}

		private void CalcSideEffects()
		{
			sideEffects = rValLeft.sideEffects || rValRight.sideEffects;
			if (!sideEffects) {
				string opStr = opcode.ToString ();
				sideEffects = opStr.EndsWith ("=") && (opStr != ">=") && 
				              (opStr != "<=") && (opStr != "!=") && (opStr != "==");
			}
		}
	}

	/**
	 * @brief an unary operator and its one operand
	 */
	public class TokenRValOpUn : TokenRVal {
		public TokenKw opcode;
		public TokenRVal rVal;

		public TokenRValOpUn (TokenKw op, TokenRVal right) : base (op)
		{
			opcode      = op;
			rVal        = right;
			sideEffects = right.sideEffects;
		}

		public override TokenType GetRValType (ScriptCodeGen scg, TokenType[] argsig)
		{
			if (opcode is TokenKwExclam) return new TokenTypeInt (opcode);
			return rVal.GetRValType (scg, null);
		}

		public override bool IsRValTrivial (ScriptCodeGen scg, TokenType[] argsig)
		{
			return rVal.IsRValTrivial (scg, null);
		}

		/**
		 * @brief If operand is constant, maybe we can say the whole thing is a constant.
		 */
		public override TokenRVal TryComputeConstant (TCCLookup lookup, ref bool didOne)
		{
			rVal = rVal.TryComputeConstant (lookup, ref didOne);
			if (rVal is TokenRValConst) {
				try {
					object val = opcode.unOpConst (((TokenRValConst)rVal).val);
					TokenRVal rValConst = new TokenRValConst (opcode, val);
					didOne = true;
					return rValConst;
				} catch {
				}
			}
			return this;
		}

		/**
		 * @brief Serialization/Deserialization.
		 */
		public TokenRValOpUn (Token original) : base (original) { }
	}

	/**
	 * @brief an R-value enclosed in parentheses
	 */
	public class TokenRValParen : TokenRVal {

		public TokenRVal rVal;

		public TokenRValParen (Token original) : base (original) { }

		public override TokenType GetRValType (ScriptCodeGen scg, TokenType[] argsig)
		{
			// pass argsig through in this simple case, ie, let 
			// them do something like (llOwnerSay)("blabla...");
			return rVal.GetRValType (scg, argsig);
		}

		public override bool IsRValTrivial (ScriptCodeGen scg, TokenType[] argsig)
		{
			// pass argsig through in this simple case, ie, let 
			// them do something like (llOwnerSay)("blabla...");
			return rVal.IsRValTrivial (scg, argsig);
		}

		/**
		 * @brief If operand is constant, we can say the whole thing is a constant.
		 */
		public override TokenRVal TryComputeConstant (TCCLookup lookup, ref bool didOne)
		{
			rVal = rVal.TryComputeConstant (lookup, ref didOne);
			if (rVal is TokenRValConst) {
				didOne = true;
				return rVal;
			}
			return this;
		}
	}

	public class TokenRValRot : TokenRVal {

		public TokenRVal xRVal;
		public TokenRVal yRVal;
		public TokenRVal zRVal;
		public TokenRVal wRVal;

		public TokenRValRot (Token original) : base (original) { }

		public override TokenType GetRValType (ScriptCodeGen scg, TokenType[] argsig)
		{
			return new TokenTypeRot (xRVal);
		}

		public override bool IsRValTrivial (ScriptCodeGen scg, TokenType[] argsig)
		{
			return xRVal.IsRValTrivial (scg, null) && 
			       yRVal.IsRValTrivial (scg, null) && 
			       zRVal.IsRValTrivial (scg, null) && 
			       wRVal.IsRValTrivial (scg, null);
		}
	}

	/**
	 * @brief 'this' is being used as an rval inside an instance method.
	 */
	public class TokenRValThis : TokenRVal {
		public Token original;
		public TokenDeclSDTypeClass sdtClass;

		public TokenRValThis (Token original, TokenDeclSDTypeClass sdtClass) : base (original)
		{
			this.original = original;
			this.sdtClass = sdtClass;
		}

		public override TokenType GetRValType (ScriptCodeGen scg, TokenType[] argsig)
		{
			return sdtClass.MakeRefToken (original, null);
		}

		public override bool IsRValTrivial (ScriptCodeGen scg, TokenType[] argsig)
		{
			return true;  // ldarg.0/starg.0 can't possibly loop
		}

		// debugging
		public override void DebString (StringBuilder sb)
		{
			sb.Append ("this");
		}
	}

	/**
	 * @brief the 'undef' keyword is being used as a value in an expression.
	 *        It is the null object pointer and has type TokenTypeUndef.
	 */
	public class TokenRValUndef : TokenRVal {
		Token original;

		public TokenRValUndef (Token original) : base (original)
		{
			this.original = original;
		}

		public override TokenType GetRValType (ScriptCodeGen scg, TokenType[] argsig)
		{
			return new TokenTypeUndef (original);
		}

		public override bool IsRValTrivial (ScriptCodeGen scg, TokenType[] argsig)
		{
			return true;
		}
	}

	/**
	 * @brief put 3 RVals together as a Vector value.
	 */
	public class TokenRValVec : TokenRVal {

		public TokenRVal xRVal;
		public TokenRVal yRVal;
		public TokenRVal zRVal;

		public TokenRValVec (Token original) : base (original) { }

		public override TokenType GetRValType (ScriptCodeGen scg, TokenType[] argsig)
		{
			return new TokenTypeVec (xRVal);
		}

		public override bool IsRValTrivial (ScriptCodeGen scg, TokenType[] argsig)
		{
			return xRVal.IsRValTrivial (scg, null) && 
			       yRVal.IsRValTrivial (scg, null) && 
			       zRVal.IsRValTrivial (scg, null);
		}
	}
	
	/**
	 * @brief encapsulates the whole script in a single token
	 */
	public class TokenScript : Token {
		public int expiryDays = Int32.MaxValue;
		public TokenDeclState defaultState;
		public Dictionary<string, TokenDeclState> states = new Dictionary<string, TokenDeclState>  ();
		public VarDict variablesStack = new VarDict ();  // initial one is used for global functions and variables

		public TokenScript (Token original) : base (original) { }

		/*
		 * Handle variable definition stack.
		 * Generally a '{' pushes a new frame and a '}' pops the frame.
		 * Function parameters are pushed in an additional frame (just outside the body's { ... } block)
		 */
		public void PushVarFrame ()
		{
			PushVarFrame (new VarDict ());
		}
		public void PushVarFrame (VarDict newFrame)
		{
			newFrame.outerVarDict = variablesStack;
			variablesStack = newFrame;
		}
		public void PopVarFrame ()
		{
			variablesStack = variablesStack.outerVarDict;
		}
		public bool AddVarEntry (TokenDeclVar var)
		{
			return variablesStack.AddEntry (var);
		}

		/*
		 * Handle list of script-defined types.
		 */
		private Dictionary<string, TokenDeclSDType> sdSrcTypes = new Dictionary<string, TokenDeclSDType> ();
		private bool sdSrcTypesSealed = false;
		public void sdSrcTypesSeal ()
		{
			sdSrcTypesSealed = true;
		}
		public bool sdSrcTypesContainsKey (string key)
		{
			return sdSrcTypes.ContainsKey (key);
		}
		public bool sdSrcTypesTryGetValue (string key, out TokenDeclSDType value)
		{
			return sdSrcTypes.TryGetValue (key, out value);
		}
		public void sdSrcTypesAdd (string key, TokenDeclSDType value)
		{
			if (sdSrcTypesSealed) throw new Exception ("sdSrcTypes is sealed");
			sdSrcTypes.Add (key, value);
		}
		public void sdSrcTypesReplace (string key, TokenDeclSDType value)
		{
			if (sdSrcTypesSealed) throw new Exception ("sdSrcTypes is sealed");
			sdSrcTypes[key] = value;
		}
		public Dictionary<string, TokenDeclSDType>.ValueCollection sdSrcTypesValues
		{
			get {
				return sdSrcTypes.Values;
			}
		}
		public int sdSrcTypesCount
		{
			get {
				return sdSrcTypes.Count;
			}
		}
	}

	/**
	 * @brief state body declaration
	 */
	public class TokenStateBody : Token {

		public TokenDeclVar eventFuncs;

		public int index = -1;  // (codegen) row in ScriptHandlerEventTable (0=default)

		public TokenStateBody (Token original) : base (original) { }
	}

	/**
	 * @brief a single statement, such as ending on a semicolon or enclosed in braces
	 * TokenStmt includes the terminating semicolon or the enclosing braces
	 * Also includes @label: for jump targets.
	 * Also includes stray ; null statements.
	 */
	public class TokenStmt : Token {

		public TokenStmt (Token original) : base (original) { }
	}

	/**
	 * @brief a group of statements enclosed in braces
	 */
	public class TokenStmtBlock : TokenStmt {

		public Token statements;               // null-terminated list of statements, can also have TokenDeclVar's in here
		public TokenStmtBlock outerStmtBlock;  // next outer stmtBlock or null if top-level, ie, function definition
		public TokenDeclVar function;          // function it is part of
		public VarDict variables = new VarDict ();  // variables declared herein
		public bool isTry;                     // true iff it's a try statement block
		public bool isCatch;                   // true iff it's a catch statement block
		public bool isFinally;                 // true iff it's a finally statement block

		public TokenStmtBlock (Token original) : base (original) { }
	}

	/**
	 * @brief definition of branch target name
	 */
	public class TokenStmtLabel : TokenStmt {

		public TokenName name;        // the label's name
		public TokenStmtBlock block;  // which block it is defined in
		public bool hasBkwdRefs = false;

		public bool labelTagged;      // code gen: location of label
		public ScriptMyLabel labelStruct;

		public TokenStmtLabel (Token original) : base (original) { }
	}

	/**
	 * @brief those types of RVals with a semi-colon on the end
	 *        that are allowed to stand alone as statements
	 */
	public class TokenStmtRVal : TokenStmt {
		public TokenRVal rVal;

		public TokenStmtRVal (Token original) : base (original) { }
	}

	public class TokenStmtBreak : TokenStmt {
		public TokenStmtBreak (Token original) : base (original) { }
	}

	public class TokenStmtCont : TokenStmt {
		public TokenStmtCont (Token original) : base (original) { }
	}

	/**
	 * @brief "do" statement
	 */
	public class TokenStmtDo : TokenStmt {

		public TokenStmt bodyStmt;
		public TokenRVal testRVal;

		public TokenStmtDo (Token original) : base (original) { }
	}

	/**
	 * @brief "for" statement
	 */
	public class TokenStmtFor : TokenStmt {

		public TokenStmt initStmt;  // there is always an init statement, though it may be a null statement
		public TokenRVal testRVal;  // there may or may not be a test (null if not)
		public TokenRVal incrRVal;  // there may or may not be an increment (null if not)
		public TokenStmt bodyStmt;  // there is always a body statement, though it may be a null statement

		public TokenStmtFor (Token original) : base (original) { }
	}

	/**
	 * @brief "foreach" statement
	 */
	public class TokenStmtForEach : TokenStmt {

		public TokenLVal keyLVal;
		public TokenLVal valLVal;
		public TokenRVal arrayRVal;
		public TokenStmt bodyStmt;  // there is always a body statement, though it may be a null statement

		public TokenStmtForEach (Token original) : base (original) { }
	}

	public class TokenStmtIf : TokenStmt {

		public TokenRVal testRVal;
		public TokenStmt trueStmt;
		public TokenStmt elseStmt;

		public TokenStmtIf (Token original) : base (original) { }
	}

	public class TokenStmtJump : TokenStmt {

		public TokenName label;

		public TokenStmtJump (Token original) : base (original) { }
	}

	public class TokenStmtNull : TokenStmt {

		public TokenStmtNull (Token original) : base (original) { }
	}

	public class TokenStmtRet : TokenStmt {

		public TokenRVal rVal;  // null if void

		public TokenStmtRet (Token original) : base (original) { }
	}

	/**
	 * @brief statement that changes the current state.
	 */
	public class TokenStmtState : TokenStmt {

		public TokenName state;  // null for default

		public TokenStmtState (Token original) : base (original) { }
	}

	/**
	 * @brief Encapsulates a whole switch statement including the body and all cases.
	 */
	public class TokenStmtSwitch : TokenStmt {

		public TokenRVal testRVal;               // the integer index expression
		public TokenSwitchCase cases = null;     // list of all cases, linked by .nextCase
		public TokenSwitchCase lastCase = null;  // used during reduce to point to last in 'cases' list

		public TokenStmtSwitch (Token original) : base (original) { }
	}

	/**
	 * @brief Encapsulates a case/default clause from a switch statement including the
	 *        two values and the corresponding body statements.
	 */
	public class TokenSwitchCase : Token {
		public TokenSwitchCase nextCase;  // next case in source-code order
		public TokenRVal rVal1;           // null means 'default', else 'case'
		public TokenRVal rVal2;           // null means 'case expr:', else 'case expr ... expr:'
		public TokenStmt stmts;           // statements associated with the case
		public TokenStmt lastStmt;        // used during reduce for building statement list

		public int val1;                        // codegen: value of rVal1 here
		public int val2;                        // codegen: value of rVal2 here
		public ScriptMyLabel label;             // codegen: target label here
		public TokenSwitchCase nextSortedCase;  // codegen: next case in ascending val order

		public TokenSwitchCase (Token original) : base (original) { }
	}

	public class TokenStmtThrow : TokenStmt {

		public TokenRVal rVal;  // null if rethrow style

		public TokenStmtThrow (Token original) : base (original) { }
	}

	/**
	 * @brief Encapsulates related try, catch and finally statements.
	 */
	public class TokenStmtTry : TokenStmt {

		public TokenStmtBlock tryStmt;
		public TokenDeclVar catchVar;		// null iff catchStmt is null
		public TokenStmtBlock catchStmt;	// can be null
		public TokenStmtBlock finallyStmt;	// can be null

		public TokenStmtTry (Token original) : base (original) { }
	}

	public class TokenStmtWhile : TokenStmt {

		public TokenRVal testRVal;
		public TokenStmt bodyStmt;

		public TokenStmtWhile (Token original) : base (original) { }
	}

	/**
	 * @brief type expressions (right-hand of 'is' keyword).
	 */
	public class TokenTypeExp : Token {
		public TokenTypeExp (Token original) : base (original) { }
	}

	public class TokenTypeExpBinOp : TokenTypeExp {
		public TokenTypeExp leftOp;
		public Token        binOp;
		public TokenTypeExp rightOp;

		public TokenTypeExpBinOp (Token original) : base (original) { }
	}

	public class TokenTypeExpNot : TokenTypeExp {
		public TokenTypeExp typeExp;

		public TokenTypeExpNot (Token original) : base (original) { }
	}

	public class TokenTypeExpPar : TokenTypeExp {
		public TokenTypeExp typeExp;

		public TokenTypeExpPar (Token original) : base (original) { }
	}

	public class TokenTypeExpType : TokenTypeExp {
		public TokenType typeToken;

		public TokenTypeExpType (Token original) : base (original) { }
	}

	public class TokenTypeExpUndef : TokenTypeExp {
		public TokenTypeExpUndef (Token original) : base (original) { }
	}
}
