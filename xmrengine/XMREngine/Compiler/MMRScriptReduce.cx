/***************************************************\
 *  COPYRIGHT 2009, Mike Rieker, Beverly, MA, USA  *
 *  All rights reserved.                           *
\***************************************************/

/**
 * @brief Reduce raw tokens to a single script token.
 * 
 * Usage:
 *
 *  tokenBegin = returned by TokenBegin.Analyze ()
 *               representing the whole script source
 *               as a flat list of tokens
 *
 *  TokenScript tokenScript = Reduce.Analyze (TokenBegin tokenBegin);
 *  
 *  tokenScript = represents the whole script source
 *                as a tree of tokens
 */

using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Reflection.Emit;
using System.Text;

#include "lsltypes.h"

namespace OpenSim.Region.ScriptEngine.XMREngine {

	public class ScriptReduce {
		public const uint SDT_ABSTRACT = 1;
		public const uint SDT_OVERRIDE = 2;
		public const uint SDT_STATIC   = 4;
		public const uint SDT_VIRTUAL  = 8;

		private static Dictionary<Type, int> precedence = PrecedenceInit ();

		private Type[] brkCloseOnly     = new Type[] { typeof (TokenKwBrkClose) };
		private Type[] cmpGTOnly        = new Type[] { typeof (TokenKwCmpGT)    };
		private Type[] colonOnly        = new Type[] { typeof (TokenKwColon)    };
		private Type[] colonOrDotDotDot = new Type[] { typeof (TokenKwColon),   typeof (TokenKwDotDotDot) };
		private Type[] parCloseOnly     = new Type[] { typeof (TokenKwParClose) };
		private Type[] semiOnly         = new Type[] { typeof (TokenKwSemi)     };

		/**
		 * @brief Initialize operator precedence table
		 * @returns with precedence table pointer
		 */
		private static Dictionary<Type, int> PrecedenceInit ()
		{
			Dictionary<Type, int> p = new Dictionary<Type, int> ();

			// http://www.lslwiki.net/lslwiki/wakka.php?wakka=operators

			p.Add (typeof (TokenKwComma),   30);

#define ASNPR 50
			p.Add (typeof (TokenKwAsnLSh), ASNPR);  // all assignment operators of equal precedence
			p.Add (typeof (TokenKwAsnRSh), ASNPR);  // ... so they get processed strictly right-to-left
			p.Add (typeof (TokenKwAsnAdd), ASNPR);
			p.Add (typeof (TokenKwAsnAnd), ASNPR);
			p.Add (typeof (TokenKwAsnSub), ASNPR);
			p.Add (typeof (TokenKwAsnMul), ASNPR);
			p.Add (typeof (TokenKwAsnDiv), ASNPR);
			p.Add (typeof (TokenKwAsnMod), ASNPR);
			p.Add (typeof (TokenKwAsnOr),  ASNPR);
			p.Add (typeof (TokenKwAsnXor), ASNPR);
			p.Add (typeof (TokenKwAssign), ASNPR);

			p.Add (typeof (TokenKwOrOr),   100);

			p.Add (typeof (TokenKwAndAnd), 120);

			p.Add (typeof (TokenKwOr),     140);

			p.Add (typeof (TokenKwXor),    160);

			p.Add (typeof (TokenKwAnd),    180);

			p.Add (typeof (TokenKwCmpEQ),  200);
			p.Add (typeof (TokenKwCmpNE),  200);

			p.Add (typeof (TokenKwCmpLT),  240);
			p.Add (typeof (TokenKwCmpLE),  240);
			p.Add (typeof (TokenKwCmpGT),  240);
			p.Add (typeof (TokenKwCmpGE),  240);

			p.Add (typeof (TokenKwRSh),    260);
			p.Add (typeof (TokenKwLSh),    260);

			p.Add (typeof (TokenKwAdd),    280);
			p.Add (typeof (TokenKwSub),    280);

			p.Add (typeof (TokenKwMul),    320);
			p.Add (typeof (TokenKwDiv),    320);
			p.Add (typeof (TokenKwMod),    320);

			return p;
		}

		/**
		 * @brief Reduce raw token stream to a single script token.
		 *        Performs a little semantic testing, ie, undefined variables, etc.
		 * @param tokenBegin = points to a TokenBegin
		 *                     followed by raw tokens
		 *                     and last token is a TokenEnd
		 * @returns null: not a valid script, error messages have been output
		 *          else: valid script top token
		 */
		public static TokenScript Reduce (TokenBegin tokenBegin)
		{
			return new ScriptReduce (tokenBegin.nextToken).tokenScript;
		}

		/*
		 * Instance variables.
		 */
		private bool errors = false;
		private TokenDeclFunc currentDeclFunc = null;
		private TokenScript tokenScript;
		private TokenStmtBlock currentStmtBlock = null;

		/**
		 * @brief the constructor does all the processing.
		 * @param token = first token of script after the TokenBegin token
		 * @returns tokenScript = null: there were errors
		 *                        else: successful
		 */
		private ScriptReduce (Token token)
		{
			/*
			 * Create a place to put the top-level script components,
			 * eg, state bodies, functions, global variables.
			 */
			tokenScript = new TokenScript (token);

			/*
			 * 'class', 'delegate', 'instance' all define types.
			 * So we pre-scan the source tokens for those keywords
			 * to build a script-defined type table and substitute
			 * type tokens for those names in the source.  This is
			 * done as a separate scan so they can cross-reference
			 * each other.
			 */
			bool didOne;
			do {
				didOne = false;
				for (Token t = token; !(t is TokenEnd); t = t.nextToken) {
					string name = null;
					TokenDeclSDType decl = null;

					// check for 'class' <name>
					if (t is TokenKwClass) {
						t = t.nextToken;
						if (t is TokenName) {
							name = ((TokenName)t).val;
							decl = new TokenDeclSDTypeClass ((TokenName)t);
						}
					}

					// check for 'delegate' [ <rettype> ] <name> '('
					// note that the <rettype> could appear as a name token
					// if it refers to a script-defined type that we haven't
					// seen the definition for yet, so we need to check for
					// the '(' after <name> to be sure we have the delegate's
					// name.
					if (t is TokenKwDelegate) {
						t = t.nextToken;
						if (t is TokenType) t = t.nextToken;
						if ((t is TokenName) && (t.nextToken is TokenKwParOpen)) {
							name = ((TokenName)t).val;
							decl = new TokenDeclSDTypeDelegate ((TokenName)t);
						}
					}

					// check for 'interface' <name>
					if (t is TokenKwInterface) {
						t = t.nextToken;
						if (t is TokenName) {
							name = ((TokenName)t).val;
							decl = new TokenDeclSDTypeInterface ((TokenName)t);
						}
					}

					// see if we found any one of those
					if (name != null) {

						// ok, substitute in declaration for <name> declaration token
						// leave the 'class', 'delegate' and 'interface' keyword tokens
						// alone so we will process the bodies later
						decl.nextToken = t.nextToken;
						decl.prevToken = t.prevToken;
						t.prevToken.nextToken = decl;
						t.nextToken.prevToken = decl;

						// add it to known script-defined types.
						// note that we can't get a duplicate here because we will
						// substitute out all other occurences of this name in the
						// next step.
						tokenScript.sdSrcTypes.Add (name, decl);

						// now scan through the entire source for other occurrences of 
						// <name> and substitute in references to the declared type
						for (Token u = token; !(u is TokenEnd); u = u.nextToken) {
							if ((u is TokenName) && (((TokenName)u).val == name)) {
								Token r = decl.MakeRefToken (u);
								r.nextToken = u.nextToken;
								r.prevToken = u.prevToken;
								u.prevToken.nextToken = r;
								u.nextToken.prevToken = r;
							}
						}

						// repeat after this pass in case of cross references
						didOne = true;
					}
				}
			} while (didOne);

			/*
			 * Scan through the tokens until we reach the end.
			 */
			while (!(token is TokenEnd)) {

				/*
				 * class <classdef> ... { ... }
				 */
				if (token is TokenKwClass) {
					ParseDeclClass (ref token);
					continue;
				}

				/*
				 * constant <name> = <rval> ;
				 */
				if (token is TokenKwConst) {
					ParseDeclVar (ref token, tokenScript.vars);
					continue;
				}

				/*
				 * delegate [<rettype>] <name> ( ... );
				 */
				if (token is TokenKwDelegate) {
					ParseDeclDelegate (ref token);
					continue;
				}

				/*
				 * interface <interfacedef> ... { ... }
				 */
				/*if (token is TokenKwInterface) {
					ParseDeclClass (ref token, true);
					continue;
				}*/

				/*
				 * <type> <name> ;
				 * <type> <name> = <rval> ;
				 */
				if ((token is TokenType) &&
				    (token.nextToken is TokenName) &&
				    ((token.nextToken.nextToken is TokenKwSemi) || 
				     (token.nextToken.nextToken is TokenKwAssign))) {
					ParseDeclVar (ref token, tokenScript.vars);
					continue;
				}

				/*
				 * <type> <name> <funcargs> <funcbody>
				 */
				if (token is TokenType) {
					TokenType tokenType = (TokenType)token;

					token = token.nextToken;
					if (!(token is TokenName)) {
						ErrorMsg (token, "expecting variable/function name");
						token = SkipPastSemi (token);
						continue;
					}
					TokenName tokenName = (TokenName)token;
					token = token.nextToken;
					if (token is TokenKwParOpen) {

						/*
						 * <type> <name> (
						 * global function definition
						 */
						token = tokenType;
						TokenDeclFunc tokenDeclFunc = ParseDeclFunc (ref token, false);
						if (tokenDeclFunc == null) continue;
						if (tokenScript.funcs.ContainsKey (tokenName.val)) {
							ErrorMsg (tokenName, "duplicate function name");
							continue;
						}
						tokenScript.funcs.Add (tokenName.val, tokenDeclFunc);
						continue;
					}
					ErrorMsg (token, "<type> <name> must be followed by ; = or (");
					token = SkipPastSemi (token);
					continue;
				}

				/*
				 * <name> <funcargs> <funcbody>
				 * global function returning void
				 */
				if (token is TokenName) {
					TokenName tokenName = (TokenName)token;
					token = token.nextToken;
					if (!(token is TokenKwParOpen)) {
						ErrorMsg (token, "looking for open paren after assuming " + 
						                 tokenName.val + " is a function name");
						token = SkipPastSemi (token);
						continue;
					}
					token = tokenName;
					TokenDeclFunc tokenDeclFunc = ParseDeclFunc (ref token, false);
					if (tokenDeclFunc == null) continue;
					if (tokenScript.funcs.ContainsKey (tokenName.val)) {
						ErrorMsg (tokenName, "duplicate function name");
						continue;
					}
					tokenScript.funcs.Add (tokenDeclFunc.funcNameSig.val, tokenDeclFunc);
					continue;
				}

				/*
				 * default <statebody>
				 */
				if (token is TokenKwDefault) {
					TokenDeclState tokenDeclState = new TokenDeclState (token);
					token = token.nextToken;
					tokenDeclState.body = ParseStateBody (ref token);
					if (tokenDeclState.body == null) continue;
					if (tokenScript.defaultState != null) {
						ErrorMsg (tokenDeclState, "default state already declared");
						continue;
					}
					tokenScript.defaultState = tokenDeclState;
					continue;
				}

				/*
				 * state <name> <statebody>
				 */
				if (token is TokenKwState) {
					TokenDeclState tokenDeclState = new TokenDeclState (token);
					token = token.nextToken;
					if (!(token is TokenName)) {
						ErrorMsg (token, "state must be followed by state name");
						token = SkipPastSemi (token);
						continue;
					}
					tokenDeclState.name = (TokenName)token;
					token = token.nextToken;
					tokenDeclState.body = ParseStateBody (ref token);
					if (tokenDeclState.body == null) continue;
					if (tokenScript.states.ContainsKey (tokenDeclState.name.val)) {
						ErrorMsg (tokenDeclState.name, "duplicate state definition");
						continue;
					}
					tokenScript.states.Add (tokenDeclState.name.val, tokenDeclState);
					continue;
				}

				/*
				 * Doesn't fit any of those forms, output message and skip to next statement.
				 */
				ErrorMsg (token, "looking for var name, type, state or default");
				token = SkipPastSemi (token);
				continue;
			}

			/*
			 * Must have a default state to start in.
			 */
			if (!errors && (tokenScript.defaultState == null)) {
				ErrorMsg (tokenScript, "no default state defined");
			}

			/*
			 * If any error messages were written out, set return value to null.
			 */
			if (errors) tokenScript = null;
		}

		/**
		 * @brief Parse a class declaration.
		 * @param token = points to 'class' keyword on entry
		 *                points just past closing '}' on return
		 */
		private void ParseDeclClass (ref Token token)
		{
			Token u = token.nextToken;
			TokenDeclSDTypeClass tokdeclcl;

			// first thing following 'class' should be the
			// class's declaration that we foud during
			// pre-scan
			if (!(u is TokenDeclSDTypeClass)) {
				ErrorMsg (u, "expecting class name");
				token = SkipPastSemi (token);
				return;
			}
			tokdeclcl = (TokenDeclSDTypeClass)u;
			u = u.nextToken;

			// next can be ':' followed by list of implemented
			// interfaces and one extended class
			if (u is TokenKwColon) {
				u = u.nextToken;
				while (true) {
					if (u is TokenTypeSDTypeClass) {
						TokenDeclSDTypeClass c = ((TokenTypeSDTypeClass)u).decl;
						if (tokdeclcl.extends == null) {
							tokdeclcl.extends = c;
						} else if (tokdeclcl.extends != c) {
							ErrorMsg (u, "can extend from only one class");
						}
					} else if (u is TokenTypeSDTypeInterface) {
						TokenDeclSDTypeInterface i = ((TokenTypeSDTypeInterface)u).decl;
						if (!tokdeclcl.implements.Contains (i)) {
							tokdeclcl.implements.Add (i);
						}
					} else {
						ErrorMsg (u, "expecting class or interface name");
						if (u is TokenKwBrcOpen) break;
					}
					u = u.nextToken;
					if (!(u is TokenKwComma)) break;
					u = u.nextToken;
				}
			}

			// next must be '{' to open class declaration body
			if (!(u is TokenKwBrcOpen)) {
				ErrorMsg (u, "expecting { to open class declaration body");
				token = SkipPastSemi (token);
				return;
			}
			token = u.nextToken;

			// process declaration statements until '}'
			while (!(token is TokenKwBrcClose)) {

				/*
				 * constant <name> = <rval> ;
				 */
				if (token is TokenKwConst) {
					ParseDeclVar (ref token, tokdeclcl.fields);
					continue;
				}

				/*
				 * Maybe there is a 'static' prefix.
				 */
				uint flags = 0;
				if (token is TokenKwStatic) {
					flags |= SDT_STATIC;
					token = token.nextToken;
				}

				/*
				 * [ static ] <type> <name> ;
				 * [ static ] <type> <name> = <rval> ;
				 */
				if ((token is TokenType) &&
				    (token.nextToken is TokenName) &&
				    ((token.nextToken.nextToken is TokenKwSemi) || 
				     (token.nextToken.nextToken is TokenKwAssign))) {
					ParseDeclVar (ref token, tokdeclcl.fields).sdtFlags = flags;
					continue;
				}

				/*
				 * Maybe there is an 'abstract', 'override' or 'virtual' prefix.
				 */
				while (true) {
					if (token is TokenKwAbstract) {
						if (flags != 0) ErrorMsg (token, "conflicting prefixes");
						else flags |= SDT_ABSTRACT;
						tokdeclcl.isAbstract = true;
						token = token.nextToken;
						continue;
					}
					if (token is TokenKwOverride) {
						if (flags != 0) ErrorMsg (token, "conflicting prefixes");
						else flags |= SDT_OVERRIDE;
						token = token.nextToken;
						continue;
					}
					if (token is TokenKwVirtual) {
						if (flags != 0) ErrorMsg (token, "conflicting prefixes");
						else flags |= SDT_VIRTUAL;
						token = token.nextToken;
						continue;
					}
					break;
				}

				/*
				 * [ abstract | override | static | virtual ] <type> <name> <funcargs> <funcbody>
				 * instance method with explicit return type
				 */
				if (token is TokenType) {
					TokenType tokenType = (TokenType)token;

					token = token.nextToken;
					if (!(token is TokenName)) {
						ErrorMsg (token, "expecting field/method name");
						token = SkipPastSemi (token);
						continue;
					}
					TokenName tokenName = (TokenName)token;
					token = token.nextToken;
					if (token is TokenKwParOpen) {

						/*
						 * <type> <name> (
						 * instance method definition
						 */
						token = tokenType;
						TokenDeclFunc tokenDeclFunc = ParseDeclFunc (ref token, (flags & SDT_ABSTRACT) != 0);
						if (tokenDeclFunc == null) continue;
						tokenDeclFunc.sdtFlags = flags;
						if (tokdeclcl.methods.ContainsKey (tokenDeclFunc.funcNameSig.val)) {
							ErrorMsg (tokenName, "duplicate method name");
							continue;
						}
						tokdeclcl.methods.Add (tokenDeclFunc.funcNameSig.val, tokenDeclFunc);
						continue;
					}
					ErrorMsg (token, "<type> <name> must be followed by ; = or (");
					token = SkipPastSemi (token);
					continue;
				}

				/*
				 * [ abstract | override | static | virtual ] <name> <funcargs> <funcbody>
				 * instance method returning void
				 */
				if (token is TokenName) {
					TokenName tokenName = (TokenName)token;
					token = token.nextToken;
					if (!(token is TokenKwParOpen)) {
						ErrorMsg (token, "looking for open paren after assuming " + 
						                 tokenName.val + " is a method name");
						token = SkipPastSemi (token);
						continue;
					}
					token = tokenName;
					TokenDeclFunc tokenDeclFunc = ParseDeclFunc (ref token, (flags & SDT_ABSTRACT) != 0);
					if (tokenDeclFunc == null) continue;
					if (tokdeclcl.methods.ContainsKey (tokenDeclFunc.funcNameSig.val)) {
						ErrorMsg (tokenName, "duplicate method name");
						continue;
					}
					tokdeclcl.methods.Add (tokenDeclFunc.funcNameSig.val, tokenDeclFunc);
					continue;
				}

				/*
				 * That's all we support in a class declaration.
				 */
				ErrorMsg (token, "expecting field or method declaration");
				token = SkipPastSemi (token);
			}

			/*
			 * Skip over the closing brace.
			 */
			token = token.nextToken;
		}

		/**
		 * @brief Parse a delegate declaration statement.
		 * @param token = points to 'delegate' keyword on entry
		 *                points just past ';' on return
		 */
		private void ParseDeclDelegate (ref Token token)
		{
			Token u = token;
			TokenDeclSDTypeDelegate tokdecldel;
			TokenType retType;

			// first thing following 'delegate' should be return type
			// but we will fill in 'void' if it is missing
			u = u.nextToken;
			if (u is TokenType) {
				retType = (TokenType)u;
				u = u.nextToken;
			} else {
				retType = new TokenTypeVoid (u);
			}

			// next should be the delegate's declaration that we found during pre-scan
			if (!(u is TokenDeclSDTypeDelegate)) {
				ErrorMsg (u, "expecting delegate name");
				token = SkipPastSemi (token);
				return;
			}
			tokdecldel = (TokenDeclSDTypeDelegate)u;
			u = u.nextToken;

			// get list of argument types until we see a ')'
			List<TokenType> args = new List<TokenType> ();
			bool first = true;
			do {
				if (first) {

					// first time should have '(' ')' or '(' <type>
					if (!(u is TokenKwParOpen)) {
						ErrorMsg (u, "expecting ( after delegate name");
						token = SkipPastSemi (token);
						return;
					}
					first = false;
					u = u.nextToken;
					if (u is TokenKwParClose) break;
				} else {

					// other times should have ',' <type>
					if (!(u is TokenKwComma)) {
						ErrorMsg (u, "expecting , separating arg types");
						token = SkipPastSemi (token);
						return;
					}
					u = u.nextToken;
				}
				if (!(u is TokenType)) {
					ErrorMsg (u, "expecting argument type");
					token = SkipPastSemi (token);
					return;
				}
				args.Add ((TokenType)u);
				u = u.nextToken;

				// they can put in a dummy name that we toss out
				if (u is TokenName) u = u.nextToken;

				// scanning ends on a ')'
			} while (!(u is TokenKwParClose));

			// fill in the return type and argment type array
			tokdecldel.SetRetArgTypes (retType, args.ToArray ());

			// and finally must have ';' to finish the delegate declaration statement
			u = u.nextToken;
			if (!(u is TokenKwSemi)) {
				ErrorMsg (u, "expecting ; after ) in delegate");
				token = SkipPastSemi (token);
				return;
			}
			token = u.nextToken;
		}

		/**
		 * @brief parse state body (including all its event handlers)
		 * @param token = points to TokenKwBrcOpen
		 * @returns null: state body parse error
		 *          else: token representing state
		 *          token = points past close brace
		 */
		private TokenStateBody ParseStateBody (ref Token token)
		{
			TokenStateBody tokenStateBody = new TokenStateBody (token);

			if (!(token is TokenKwBrcOpen)) {
				ErrorMsg (token, "expecting { at beg of state");
				token = SkipPastSemi (token);
				return null;
			}

			token = token.nextToken;
			while (!(token is TokenKwBrcClose)) {
				if (token is TokenEnd) {
					ErrorMsg (tokenStateBody, "eof parsing state body");
					return null;
				}
				TokenDeclFunc tokenDeclFunc = ParseDeclFunc (ref token, false);
				if (tokenDeclFunc == null) return null;
				if (!(tokenDeclFunc.retType is TokenTypeVoid)) {
					ErrorMsg (tokenDeclFunc.retType, "event handlers don't have return types");
					return null;
				}
				tokenDeclFunc.nextToken = tokenStateBody.eventFuncs;
				tokenStateBody.eventFuncs = tokenDeclFunc;
			}
			token = token.nextToken;
			return tokenStateBody;
		}

		/**
		 * @brief parse a function declaration, including its arg list and body
		 * @param token = points to function type token (or function name token if void)
		 * @param abs = false: concrete function; true: abstract declaration
		 * @returns null: error parsing function definition
		 *          else: function declaration
		 *          token = advanced just past function, ie, just past the closing brace
		 */
		private TokenDeclFunc ParseDeclFunc (ref Token token, bool abs)
		{
			TokenType tokenType;
			if (token is TokenType) {
				tokenType = (TokenType)token;
				token = token.nextToken;
			} else {
				tokenType = new TokenTypeVoid (token);
			}
			if (!(token is TokenName)) {
				ErrorMsg (token, "expecting function name");
				token = SkipPastSemi (token);
				return null;
			}
			TokenName tokenName = (TokenName)token;
			token = token.nextToken;
			TokenDeclFunc tokenDeclFunc = new TokenDeclFunc (tokenName);
			tokenDeclFunc.retType       = tokenType;
			tokenDeclFunc.argDecl       = ParseFuncArgs (ref token);
			tokenDeclFunc.funcNameSig   = new TokenName (tokenName, tokenName.val + tokenDeclFunc.argDecl.GetArgSig ());

			if (token is TokenKwSemi) {
				if (!abs) {
					ErrorMsg (token, "expecting function body, not abstract");
					token = SkipPastSemi (token);
					return null;
				}
				token = token.nextToken;
			} else {
				TokenDeclFunc saveDeclFunc = currentDeclFunc;
				currentDeclFunc = tokenDeclFunc;
				tokenDeclFunc.body = ParseStmtBlock (ref token);
				currentDeclFunc = saveDeclFunc;
				if (tokenDeclFunc.body == null) return null;
				if (abs) {
					ErrorMsg (tokenDeclFunc.body, "function declared abstract but has body");
					tokenDeclFunc.body = null;
				}
			}
			if (tokenDeclFunc.argDecl == null) return null;
			return tokenDeclFunc;
		}

		/**
		 * @brief Parse statement
		 * @param token = first token of statement
		 * @returns null: parse error
		 *          else: token representing whole statement
		 *          token = points past statement
		 */
		private TokenStmt ParseStmt (ref Token token)
		{
			/*
			 * Statements that begin with a specific keyword.
			 */
			if (token is TokenKwAt)      return ParseStmtLabel   (ref token);
			if (token is TokenKwBrcOpen) return ParseStmtBlock   (ref token);
			if (token is TokenKwBreak)   return ParseStmtBreak   (ref token);
			if (token is TokenKwCont)    return ParseStmtCont    (ref token);
			if (token is TokenKwDo)      return ParseStmtDo      (ref token);
			if (token is TokenKwFor)     return ParseStmtFor     (ref token);
			if (token is TokenKwForEach) return ParseStmtForEach (ref token);
			if (token is TokenKwIf)      return ParseStmtIf      (ref token);
			if (token is TokenKwJump)    return ParseStmtJump    (ref token);
			if (token is TokenKwRet)     return ParseStmtRet     (ref token);
			if (token is TokenKwSemi)    return ParseStmtNull    (ref token);
			if (token is TokenKwState)   return ParseStmtState   (ref token);
			if (token is TokenKwSwitch)  return ParseStmtSwitch  (ref token);
			if (token is TokenKwThrow)   return ParseStmtThrow   (ref token);
			if (token is TokenKwTry)     return ParseStmtTry     (ref token);
			if (token is TokenKwWhile)   return ParseStmtWhile   (ref token);

			/*
			 * Try to parse anything else as an expression, possibly calling
			 * something and/or writing to a variable.
			 */
			TokenRVal tokenRVal = ParseRVal (ref token, semiOnly);
			if (tokenRVal != null) {
				TokenStmtRVal tokenStmtRVal = new TokenStmtRVal (tokenRVal);
				tokenStmtRVal.rVal = tokenRVal;
				return tokenStmtRVal;
			}

			/*
			 * Who knows what it is...
			 */
			ErrorMsg (token, "unknown statement");
			token = SkipPastSemi (token);
			return null;
		}

		/**
		 * @brief parse a statement block, ie, group of statements between braces
		 * @param token = points to { token
		 * @returns null: error parsing
		 *          else: statements bundled in this token
		 *          token = advanced just past the } token
		 */
		private TokenStmtBlock ParseStmtBlock (ref Token token)
		{
			if (!(token is TokenKwBrcOpen)) {
				ErrorMsg (token, "statement block body must begin with a {");
				token = SkipPastSemi (token);
				return null;
			}
			TokenStmtBlock tokenStmtBlock = new TokenStmtBlock (token);
			tokenStmtBlock.function = currentDeclFunc;
			tokenStmtBlock.outerStmtBlock = currentStmtBlock;
			currentStmtBlock = tokenStmtBlock;
			Token prevStmt = null;
			token = token.nextToken;
			while (!(token is TokenKwBrcClose)) {
				if (token is TokenEnd) {
					ErrorMsg (tokenStmtBlock, "missing }");
					currentStmtBlock = tokenStmtBlock.outerStmtBlock;
					return null;
				}
				Token thisStmt;
				if ((token is TokenType) || (token is TokenKwConst)) {
					thisStmt = ParseDeclVar (ref token, currentStmtBlock.variables);
				} else {
					thisStmt = ParseStmt (ref token);
				}
				if (thisStmt == null) return null;
				if (prevStmt == null) tokenStmtBlock.statements = thisStmt;
				                 else prevStmt.nextToken = thisStmt;
				prevStmt = thisStmt;
			}
			token = token.nextToken;
			currentStmtBlock = tokenStmtBlock.outerStmtBlock;
			return tokenStmtBlock;
		}

		/**
		 * @brief parse a 'break' statement
		 * @param token = points to break keyword token
		 * @returns null: error parsing
		 *          else: statements bundled in this token
		 *          token = advanced just past the ; token
		 */
		private TokenStmtBreak ParseStmtBreak (ref Token token)
		{
			TokenStmtBreak tokenStmtBreak = new TokenStmtBreak (token);
			token = token.nextToken;
			if (!(token is TokenKwSemi)) {
				ErrorMsg (token, "expecting ;");
				token = SkipPastSemi (token);
				return null;
			}
			token = token.nextToken;
			return tokenStmtBreak;
		}

		/**
		 * @brief parse a 'continue' statement
		 * @param token = points to continue keyword token
		 * @returns null: error parsing
		 *          else: statements bundled in this token
		 *          token = advanced just past the ; token
		 */
		private TokenStmtCont ParseStmtCont (ref Token token)
		{
			TokenStmtCont tokenStmtCont = new TokenStmtCont (token);
			token = token.nextToken;
			if (!(token is TokenKwSemi)) {
				ErrorMsg (token, "expecting ;");
				token = SkipPastSemi (token);
				return null;
			}
			token = token.nextToken;
			return tokenStmtCont;
		}

		/**
		 * @brief parse a 'do' statement
		 * @params token = points to 'do' keyword token
		 * @returns null: parse error
		 *          else: pointer to token encapsulating the do statement, including body
		 *          token = advanced just past the body statement
		 */
		private TokenStmtDo ParseStmtDo (ref Token token)
		{
			TokenStmtDo tokenStmtDo = new TokenStmtDo (token);
			token = token.nextToken;
			tokenStmtDo.bodyStmt = ParseStmt (ref token);
			if (tokenStmtDo.bodyStmt == null) return null;
			if (!(token is TokenKwWhile)) {
				ErrorMsg (token, "expecting while clause");
				return null;
			}
			token = token.nextToken;
			tokenStmtDo.testRVal = ParseRValParen (ref token);
			if (tokenStmtDo.testRVal == null) return null;
			if (!(token is TokenKwSemi)) {
				ErrorMsg (token, "while clause must terminate on semicolon");
				token = SkipPastSemi (token);
				return null;
			}
			token = token.nextToken;
			return tokenStmtDo;
		}

		/**
		 * @brief parse a for statement
		 * @param token = points to 'for' keyword token
		 * @returns null: parse error
		 *          else: pointer to encapsulated for statement token
		 *          token = advanced just past for body statement
		 */
		private TokenStmt ParseStmtFor (ref Token token)
		{

			/*
			 * Create encapsulating token and skip past 'for ('
			 */
			TokenStmtFor tokenStmtFor = new TokenStmtFor (token);
			token = token.nextToken;
			if (!(token is TokenKwParOpen)) {
				ErrorMsg (token, "for must be followed by (");
				return null;
			}
			token = token.nextToken;

			/*
			 * If a plain for, ie, not declaring a variable, it's straightforward.
			 */
			if (!(token is TokenType)) {
				tokenStmtFor.initStmt = ParseStmt (ref token);
				if (tokenStmtFor.initStmt == null) return null;
				return ParseStmtFor2 (tokenStmtFor, ref token) ? tokenStmtFor : null;
			}

			/*
			 * Initialization declares a variable, so encapsulate it in a block so
			 * variable has scope only in the for statement, including its body.
			 */
			TokenStmtBlock forStmtBlock = new TokenStmtBlock (tokenStmtFor);
			forStmtBlock.outerStmtBlock = currentStmtBlock;
			forStmtBlock.function       = currentDeclFunc;

			TokenDeclVar tokenDeclVar   = ParseDeclVar (ref token, currentStmtBlock.variables);
			if (tokenDeclVar == null) {
				currentStmtBlock    = forStmtBlock.outerStmtBlock;
				return null;
			}

			forStmtBlock.statements     = tokenDeclVar;
			tokenDeclVar.nextToken      = tokenStmtFor;

			bool ok                     = ParseStmtFor2 (tokenStmtFor, ref token);
			currentStmtBlock            = forStmtBlock.outerStmtBlock;
			return ok ? forStmtBlock : null;
		}

		/**
		 * @brief parse rest of 'for' statement starting with the test expression.
		 * @param tokenStmtFor = token encapsulating the for statement
		 * @param token = points to test expression
		 * @returns false: parse error
		 *           true: successful
		 *          token = points just past body statement
		 */
		private bool ParseStmtFor2 (TokenStmtFor tokenStmtFor, ref Token token)
		{
			if (token is TokenKwSemi) {
				token = token.nextToken;
			} else {
				tokenStmtFor.testRVal = ParseRVal (ref token, semiOnly);
				if (tokenStmtFor.testRVal == null) return false;
			}
			if (token is TokenKwParClose) {
				token = token.nextToken;
			} else {
				tokenStmtFor.incrRVal = ParseRVal (ref token, parCloseOnly);
				if (tokenStmtFor.incrRVal == null) return false;
			}
			tokenStmtFor.bodyStmt = ParseStmt (ref token);
			return tokenStmtFor.bodyStmt != null;
		}

		/**
		 * @brief parse a foreach statement
		 * @param token = points to 'foreach' keyword token
		 * @returns null: parse error
		 *          else: pointer to encapsulated foreach statement token
		 *          token = advanced just past for body statement
		 */
		private TokenStmt ParseStmtForEach (ref Token token)
		{

			/*
			 * Create encapsulating token and skip past 'foreach ('
			 */
			TokenStmtForEach tokenStmtForEach = new TokenStmtForEach (token);
			token = token.nextToken;
			if (!(token is TokenKwParOpen)) {
				ErrorMsg (token, "foreach must be followed by (");
				return null;
			}
			token = token.nextToken;

			if (token is TokenName) {
				tokenStmtForEach.keyLVal = new TokenLValName ((TokenName)token);
				token = token.nextToken;
			}
			if (!(token is TokenKwComma)) {
				ErrorMsg (token, "expecting comma");
				token = SkipPastSemi (token);
				return null;
			}
			token = token.nextToken;
			if (token is TokenName) {
				tokenStmtForEach.valLVal = new TokenLValName ((TokenName)token);
				token = token.nextToken;
			}
			if (!(token is TokenKwIn)) {
				ErrorMsg (token, "expecting 'in'");
				token = SkipPastSemi (token);
				return null;
			}
			token = token.nextToken;
			tokenStmtForEach.arrayRVal = GetOperand (ref token);
			if (tokenStmtForEach.arrayRVal == null) return null;
			if (!(token is TokenKwParClose)) {
				ErrorMsg (token, "expecting )");
				token = SkipPastSemi (token);
				return null;
			}
			token = token.nextToken;
			tokenStmtForEach.bodyStmt = ParseStmt (ref token);
			if (tokenStmtForEach.bodyStmt == null) return null;
			return tokenStmtForEach;
		}

		private TokenStmtIf ParseStmtIf (ref Token token)
		{
			TokenStmtIf tokenStmtIf = new TokenStmtIf (token);
			token = token.nextToken;
			tokenStmtIf.testRVal = ParseRValParen (ref token);
			if (tokenStmtIf.testRVal == null) return null;
			tokenStmtIf.trueStmt = ParseStmt (ref token);
			if (tokenStmtIf.trueStmt == null) return null;
			if (token is TokenKwElse) {
				token = token.nextToken;
				tokenStmtIf.elseStmt = ParseStmt (ref token);
				if (tokenStmtIf.elseStmt == null) return null;
			}
			return tokenStmtIf;
		}

		private TokenStmtJump ParseStmtJump (ref Token token)
		{

			/*
			 * Create jump statement token to encapsulate the whole statement.
			 */
			TokenStmtJump tokenStmtJump = new TokenStmtJump (token);
			token = token.nextToken;
			if (!(token is TokenName) || !(token.nextToken is TokenKwSemi)) {
				ErrorMsg (token, "expecting label;");
				token = SkipPastSemi (token);
				return null;
			}
			tokenStmtJump.label = (TokenName)token;
			token = token.nextToken.nextToken;

			/*
			 * If label is already defined, it means this is a backward (looping)
			 * jump, so remember the label has backward jump references.
			 */
			if (currentDeclFunc.labels.ContainsKey (tokenStmtJump.label.val)) {
				currentDeclFunc.labels[tokenStmtJump.label.val].hasBkwdRefs = true;
			}

			return tokenStmtJump;
		}

		/**
		 * @brief parse a jump target label statement
		 * @param token = points to the '@' token
		 * @returns null: error parsing
		 *          else: the label
		 *          token = advanced just past the ;
		 */
		private TokenStmtLabel ParseStmtLabel (ref Token token)
		{
			if (!(token.nextToken is TokenName) ||
			    !(token.nextToken.nextToken is TokenKwSemi)) {
				ErrorMsg (token, "invalid label");
				token = SkipPastSemi (token);
				return null;
			}
			TokenStmtLabel stmtLabel = new TokenStmtLabel (token);
			stmtLabel.name  = (TokenName)token.nextToken;
			stmtLabel.block = currentStmtBlock;
			if (currentDeclFunc.labels.ContainsKey (stmtLabel.name.val)) {
				ErrorMsg (token.nextToken, "duplicate label");
				ErrorMsg (currentDeclFunc.labels[stmtLabel.name.val], "previously defined here");
				token = SkipPastSemi (token);
				return null;
			}
			currentDeclFunc.labels.Add (stmtLabel.name.val, stmtLabel);
			token = token.nextToken.nextToken.nextToken;
			return stmtLabel;
		}

		private TokenStmtNull ParseStmtNull (ref Token token)
		{
			TokenStmtNull tokenStmtNull = new TokenStmtNull (token);
			token = token.nextToken;
			return tokenStmtNull;
		}

		private TokenStmtRet ParseStmtRet (ref Token token)
		{
			TokenStmtRet tokenStmtRet = new TokenStmtRet (token);
			token = token.nextToken;
			if (token is TokenKwSemi) {
				token = token.nextToken;
			} else {
				tokenStmtRet.rVal = ParseRVal (ref token, semiOnly);
				if (tokenStmtRet.rVal == null) return null;
			}
			return tokenStmtRet;
		}

		private TokenStmtSwitch ParseStmtSwitch (ref Token token)
		{
			TokenStmtSwitch tokenStmtSwitch = new TokenStmtSwitch (token);
			token = token.nextToken;
			tokenStmtSwitch.testRVal = ParseRValParen (ref token);
			if (tokenStmtSwitch.testRVal == null) return null;
			if (!(token is TokenKwBrcOpen)) {
				ErrorMsg (token, "expecting open brace");
				token = SkipPastSemi (token);
				return null;
			}
			token = token.nextToken;
			TokenSwitchCase tokenSwitchCase = null;
			bool haveComplained = false;
			while (!(token is TokenKwBrcClose)) {
				if (token is TokenKwCase) {
					tokenSwitchCase = new TokenSwitchCase (token);
					if (tokenStmtSwitch.lastCase == null) {
						tokenStmtSwitch.cases = tokenSwitchCase;
					} else {
						tokenStmtSwitch.lastCase.nextCase = tokenSwitchCase;
					}
					tokenStmtSwitch.lastCase =  tokenSwitchCase;

					token = token.nextToken;
					tokenSwitchCase.rVal1 = ParseRVal (ref token, colonOrDotDotDot);
					if (tokenSwitchCase.rVal1 == null) return null;
					if (token is TokenKwDotDotDot) {
						token = token.nextToken;
						tokenSwitchCase.rVal2 = ParseRVal (ref token, colonOnly);
						if (tokenSwitchCase.rVal2 == null) return null;
					} else {
						if (!(token is TokenKwColon)) {
							ErrorMsg (token, "expecting : or ...");
							token = SkipPastSemi (token);
							return null;
						}
						token = token.nextToken;
					}
				} else if (token is TokenKwDefault) {
					tokenSwitchCase = new TokenSwitchCase (token);
					if (tokenStmtSwitch.lastCase == null) {
						tokenStmtSwitch.cases = tokenSwitchCase;
					} else {
						tokenStmtSwitch.lastCase.nextCase = tokenSwitchCase;
					}
					tokenStmtSwitch.lastCase =  tokenSwitchCase;

					token = token.nextToken;
					if (!(token is TokenKwColon)) {
						ErrorMsg (token, "expecting :");
						token = SkipPastSemi (token);
						return null;
					}
					token = token.nextToken;
				} else if (tokenSwitchCase != null) {
					TokenStmt bodyStmt = ParseStmt (ref token);
					if (bodyStmt == null) return null;
					if (tokenSwitchCase.lastStmt == null) {
						tokenSwitchCase.stmts = bodyStmt;
					} else {
						tokenSwitchCase.lastStmt.nextToken = bodyStmt;
					}
					tokenSwitchCase.lastStmt = bodyStmt;
					bodyStmt.nextToken = null;
				} else if (!haveComplained) {
					ErrorMsg (token, "expecting case or default label");
					token = SkipPastSemi (token);
					haveComplained = true;
				}
			}
			token = token.nextToken;
			return tokenStmtSwitch;
		}

		private TokenStmtState ParseStmtState (ref Token token)
		{
			TokenStmtState tokenStmtState = new TokenStmtState (token);
			token = token.nextToken;
			if ((!(token is TokenName) && !(token is TokenKwDefault)) || !(token.nextToken is TokenKwSemi)) {
				ErrorMsg (token, "expecting state;");
				token = SkipPastSemi (token);
				return null;
			}
			if (token is TokenName) {
				tokenStmtState.state = (TokenName)token;
			}
			token = token.nextToken.nextToken;
			return tokenStmtState;
		}

		private TokenStmtThrow ParseStmtThrow (ref Token token)
		{
			TokenStmtThrow tokenStmtThrow = new TokenStmtThrow (token);
			token = token.nextToken;
			if (token is TokenKwSemi) {
				token = token.nextToken;
			} else {
				tokenStmtThrow.rVal = ParseRVal (ref token, semiOnly);
				if (tokenStmtThrow.rVal == null) return null;
			}
			return tokenStmtThrow;
		}

		private TokenStmtTry ParseStmtTry (ref Token token)
		{
			TokenStmtTry tokenStmtTry = new TokenStmtTry (token);
			token = token.nextToken;
			tokenStmtTry.tryStmt = ParseStmtBlock (ref token);
			if (tokenStmtTry.tryStmt == null) return null;
			if (token is TokenKwCatch) {
				if (!(token.nextToken is TokenKwParOpen) ||
				    !(token.nextToken.nextToken is TokenTypeStr) ||
				    !(token.nextToken.nextToken.nextToken is TokenName) ||
				    !(token.nextToken.nextToken.nextToken.nextToken is TokenKwParClose)) {
					ErrorMsg (token, "catch must be followed by ( string <varname> ) <statement>");
					return null;
				}
				tokenStmtTry.catchVar = (TokenName) token.nextToken.nextToken.nextToken;
				token = token.nextToken.nextToken.nextToken.nextToken.nextToken;
				tokenStmtTry.catchStmt = ParseStmtBlock (ref token);
				if (tokenStmtTry.catchStmt == null) return null;
			}
			if (token is TokenKwFinally) {
				token = token.nextToken;
				tokenStmtTry.finallyStmt = ParseStmtBlock (ref token);
				if (tokenStmtTry.finallyStmt == null) return null;
			}
			if ((tokenStmtTry.catchStmt == null) && (tokenStmtTry.finallyStmt == null)) {
				ErrorMsg (tokenStmtTry, "try must have a matching catch and/or finally");
				return null;
			}
			return tokenStmtTry;
		}

		private TokenStmtWhile ParseStmtWhile (ref Token token)
		{
			TokenStmtWhile tokenStmtWhile = new TokenStmtWhile (token);
			token = token.nextToken;
			tokenStmtWhile.testRVal = ParseRValParen (ref token);
			if (tokenStmtWhile.testRVal == null) return null;
			tokenStmtWhile.bodyStmt = ParseStmt (ref token);
			if (tokenStmtWhile.bodyStmt == null) return null;
			return tokenStmtWhile;
		}

		/**
		 * @brief parse a variable declaration statement, including init value if any.
		 * @param token = points to type or 'constant' token
		 * @param variables = list of variables to insert it in
		 * @returns null: parsing error
		 *          else: variable declaration encapulating token
		 *          token = advanced just past semi-colon
		 *          variables = modified to include the new variable
		 */
		private TokenDeclVar ParseDeclVar (ref Token token, Dictionary<string, TokenDeclVar> variables)
		{
			TokenDeclVar tokenDeclVar = new TokenDeclVar (token.nextToken, currentDeclFunc);

			/*
			 * Handle constant declaration.
			 * It ends up in the declared variables list for the statement block just like
			 * any other variable, except it has .constant = true and its value is an
			 * TokenRValConst.
			 *
			 * 	constant <name> = <value> ;
			 */
			if (token is TokenKwConst) {
				token = token.nextToken;
				if (!(token is TokenName)) {
					ErrorMsg (token, "expecting constant name");
					token = SkipPastSemi (token);
					return null;
				}
				tokenDeclVar.name = (TokenName)token;
				token = token.nextToken;
				if (!(token is TokenKwAssign)) {
					ErrorMsg (token, "expecting =");
					token = SkipPastSemi (token);
					return null;
				}
				token = token.nextToken;
				TokenRVal rVal = ParseRVal (ref token, semiOnly);
				if (rVal == null) return null;
				if (!(rVal is TokenRValConst)) {
					ErrorMsg (tokenDeclVar, "constant value not constant float,integer,string");
					token = SkipPastSemi (token);
					return null;
				}
				tokenDeclVar.type = TokenType.FromSysType (tokenDeclVar, 
				                                           ((TokenRValConst)rVal).val.GetType ());
				tokenDeclVar.init = rVal;
				tokenDeclVar.constant = true;
			}

			/*
			 * Otherwise, normal variable declaration with optional initialization value.
			 */
			else {
				/*
				 * Build basic encapsulating token with type and name.
				 */
				tokenDeclVar.type = (TokenType)token;
				token = token.nextToken;
				if (!(token is TokenName)) {
					ErrorMsg (token, "expecting variable name");
					token = SkipPastSemi (token);
					return null;
				}
				tokenDeclVar.name = (TokenName)token;
				token = token.nextToken;

				/*
				 * If just a ;, there is no explicit initialization value.
				 * Otherwise, look for an =RVal; expression that has init value.
				 */
				if (token is TokenKwSemi) {
					token = token.nextToken;
				} else if (token is TokenKwAssign) {
					token = token.nextToken;
					tokenDeclVar.init = ParseRVal (ref token, semiOnly);
					if (tokenDeclVar.init == null) return null;
				} else {
					ErrorMsg (token, "expecting = or ;");
					token = SkipPastSemi (token);
					return null;
				}
			}

			/*
			 * Can't be same name already in block.
			 */
			TokenDeclVar bad;
			if (variables.TryGetValue (tokenDeclVar.name.val, out bad)) {
				ErrorMsg (tokenDeclVar, "duplicate variable definition");
				ErrorMsg (bad.name, "previously defined here");
				return null;
			}
			variables.Add (tokenDeclVar.name.val, tokenDeclVar);

			return tokenDeclVar;
		}

		/**
		 * @brief parse function declaration argument list
		 * @param token = points to TokenKwParOpen
		 * @returns null: parse error
		 *          else: points to token with types and names
		 *          token = updated past the TokenKwParClose
		 */
		private TokenArgDecl ParseFuncArgs (ref Token token)
		{
			int nArgs = 0;
			LinkedList<TokenName> nameList = new LinkedList<TokenName> ();
			LinkedList<TokenType> typeList = new LinkedList<TokenType> ();
			TokenArgDecl tokenArgDecl = new TokenArgDecl (token);

			do {
				token = token.nextToken;
				if ((nArgs == 0) && (token is TokenKwParClose)) break;
				if (!(token is TokenType)) {
					ErrorMsg (token, "expecting arg type");
					token = SkipPastSemi (token);
					return null;
				}
				typeList.AddLast ((TokenType)token);

				token = token.nextToken;
				if (!(token is TokenName)) {
					ErrorMsg (token, "expecting arg name");
					token = SkipPastSemi (token);
					return null;
				}
				foreach (TokenName dupCheck in nameList) {
					if (dupCheck.val == ((TokenName)token).val) {
						ErrorMsg (token, "duplicate arg name");
						break;
					}
				}
				nameList.AddLast ((TokenName)token);
				nArgs ++;

				token = token.nextToken;
			} while (token is TokenKwComma);
			if (!(token is TokenKwParClose)) {
				ErrorMsg (token, "expecting comma or close paren");
				token = SkipPastSemi (token);
				return null;
			}
			token = token.nextToken;

			tokenArgDecl.types = System.Linq.Enumerable.ToArray (typeList);
			tokenArgDecl.names = System.Linq.Enumerable.ToArray (nameList);
			tokenArgDecl.locns = new CompValu[nArgs];
			return tokenArgDecl;
		}

		/**
		 * @brief parse right-hand value expression
		 *        this is where arithmetic-like expressions are processed
		 * @param token = points to first token expression
		 * @param termTokenType = expression termination token type
		 * @returns null: not an RVal
		 *          else: single token representing whole expression
		 *          token = if termTokenType.Length == 1, points just past terminating token
		 *                                          else, points right at terminating token
		 */
		public TokenRVal ParseRVal (ref Token token, Type[] termTokenTypes)
		{
			/*
			 * Start with pushing the first operand on operand stack.
			 */
			BinOp binOps = null;
			TokenRVal operands = GetOperand (ref token);
			if (operands == null) return null;

			/*
			 * Keep scanning until we hit the termination token.
			 */
			while (true) {
				Type tokType = token.GetType();
				for (int i = termTokenTypes.Length; -- i >= 0;) {
					if (tokType == termTokenTypes[i]) goto done;
				}

				/*
				 * Special form:
				 *   <operand> is <typeexp>
				 */
				if (token is TokenKwIs) {
					TokenRValIsType tokenRValIsType = new TokenRValIsType (token);
					token = token.nextToken;

					/*
					 * Parse the <typeexp>.
					 */
					tokenRValIsType.typeExp = ParseTypeExp (ref token);
					if (tokenRValIsType.typeExp == null) return null;

					/*
					 * Replace top operand with result of <operand> is <typeexp>
					 */
					tokenRValIsType.rValExp   = operands;
					tokenRValIsType.nextToken = operands.nextToken;
					operands = tokenRValIsType;

					/*
					 * token points just past <typeexp> so see if it is another operator.
					 */
					continue;
				}

				/*
				 * Peek at next operator.
				 */
				BinOp binOp = GetOperator (ref token);
				if (binOp == null) return null;

				/*
				 * If there are stacked operators of higher or same precedence than new one,
				 * perform their computation then push result back on operand stack.
				 *
				 *  higher or same = left-to-right application of operators
				 *                   eg, a - b - c becomes (a - b) - c
				 *
				 *  higher precedence = right-to-left application of operators
				 *                      eg, a - b - c becomes a - (b - c)
				 *
				 * Now of course, there is some ugliness necessary:
				 *      we want:  a  - b - c  =>  (a - b) - c    so we do 'higher or same'
				 *  but we want:  a += b = c  =>  a += (b = c)   so we do 'higher only'
				 *
				 * binOps is the first operator (or null if only one)
				 * binOp is the second operator (or first if only one)
				 */
				while (binOps != null) {
					if (binOps.preced < binOp.preced) break;       // 1st operator lower than 2nd, so leave 1st on stack to do later
					if (binOps.preced > binOp.preced) goto do1st;  // 1st op higher than 2nd, so we always do 1st op first
					if (binOps.preced == ASNPR) break;             // equal preced, if assignment type, leave 1st on stack to do later
					                                               //               if non-asn type, do 1st op first (ie left-to-right)
				do1st:
					TokenRVal result = PerformBinOp ((TokenRVal)operands.prevToken, binOps, (TokenRVal)operands);
					result.prevToken = operands.prevToken.prevToken;
					operands = result;
					binOps   = binOps.pop;
				}

				/*
				 * Push new operator on its stack.
				 */
				binOp.pop = binOps;
				binOps = binOp;

				/*
				 * Push next operand on its stack.
				 */
				TokenRVal operand = GetOperand (ref token);
				if (operand == null) return null;
				operand.prevToken = operands;
				operands = operand;
			}
		done:

			/*
			 * At end of expression, perform any stacked computations.
			 */
			while (binOps != null) {
				TokenRVal result = PerformBinOp ((TokenRVal)operands.prevToken, binOps, (TokenRVal)operands);
				result.prevToken = operands.prevToken.prevToken;
				operands = result;
				binOps   = binOps.pop;
			}

			/*
			 * There should be exactly one remaining operand on the stack which is our final result.
			 */
			if (operands.prevToken != null) throw new Exception ("too many operands");

			/*
			 * If only one terminator type possible, advance past the terminator.
			 */
			if (termTokenTypes.Length == 1) token = token.nextToken;

			return operands;
		}

		private TokenTypeExp ParseTypeExp (ref Token token)
		{
			TokenTypeExp leftOperand = GetTypeExp (ref token);
			if (leftOperand == null) return null;

			while ((token is TokenKwAnd) || (token is TokenKwOr)) {
				Token typeBinOp = token;
				token = token.nextToken;
				TokenTypeExp rightOperand = GetTypeExp (ref token);
				if (rightOperand == null) return null;
				TokenTypeExpBinOp typeExpBinOp = new TokenTypeExpBinOp (typeBinOp);
				typeExpBinOp.leftOp  = leftOperand;
				typeExpBinOp.binOp   = typeBinOp;
				typeExpBinOp.rightOp = rightOperand;
				leftOperand = typeExpBinOp;
			}
			return leftOperand;
		}

		private TokenTypeExp GetTypeExp (ref Token token)
		{
			if (token is TokenKwTilde) {
				TokenTypeExpNot typeExpNot = new TokenTypeExpNot (token);
				token = token.nextToken;
				typeExpNot.typeExp = GetTypeExp (ref token);
				if (typeExpNot.typeExp == null) return null;
				return typeExpNot;
			}
			if (token is TokenKwParOpen) {
				TokenTypeExpPar typeExpPar = new TokenTypeExpPar (token);
				token = token.nextToken;
				typeExpPar.typeExp = GetTypeExp (ref token);
				if (typeExpPar.typeExp == null) return null;
				if (!(token is TokenKwParClose)) {
					ErrorMsg (token, "expected close parenthesis");
					token = SkipPastSemi (token);
					return null;
				}
				return typeExpPar;
			}
			if (token is TokenKwUndef) {
				TokenTypeExpUndef typeExpUndef = new TokenTypeExpUndef (token);
				token = token.nextToken;
				return typeExpUndef;
			}
			if (token is TokenType) {
				TokenTypeExpType typeExpType = new TokenTypeExpType (token);
				typeExpType.typeToken = (TokenType)token;
				token = token.nextToken;
				return typeExpType;
			}
			ErrorMsg (token, "expected type");
			token = SkipPastSemi (token);
			return null;
		}

		/**
		 * @brief get a right-hand operand expression token
		 * @param token = first token of operand to parse
		 * @returns null: invalid operand
		 *          else: token that bundles or wraps the operand
		 *          token = points to token following last operand token
		 */
		private TokenRVal GetOperand (ref Token token)
		{
			/*
			 * Prefix unary operators (eg ++, --) requiring an L-value.
			 */
			if ((token is TokenKwIncr) || (token is TokenKwDecr)) {
				TokenRValAsnPre asnPre = new TokenRValAsnPre (token);
				asnPre.prefix = token;
				token = token.nextToken;
				TokenRVal op = GetOperand (ref token);
				if (op == null) return null;
				if (!(op is TokenLVal)) {
					ErrorMsg (op, "can pre{in,de}crement only an L-value");
					return null;
				}
				asnPre.lVal = (TokenLVal)op;
				return asnPre;
			}

			/*
			 * Get the bulk of the operand, ie, without any of the below suffixes.
			 */
			TokenRVal operand = GetOperandNoMods (ref token);
			if (operand == null) return null;
		modifiers:

			/*
			 * If followed by '++' or '--', it is post-{in,de}cremented.
			 */
			if ((token is TokenKwIncr) || (token is TokenKwDecr)) {
				TokenRValAsnPost asnPost = new TokenRValAsnPost (token);
				asnPost.postfix = token;
				token = token.nextToken;
				if (!(operand is TokenLVal)) {
					ErrorMsg (operand, "can post{in,de}crement only an L-value");
					return null;
				}
				asnPost.lVal = (TokenLVal)operand;
				return asnPost;
			}

			/*
			 * If followed by a '.', it is an instance field or instance method reference.
			 */
			if (token is TokenKwDot) {
				token = token.nextToken;
				if (!(token is TokenName)) {
					ErrorMsg (token, ". must be followed by field/method name");
					return null;
				}
				TokenLValIField field = new TokenLValIField (token);
				field.baseRVal = operand;
				field.field = (TokenName)token;
				operand = field;
				token = token.nextToken;
				goto modifiers;
			}

			/*
			 * If follwed by a '[', it is an array subscript.
			 */
			if (token is TokenKwBrkOpen) {
				TokenLValArEle tokenLValArEle = new TokenLValArEle (token);
				token = token.nextToken;

				/*
				 * Parse subscript(s) expression.
				 */
				tokenLValArEle.subRVal = ParseRVal (ref token, brkCloseOnly);
				if (tokenLValArEle.subRVal == null) {
					ErrorMsg (tokenLValArEle, "invalid subscript");
					return null;
				}

				/*
				 * See if comma-separated list of values.
				 */
				bool sideEffects = false;
				TokenRVal subscriptRVals;
				int numSubscripts = SplitCommaRVals (tokenLValArEle.subRVal, out subscriptRVals, ref sideEffects);
				if (numSubscripts > 1) {

					/*
					 * If so, put the values in an LSL_List object.
					 */
					TokenRValList rValList = new TokenRValList (tokenLValArEle);
					rValList.rVal = subscriptRVals;
					rValList.nItems = numSubscripts;
					rValList.sideEffects = sideEffects;
					tokenLValArEle.subRVal = rValList;
				}

				/*
				 * Either way, save array variable name
				 * and substitute whole reference for L-value
				 */
				tokenLValArEle.baseRVal = operand;
				operand = tokenLValArEle;
				goto modifiers;
			}

			/*
			 * If followed by a '(', it is a function/method call.
			 */
			if (token is TokenKwParOpen) {

				/*
				 * Set up basic function call struct with function name.
				 */
				TokenRValCall rValCall = new TokenRValCall (token);
				rValCall.meth = operand;
				token = token.nextToken;

				/*
				 * Parse the call parameters, if any.
				 */
				if (token is TokenKwParClose) {
					token = token.nextToken;
				} else {
					rValCall.args = ParseRVal (ref token, parCloseOnly);
					if (rValCall.args == null) return null;
					rValCall.nArgs = SplitCommaRVals (rValCall.args, out rValCall.args, ref rValCall.sideEffects);
				}

				operand = rValCall;
				goto modifiers;
			}

			return operand;
		}

		/**
		 * @brief same as GetOperand() except doesn't check for any modifiers
		 */
		private TokenRVal GetOperandNoMods (ref Token token)
		{
			/*
			 * Simple unary operators.
			 */
			if ((token is TokenKwSub) || 
			    (token is TokenKwTilde) ||
			    (token is TokenKwExclam)) {
				Token uop = token;
				token = token.nextToken;
				TokenRVal rVal = GetOperand (ref token);
				if (rVal == null) return null;
				return PerformUnOp (uop, rVal);
			}

			/*
			 * Type casting.
			 */
			if ((token is TokenKwParOpen) &&
			    (token.nextToken is TokenType) &&
			    (token.nextToken.nextToken is TokenKwParClose)) {
				TokenType type = (TokenType)token.nextToken;
				token = token.nextToken.nextToken.nextToken;
				TokenRVal rVal = GetOperand (ref token);
				if (rVal == null) return null;
				return new TokenRValCast (type, rVal);
			}

			/*
			 * Parenthesized expression.
			 */
			if (token is TokenKwParOpen) {
				return ParseRValParen (ref token);
			}

			/*
			 * Constants.
			 */
			if (token is TokenFloat) {
				TokenRValConst rValConst = new TokenRValConst (token, ((TokenFloat)token).val);
				token = token.nextToken;
				return rValConst;
			}
			if (token is TokenInt) {
				TokenRValConst rValConst = new TokenRValConst (token, ((TokenInt)token).val);
				token = token.nextToken;
				return rValConst;
			}
			if (token is TokenStr) {
				TokenRValConst rValConst = new TokenRValConst (token, ((TokenStr)token).val);
				token = token.nextToken;
				return rValConst;
			}
			if (token is TokenKwUndef) {
				TokenRValUndef rValUndef = new TokenRValUndef ((TokenKwUndef)token);
				token = token.nextToken;
				return rValUndef;
			}

			/*
			 * '<'value,...'>', ie, rotation or vector
			 */
			if (token is TokenKwCmpLT) {
				Token openBkt = token;
				token = token.nextToken;
				TokenRVal rValAll = ParseRVal (ref token, cmpGTOnly);
				if (rValAll == null) return null;
				TokenRVal rVals;
				bool sideEffects = false;
				int nVals = SplitCommaRVals (rValAll, out rVals, ref sideEffects);
				switch (nVals) {
					case 3: {
						TokenRValVec rValVec = new TokenRValVec (openBkt);
						rValVec.xRVal = rVals;
						rValVec.yRVal = (TokenRVal)rVals.nextToken;
						rValVec.zRVal = (TokenRVal)rVals.nextToken.nextToken;
						rValVec.sideEffects = sideEffects;
						return rValVec;
					}
					case 4: {
						TokenRValRot rValRot = new TokenRValRot (openBkt);
						rValRot.xRVal = rVals;
						rValRot.yRVal = (TokenRVal)rVals.nextToken;
						rValRot.zRVal = (TokenRVal)rVals.nextToken.nextToken;
						rValRot.wRVal = (TokenRVal)rVals.nextToken.nextToken.nextToken;
						rValRot.sideEffects = sideEffects;
						return rValRot;
					}
					default: {
						ErrorMsg (openBkt, "bad rotation/vector");
						token = SkipPastSemi (token);
						return null;
					}
				}
			}

			/*
			 * '['value,...']', ie, list
			 */
			if (token is TokenKwBrkOpen) {
				TokenRValList rValList = new TokenRValList (token);
				token = token.nextToken;
				if (token is TokenKwBrkClose) {
					token = token.nextToken;  // empty list
				} else {
					TokenRVal rValAll = ParseRVal (ref token, brkCloseOnly);
					if (rValAll == null) return null;
					rValList.nItems = SplitCommaRVals (rValAll, out rValList.rVal, ref rValList.sideEffects);
				}
				return rValList;
			}

			/*
			 * Reference to such as the <name> defined by 'constant <name> = <value> ;'
			 */
			if (token is TokenName) {
				TokenRValConst rValConst = TryUserDefConst (ref token);
				if (rValConst != null) return rValConst;
			}

			/*
			 * Built-in symbolic constants.
			 */
			if (token is TokenName) {
				ScriptConst scriptConst = ScriptConst.Lookup (((TokenName)token).val);
				if (scriptConst != null) {
					CompValu val = scriptConst.rVal;
					TokenRVal rVal = null;

					/*
					 * Decode these types as TokenRValConst's so they will combine with other constants at
					 * compile time.
					 */
					if (val is CompValuFloat)   rVal = new TokenRValConst (token, ((CompValuFloat)val).x);
					if (val is CompValuInteger) rVal = new TokenRValConst (token, ((CompValuInteger)val).x);
					if (val is CompValuString)  rVal = new TokenRValConst (token, ((CompValuString)val).x);

					/*
					 * If tere is no TokenRValConst equivalent for this one, just keep the CompValu as is.
					 */
					if (val is CompValuSField) {
						object v = ((CompValuSField)val).field.GetValue(null);

						// Handle the basic types LSL_Constants contains
						if (v is string) {
							rVal =  new TokenRValConst (token, v);
						} else if (v is float) {
							rVal =  new TokenRValConst (token, v);
						} else if (v is int) {
							rVal =  new TokenRValConst (token, v);
						} else if (v is LSL_Vector) {
							LSL_Vector vec = (LSL_Vector)v;
							TokenRValVec rValVec =  new TokenRValVec (token);
							rValVec.xRVal = new TokenRValConst(token, vec.x);
							rValVec.yRVal = new TokenRValConst(token, vec.y);
							rValVec.zRVal = new TokenRValConst(token, vec.z);
							rVal = rValVec;
						} else if (v is LSL_Rotation) {
							LSL_Rotation rot = (LSL_Rotation)v;
							TokenRValRot rValRot =  new TokenRValRot (token);
							rValRot.xRVal = new TokenRValConst(token, rot.x);
							rValRot.yRVal = new TokenRValConst(token, rot.y);
							rValRot.zRVal = new TokenRValConst(token, rot.z);
							rValRot.wRVal = new TokenRValConst(token, rot.s);
							rVal = rValRot;
						} else {
							rVal = new TokenRValCVSField (token, (CompValuSField)val);
						}
					}

					/*
					 * We should have been able to decode it somehow!
					 */
					if (rVal == null) {
						throw new Exception ("unhandled ScriptConst type " + val.GetType());
					}

					/*
					 * Advance pointer past the name token and return ref to the constant.
					 */
					token = token.nextToken;
					return rVal;
				}
			}

			/*
			 * Maybe we have <type>.<name> referencing a static field or method of some type.
			 */
			if ((token is TokenType) && (token.nextToken is TokenKwDot) && (token.nextToken.nextToken is TokenName)) {
				TokenLValSField field = new TokenLValSField (token.nextToken.nextToken);
				field.baseType = (TokenType)token;
				field.fieldName = (TokenName)token.nextToken.nextToken;
				token = token.nextToken.nextToken.nextToken;
				return field;
			}

			/*
			 * All we got left is <name>, eg, arg, function, global or local variable reference
			 */
			if (token is TokenName) {
				TokenLValName name = new TokenLValName ((TokenName)token);
				token = token.nextToken;
				return name;
			}

			/*
			 * Who knows what it is supposed to be?
			 */
			ErrorMsg (token, "invalid operand token");
			token = SkipPastSemi (token);
			return null;
		}

		/**
		 * @brief See if the given token (already known to be a TokenName) references a user-defined constant,
		 *        eg, something declared like 'integer constant FOO = 3;'
		 * @param token = points to the TokenName
		 * @returns null: it's not such a constant
		 *          else: corresponding constant value
		 *                token advanced past the name
		 */
		private TokenRValConst TryUserDefConst (ref Token token)
		{
			string name = ((TokenName)token).val;
			TokenDeclVar declVar = null;

			for (TokenStmtBlock stmtBlock = currentStmtBlock; stmtBlock != null; stmtBlock = stmtBlock.outerStmtBlock) {
				if (stmtBlock.variables.TryGetValue (name, out declVar)) goto found;
			}
			if (tokenScript.vars.TryGetValue (name, out declVar)) goto found;
			return null;
		found:
			if (!declVar.constant) return null;
			token = token.nextToken;
			return (TokenRValConst)(declVar.init);
		}

		/**
		 * @brief decode binary operator token
		 * @param token = points to token to decode
		 * @returns null: invalid operator token
		 *          else: operator token and precedence
		 */
		private BinOp GetOperator (ref Token token)
		{
			BinOp binOp = new BinOp ();
			if (precedence.TryGetValue (token.GetType (), out binOp.preced)) {
				binOp.token = (TokenKw)token;
				token = token.nextToken;
				return binOp;
			}

			if ((token is TokenKwSemi) || (token is TokenKwBrcOpen) || (token is TokenKwBrcClose)) {
				ErrorMsg (token, "premature expression end");
			} else {
				ErrorMsg (token, "invalid operator");
			}
			token = SkipPastSemi (token);
			return null;
		}

		private class BinOp {
			public BinOp pop;
			public TokenKw token;
			public int preced;
		}

		/**
		 * @brief If the operands are constants and the operator can do it here, perform the operation and return the
		 *        result as a new constant token.  Otherwise, return an R-value expression token that will be used to
		 *        generate code to perform the operation at runtime.
		 * @param left  = left-hand operand
		 * @param binOp = operator
		 * @param right = right-hand operand
		 * @returns resultant constant or expression
		 */
		private TokenRVal PerformBinOp (TokenRVal left, BinOp binOp, TokenRVal right)
		{
			/*
			 * Maybe both operands are constants and the operator knows how to handle them.
			 * If so, perform computation and return the resultant constant.
			 */
			if ((left is TokenRValConst) && (right is TokenRValConst)) {
				object val;
				try {
					val = binOp.token.binOpConst (((TokenRValConst)left).val, ((TokenRValConst)right).val);
				} catch {
					val = null;
				}
				if (val != null) {
					return new TokenRValConst (binOp.token, val);
				}
				////???? throw exception or print warning ????////
			}

			/*
			 * Otherwise, output token that encapsulates the expression for code generation.
			 */
			return new TokenRValOpBin (left, binOp.token, right);
		}

		/**
		 * @brief If the operand is a constant and the operator can do it here, perform the operation and return the
		 *        result as a new constant token.  Otherwise, return an R-value expression token that will be used to
		 *        generate code to perform the operation at runtime.
		 * @param unOp  = operator
		 * @param right = right-hand operand
		 * @returns resultant constant or expression
		 */
		private TokenRVal PerformUnOp (Token unOp, TokenRVal right)
		{
			/*
			 * Maybe the operand is a constant and the operator knows how to handle them.
			 * If so, perform computation and return the resultant constant.
			 */
			if (right is TokenRValConst) {
				object val;
				try {
					val = ((TokenKw)unOp).unOpConst (((TokenRValConst)right).val);
				} catch {
					val = null;
				}
				if (val != null) {
					return new TokenRValConst (unOp, val);
				}
				////???? throw exception or print warning ????////
			}

			/*
			 * Otherwise, output token that encapsulates the expression for code generation.
			 */
			return new TokenRValOpUn (unOp, right);
		}

		/**
		 * @brief parse out a parenthesized expression.
		 * @param token = points to open parenthesis
		 * @returns null: invalid expression
		 *          else: parenthesized expression token or constant token
		 *          token = points past the close parenthesis
		 */
		private TokenRVal ParseRValParen (ref Token token)
		{
			if (!(token is TokenKwParOpen)) {
				ErrorMsg (token, "expecting (");
				token = SkipPastSemi (token);
				return null;
			}
			TokenRValParen tokenRValParen = new TokenRValParen (token);
			token = token.nextToken;
			tokenRValParen.rVal = ParseRVal (ref token, parCloseOnly);
			if (tokenRValParen.rVal == null) return null;
			if (tokenRValParen.rVal is TokenRValConst) return tokenRValParen.rVal;
			tokenRValParen.sideEffects = tokenRValParen.rVal.sideEffects;
			return tokenRValParen;
		}

		/**
		 * @brief Split a comma'd RVal into separate expressions
		 * @param rValAll = expression containing commas
		 * @returns number of comma separated values
		 *          rVals = values in a null-terminated list linked by rVals.nextToken
		 *          sideEffects |= some of the values have side effects
		 */
		private int SplitCommaRVals (TokenRVal rValAll, out TokenRVal rVals, ref bool sideEffects)
		{
			if (!(rValAll is TokenRValOpBin) || !(((TokenRValOpBin)rValAll).opcode is TokenKwComma)) {
				rVals = rValAll;
				if (rVals.nextToken != null) throw new Exception ("expected null");
				sideEffects |= rValAll.sideEffects;
				return 1;
			}
			TokenRValOpBin opBin = (TokenRValOpBin)rValAll;
			TokenRVal rValLeft, rValRight;
			bool sel = false;
			bool ser = false;
			int leftCount  = SplitCommaRVals (opBin.rValLeft,  out rValLeft,  ref sel);
			int rightCount = SplitCommaRVals (opBin.rValRight, out rValRight, ref ser);
			rVals = rValLeft;
			while (rValLeft.nextToken != null) rValLeft = (TokenRVal)rValLeft.nextToken;
			rValLeft.nextToken = rValRight;
			sideEffects |= sel | ser;
			return leftCount + rightCount;
		}

		/**
		 * @brief output error message and remember that there is an error.
		 * @param token = what token is associated with the error
		 * @param message = error message string
		 */
		private void ErrorMsg (Token token, string message)
		{
			errors = true;
			token.ErrorMsg (message);
		}

		/**
		 * @brief Skip past the next semicolon (or matched braces)
		 * @param token = points to token to skip over
		 * @returns token just after the semicolon or close brace
		 */
		private Token SkipPastSemi (Token token)
		{
			int braceLevel = 0;

			while (!(token is TokenEnd)) {
				if ((token is TokenKwSemi) && (braceLevel == 0)) {
					return token.nextToken;
				}
				if (token is TokenKwBrcOpen) {
					braceLevel ++;
				}
				if ((token is TokenKwBrcClose) && (-- braceLevel <= 0)) {
					return token.nextToken;
				}
				token = token.nextToken;
			}
			return token;
		}
	}

	/**
	 * @brief Script-defined type declarations
	 */
	public abstract class TokenDeclSDType : Token {
		protected const byte CLASS     = 0;
		protected const byte DELEGATE  = 1;
		protected const byte INTERFACE = 2;

		/*
		 * Dictionary used when reading from object file that holds all script-defined types.
		 * Not complete though until all types have been read from the object file.
		 */
		private Dictionary<string, TokenDeclSDType> sdTypes;

		public TokenDeclSDType (Token t) : base (t) { }
		public abstract TokenTypeSDType MakeRefToken (Token t);
		public abstract Type GetSysType ();
		public abstract void WriteToFile (BinaryWriter objFileWriter);
		public abstract void ReadFromFile (BinaryReader objFileReader, TextWriter asmFileWriter);

		/**
		 * @brief Read one of these in from the object file.
		 * @param sdTypes = dictionary of script-defined types, not yet complete
		 * @param name = script-visible name of this type
		 * @param objFileReader = reads from the object file
		 * @param asmFileWriter = writes to the disassembly file (might be null)
		 */
		public static TokenDeclSDType ReadFromFile (Dictionary<string, TokenDeclSDType> sdTypes, string name, 
		                                            BinaryReader objFileReader, TextWriter asmFileWriter)
		{
			string file = objFileReader.ReadString ();
			int    line = objFileReader.ReadInt32 ();
			int    posn = objFileReader.ReadInt32 ();
			byte   code = objFileReader.ReadByte ();
			TokenName n = new TokenName (null, file, line, posn, name);
			TokenDeclSDType sdt;
			switch (code) {
				case CLASS: {
					sdt = new TokenDeclSDTypeClass (n);
					break;
				}
				case DELEGATE: {
					sdt = new TokenDeclSDTypeDelegate (n);
					break;
				}
				case INTERFACE: {
					sdt = new TokenDeclSDTypeInterface (n);
					break;
				}
				default: throw new Exception ();
			}
			sdt.sdTypes = sdTypes;
			sdt.ReadFromFile (objFileReader, asmFileWriter);
			return sdt;
		}

		/**
		 * @brief Convert a typename string to a type token
		 * @param name = script-visible name of token to create, 
		 *               either a script-defined type or an LSL-defined type
		 * @returns type token
		 */
		protected TokenType MakeTypeToken (string name)
		{
			TokenDeclSDType sdtdecl;
			if (sdTypes.TryGetValue (name, out sdtdecl)) return sdtdecl.MakeRefToken (this);
			return TokenType.FromLSLType (this, name);
		}
	}

	public class TokenDeclSDTypeClass : TokenDeclSDType {
		public TokenName name;
		public TokenDeclSDTypeClass extends;
		public List<TokenDeclSDTypeInterface> implements = new List<TokenDeclSDTypeInterface> ();
		public bool isAbstract;
		public Dictionary<string, TokenDeclVar>  fields  = new Dictionary<string, TokenDeclVar>  ();
		public Dictionary<string, TokenDeclFunc> methods = new Dictionary<string, TokenDeclFunc> ();

		public bool slotsAssigned;    // set true when slots have been assigned...
		public int numInstArrays;     // number of non-static array fields
		public int numInstFloats;     // number of non-static float fields
		public int numInstIntegers;   // number of non-static integer fields
		public int numInstLists;      // number of non-static list fields
		public int numInstObjects;    // number of non-static object fields
		public int numInstRotations;  // number of non-static rotation fields
		public int numInstStrings;    // number of non-static string fields
		public int numInstVectors;    // number of non-static vector fields
		public int numInstSDTClasses; // number of non-static sdt-class fields
		public int numInstVirtFuncs;  // number of virtual functions

		private string extendsStr;
		private List<StackedMethod> stackedMethods;

		public DynamicMethod[] vDynMeths;  // virtual method entrypoints
		public Type[] vMethTypes;          // virtual method delegate type

		public TokenDeclSDTypeClass (TokenName name) : base (name)
		{
			this.name = name;
		}

		public override TokenTypeSDType MakeRefToken (Token t)
		{
			return new TokenTypeSDTypeClass (t, this);
		}

		public override Type GetSysType ()
		{
			return typeof (XMRSDTypeClassInstance);
		}

		/**
		 * @brief Write enough out so we can reconstruct with ReadFromFile.
		 */
		public override void WriteToFile (BinaryWriter objFileWriter)
		{
			objFileWriter.Write (this.file);
			objFileWriter.Write (this.line);
			objFileWriter.Write (this.posn);
			objFileWriter.Write ((byte)CLASS);

			objFileWriter.Write (numInstArrays);
			objFileWriter.Write (numInstFloats);
			objFileWriter.Write (numInstIntegers);
			objFileWriter.Write (numInstLists);
			objFileWriter.Write (numInstObjects);
			objFileWriter.Write (numInstRotations);
			objFileWriter.Write (numInstStrings);
			objFileWriter.Write (numInstVectors);
			objFileWriter.Write (numInstSDTClasses);
			objFileWriter.Write (numInstVirtFuncs);

			if (extends == null) {
				objFileWriter.Write ("");
			} else {
				objFileWriter.Write (extends.name.val);
			}

			foreach (KeyValuePair<string, TokenDeclFunc> kvp in methods) {
				TokenDeclFunc meth = kvp.Value;
				if (meth.vTableIndex >= 0) {
					objFileWriter.Write (meth.vTableIndex);
					objFileWriter.Write (meth.ilGen.methName);
					objFileWriter.Write (meth.delType.decl.GetWholeSig ());
				}
			}
			objFileWriter.Write (-1);
		}

		/**
		 * @brief Reconstruct from the file.
		 */
		public override void ReadFromFile (BinaryReader objFileReader, TextWriter asmFileWriter)
		{
			numInstArrays     = objFileReader.ReadInt32 ();
			numInstFloats     = objFileReader.ReadInt32 ();
			numInstIntegers   = objFileReader.ReadInt32 ();
			numInstLists      = objFileReader.ReadInt32 ();
			numInstObjects    = objFileReader.ReadInt32 ();
			numInstRotations  = objFileReader.ReadInt32 ();
			numInstStrings    = objFileReader.ReadInt32 ();
			numInstVectors    = objFileReader.ReadInt32 ();
			numInstSDTClasses = objFileReader.ReadInt32 ();
			numInstVirtFuncs  = objFileReader.ReadInt32 ();

			extendsStr = objFileReader.ReadString ();

			stackedMethods = new List<StackedMethod> ();
			int vTableIndex;
			while ((vTableIndex = objFileReader.ReadInt32 ()) >= 0) {
				StackedMethod sm;
				sm.methVTI  = vTableIndex;
				sm.methName = objFileReader.ReadString ();
				sm.methSig  = objFileReader.ReadString ();
				stackedMethods.Add (sm);
			}
		}

		private struct StackedMethod {
			public int methVTI;
			public string methName;
			public string methSig;
		}

		/**
		 * @brief Called after all dynamic method code has been generated to fill in vDynMeths and vMethTypes
		 */
		public void FillVTables (ScriptObjCode scriptObjCode)
		{
			if (extendsStr != null) {
				if (extendsStr != "") {
					extends = (TokenDeclSDTypeClass)scriptObjCode.sdObjTypes[extendsStr];
					extends.FillVTables (scriptObjCode);
				}
				extendsStr = null;
			}

			if ((numInstVirtFuncs > 0) && (stackedMethods != null)) {

				/*
				 * Allocate arrays big enough for mine plus type we are extending.
				 */
				vDynMeths  = new DynamicMethod[numInstVirtFuncs];
				vMethTypes = new Type[numInstVirtFuncs];

				/*
				 * Fill in low parts from type we are extending.
				 */
				if (extends != null) {
					int n = extends.numInstVirtFuncs;
					for (int i = 0; i < n; i ++) {
						vDynMeths[i]  = extends.vDynMeths[i];
						vMethTypes[i] = extends.vMethTypes[i];
					}
				}

				/*
				 * Fill in high parts with my own methods.
				 * Might also overwrite lower ones with 'override' methods.
				 */
				foreach (StackedMethod sm in stackedMethods) {
					int i = sm.methVTI;
					string methName  = sm.methName;
					DynamicMethod dm = scriptObjCode.dynamicMethods[methName];
					vDynMeths[i] = dm;
					Type retType = dm.ReturnType;
					ParameterInfo[] pi = dm.GetParameters ();
					Type[] argTypes = new Type[pi.Length];
					for (int j = 0; j < pi.Length; j ++) {
						argTypes[j] = pi[j].ParameterType;
					}
					vMethTypes[i] = DelegateCommon.GetType (retType, argTypes, sm.methSig);
				}
				stackedMethods = null;
			}
		}
	}

	public class TokenDeclSDTypeDelegate : TokenDeclSDType {
		public TokenName name;

		private TokenType retType;
		private TokenType[] argTypes;

		private string argSig;
		private string wholeSig;
		private Type sysType;
		private Type retSysType;
		private Type[] argSysTypes;

		private string retStr;
		private string[] argStrs;

		private static Dictionary<string, TokenDeclSDTypeDelegate> inlines = new Dictionary<string, TokenDeclSDTypeDelegate> ();
		private static Dictionary<Type, string> inlrevs = new Dictionary<Type, string> ();

		public TokenDeclSDTypeDelegate (TokenName name) : base (name)
		{
			this.name = name;
		}
		public void SetRetArgTypes (TokenType retType, TokenType[] argTypes)
		{
			this.retType  = retType;
			this.argTypes = argTypes;
		}

		public override TokenTypeSDType MakeRefToken (Token t)
		{
			return new TokenTypeSDTypeDelegate (t, this);
		}

		/**
		 * @brief Get system type for the whole delegate.
		 */
		public override Type GetSysType ()
		{
			if (sysType == null) FillInStuff ();
			return sysType;
		}

		/**
		 * @brief Get the function's return value type (TokenTypeVoid if void, never null)
		 */
		public TokenType GetRetType ()
		{
			if (retType == null) FillInStuff ();
			return retType;
		}

		/**
		 * @brief Get the function's argument types
		 */
		public TokenType[] GetArgTypes ()
		{
			if (argTypes == null) FillInStuff ();
			return argTypes;
		}

		/**
		 * @brief Get signature for the whole delegate, eg, "void(integer,list)"
		 */
		public string GetWholeSig ()
		{
			if (wholeSig == null) FillInStuff ();
			return wholeSig;
		}

		/**
		 * @brief Get signature for the arguments, eg, "(integer,list)"
		 */
		public string GetArgSig ()
		{
			if (argSig == null) FillInStuff ();
			return argSig;
		}

		/**
		 * @brief Find out how to create one of these delegates.
		 */
		public ConstructorInfo GetConstructorInfo ()
		{
			if (sysType == null) FillInStuff ();
			return sysType.GetConstructor (DelegateCommon.constructorArgTypes);
		}

		/**
		 * @brief Find out how to call what one of these delegates points to.
		 */
		public MethodInfo GetInvokerInfo ()
		{
			if (sysType == null) FillInStuff ();
			return sysType.GetMethod ("Invoke", argSysTypes);
		}

		/**
		 * @brief Write enough out to a file so delegate can be reconstructed in ReadFromFile().
		 */
		public override void WriteToFile (BinaryWriter objFileWriter)
		{
			objFileWriter.Write (this.file);
			objFileWriter.Write (this.line);
			objFileWriter.Write (this.posn);
			objFileWriter.Write ((byte)DELEGATE);

			objFileWriter.Write (retType.ToString ());
			int nArgs = argTypes.Length;
			objFileWriter.Write (nArgs);
			for (int i = 0; i < nArgs; i ++) {
				objFileWriter.Write (argTypes[i].ToString ());
			}
		}

		/**
		 * @brief Read that data from file so we can reconstruct.
		 *        Don't actually reconstruct yet in case any forward-referenced types are undefined.
		 */
		public override void ReadFromFile (BinaryReader objFileReader, TextWriter asmFileWriter)
		{
			retStr = objFileReader.ReadString ();
			int nArgs = objFileReader.ReadInt32 ();
			if (asmFileWriter != null) {
				asmFileWriter.Write ("  delegate " + retStr + " " + name.val + "(");
			}
			argStrs = new string[nArgs];
			for (int i = 0; i < nArgs; i ++) {
				argStrs[i] = objFileReader.ReadString ();
				if (asmFileWriter != null) {
					if (i > 0) asmFileWriter.Write (",");
					asmFileWriter.Write (argStrs[i]);
				}
			}
			if (asmFileWriter != null) {
				asmFileWriter.WriteLine (");");
			}
		}

		/**
		 * @brief Fill in missing internal data.
		 */
		private void FillInStuff ()
		{
			int nArgs;

			/*
			 * This happens when the node was restored via ReadFromFile().
			 * It leaves the types in retStr/argStrs for resolution after
			 * all definitions have been read from the object file in case
			 * there are forward references.
			 */
			if (retType == null) {
				retType = MakeTypeToken (retStr);
			}
			if (argTypes == null) {
				nArgs = argStrs.Length;
				argTypes = new TokenType[nArgs];
				for (int i = 0; i < nArgs; i ++) {
					argTypes[i] = MakeTypeToken (argStrs[i]);
				}
			}

			/*
			 * Fill in system types from token types.
			 * Might as well build the signature strings too from token types.
			 */
			retSysType = retType.ToSysType();

			nArgs = argTypes.Length;
			StringBuilder sb = new StringBuilder ();
			argSysTypes = new Type[nArgs];
			sb.Append ('(');
			for (int i = 0; i < nArgs; i ++) {
				if (i > 0) sb.Append (',');
				sb.Append (argTypes[i].ToString ());
				argSysTypes[i] = argTypes[i].ToSysType ();
			}
			sb.Append (')');
			argSig = sb.ToString ();
			wholeSig = retType.ToString () + argSig;

			/*
			 * Now we can create a system delegate type from the given
			 * return and argument types.  Give it an unique name using
			 * the whole signature string.
			 */
			sysType = DelegateCommon.GetType (retSysType, argSysTypes, wholeSig);
		}

		/**
		 * @brief create delegate reference token for inline functions.
		 *        there is just one instance of these per inline function
		 *        shared by all scripts, and it is just used when the
		 *        script engine is just loaded.
		 */
		public static TokenDeclSDTypeDelegate CreateInline (Type retType, string argsigst)
		{
			TokenDeclSDTypeDelegate decldel;

			/*
			 * Name it after the whole signature string.
			 * Fortunately retType is a basic LSL type.
			 */
			string retsig = TokenType.FromSysType (null, retType).ToString ();
			string inlname = "$inlines$" + retsig + argsigst;
			if (!inlines.TryGetValue (inlname, out decldel)) {

				TokenName name = new TokenName (null, "inlines", 0, 0, inlname);

				/*
				 * Fortunately argsigst is simply formed by (type,...)
				 * and consists of only the basic LSL types.
				 */
				List<TokenType> args = new List<TokenType> ();
				for (int i = 0; i < argsigst.Length; i ++) {
					char c = argsigst[i];
					if (c == '(') continue;
					if (c == ')') continue;
					if (c == ',') continue;
					int j = argsigst.IndexOf (',', i);
					if (j < 0) j = argsigst.IndexOf (')');
					args.Add (TokenType.FromLSLType (name, argsigst.Substring (i, j - i)));
					i = j;
				}

				/*
				 * Now we can create the corresponding declaration and link to it
				 */
				decldel          = new TokenDeclSDTypeDelegate (name);
				decldel.retType  = TokenType.FromSysType (name, retType);
				decldel.argTypes = args.ToArray ();
				inlines.Add (inlname, decldel);
				inlrevs.Add (decldel.GetSysType(), inlname);
			}
			return decldel;
		}

		public static string TryGetInlineName (Type sysType)
		{
			string name;
			if (!inlrevs.TryGetValue (sysType, out name)) return null;
			return name;
		}

		public static Type TryGetInlineSysType (string name)
		{
			TokenDeclSDTypeDelegate decl;
			if (!inlines.TryGetValue (name, out decl)) return null;
			return decl.GetSysType ();
		}
	}

	public class TokenDeclSDTypeInterface : TokenDeclSDType {
		public TokenName name;

		public TokenDeclSDTypeInterface (TokenName name) : base (name)
		{
			this.name = name;
		}

		public override TokenTypeSDType MakeRefToken (Token t)
		{
			return new TokenTypeSDTypeInterface (t, this);
		}

		public override Type GetSysType ()
		{
			throw new Exception ("not implemented");
		}
		public override void WriteToFile (BinaryWriter objFileWriter)
		{
			throw new Exception ("not implemented");
		}
		public override void ReadFromFile (BinaryReader objFileReader, TextWriter asmFileWriter)
		{
			throw new Exception ("not implemented");
		}
	}

	/**
	 * @brief Script-defined type references.
	 */
	public abstract class TokenTypeSDType : TokenType {
		public TokenTypeSDType (TokenErrorMessage emsg, string file, int line, int posn) : base (emsg, file, line, posn) { }
		public TokenTypeSDType (Token t) : base (t) { }
	}

	public class TokenTypeSDTypeClass : TokenTypeSDType {
		private static readonly FieldInfo gblSDTClassesFieldInfo  = typeof (XMRInstAbstract).GetField ("gblSDTClasses");
		private static readonly FieldInfo sdtcSDTClassesFieldInfo = typeof (XMRSDTypeClassInstance).GetField ("sdtcSDTClasses");
 
		public TokenDeclSDTypeClass decl;
		public TokenTypeSDTypeClass (Token t, TokenDeclSDTypeClass decl) : base (t)
		{
			this.decl = decl;
		}
		public override Type ToSysType ()
		{
			return null;
		}
		public override void AssignGlobalVarSlot (TokenDeclVar declVar, ScriptObjCode scriptObjCode)
		{
			declVar.vTableArray = gblSDTClassesFieldInfo;
			declVar.vTableIndex = scriptObjCode.numGblSDTClasses ++;
		}
		public override void AssignSDTClassFieldSlot (TokenDeclVar declVar, TokenDeclSDTypeClass sdtClass)
		{
			declVar.vTableArray = sdtcSDTClassesFieldInfo;
			declVar.vTableIndex = sdtClass.numInstSDTClasses ++;
		}
	}

	public class TokenTypeSDTypeDelegate : TokenTypeSDType {
		private static readonly FieldInfo gblObjectsFieldInfo  = typeof (XMRInstAbstract).GetField ("gblObjects");
		private static readonly FieldInfo sdtcObjectsFieldInfo = typeof (XMRSDTypeClassInstance).GetField ("sdtcObjects");

		public TokenDeclSDTypeDelegate decl;

		private static ulong anonDeclDel = 0;

		/**
		 * @brief create a reference to an explicitly declared delegate
		 * @param t = where the reference is being made in the source file
		 * @param decl = the explicit delegate declaration
		 */
		public TokenTypeSDTypeDelegate (Token t, TokenDeclSDTypeDelegate decl) : base (t)
		{
			this.decl = decl;
		}

		/**
		 * @brief create a reference to a possibly anonymous delegate
		 * @param t = where the reference is being made in the source file
		 * @param retType = return type (TokenTypeVoid if void, never null)
		 * @param argTypes = script-visible argument types
		 * @param tokenScript = what script this is part of
		 */
		public TokenTypeSDTypeDelegate (Token t, TokenType retType, TokenType[] argTypes, TokenScript tokenScript) : base (t)
		{
			TokenDeclSDTypeDelegate decldel;

			/*
			 * See if we already have a matching declared one cataloged.
			 */
			int nArgs = argTypes.Length;
			foreach (TokenDeclSDType decl in tokenScript.sdSrcTypes.Values) {
				if (decl is TokenDeclSDTypeDelegate) {
					decldel         = (TokenDeclSDTypeDelegate)decl;
					TokenType   rt  = decldel.GetRetType  ();
					TokenType[] ats = decldel.GetArgTypes ();
					if ((rt.ToSysType () == retType.ToSysType ()) && (ats.Length == nArgs)) {
						for (int i = 0; i < nArgs; i ++) {
							if (ats[i].ToSysType () != argTypes[i].ToSysType ()) goto nomatch;
						}
						this.decl = decldel;
						return;
					}
				}
			nomatch:;
			}

			/*
			 * No such luck, create a new anonymous declaration.
			 */
			string namestr = ".anondel." + (++ anonDeclDel);
			TokenName name = new TokenName (t, namestr);
			decldel        = new TokenDeclSDTypeDelegate (name);
			decldel.SetRetArgTypes (retType, argTypes);
			this.decl = decldel;
		}

		public override Type ToSysType ()
		{
			return decl.GetSysType ();
		}

		public override string ToString ()
		{
			return decl.name.val;
		}

		/**
		 * @brief Assign slots in the gblObjects[] array because we have to typecast out in any case.
		 *        Likewise with the sdtcObjects[] array.
		 */
		public override void AssignGlobalVarSlot (TokenDeclVar declVar, ScriptObjCode scriptObjCode)
		{
			declVar.vTableArray = gblObjectsFieldInfo;
			declVar.vTableIndex = scriptObjCode.numGblObjects ++;
		}
		public override void AssignSDTClassFieldSlot (TokenDeclVar declVar, TokenDeclSDTypeClass sdtClass)
		{
			declVar.vTableArray = sdtcObjectsFieldInfo;
			declVar.vTableIndex = sdtClass.numInstObjects ++;
		}

		/**
		 * @brief create delegate reference token for inline functions.
		 */
		public TokenTypeSDTypeDelegate (Type retType, string argsigst) : base (null, "inlines", 0, 0)
		{
			this.decl = TokenDeclSDTypeDelegate.CreateInline (retType, argsigst);
		}
	}

	public class TokenTypeSDTypeInterface : TokenTypeSDType {
		public TokenDeclSDTypeInterface decl;
		public TokenTypeSDTypeInterface (Token t, TokenDeclSDTypeInterface decl) : base (t)
		{
			this.decl = decl;
		}

		public override Type ToSysType ()
		{
			return null;
		}
	}

	/**
	 * @brief function argument list declaration
	 */
	public class TokenArgDecl : Token
	{
		public TokenType[] types;
		public TokenName[] names;
		public CompValu[]  locns;  // used by codegen to keep track of locations

		public TokenArgDecl (Token original) : base (original) { }

		/**
		 * @brief Get argument signature string, eg, "(list,vector,integer)"
		 */
		private string argSig = null;
		public string GetArgSig ()
		{
			if (argSig == null) {
				StringBuilder sb = new StringBuilder ("(");
				bool first = true;
				foreach (TokenType t in types) {
					if (!first) sb.Append (',');
					sb.Append (t.ToString ());
					first = false;
				}
				sb.Append (")");
				argSig = sb.ToString ();
			}
			return argSig;
		}

		public override void WriteOut (TokenWriter writer)
		{
			int n = types.Length;
			writer.Write (n);
			for (int i = 0; i < n; i ++) {
				writer.Write (types[i]);
				writer.Write (names[i]);
			}
		}

		public override void ReadIn (TokenReader reader)
		{
			int n = reader.ReadInt ();
			types = new TokenType[n];
			names = new TokenName[n];
			locns = new CompValu[n];
			for (int i = 0; i < n; i ++) {
				types[i] = (TokenType)reader.ReadToken ();
				names[i] = (TokenName)reader.ReadToken ();
			}
		}
	}

	/**
	 * @brief encapsulates a function definition
	 */
	public class TokenDeclFunc : Token {

		public TokenType retType;            // new TokenTypeVoid (token) if void; NEVER null
		public TokenName funcNameSig;        // function name including argumet signature, eg, "PrintStuff(list,string)"
		public TokenArgDecl argDecl;         // argument list prototypes
		public TokenStmtBlock body;          // statements (null iff abstract)
		public uint sdtFlags;                // abstract/override/static/virtual
		public Dictionary<string, TokenStmtLabel> labels = new Dictionary<string, TokenStmtLabel> ();
		                                     // all labels defined in the function
		public LinkedList<TokenDeclVar> localVars = new LinkedList<TokenDeclVar> ();
		                                     // all local variables declared by this function
		                                     // - doesn't include argument variables

		public TokenTypeSDTypeDelegate delType;
		                                     // the function's script-visible type,
		                                     // includes return type and all script-visible argument types

		public int vTableIndex = -1;         // if script-defined type method, vtable index
		                                     //  <0: non-virtual; >=0: virtual
		public ScriptMyILGen ilGen;          // codegen stores emitted code here

		public TokenDeclFunc (Token original) : base (original) { }

		public string GetSimpleName ()
		{
			string nameWithSig = funcNameSig.val;
			string simpleName  = nameWithSig.Substring (0, nameWithSig.IndexOf ('('));
			return simpleName;
		}

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (retType);
			writer.Write (funcNameSig);
			writer.Write (argDecl);
			writer.Write (body);

			////???? the below probably should be rederived when reconstructed
			writer.Write (labels.Count);
			foreach (KeyValuePair<string, TokenStmtLabel> kvp in labels) {
				writer.Write (kvp.Value);
			}
			writer.Write (localVars.Count);
			foreach (TokenDeclVar val in localVars) {
				writer.Write (val);
			}
		}

		public override void ReadIn (TokenReader reader)
		{
			retType     = (TokenType)     reader.ReadToken ();
			funcNameSig = (TokenName)     reader.ReadToken ();
			argDecl     = (TokenArgDecl)  reader.ReadToken ();
			body        = (TokenStmtBlock)reader.ReadToken ();

			////???? the below probably should be rederived when reconstructed

			int nLabels = reader.ReadInt ();
			while (-- nLabels >= 0) {
				TokenStmtLabel label = (TokenStmtLabel)reader.ReadToken ();
				labels[label.name.val] = label;
			}
			int nLocals = reader.ReadInt ();
			while (-- nLocals >= 0) {
				TokenDeclVar local = (TokenDeclVar)reader.ReadToken ();
				localVars.AddLast (local);
			}
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			if (!(retType is TokenTypeVoid)) {
				writeSrc (retType.ToString () + " ");
			}
			writeSrc (GetSimpleName () + " (");
			for (int i = 0; i < argDecl.types.Length; i ++) {
				if (i > 0) writeSrc (", ");
				writeSrc (argDecl.types[i].ToString () + " " + argDecl.names[i].val);
			}
			writeSrc (")\n");
			body.Reconst (writeSrc);
			writeSrc ("\n");
		}
#endif
	}

	/**
	 * @brief encapsulate a state declaration in a single token
	 */
	public class TokenDeclState : Token {

		public TokenName name;  // null for default state
		public TokenStateBody body;

		public TokenDeclState (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (name);
			writer.Write (body);
		}

		public override void ReadIn (TokenReader reader)
		{
			name = (TokenName)     reader.ReadToken ();
			body = (TokenStateBody)reader.ReadToken ();
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			if (name == null) {
				writeSrc ("default {");
			} else {
				writeSrc ("state " + name.val + " {");
			}
			body.Reconst (writeSrc);
			writeSrc ("}");
		}
#endif
	}

	public class TokenDeclVar : Token {

		public TokenType type;
		public TokenName name;
		public TokenRVal init;  // null if none
		public bool constant;
		public uint sdtFlags;

		public CompValu location;  // used by codegen to keep track of location
		public FieldInfo vTableArray;
		public int vTableIndex;

		public TokenDeclVar heapTracker;

		/**
		 * @brief Set up a variable declaration statement token.
		 * @param original = original source token that triggered definition
		 *                   (for error messages)
		 * @param func = null: global variable
		 *               else: local to the given function
		 */
		public TokenDeclVar (Token original, TokenDeclFunc func) : base (original)
		{
			if (func != null) {
				func.localVars.AddLast (this);
			}
		}

		/**
		 * @brief Serialization/Deserialization.
		 */
		public TokenDeclVar (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (type);
			writer.Write (name);
			writer.Write (init);
		}

		public override void ReadIn (TokenReader reader)
		{
			type = (TokenType)reader.ReadToken ();
			name = (TokenName)reader.ReadToken ();
			init = (TokenRVal)reader.ReadToken ();
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			writeSrc (type.ToString () + " " + name.val);
			if (init != null) {
				writeSrc (" = ");
				init.Reconst (writeSrc);
			}
			writeSrc (";");
		}
#endif
	}


	/**
	 * @brief any expression that can go on left side of an "="
	 */
	public class TokenLVal : TokenRVal {

		public TokenLVal (Token original) : base (original) { }
	}

	/**
	 * @brief an element of an array is an L-value
	 */
	public class TokenLValArEle : TokenLVal {
		public TokenRVal baseRVal;
		public TokenRVal subRVal;

		public TokenLValArEle (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (baseRVal);
			writer.Write (subRVal);
		}

		public override void ReadIn (TokenReader reader)
		{
			baseRVal = (TokenRVal)reader.ReadToken ();
			subRVal  = (TokenRVal)reader.ReadToken ();
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			baseRVal.Reconst (writeSrc);
			writeSrc ("[");
			subRVal.Reconst (writeSrc);
			writeSrc ("]");
		}
#endif
	}

	/**
	 * @brief a field within an L-value struct is an L-value
	 */
	public class TokenLValIField : TokenLVal {
		public TokenRVal baseRVal;
		public TokenName field;

		public TokenLValIField (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (baseRVal);
			writer.Write (field);
		}

		public override void ReadIn (TokenReader reader)
		{
			baseRVal = (TokenRVal)reader.ReadToken ();
			field    = (TokenName)reader.ReadToken ();
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			baseRVal.Reconst (writeSrc);
			writeSrc (".");
			writeSrc (field.val);
		}
#endif
	}

	/**
	 * @brief a name is being used as an L-value
	 */
	public class TokenLValName : TokenLVal {
		public TokenName name;

		public TokenLValName (TokenName original) : base (original)
		{
			this.name = original;
		}

		/**
		 * @brief Serialization/Deserialization.
		 */
		public TokenLValName (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (name);
		}

		public override void ReadIn (TokenReader reader)
		{
			name = (TokenName)reader.ReadToken ();
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			writeSrc (name.val);
		}
#endif
	}

	/**
	 * @brief a static field within a struct is an L-value
	 */
	public class TokenLValSField : TokenLVal {
		public TokenType baseType;
		public TokenName fieldName;

		public TokenLValSField (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (baseType);
			writer.Write (fieldName);
		}

		public override void ReadIn (TokenReader reader)
		{
			baseType  = (TokenType)reader.ReadToken ();
			fieldName = (TokenName)reader.ReadToken ();
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			writeSrc (baseType.ToString ());
			writeSrc (".");
			writeSrc (fieldName.val);
		}
#endif
	}

	/**
	 * @brief any expression that can go on right side of "="
	 */
	public class TokenRVal : Token {
		public bool sideEffects = false;  // the value (or some sub-value) has side effects
		                                  // - constants are always false
		                                  // - we assume calls always have side effects
		                                  // - post increment/decrement are always true
		                                  // - any assignment operator (=, +=, etc) always true
		                                  // - all others inherit from their operands
		public TokenRVal (Token original) : base (original) { }
	}

	/**
	 * @brief a postfix operator and corresponding L-value
	 */
	public class TokenRValAsnPost : TokenRVal {
		public TokenLVal lVal;
		public Token postfix;

		public TokenRValAsnPost (Token original) : base (original) {
			sideEffects = true;
		}

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (lVal);
			writer.Write (postfix);
		}

		public override void ReadIn (TokenReader reader)
		{
			lVal = (TokenLVal)reader.ReadToken ();
			postfix = reader.ReadToken ();
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			lVal.Reconst (writeSrc);
			writeSrc (" " + postfix.ToString ());
		}
#endif
	}

	/**
	 * @brief a prefix operator and corresponding L-value
	 */
	public class TokenRValAsnPre : TokenRVal {
		public Token prefix;
		public TokenLVal lVal;

		public TokenRValAsnPre (Token original) : base (original) {
			sideEffects = true;
		}

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (prefix);
			writer.Write (lVal);
		}

		public override void ReadIn (TokenReader reader)
		{
			prefix = reader.ReadToken ();
			lVal = (TokenLVal)reader.ReadToken ();
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			writeSrc (prefix.ToString () + " ");
			lVal.Reconst (writeSrc);
		}
#endif
	}

	/**
	 * @brief calling a function or method, ie, may have side-effects
	 */
	public class TokenRValCall : TokenRVal {

		public TokenRVal meth;  // TokenLValName or TokenLValField
		public TokenRVal args;  // null-terminated TokenRVal list
		public int nArgs;       // number of elements in args

		public TokenRValCall (Token original) : base (original) {
			sideEffects = true;
		}

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (meth);
			writer.Write (nArgs);
			TokenRVal arg = args;
			for (int i = 0; i < nArgs; i ++) {
				writer.Write (arg);
				arg = (TokenRVal)arg.nextToken;
			}
		}

		public override void ReadIn (TokenReader reader)
		{
			meth  = (TokenLVal)reader.ReadToken ();
			nArgs = reader.ReadInt ();
			Token lastArg = null;
			for (int i = 0; i < nArgs; i ++) {
				TokenRVal arg = (TokenRVal)reader.ReadToken ();
				if (lastArg == null) {
					args = arg;
				} else {
					lastArg.nextToken = arg;
				}
				lastArg = arg;
			}
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			meth.Reconst (writeSrc);
			writeSrc (" (");
			for (Token t = args; t != null; t = t.nextToken) {
				if (t != args) writeSrc (", ");
				t.Reconst (writeSrc);
			}
			writeSrc (")");
		}
#endif
	}

	/**
	 * @brief encapsulates a typecast, ie, (type)
	 */
	public class TokenRValCast : TokenRVal {
		public TokenType castTo;
		public TokenRVal rVal;

		public TokenRValCast (TokenType type, TokenRVal value) : base (type)
		{
			castTo = type;
			rVal   = value;
			sideEffects = value.sideEffects;
		}

		/**
		 * @brief Serialization/Deserialization.
		 */
		public TokenRValCast (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (castTo);
			writer.Write (rVal);
		}

		public override void ReadIn (TokenReader reader)
		{
			castTo = (TokenType)reader.ReadToken ();
			rVal   = (TokenRVal)reader.ReadToken ();
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			writeSrc ("(" + castTo.ToString () + ")");
			rVal.Reconst (writeSrc);
		}
#endif
	}

	/**
	 * @brief all constants supposed to end up here
	 */
	public enum TokenRValConstType : byte { FLOAT = 0, INT = 1, STRING = 2 };
	public class TokenRValConst : TokenRVal {
		public object val;	// always a system type (int, SCRIPTFLOAT, string)
		public TokenRValConstType type;
		public TokenRValConst (Token original, object value) : base (original) {
			val = value;
			     if (val is int) type = TokenRValConstType.INT;
			else if (val is SCRIPTFLOAT) type = TokenRValConstType.FLOAT;
			else if (val is string) type = TokenRValConstType.STRING;
			else throw new Exception ("invalid constant type " + val.GetType ());
		}

		public TokenRValConst (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write ((byte)type);
			switch (type) {
				case TokenRValConstType.FLOAT:  { writer.Write ((SCRIPTFLOAT)val); break; }
				case TokenRValConstType.INT:    { writer.Write ((int)val);         break; }
				case TokenRValConstType.STRING: { writer.Write ((string)val);      break; }
				default: throw new Exception ("unknown type");
			}
		}

		public override void ReadIn (TokenReader reader)
		{
			type = (TokenRValConstType)reader.ReadByte ();
			switch (type) {
				case TokenRValConstType.FLOAT:  { val = reader.ReadScriptFloat (); break; }
				case TokenRValConstType.INT:    { val = reader.ReadInt ();         break; }
				case TokenRValConstType.STRING: { val = reader.ReadString ();      break; }
				default: throw new Exception ("unknown type");
			}
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			object v = val;
			     if (v is int) writeSrc (((int)v).ToString());
			else if (v is SCRIPTFLOAT) writeSrc (((SCRIPTFLOAT)v).ToString());
			else if (v is string) ReconstString ((string)v, writeSrc);
			else throw new Exception ("unknown const type " + v.GetType ());
		}

		private static void ReconstString (string s, SrcWriter writeSrc)
		{
			StringBuilder sb = new StringBuilder ();
			sb.Append ('"');
			for (int i = 0; i < s.Length; i ++) {
				char c = s[i];
				if ((c == '"') || (c == '\\')) {
					sb.Append ('\\');
				}
				if (c == '\n') {
					sb.Append ('\\');
					c = 'n';
				}
				sb.Append (c);
			}
			sb.Append ('"');
			writeSrc (sb.ToString ());
		}
#endif
	}

	public class TokenRValCVSField : TokenRVal {
		public CompValuSField cvsf;
		public TokenRValCVSField (Token original, CompValuSField cvsf) : base (original) {
			this.cvsf = cvsf;
		}
	}

	/**
	 * @brief encapsulation of <rval> is <typeexp>
	 */
	public class TokenRValIsType : TokenRVal {
		public TokenRVal    rValExp;
		public TokenTypeExp typeExp;

		public TokenRValIsType (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (rValExp);
			writer.Write (typeExp);
		}

		public override void ReadIn (TokenReader reader)
		{
			rValExp = (TokenRVal)   reader.ReadToken ();
			typeExp = (TokenTypeExp)reader.ReadToken ();
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			rValExp.Reconst (writeSrc);
			writeSrc (" is ");
			typeExp.Reconst (writeSrc);
		}
#endif
	}

	/**
	 * @brief an R-value enclosed in brackets is an LSLList
	 */
	public class TokenRValList : TokenRVal {

		public TokenRVal rVal;  // null-terminated list of TokenRVal objects
		public int nItems;

		public TokenRValList (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (nItems);
			Token t = rVal;
			for (int i = 0; i < nItems; i ++) {
				writer.Write (t);
				t = t.nextToken;
			}
		}

		public override void ReadIn (TokenReader reader)
		{
			nItems = reader.ReadInt ();
			Token lastRVal = null;
			for (int i = 0; i < nItems; i ++) {
				TokenRVal thisRVal = (TokenRVal)reader.ReadToken ();
				if (lastRVal == null) {
					rVal = thisRVal;
				} else {
					lastRVal.nextToken = thisRVal;
				}
				lastRVal = thisRVal;
			}
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			bool first = true;
			writeSrc ("[");
			for (Token t = rVal; t != null; t = t.nextToken) {
				if (!first) writeSrc (", ");
				t.Reconst (writeSrc);
				first = false;
			}
			writeSrc ("]");
		}
#endif
	}

	/**
	 * @brief a binary operator and its two operands
	 */
	public class TokenRValOpBin : TokenRVal {
		public TokenRVal rValLeft;
		public Token opcode;
		public TokenRVal rValRight;

		public TokenRValOpBin (TokenRVal left, Token op, TokenRVal right) : base (op)
		{
			rValLeft  = left;
			opcode    = op;
			rValRight = right;

			CalcSideEffects();
		}

		/**
		 * @brief Serialization/Deserialization.
		 */
		public TokenRValOpBin (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (rValLeft);
			writer.Write (opcode);
			writer.Write (rValRight);
		}

		public override void ReadIn (TokenReader reader)
		{
			rValLeft  = (TokenRVal)reader.ReadToken ();
			opcode    =            reader.ReadToken ();
			rValRight = (TokenRVal)reader.ReadToken ();

			CalcSideEffects();
		}

		private void CalcSideEffects()
		{
			sideEffects = rValLeft.sideEffects || rValRight.sideEffects;
			if (!sideEffects) {
				string opStr = opcode.ToString ();
				sideEffects = opStr.EndsWith ("=") && (opStr != ">=") && 
				              (opStr != "<=") && (opStr != "!=") && (opStr != "==");
			}
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			rValLeft.Reconst (writeSrc);
			writeSrc (" " + opcode.ToString () + " ");
			rValRight.Reconst (writeSrc);
		}
#endif
	}

	/**
	 * @brief an unary operator and its one operand
	 */
	public class TokenRValOpUn : TokenRVal {
		public Token opcode;
		public TokenRVal rVal;

		public TokenRValOpUn (Token op, TokenRVal right) : base (op)
		{
			opcode      = op;
			rVal        = right;
			sideEffects = right.sideEffects;
		}

		/**
		 * @brief Serialization/Deserialization.
		 */
		public TokenRValOpUn (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (opcode);
			writer.Write (rVal);
		}

		public override void ReadIn (TokenReader reader)
		{
			opcode      = reader.ReadToken ();
			rVal        = (TokenRVal)reader.ReadToken ();
			sideEffects = rVal.sideEffects;
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			writeSrc (opcode.ToString () + " ");
			rVal.Reconst (writeSrc);
		}
#endif
	}

	/**
	 * @brief an R-value enclosed in parentheses
	 */
	public class TokenRValParen : TokenRVal {

		public TokenRVal rVal;

		public TokenRValParen (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (rVal);
		}

		public override void ReadIn (TokenReader reader)
		{
			rVal = (TokenRVal)reader.ReadToken ();
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			writeSrc ("(");
			rVal.Reconst (writeSrc);
			writeSrc (")");
		}
#endif
	}

	public class TokenRValRot : TokenRVal {

		public TokenRVal xRVal;
		public TokenRVal yRVal;
		public TokenRVal zRVal;
		public TokenRVal wRVal;

		public TokenRValRot (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (xRVal);
			writer.Write (yRVal);
			writer.Write (zRVal);
			writer.Write (wRVal);
		}

		public override void ReadIn (TokenReader reader)
		{
			xRVal = (TokenRVal)reader.ReadToken ();
			yRVal = (TokenRVal)reader.ReadToken ();
			zRVal = (TokenRVal)reader.ReadToken ();
			wRVal = (TokenRVal)reader.ReadToken ();
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			writeSrc ("<");
			xRVal.Reconst (writeSrc);
			writeSrc (", ");
			yRVal.Reconst (writeSrc);
			writeSrc (", ");
			zRVal.Reconst (writeSrc);
			writeSrc (", ");
			wRVal.Reconst (writeSrc);
			writeSrc (">");
		}
#endif
	}

	/**
	 * @brief the 'undef' keyword is being used as a value in an expression.
	 */
	public class TokenRValUndef : TokenRVal {
		public TokenRValUndef (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
		}

		public override void ReadIn (TokenReader reader)
		{
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			writeSrc ("undef");
		}
#endif
	}

	/**
	 * @brief put 3 RVals together as a Vector value.
	 */
	public class TokenRValVec : TokenRVal {

		public TokenRVal xRVal;
		public TokenRVal yRVal;
		public TokenRVal zRVal;

		public TokenRValVec (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (xRVal);
			writer.Write (yRVal);
			writer.Write (zRVal);
		}

		public override void ReadIn (TokenReader reader)
		{
			xRVal = (TokenRVal)reader.ReadToken ();
			yRVal = (TokenRVal)reader.ReadToken ();
			zRVal = (TokenRVal)reader.ReadToken ();
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			writeSrc ("<");
			xRVal.Reconst (writeSrc);
			writeSrc (", ");
			yRVal.Reconst (writeSrc);
			writeSrc (", ");
			zRVal.Reconst (writeSrc);
			writeSrc (">");
		}
#endif
	}
	
	/**
	 * @brief encapsulates the whole script in a single token
	 */
	public class TokenScript : Token {
		public Dictionary<string, TokenDeclVar>    vars       = new Dictionary<string, TokenDeclVar>    ();
		public Dictionary<string, TokenDeclFunc>   funcs      = new Dictionary<string, TokenDeclFunc>   ();
		public TokenDeclState defaultState;
		public Dictionary<string, TokenDeclState>  states     = new Dictionary<string, TokenDeclState>  ();
		public Dictionary<string, TokenDeclSDType> sdSrcTypes = new Dictionary<string, TokenDeclSDType> ();

		public TokenScript (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			int numVars = 0;
			foreach (KeyValuePair<string, TokenDeclVar> kvp in vars) {
				if (!kvp.Value.constant) numVars ++;
			}
			writer.Write (numVars);
			foreach (KeyValuePair<string, TokenDeclVar> kvp in vars) {
				if (!kvp.Value.constant) writer.Write (kvp.Value);
			}
			writer.Write (funcs.Count);
			foreach (KeyValuePair<string, TokenDeclFunc> kvp in funcs) {
				writer.Write (kvp.Value);
			}
			writer.Write (defaultState);
			writer.Write (states.Count);
			foreach (KeyValuePair<string, TokenDeclState> kvp in states) {
				writer.Write (kvp.Value);
			}
		}

		public override void ReadIn (TokenReader reader)
		{
			int nVars = reader.ReadInt ();
			while (-- nVars >= 0) {
				TokenDeclVar var = (TokenDeclVar)reader.ReadToken ();
				vars[var.name.val] = var;
			}
			int nFuncs = reader.ReadInt ();
			while (-- nFuncs >= 0) {
				TokenDeclFunc func = (TokenDeclFunc)reader.ReadToken ();
				funcs[func.funcNameSig.val] = func;
			}
			defaultState = (TokenDeclState)reader.ReadToken ();
			int nStates = reader.ReadInt ();
			while (-- nStates >= 0) {
				TokenDeclState state = (TokenDeclState)reader.ReadToken ();
				states[state.name.val] = state;
			}
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			/*
			 * Global variables.
			 */
			foreach (KeyValuePair<string, TokenDeclVar> kvp in vars) {
				TokenDeclVar declVar = kvp.Value;
				declVar.Reconst (writeSrc);
			}

			/*
			 * Functions.
			 */
			foreach (KeyValuePair<string, TokenDeclFunc> kvp in funcs) {
				TokenDeclFunc declFunc = kvp.Value;
				declFunc.Reconst (writeSrc);
			}

			/*
			 * States.
			 */
			defaultState.Reconst (writeSrc);
			foreach (KeyValuePair<string, TokenDeclState> kvp in states) {
				TokenDeclState declState = kvp.Value;
				declState.Reconst (writeSrc);
			}
		}
#endif
	}

	/**
	 * @brief state body declaration
	 */
	public class TokenStateBody : Token {

		public TokenDeclFunc eventFuncs;

		public int index = -1;  // (codegen) row in ScriptHandlerEventTable (0=default)

		public TokenStateBody (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			Token t;
			for (t = eventFuncs; t != null; t = t.nextToken) {
				writer.Write (t);
			}
			writer.Write (t);
		}

		public override void ReadIn (TokenReader reader)
		{
			TokenDeclFunc lastT, thisT;

			lastT = null;
			while ((thisT = (TokenDeclFunc)reader.ReadToken ()) != null) {
				if (lastT == null) {
					eventFuncs = thisT;
				} else {
					lastT.nextToken = thisT;
				}
				lastT = thisT;
			}
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			for (Token t = eventFuncs; t != null; t = t.nextToken) {
				t.Reconst (writeSrc);
			}
		}
#endif
	}

	/**
	 * @brief a single statement, such as ending on a semicolon or enclosed in braces
	 * TokenStmt includes the terminating semicolon or the enclosing braces
	 * Also includes @label: for jump targets.
	 * Also includes stray ; null statements.
	 */
	public class TokenStmt : Token {

		public TokenStmt (Token original) : base (original) { }
	}

	/**
	 * @brief a group of statements enclosed in braces
	 */
	public class TokenStmtBlock : TokenStmt {

		public Token statements;               // null-terminated list of statements, can also have TokenDeclVar's in here
		public TokenStmtBlock outerStmtBlock;  // next outer stmtBlock or null if top-level, ie, function definition
		public TokenDeclFunc function;         // function it is part of
		public Dictionary<string, TokenDeclVar> variables = new Dictionary<string, TokenDeclVar> ();  // variables declared herein
		public bool isTry;                     // true iff it's a try statement block
		public bool isCatch;                   // true iff it's a catch statement block
		public bool isFinally;                 // true iff it's a finally statement block

		public TokenStmtBlock (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			Token t;
			for (t = statements; t != null; t = t.nextToken) {
				writer.Write (t);
			}
			writer.Write (t);
			writer.Write (outerStmtBlock);
			writer.Write (function);
			writer.Write (variables.Count);
			foreach (KeyValuePair<string, TokenDeclVar> kvp in variables) {
				writer.Write (kvp.Value);
			}
		}

		public override void ReadIn (TokenReader reader)
		{
			Token lastT, thisT;

			lastT = null;
			while ((thisT = reader.ReadToken ()) != null) {
				if (lastT == null) {
					statements = thisT;
				} else {
					lastT.nextToken = thisT;
				}
				lastT = thisT;
			}
			outerStmtBlock = (TokenStmtBlock)reader.ReadToken ();
			function = (TokenDeclFunc)reader.ReadToken ();
			int nVars = reader.ReadInt ();
			while (-- nVars >= 0) {
				TokenDeclVar var = (TokenDeclVar)reader.ReadToken ();
				variables[var.name.val] = var;
			}
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			writeSrc ("{");
			for (Token t = statements; t != null; t = t.nextToken) {
				t.Reconst (writeSrc);
			}
			writeSrc ("}");
		}
#endif
	}

	/**
	 * @brief definition of branch target name
	 */
	public class TokenStmtLabel : TokenStmt {

		public TokenName name;        // the label's name
		public TokenStmtBlock block;  // which block it is defined in
		public bool hasBkwdRefs = false;

		public bool labelTagged;      // code gen: location of label
		public ScriptMyLabel labelStruct;

		public TokenStmtLabel (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (name);
			writer.Write (block);
			writer.Write (hasBkwdRefs);  ///??? recompute on readin
		}

		public override void ReadIn (TokenReader reader)
		{
			name        = (TokenName)reader.ReadToken ();
			block       = (TokenStmtBlock)reader.ReadToken ();
			hasBkwdRefs = reader.ReadBool ();
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			writeSrc ("@" + name.val + ";");
		}
#endif
	}

	/**
	 * @brief those types of RVals with a semi-colon on the end
	 *        that are allowed to stand alone as statements
	 */
	public class TokenStmtRVal : TokenStmt {
		public TokenRVal rVal;

		public TokenStmtRVal (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (rVal);
		}

		public override void ReadIn (TokenReader reader)
		{
			rVal = (TokenRVal)reader.ReadToken ();
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			rVal.Reconst (writeSrc);
			writeSrc (";");
		}
#endif
	}

	public class TokenStmtBreak : TokenStmt {
		public TokenStmtBreak (Token original) : base (original) { }
		public override void WriteOut (TokenWriter writer) { }
		public override void ReadIn (TokenReader reader) { }

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			writeSrc ("break;");
		}
#endif
	}

	public class TokenStmtCont : TokenStmt {
		public TokenStmtCont (Token original) : base (original) { }
		public override void WriteOut (TokenWriter writer) { }
		public override void ReadIn (TokenReader reader) { }

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			writeSrc ("continue;");
		}
#endif
	}

	/**
	 * @brief "do" statement
	 */
	public class TokenStmtDo : TokenStmt {

		public TokenStmt bodyStmt;
		public TokenRVal testRVal;

		public TokenStmtDo (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (bodyStmt);
			writer.Write (testRVal);
		}

		public override void ReadIn (TokenReader reader)
		{
			bodyStmt = (TokenStmt)reader.ReadToken ();
			testRVal = (TokenRVal)reader.ReadToken ();
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			writeSrc ("do ");
			bodyStmt.Reconst (writeSrc);
			writeSrc ("while ");
			testRVal.Reconst (writeSrc);
			writeSrc (";");
		}
#endif
	}

	/**
	 * @brief "for" statement
	 */
	public class TokenStmtFor : TokenStmt {

		public TokenStmt initStmt;  // there is always an init statement, though it may be a null statement
		public TokenRVal testRVal;  // there may or may not be a test (null if not)
		public TokenRVal incrRVal;  // there may or may not be an increment (null if not)
		public TokenStmt bodyStmt;  // there is always a body statement, though it may be a null statement

		public TokenStmtFor (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (initStmt);
			writer.Write (testRVal);
			writer.Write (incrRVal);
			writer.Write (bodyStmt);
		}

		public override void ReadIn (TokenReader reader)
		{
			initStmt = (TokenStmt)reader.ReadToken ();
			testRVal = (TokenRVal)reader.ReadToken ();
			incrRVal = (TokenRVal)reader.ReadToken ();
			bodyStmt = (TokenStmt)reader.ReadToken ();
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			writeSrc ("for (");
			if (initStmt == null) writeSrc (";");
			else initStmt.Reconst (writeSrc);
			if (testRVal != null) {
				writeSrc (" ");
				testRVal.Reconst (writeSrc);
			}
			writeSrc (";");
			if (incrRVal != null) {
				writeSrc (" ");
				incrRVal.Reconst (writeSrc);
			}
			writeSrc (") ");
			bodyStmt.Reconst (writeSrc);
		}
#endif
	}

	/**
	 * @brief "foreach" statement
	 */
	public class TokenStmtForEach : TokenStmt {

		public TokenLVal keyLVal;
		public TokenLVal valLVal;
		public TokenRVal arrayRVal;
		public TokenStmt bodyStmt;  // there is always a body statement, though it may be a null statement

		public TokenStmtForEach (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (keyLVal);
			writer.Write (valLVal);
			writer.Write (arrayRVal);
			writer.Write (bodyStmt);
		}

		public override void ReadIn (TokenReader reader)
		{
			keyLVal   = (TokenLVal)reader.ReadToken ();
			valLVal   = (TokenLVal)reader.ReadToken ();
			arrayRVal = (TokenRVal)reader.ReadToken ();
			bodyStmt  = (TokenStmt)reader.ReadToken ();
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			writeSrc ("foreach (");
			if (keyLVal != null) {
				keyLVal.Reconst (writeSrc);
			}
			writeSrc (",");
			if (valLVal != null) {
				valLVal.Reconst (writeSrc);
			}
			writeSrc (" in ");
			arrayRVal.Reconst (writeSrc);
			writeSrc (") ");
			bodyStmt.Reconst (writeSrc);
		}
#endif
	}

	public class TokenStmtIf : TokenStmt {

		public TokenRVal testRVal;
		public TokenStmt trueStmt;
		public TokenStmt elseStmt;

		public TokenStmtIf (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (testRVal);
			writer.Write (trueStmt);
			writer.Write (elseStmt);
		}

		public override void ReadIn (TokenReader reader)
		{
			testRVal = (TokenRVal)reader.ReadToken ();
			trueStmt = (TokenStmt)reader.ReadToken ();
			elseStmt = (TokenStmt)reader.ReadToken ();
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			writeSrc ("if ");
			testRVal.Reconst (writeSrc);
			writeSrc (" ");
			trueStmt.Reconst (writeSrc);
			if (elseStmt != null) {
				writeSrc (" else ");
				elseStmt.Reconst (writeSrc);
			}
		}
#endif
	}

	public class TokenStmtJump : TokenStmt {

		public TokenName label;

		public TokenStmtJump (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (label);
		}

		public override void ReadIn (TokenReader reader)
		{
			label = (TokenName)reader.ReadToken ();
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			writeSrc ("jump " + label.val + ";");
		}
#endif
	}

	public class TokenStmtNull : TokenStmt {

		public TokenStmtNull (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
		}

		public override void ReadIn (TokenReader reader)
		{
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			writeSrc (";");
		}
#endif
	}

	public class TokenStmtRet : TokenStmt {

		public TokenRVal rVal;  // null if void

		public TokenStmtRet (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (rVal);
		}

		public override void ReadIn (TokenReader reader)
		{
			rVal = (TokenRVal)reader.ReadToken ();
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			writeSrc ("return");
			if (rVal != null) {
				writeSrc (" ");
				rVal.Reconst (writeSrc);
			}
			writeSrc (";");
		}
#endif
	}

	/**
	 * @brief statement that changes the current state.
	 */
	public class TokenStmtState : TokenStmt {

		public TokenName state;  // null for default

		public TokenStmtState (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (state);
		}

		public override void ReadIn (TokenReader reader)
		{
			state = (TokenName)reader.ReadToken ();
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			writeSrc ("state " + ((state == null) ? "default" : state.val) + ";");
		}
#endif
	}

	/**
	 * @brief Encapsulates a whole switch statement including the body and all cases.
	 */
	public class TokenStmtSwitch : TokenStmt {

		public TokenRVal testRVal;               // the integer index expression
		public TokenSwitchCase cases = null;     // list of all cases, linked by .nextCase
		public TokenSwitchCase lastCase = null;  // used during reduce to point to last in 'cases' list

		public TokenStmtSwitch (Token original) : base (original) { }

		/**
		 * @brief Write abstract syntax tree representation
		 */
		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (testRVal);
			for (TokenSwitchCase thisCase = cases; thisCase != null; thisCase = thisCase.nextCase) {
				writer.Write (thisCase);
			}
			writer.Write ((Token)null);
		}

		/**
		 * @brief Read abstract syntax tree representation
		 */
		public override void ReadIn (TokenReader reader)
		{
			TokenSwitchCase thisCase;

			testRVal = (TokenRVal)reader.ReadToken ();
			while ((thisCase = (TokenSwitchCase)reader.ReadToken ()) != null) {
				if (lastCase == null) {
					cases = thisCase;
				} else {
					lastCase.nextCase = thisCase;
				}
				lastCase = thisCase;
			}
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			writeSrc ("switch ");
			testRVal.Reconst (writeSrc);
			writeSrc (" {");
			for (TokenSwitchCase thisCase = cases; thisCase != null; thisCase = thisCase.nextCase) {
				if (thisCase.rVal1 == null) {
					writeSrc ("default:");
				} else {
					writeSrc ("case ");
					thisCase.rVal1.Reconst (writeSrc);
					if (thisCase.rVal2 != null) {
						writeSrc (" ... ");
						thisCase.rVal2.Reconst (writeSrc);
					}
					writeSrc (":");
				}
				for (TokenStmt stmt = thisCase.stmts; stmt != null; stmt = (TokenStmt)stmt.nextToken) {
					stmt.Reconst (writeSrc);
				}
			}
			writeSrc ("}");
		}
#endif
	}

	/**
	 * @brief Encapsulates a case/default clause from a switch statement including the
	 *        two values and the corresponding body statements.
	 */
	public class TokenSwitchCase : Token {
		public TokenSwitchCase nextCase;  // next case in source-code order
		public TokenRVal rVal1;           // null means 'default', else 'case'
		public TokenRVal rVal2;           // null means 'case expr:', else 'case expr ... expr:'
		public TokenStmt stmts;           // statements associated with the case
		public TokenStmt lastStmt;        // used during reduce for building statement list

		public int val1;                        // codegen: value of rVal1 here
		public int val2;                        // codegen: value of rVal2 here
		public ScriptMyLabel label;             // codegen: target label here
		public TokenSwitchCase nextSortedCase;  // codegen: next case in ascending val order

		public TokenSwitchCase (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (rVal1);
			writer.Write (rVal2);
			for (TokenStmt stmt = stmts; stmt != null; stmt = (TokenStmt)stmt.nextToken) {
				writer.Write (stmt);
			}
			writer.Write ((Token)null);
		}

		public override void ReadIn (TokenReader reader)
		{
			TokenStmt stmt;

			rVal1 = (TokenRVal)reader.ReadToken ();
			rVal2 = (TokenRVal)reader.ReadToken ();
			while ((stmt = (TokenStmt)reader.ReadToken ()) != null) {
				if (lastStmt == null) {
					stmts = stmt;
				} else {
					lastStmt.nextToken = stmt;
				}
				lastStmt = stmt;
			}
		}
	}

	public class TokenStmtThrow : TokenStmt {

		public TokenRVal rVal;  // null if rethrow style

		public TokenStmtThrow (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (rVal);
		}

		public override void ReadIn (TokenReader reader)
		{
			rVal = (TokenRVal)reader.ReadToken ();
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			writeSrc ("throw");
			if (rVal != null) {
				writeSrc (" ");
				rVal.Reconst (writeSrc);
			}
			writeSrc (";");
		}
#endif
	}

	/**
	 * @brief Encapsulates related try, catch and finally statements.
	 */
	public class TokenStmtTry : TokenStmt {

		public TokenStmtBlock tryStmt;
		public TokenName catchVar;		// null iff catchStmt is null
		public TokenStmtBlock catchStmt;	// can be null
		public TokenStmtBlock finallyStmt;	// can be null

		public TokenStmtTry (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (tryStmt);
			writer.Write (catchVar);
			writer.Write (catchStmt);
			writer.Write (finallyStmt);
		}

		public override void ReadIn (TokenReader reader)
		{
			tryStmt     = (TokenStmtBlock)reader.ReadToken ();
			catchVar    = (TokenName)reader.ReadToken ();
			catchStmt   = (TokenStmtBlock)reader.ReadToken ();
			finallyStmt = (TokenStmtBlock)reader.ReadToken ();
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			writeSrc ("try ");
			tryStmt.Reconst (writeSrc);
			if (catchStmt != null) {
				writeSrc (" catch (string ");
				writeSrc (catchVar.val);
				writeSrc (") ");
				catchStmt.Reconst (writeSrc);
			}
			if (finallyStmt != null) {
				writeSrc (" finally ");
				finallyStmt.Reconst (writeSrc);
			}
		}
#endif
	}

	public class TokenStmtWhile : TokenStmt {

		public TokenRVal testRVal;
		public TokenStmt bodyStmt;

		public TokenStmtWhile (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (testRVal);
			writer.Write (bodyStmt);
		}

		public override void ReadIn (TokenReader reader)
		{
			testRVal = (TokenRVal)reader.ReadToken ();
			bodyStmt = (TokenStmt)reader.ReadToken ();
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			writeSrc ("while (");
			testRVal.Reconst (writeSrc);
			writeSrc (") ");
			bodyStmt.Reconst (writeSrc);
		}
#endif
	}

	/**
	 * @brief type expressions (right-hand of 'is' keyword).
	 */
	public class TokenTypeExp : Token {
		public TokenTypeExp (Token original) : base (original) { }
	}

	public class TokenTypeExpBinOp : TokenTypeExp {
		public TokenTypeExp leftOp;
		public Token        binOp;
		public TokenTypeExp rightOp;

		public TokenTypeExpBinOp (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (leftOp);
			writer.Write (binOp);
			writer.Write (rightOp);
		}

		public override void ReadIn (TokenReader reader)
		{
			leftOp  = (TokenTypeExp)reader.ReadToken ();
			binOp   =               reader.ReadToken ();
			rightOp = (TokenTypeExp)reader.ReadToken ();
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			leftOp.Reconst (writeSrc);
			writeSrc (" " + binOp.ToString () + " ");
			rightOp.Reconst (writeSrc);
		}
#endif
	}

	public class TokenTypeExpNot : TokenTypeExp {
		public TokenTypeExp typeExp;

		public TokenTypeExpNot (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (typeExp);
		}

		public override void ReadIn (TokenReader reader)
		{
			typeExp = (TokenTypeExp)reader.ReadToken ();
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			writeSrc ("~");
			typeExp.Reconst (writeSrc);
		}
#endif
	}

	public class TokenTypeExpPar : TokenTypeExp {
		public TokenTypeExp typeExp;

		public TokenTypeExpPar (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (typeExp);
		}

		public override void ReadIn (TokenReader reader)
		{
			typeExp = (TokenTypeExp)reader.ReadToken ();
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			writeSrc ("(");
			typeExp.Reconst (writeSrc);
			writeSrc (")");
		}
#endif
	}

	public class TokenTypeExpType : TokenTypeExp {
		public TokenType typeToken;

		public TokenTypeExpType (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (typeToken);
		}

		public override void ReadIn (TokenReader reader)
		{
			typeToken = (TokenType)reader.ReadToken ();
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			writeSrc (typeToken.ToString ());
		}
#endif
	}

	public class TokenTypeExpUndef : TokenTypeExp {
		public TokenTypeExpUndef (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
		}

		public override void ReadIn (TokenReader reader)
		{
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			writeSrc ("undef");
		}
#endif
	}
}
