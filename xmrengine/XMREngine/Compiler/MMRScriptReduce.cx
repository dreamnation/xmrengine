/***************************************************\
 *  COPYRIGHT 2009, Mike Rieker, Beverly, MA, USA  *
 *  All rights reserved.                           *
\***************************************************/

/**
 * @brief Reduce raw tokens to a single script token.
 * 
 * Usage:
 *
 *  tokenBegin = returned by TokenBegin.Analyze ()
 *               representing the whole script source
 *               as a flat list of tokens
 *
 *  TokenScript tokenScript = Reduce.Analyze (TokenBegin tokenBegin);
 *  
 *  tokenScript = represents the whole script source
 *                as a tree of tokens
 */

using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Reflection.Emit;
using System.Text;

#include "lsltypes.h"

namespace OpenSim.Region.ScriptEngine.XMREngine {

	public class ScriptReduce {
		public const uint SDT_ABSTRACT = 1;
		public const uint SDT_OVERRIDE = 2;
		public const uint SDT_STATIC   = 4;
		public const uint SDT_VIRTUAL  = 8;

		private static Dictionary<Type, int> precedence = PrecedenceInit ();

		private Type[] brkCloseOnly     = new Type[] { typeof (TokenKwBrkClose) };
		private Type[] cmpGTOnly        = new Type[] { typeof (TokenKwCmpGT)    };
		private Type[] colonOnly        = new Type[] { typeof (TokenKwColon)    };
		private Type[] colonOrDotDotDot = new Type[] { typeof (TokenKwColon),   typeof (TokenKwDotDotDot) };
		private Type[] parCloseOnly     = new Type[] { typeof (TokenKwParClose) };
		private Type[] semiOnly         = new Type[] { typeof (TokenKwSemi)     };

		/**
		 * @brief Initialize operator precedence table
		 * @returns with precedence table pointer
		 */
		private static Dictionary<Type, int> PrecedenceInit ()
		{
			Dictionary<Type, int> p = new Dictionary<Type, int> ();

			// http://www.lslwiki.net/lslwiki/wakka.php?wakka=operators

			p.Add (typeof (TokenKwComma),   30);

#define ASNPR 50
			p.Add (typeof (TokenKwAsnLSh), ASNPR);  // all assignment operators of equal precedence
			p.Add (typeof (TokenKwAsnRSh), ASNPR);  // ... so they get processed strictly right-to-left
			p.Add (typeof (TokenKwAsnAdd), ASNPR);
			p.Add (typeof (TokenKwAsnAnd), ASNPR);
			p.Add (typeof (TokenKwAsnSub), ASNPR);
			p.Add (typeof (TokenKwAsnMul), ASNPR);
			p.Add (typeof (TokenKwAsnDiv), ASNPR);
			p.Add (typeof (TokenKwAsnMod), ASNPR);
			p.Add (typeof (TokenKwAsnOr),  ASNPR);
			p.Add (typeof (TokenKwAsnXor), ASNPR);
			p.Add (typeof (TokenKwAssign), ASNPR);

			p.Add (typeof (TokenKwOrOr),   100);

			p.Add (typeof (TokenKwAndAnd), 120);

			p.Add (typeof (TokenKwOr),     140);

			p.Add (typeof (TokenKwXor),    160);

			p.Add (typeof (TokenKwAnd),    180);

			p.Add (typeof (TokenKwCmpEQ),  200);
			p.Add (typeof (TokenKwCmpNE),  200);

			p.Add (typeof (TokenKwCmpLT),  240);
			p.Add (typeof (TokenKwCmpLE),  240);
			p.Add (typeof (TokenKwCmpGT),  240);
			p.Add (typeof (TokenKwCmpGE),  240);

			p.Add (typeof (TokenKwRSh),    260);
			p.Add (typeof (TokenKwLSh),    260);

			p.Add (typeof (TokenKwAdd),    280);
			p.Add (typeof (TokenKwSub),    280);

			p.Add (typeof (TokenKwMul),    320);
			p.Add (typeof (TokenKwDiv),    320);
			p.Add (typeof (TokenKwMod),    320);

			return p;
		}

		/**
		 * @brief Reduce raw token stream to a single script token.
		 *        Performs a little semantic testing, ie, undefined variables, etc.
		 * @param tokenBegin = points to a TokenBegin
		 *                     followed by raw tokens
		 *                     and last token is a TokenEnd
		 * @returns null: not a valid script, error messages have been output
		 *          else: valid script top token
		 */
		public static TokenScript Reduce (TokenBegin tokenBegin)
		{
			return new ScriptReduce (tokenBegin.nextToken).tokenScript;
		}

		/*
		 * Instance variables.
		 */
		private bool errors = false;
		private TokenDeclFunc currentDeclFunc = null;
		private TokenScript tokenScript;
		private TokenStmtBlock currentStmtBlock = null;

		/**
		 * @brief the constructor does all the processing.
		 * @param token = first token of script after the TokenBegin token
		 * @returns tokenScript = null: there were errors
		 *                        else: successful
		 */
		private ScriptReduce (Token token)
		{
			/*
			 * Create a place to put the top-level script components,
			 * eg, state bodies, functions, global variables.
			 */
			tokenScript = new TokenScript (token);

			/*
			 * 'class', 'delegate', 'instance' all define types.
			 * So we pre-scan the source tokens for those keywords
			 * to build a script-defined type table and substitute
			 * type tokens for those names in the source.  This is
			 * done as a separate scan so they can cross-reference
			 * each other.
			 */
			bool didOne;
			do {
				didOne = false;
				for (Token t = token; !(t is TokenEnd); t = t.nextToken) {
					string name = null;
					TokenDeclSDType decl = null;

					// check for 'class' <name>
					if (t is TokenKwClass) {
						t = t.nextToken;
						if (t is TokenName) {
							name = ((TokenName)t).val;
							decl = new TokenDeclSDTypeClass ((TokenName)t);
						}
					}

					// check for 'delegate' [ <rettype> ] <name> '('
					// note that the <rettype> could appear as a name token
					// if it refers to a script-defined type that we haven't
					// seen the definition for yet, so we need to check for
					// the '(' after <name> to be sure we have the delegate's
					// name.
					if (t is TokenKwDelegate) {
						t = t.nextToken;
						if (t is TokenType) t = t.nextToken;
						if ((t is TokenName) && (t.nextToken is TokenKwParOpen)) {
							name = ((TokenName)t).val;
							decl = new TokenDeclSDTypeDelegate ((TokenName)t);
						}
					}

					// check for 'interface' <name>
					if (t is TokenKwInterface) {
						t = t.nextToken;
						if (t is TokenName) {
							name = ((TokenName)t).val;
							decl = new TokenDeclSDTypeInterface ((TokenName)t);
						}
					}

					// see if we found any one of those
					if (name != null) {

						// ok, substitute in declaration for <name> declaration token
						// leave the 'class', 'delegate' and 'interface' keyword tokens
						// alone so we will process the bodies later
						decl.nextToken = t.nextToken;
						decl.prevToken = t.prevToken;
						t.prevToken.nextToken = decl;
						t.nextToken.prevToken = decl;

						// add it to known script-defined types.
						// note that we can't get a duplicate here because we will
						// substitute out all other occurences of this name in the
						// next step.
						tokenScript.sdSrcTypes.Add (name, decl);

						// now scan through the entire source for other occurrences of 
						// <name> and substitute in references to the declared type
						for (Token u = token; !(u is TokenEnd); u = u.nextToken) {
							if ((u is TokenName) && (((TokenName)u).val == name)) {
								Token r = decl.MakeRefToken (u);
								r.nextToken = u.nextToken;
								r.prevToken = u.prevToken;
								u.prevToken.nextToken = r;
								u.nextToken.prevToken = r;
							}
						}

						// repeat after this pass in case of cross references
						didOne = true;
					}
				}
			} while (didOne);

			/*
			 * Scan through the tokens until we reach the end.
			 */
			while (!(token is TokenEnd)) {

				/*
				 * class <classdef> ... { ... }
				 */
				if (token is TokenKwClass) {
					ParseDeclClass (ref token);
					continue;
				}

				/*
				 * constant <name> = <rval> ;
				 */
				if (token is TokenKwConst) {
					ParseDeclVar (ref token, tokenScript.vars);
					continue;
				}

				/*
				 * delegate [<rettype>] <name> ( ... );
				 */
				if (token is TokenKwDelegate) {
					ParseDeclDelegate (ref token);
					continue;
				}

				/*
				 * interface <interfacedef> ... { ... }
				 */
				if (token is TokenKwInterface) {
					ParseDeclInterface (ref token);
					continue;
				}

				/*
				 * <type> <name> ;
				 * <type> <name> = <rval> ;
				 */
				if ((token is TokenType) &&
				    (token.nextToken is TokenName) &&
				    ((token.nextToken.nextToken is TokenKwSemi) || 
				     (token.nextToken.nextToken is TokenKwAssign))) {
					ParseDeclVar (ref token, tokenScript.vars);
					continue;
				}

				/*
				 * <type> <name> <funcargs> <funcbody>
				 * global function returning specified type
				 */
				if (token is TokenType) {
					TokenType tokenType = (TokenType)token;

					token = token.nextToken;
					if (!(token is TokenName)) {
						ErrorMsg (token, "expecting variable/function name");
						token = SkipPastSemi (token);
						continue;
					}
					TokenName tokenName = (TokenName)token;
					token = token.nextToken;
					if (!(token is TokenKwParOpen)) {
						ErrorMsg (token, "<type> <name> must be followed by ; = or (");
						token = SkipPastSemi (token);
						continue;
					}
					token = tokenType;
					TokenDeclFunc tokenDeclFunc = ParseDeclFunc (ref token, false, false);
					if (tokenDeclFunc == null) continue;
					if (tokenScript.funcs.ContainsKey (tokenName.val)) {
						ErrorMsg (tokenName, "duplicate function name");
						continue;
					}
					tokenScript.funcs.Add (tokenName.val, tokenDeclFunc);
					continue;
				}

				/*
				 * <name> <funcargs> <funcbody>
				 * global function returning void
				 */
				if (token is TokenName) {
					TokenName tokenName = (TokenName)token;
					token = token.nextToken;
					if (!(token is TokenKwParOpen)) {
						ErrorMsg (token, "looking for open paren after assuming " + 
						                 tokenName.val + " is a function name");
						token = SkipPastSemi (token);
						continue;
					}
					token = tokenName;
					TokenDeclFunc tokenDeclFunc = ParseDeclFunc (ref token, false, false);
					if (tokenDeclFunc == null) continue;
					if (tokenScript.funcs.ContainsKey (tokenName.val)) {
						ErrorMsg (tokenName, "duplicate function name");
						continue;
					}
					tokenScript.funcs.Add (tokenDeclFunc.funcNameSig.val, tokenDeclFunc);
					continue;
				}

				/*
				 * default <statebody>
				 */
				if (token is TokenKwDefault) {
					TokenDeclState tokenDeclState = new TokenDeclState (token);
					token = token.nextToken;
					tokenDeclState.body = ParseStateBody (ref token);
					if (tokenDeclState.body == null) continue;
					if (tokenScript.defaultState != null) {
						ErrorMsg (tokenDeclState, "default state already declared");
						continue;
					}
					tokenScript.defaultState = tokenDeclState;
					continue;
				}

				/*
				 * state <name> <statebody>
				 */
				if (token is TokenKwState) {
					TokenDeclState tokenDeclState = new TokenDeclState (token);
					token = token.nextToken;
					if (!(token is TokenName)) {
						ErrorMsg (token, "state must be followed by state name");
						token = SkipPastSemi (token);
						continue;
					}
					tokenDeclState.name = (TokenName)token;
					token = token.nextToken;
					tokenDeclState.body = ParseStateBody (ref token);
					if (tokenDeclState.body == null) continue;
					if (tokenScript.states.ContainsKey (tokenDeclState.name.val)) {
						ErrorMsg (tokenDeclState.name, "duplicate state definition");
						continue;
					}
					tokenScript.states.Add (tokenDeclState.name.val, tokenDeclState);
					continue;
				}

				/*
				 * Doesn't fit any of those forms, output message and skip to next statement.
				 */
				ErrorMsg (token, "looking for var name, type, state or default");
				token = SkipPastSemi (token);
				continue;
			}

			/*
			 * Must have a default state to start in.
			 */
			if (!errors && (tokenScript.defaultState == null)) {
				ErrorMsg (tokenScript, "no default state defined");
			}

			/*
			 * If any error messages were written out, set return value to null.
			 */
			if (errors) tokenScript = null;
		}

		/**
		 * @brief Parse a class declaration.
		 * @param token = points to 'class' keyword on entry
		 *                points just past closing '}' on return
		 */
		private void ParseDeclClass (ref Token token)
		{
			bool haveExplicitConstructor = false;
			Token u = token.nextToken;
			TokenDeclSDTypeClass tokdeclcl;

			// first thing following 'class' should be the
			// class's declaration that we foud during
			// pre-scan
			if (!(u is TokenDeclSDTypeClass)) {
				ErrorMsg (u, "expecting class name");
				token = SkipPastSemi (token);
				return;
			}
			tokdeclcl = (TokenDeclSDTypeClass)u;
			u = u.nextToken;

			// next can be ':' followed by list of implemented
			// interfaces and one extended class
			if (u is TokenKwColon) {
				u = u.nextToken;
				while (true) {
					if (u is TokenTypeSDTypeClass) {
						TokenDeclSDTypeClass c = ((TokenTypeSDTypeClass)u).decl;
						if (tokdeclcl.extends == null) {
							tokdeclcl.extends = c;
						} else if (tokdeclcl.extends != c) {
							ErrorMsg (u, "can extend from only one class");
						}
					} else if (u is TokenTypeSDTypeInterface) {
						TokenDeclSDTypeInterface i = ((TokenTypeSDTypeInterface)u).decl;
						if (!tokdeclcl.implements.Contains (i)) {
							tokdeclcl.implements.Add (i);
						}
					} else {
						ErrorMsg (u, "expecting class or interface name");
						if (u is TokenKwBrcOpen) break;
					}
					u = u.nextToken;
					if (!(u is TokenKwComma)) break;
					u = u.nextToken;
				}
			}

			// next must be '{' to open class declaration body
			if (!(u is TokenKwBrcOpen)) {
				ErrorMsg (u, "expecting { to open class declaration body");
				token = SkipPastSemi (token);
				return;
			}
			token = u.nextToken;

			// process declaration statements until '}'
			while (!(token is TokenKwBrcClose)) {

				/*
				 * Maybe there is a 'static' prefix.
				 */
				uint flags = 0;
				if (token is TokenKwStatic) {
					flags |= SDT_STATIC;
					token = token.nextToken;
				}

				/*
				 * [ static ] constant <name> = <rval> ;
				 */
				if (token is TokenKwConst) {
					TokenDeclVar var = ParseDeclVar (ref token, tokdeclcl.fields);
					if (var != null) var.sdtFlags |= SDT_STATIC;
					continue;
				}

				/*
				 * [ static ] <type> <name> ;
				 * [ static ] <type> <name> = <rval> ;
				 */
				if ((token is TokenType) &&
				    (token.nextToken is TokenName) &&
				    ((token.nextToken.nextToken is TokenKwSemi) || 
				     (token.nextToken.nextToken is TokenKwAssign))) {
					ParseDeclVar (ref token, tokdeclcl.fields).sdtFlags = flags;
					continue;
				}

				/*
				 * Maybe there is an 'abstract', 'override' or 'virtual' prefix.
				 */
				while (true) {
					if (token is TokenKwAbstract) {
						if (flags != 0) ErrorMsg (token, "conflicting prefixes");
						else flags |= SDT_ABSTRACT;
						tokdeclcl.isAbstract = true;
						token = token.nextToken;
						continue;
					}
					if (token is TokenKwOverride) {
						if (flags != 0) ErrorMsg (token, "conflicting prefixes");
						else flags |= SDT_OVERRIDE;
						token = token.nextToken;
						continue;
					}
					if (token is TokenKwVirtual) {
						if (flags != 0) ErrorMsg (token, "conflicting prefixes");
						else flags |= SDT_VIRTUAL;
						token = token.nextToken;
						continue;
					}
					break;
				}

				/*
				 * 'constructor' '(' arglist ')' [ ':' [ 'base' ] '(' baseconstructorcall ')' ] '{' body '}'
				 */
				if (token is TokenKwConstructor) {
					if (flags != 0) {
						ErrorMsg (token, "constructors can't be abstract/override/static/virtual");
					}

					TokenDeclFunc tokenDeclFunc = new TokenDeclFunc (token, tokenScript);
					tokenDeclFunc.retType       = new TokenTypeVoid (token);

					token = token.nextToken;
					if (!(token is TokenKwParOpen)) {
						ErrorMsg (token, "expecting ( for constructor argument list");
						token = SkipPastSemi (token);
						continue;
					}

					tokenDeclFunc.argDecl       = ParseFuncArgs (ref token);
					if (tokenDeclFunc.argDecl == null) continue;
					string nameSig              = "constructor" + tokenDeclFunc.argDecl.GetArgSig ();

					tokenDeclFunc.funcNameSig   = new TokenName (tokenDeclFunc, nameSig);
					tokenDeclFunc.sdtClass      = tokdeclcl;
					tokenDeclFunc.sdtFlags      = flags;

					TokenDeclFunc saveDeclFunc = currentDeclFunc;
					currentDeclFunc = tokenDeclFunc;
					try {
						/*
						 * Set up reference to base constructor.
						 */
						TokenRValBaseField baseCtor = new TokenRValBaseField (token, 
						                              new TokenName (token, "constructor"));

						/*
						 * Parse any base constructor call as if it were the first statement of the
						 * constructor itself.
						 */
						if (token is TokenKwColon) {
							token = token.nextToken;
							if (token is TokenKwBase) {
								token = token.nextToken;
							}
							if (!(token is TokenKwParOpen)) {
								ErrorMsg (token, "expecting ( for base constructor call arguments");
								token = SkipPastSemi (token);
								continue;
							}
							TokenRValCall rvc = ParseRValCall (ref token, baseCtor);
							if (rvc == null) continue;
							if (tokdeclcl.extends != null) {
								tokenDeclFunc.baseCtorCall = rvc;
							} else {
								ErrorMsg (rvc, "base constructor call cannot be specified if not extending anything");
							}
						} else if (tokdeclcl.extends != null) {

							/*
							 * Caller didn't specify a constructor but we are extending, so we will 
							 * call the extended class's default constructor.
							 */
							TokenRValCall rvc = new TokenRValCall (token);
							rvc.meth          = baseCtor;
							tokenDeclFunc.baseCtorCall = rvc;
						}

						/*
						 * Parse the constructor body.
						 */
						tokenDeclFunc.body = ParseStmtBlock (ref token);
						if (tokenDeclFunc.body == null) continue;
						if (tokenDeclFunc.argDecl == null) continue;
					} finally {
						currentDeclFunc = saveDeclFunc;
					}

					/*
					 * Add to list of methods defined by this class.
					 * It has the name "constructor(argsig)".
					 * Note that script can't call it directly via a call to a method named constructor
					 * because constructor is a keyword.
					 */
					if (tokdeclcl.methods.ContainsKey (tokenDeclFunc.funcNameSig.val)) {
						ErrorMsg (tokenDeclFunc.funcNameSig, "duplicate constructor");
						continue;
					}
					tokdeclcl.methods.Add (tokenDeclFunc.funcNameSig.val, tokenDeclFunc);

					haveExplicitConstructor = true;

					continue;
				}

				/*
				 * [ abstract | override | static | virtual ] <type> <name> <funcargs> <funcbody>
				 * method with explicit return type
				 */
				if (token is TokenType) {
					ParseSDTClassMethodDecl (ref token, flags, tokdeclcl);
					continue;
				}

				/*
				 * [ abstract | override | static | virtual ] <name> <funcargs> <funcbody>
				 * method returning void
				 */
				if (token is TokenName) {
					ParseSDTClassMethodDecl (ref token, flags, tokdeclcl);
					continue;
				}

				/*
				 * That's all we support in a class declaration.
				 */
				ErrorMsg (token, "expecting field or method declaration");
				token = SkipPastSemi (token);
			}

			/*
			 * If script didn't specify any constructor, create a default no-argument one.
			 */
			if (!haveExplicitConstructor) {
				TokenDeclFunc tokenDeclFunc = new TokenDeclFunc (token, tokenScript);
				tokenDeclFunc.retType       = new TokenTypeVoid (token);
				tokenDeclFunc.argDecl       = new TokenArgDecl (token);
				tokenDeclFunc.argDecl.types = new TokenType[0];
				tokenDeclFunc.argDecl.names = new TokenName[0];
				tokenDeclFunc.argDecl.locns = new CompValu[0];
				tokenDeclFunc.funcNameSig   = new TokenName (token, "constructor()");
				tokenDeclFunc.sdtClass      = tokdeclcl;
				tokenDeclFunc.sdtFlags      = 0;
				tokenDeclFunc.body          = new TokenStmtBlock (token);
				tokenDeclFunc.body.function = tokenDeclFunc;

				if (tokdeclcl.extends != null) {
					TokenRValBaseField meth = new TokenRValBaseField (token, 
					                          new TokenName (token, "constructor"));
					TokenRValCall rvc       = new TokenRValCall (token);
					rvc.meth                = meth;
					TokenStmtRVal bcc       = new TokenStmtRVal (token);
					bcc.rVal                = rvc;
					bcc.nextToken           = null;
					tokenDeclFunc.body.statements = bcc;
				}

				tokdeclcl.methods.Add (tokenDeclFunc.funcNameSig.val, tokenDeclFunc);
			}

			/*
			 * Skip over the closing brace.
			 */
			token = token.nextToken;
		}

		/**
		 * @brief Parse a method definition for a script-defined type class.
		 * @param token = points to return type (or method name for implicit return type of void)
		 * @param flags = abstract/override/static/virtual flags
		 * @param tokdeclcl = which script-defined type class this method is in
		 * @returns with method parsed and cataloged (or error message(s) printed)
		 */
		private void ParseSDTClassMethodDecl (ref Token token, uint flags, TokenDeclSDTypeClass tokdeclcl)
		{
			TokenDeclFunc tokenDeclFunc = ParseDeclFunc (ref token, 
			                                             (flags & SDT_ABSTRACT) != 0, 
			                                             (flags & SDT_STATIC) == 0);
			if (tokenDeclFunc != null) {
				tokenDeclFunc.sdtClass = tokdeclcl;
				tokenDeclFunc.sdtFlags = flags;
				string funcNameSig = tokenDeclFunc.funcNameSig.val;
				if (tokdeclcl.methods.ContainsKey (funcNameSig)) {
					ErrorMsg (tokenDeclFunc.funcNameSig, "duplicate method name " + funcNameSig);
				} else {
					tokdeclcl.methods.Add (funcNameSig, tokenDeclFunc);
				}
			}
		}

		/**
		 * @brief Parse a delegate declaration statement.
		 * @param token = points to 'delegate' keyword on entry
		 *                points just past ';' on return
		 */
		private void ParseDeclDelegate (ref Token token)
		{
			Token u = token;
			TokenDeclSDTypeDelegate tokdecldel;
			TokenType retType;

			// first thing following 'delegate' should be return type
			// but we will fill in 'void' if it is missing
			u = u.nextToken;
			if (u is TokenType) {
				retType = (TokenType)u;
				u = u.nextToken;
			} else {
				retType = new TokenTypeVoid (u);
			}

			// next should be the delegate's declaration that we found during pre-scan
			if (!(u is TokenDeclSDTypeDelegate)) {
				ErrorMsg (u, "expecting delegate name");
				token = SkipPastSemi (token);
				return;
			}
			tokdecldel = (TokenDeclSDTypeDelegate)u;
			u = u.nextToken;

			// get list of argument types until we see a ')'
			List<TokenType> args = new List<TokenType> ();
			bool first = true;
			do {
				if (first) {

					// first time should have '(' ')' or '(' <type>
					if (!(u is TokenKwParOpen)) {
						ErrorMsg (u, "expecting ( after delegate name");
						token = SkipPastSemi (token);
						return;
					}
					first = false;
					u = u.nextToken;
					if (u is TokenKwParClose) break;
				} else {

					// other times should have ',' <type>
					if (!(u is TokenKwComma)) {
						ErrorMsg (u, "expecting , separating arg types");
						token = SkipPastSemi (token);
						return;
					}
					u = u.nextToken;
				}
				if (!(u is TokenType)) {
					ErrorMsg (u, "expecting argument type");
					token = SkipPastSemi (token);
					return;
				}
				args.Add ((TokenType)u);
				u = u.nextToken;

				// they can put in a dummy name that we toss out
				if (u is TokenName) u = u.nextToken;

				// scanning ends on a ')'
			} while (!(u is TokenKwParClose));

			// fill in the return type and argment type array
			tokdecldel.SetRetArgTypes (retType, args.ToArray ());

			// and finally must have ';' to finish the delegate declaration statement
			u = u.nextToken;
			if (!(u is TokenKwSemi)) {
				ErrorMsg (u, "expecting ; after ) in delegate");
				token = SkipPastSemi (token);
				return;
			}
			token = u.nextToken;
		}

		/**
		 * @brief Parse an interface declaration.
		 * @param token = points to 'interface' keyword on entry
		 *                points just past closing '}' on return
		 */
		private void ParseDeclInterface (ref Token token)
		{
			Token u = token.nextToken;
			TokenDeclSDTypeInterface tokdeclin;

			// first thing following 'interface' should be the
			// interface's declaration that we foud during
			// pre-scan
			if (!(u is TokenDeclSDTypeInterface)) {
				ErrorMsg (u, "expecting interface name");
				token = SkipPastSemi (token);
				return;
			}
			tokdeclin = (TokenDeclSDTypeInterface)u;
			u = u.nextToken;

			// next must be '{' to open interface declaration body
			if (!(u is TokenKwBrcOpen)) {
				ErrorMsg (u, "expecting { to open interface declaration body");
				token = SkipPastSemi (token);
				return;
			}
			token = u.nextToken;

			// process declaration statements until '}'
			while (!(token is TokenKwBrcClose)) {

				/*
				 * <type> <name> <funcargs> ;
				 * abstract method with explicit return type
				 */
				if (token is TokenType) {
					TokenType tokenType = (TokenType)token;

					token = token.nextToken;
					if (!(token is TokenName)) {
						ErrorMsg (token, "expecting method name");
						token = SkipPastSemi (token);
						continue;
					}
					TokenName tokenName = (TokenName)token;
					token = token.nextToken;
					if (!(token is TokenKwParOpen)) {
						ErrorMsg (token, "<type> <name> must be followed by (");
						token = SkipPastSemi (token);
						continue;
					}

					token = tokenType;
					TokenDeclFunc tokenDeclFunc = ParseDeclFunc (ref token, true, false);
					if (tokenDeclFunc == null) continue;
					if (tokdeclin.methods.ContainsKey (tokenDeclFunc.funcNameSig.val)) {
						ErrorMsg (tokenName, "duplicate method name");
						continue;
					}
					tokdeclin.methods.Add (tokenDeclFunc.funcNameSig.val, tokenDeclFunc);
					continue;
				}

				/*
				 * <name> <funcargs> ;
				 * abstract method returning void
				 */
				if (token is TokenName) {
					TokenName tokenName = (TokenName)token;
					token = token.nextToken;
					if (!(token is TokenKwParOpen)) {
						ErrorMsg (token, "<name> must be followed by (");
						token = SkipPastSemi (token);
						continue;
					}
					token = tokenName;
					TokenDeclFunc tokenDeclFunc = ParseDeclFunc (ref token, true, false);
					if (tokenDeclFunc == null) continue;
					if (tokdeclin.methods.ContainsKey (tokenDeclFunc.funcNameSig.val)) {
						ErrorMsg (tokenName, "duplicate method name");
						continue;
					}
					tokdeclin.methods.Add (tokenDeclFunc.funcNameSig.val, tokenDeclFunc);
					continue;
				}

				/*
				 * That's all we support in an interface declaration.
				 */
				ErrorMsg (token, "expecting method declaration");
				token = SkipPastSemi (token);
			}

			/*
			 * Skip over the closing brace.
			 */
			token = token.nextToken;
		}

		/**
		 * @brief parse state body (including all its event handlers)
		 * @param token = points to TokenKwBrcOpen
		 * @returns null: state body parse error
		 *          else: token representing state
		 *          token = points past close brace
		 */
		private TokenStateBody ParseStateBody (ref Token token)
		{
			TokenStateBody tokenStateBody = new TokenStateBody (token);

			if (!(token is TokenKwBrcOpen)) {
				ErrorMsg (token, "expecting { at beg of state");
				token = SkipPastSemi (token);
				return null;
			}

			token = token.nextToken;
			while (!(token is TokenKwBrcClose)) {
				if (token is TokenEnd) {
					ErrorMsg (tokenStateBody, "eof parsing state body");
					return null;
				}
				TokenDeclFunc tokenDeclFunc = ParseDeclFunc (ref token, false, false);
				if (tokenDeclFunc == null) return null;
				if (!(tokenDeclFunc.retType is TokenTypeVoid)) {
					ErrorMsg (tokenDeclFunc.retType, "event handlers don't have return types");
					return null;
				}
				tokenDeclFunc.nextToken = tokenStateBody.eventFuncs;
				tokenStateBody.eventFuncs = tokenDeclFunc;
			}
			token = token.nextToken;
			return tokenStateBody;
		}

		/**
		 * @brief Parse a function declaration, including its arg list and body
		 * @param token = points to function return type token (or function name token if return type void)
		 * @param abs = false: concrete function; true: abstract declaration
		 * @param imp = allow implemented interface specs
		 * @returns null: error parsing function definition
		 *          else: function declaration
		 *          token = advanced just past function, ie, just past the closing brace
		 */
		private TokenDeclFunc ParseDeclFunc (ref Token token, bool abs, bool imp)
		{
			TokenType retType;
			if (token is TokenType) {
				retType = (TokenType)token;
				token = token.nextToken;
			} else {
				retType = new TokenTypeVoid (token);
			}
			if (!(token is TokenName)) {
				ErrorMsg (token, "expecting function name");
				token = SkipPastSemi (token);
				return null;
			}

			TokenName simpleName = (TokenName)token;
			token = token.nextToken;
			return ParseDeclFunc (ref token, abs, imp, retType, simpleName);
		}

		/**
		 * @brief Parse a function declaration, including its arg list and body
		 *        This version enters with token pointing to the '('
		 * @param token = points to the '(' of the arg list
		 * @param abs = false: concrete function; true: abstract declaration
		 * @param imp = allow implemented interface specs
		 * @param retType = return type (TokenTypeVoid if void, never null)
		 * @param simpleName = function name without any signature
		 * @returns null: error parsing remainder of function definition
		 *          else: function declaration
		 *          token = advanced just past function, ie, just past the closing brace
		 */
		private TokenDeclFunc ParseDeclFunc (ref Token token, bool abs, bool imp, TokenType retType, TokenName simpleName)
		{
			TokenDeclFunc tokenDeclFunc = new TokenDeclFunc (simpleName, tokenScript);
			tokenDeclFunc.retType       = retType;
			tokenDeclFunc.argDecl       = ParseFuncArgs (ref token);
			if (tokenDeclFunc.argDecl == null) return null;
			tokenDeclFunc.funcNameSig   = new TokenName (simpleName, 
			                                             simpleName.val + tokenDeclFunc.argDecl.GetArgSig ());

			if (token is TokenKwColon) {
				do {
					token = token.nextToken;
					if (!(token is TokenTypeSDTypeInterface)) {
						ErrorMsg (token, "expecting interface type");
						token = SkipPastSemi (token);
						return null;
					}
					TokenTypeSDTypeInterface intfType = (TokenTypeSDTypeInterface)token;
					token = token.nextToken;
					TokenName methName = simpleName;
					if ((token is TokenKwDot) && (token.nextToken is TokenName)) {
						methName = (TokenName)token.nextToken;
						token = token.nextToken.nextToken;
					}
					TokenIntfImpl intfImpl = new TokenIntfImpl (intfType, methName);
					intfImpl.nextToken = tokenDeclFunc.implements;
					tokenDeclFunc.implements = intfImpl;
				} while (token is TokenKwComma);
				if (!imp) {
					ErrorMsg (tokenDeclFunc.implements, "cannot implement interface method");
				}
			}

			if (token is TokenKwSemi) {
				if (!abs) {
					ErrorMsg (token, "expecting function body, not abstract");
					token = SkipPastSemi (token);
					return null;
				}
				token = token.nextToken;
			} else {
				TokenDeclFunc saveDeclFunc = currentDeclFunc;
				currentDeclFunc = tokenDeclFunc;
				tokenDeclFunc.body = ParseStmtBlock (ref token);
				currentDeclFunc = saveDeclFunc;
				if (tokenDeclFunc.body == null) return null;
				if (abs) {
					ErrorMsg (tokenDeclFunc.body, "function declared abstract but has body");
					tokenDeclFunc.body = null;
				}
			}
			if (tokenDeclFunc.argDecl == null) return null;
			return tokenDeclFunc;
		}

		/**
		 * @brief Parse statement
		 * @param token = first token of statement
		 * @returns null: parse error
		 *          else: token representing whole statement
		 *          token = points past statement
		 */
		private TokenStmt ParseStmt (ref Token token)
		{
			/*
			 * Statements that begin with a specific keyword.
			 */
			if (token is TokenKwAt)      return ParseStmtLabel   (ref token);
			if (token is TokenKwBrcOpen) return ParseStmtBlock   (ref token);
			if (token is TokenKwBreak)   return ParseStmtBreak   (ref token);
			if (token is TokenKwCont)    return ParseStmtCont    (ref token);
			if (token is TokenKwDo)      return ParseStmtDo      (ref token);
			if (token is TokenKwFor)     return ParseStmtFor     (ref token);
			if (token is TokenKwForEach) return ParseStmtForEach (ref token);
			if (token is TokenKwIf)      return ParseStmtIf      (ref token);
			if (token is TokenKwJump)    return ParseStmtJump    (ref token);
			if (token is TokenKwRet)     return ParseStmtRet     (ref token);
			if (token is TokenKwSemi)    return ParseStmtNull    (ref token);
			if (token is TokenKwState)   return ParseStmtState   (ref token);
			if (token is TokenKwSwitch)  return ParseStmtSwitch  (ref token);
			if (token is TokenKwThrow)   return ParseStmtThrow   (ref token);
			if (token is TokenKwTry)     return ParseStmtTry     (ref token);
			if (token is TokenKwWhile)   return ParseStmtWhile   (ref token);

			/*
			 * Try to parse anything else as an expression, possibly calling
			 * something and/or writing to a variable.
			 */
			TokenRVal tokenRVal = ParseRVal (ref token, semiOnly);
			if (tokenRVal != null) {
				TokenStmtRVal tokenStmtRVal = new TokenStmtRVal (tokenRVal);
				tokenStmtRVal.rVal = tokenRVal;
				return tokenStmtRVal;
			}

			/*
			 * Who knows what it is...
			 */
			ErrorMsg (token, "unknown statement");
			token = SkipPastSemi (token);
			return null;
		}

		/**
		 * @brief parse a statement block, ie, group of statements between braces
		 * @param token = points to { token
		 * @returns null: error parsing
		 *          else: statements bundled in this token
		 *          token = advanced just past the } token
		 */
		private TokenStmtBlock ParseStmtBlock (ref Token token)
		{
			if (!(token is TokenKwBrcOpen)) {
				ErrorMsg (token, "statement block body must begin with a {");
				token = SkipPastSemi (token);
				return null;
			}
			TokenStmtBlock tokenStmtBlock = new TokenStmtBlock (token);
			tokenStmtBlock.function = currentDeclFunc;
			tokenStmtBlock.outerStmtBlock = currentStmtBlock;
			currentStmtBlock = tokenStmtBlock;
			Token prevStmt = null;
			token = token.nextToken;
			while (!(token is TokenKwBrcClose)) {
				if (token is TokenEnd) {
					ErrorMsg (tokenStmtBlock, "missing }");
					currentStmtBlock = tokenStmtBlock.outerStmtBlock;
					return null;
				}
				Token thisStmt;
				if ((token is TokenType) || (token is TokenKwConst)) {
					thisStmt = ParseDeclVar (ref token, currentStmtBlock.variables);
				} else {
					thisStmt = ParseStmt (ref token);
				}
				if (thisStmt == null) return null;
				if (prevStmt == null) tokenStmtBlock.statements = thisStmt;
				                 else prevStmt.nextToken = thisStmt;
				prevStmt = thisStmt;
			}
			token = token.nextToken;
			currentStmtBlock = tokenStmtBlock.outerStmtBlock;
			return tokenStmtBlock;
		}

		/**
		 * @brief parse a 'break' statement
		 * @param token = points to break keyword token
		 * @returns null: error parsing
		 *          else: statements bundled in this token
		 *          token = advanced just past the ; token
		 */
		private TokenStmtBreak ParseStmtBreak (ref Token token)
		{
			TokenStmtBreak tokenStmtBreak = new TokenStmtBreak (token);
			token = token.nextToken;
			if (!(token is TokenKwSemi)) {
				ErrorMsg (token, "expecting ;");
				token = SkipPastSemi (token);
				return null;
			}
			token = token.nextToken;
			return tokenStmtBreak;
		}

		/**
		 * @brief parse a 'continue' statement
		 * @param token = points to continue keyword token
		 * @returns null: error parsing
		 *          else: statements bundled in this token
		 *          token = advanced just past the ; token
		 */
		private TokenStmtCont ParseStmtCont (ref Token token)
		{
			TokenStmtCont tokenStmtCont = new TokenStmtCont (token);
			token = token.nextToken;
			if (!(token is TokenKwSemi)) {
				ErrorMsg (token, "expecting ;");
				token = SkipPastSemi (token);
				return null;
			}
			token = token.nextToken;
			return tokenStmtCont;
		}

		/**
		 * @brief parse a 'do' statement
		 * @params token = points to 'do' keyword token
		 * @returns null: parse error
		 *          else: pointer to token encapsulating the do statement, including body
		 *          token = advanced just past the body statement
		 */
		private TokenStmtDo ParseStmtDo (ref Token token)
		{
			TokenStmtDo tokenStmtDo = new TokenStmtDo (token);
			token = token.nextToken;
			tokenStmtDo.bodyStmt = ParseStmt (ref token);
			if (tokenStmtDo.bodyStmt == null) return null;
			if (!(token is TokenKwWhile)) {
				ErrorMsg (token, "expecting while clause");
				return null;
			}
			token = token.nextToken;
			tokenStmtDo.testRVal = ParseRValParen (ref token);
			if (tokenStmtDo.testRVal == null) return null;
			if (!(token is TokenKwSemi)) {
				ErrorMsg (token, "while clause must terminate on semicolon");
				token = SkipPastSemi (token);
				return null;
			}
			token = token.nextToken;
			return tokenStmtDo;
		}

		/**
		 * @brief parse a for statement
		 * @param token = points to 'for' keyword token
		 * @returns null: parse error
		 *          else: pointer to encapsulated for statement token
		 *          token = advanced just past for body statement
		 */
		private TokenStmt ParseStmtFor (ref Token token)
		{

			/*
			 * Create encapsulating token and skip past 'for ('
			 */
			TokenStmtFor tokenStmtFor = new TokenStmtFor (token);
			token = token.nextToken;
			if (!(token is TokenKwParOpen)) {
				ErrorMsg (token, "for must be followed by (");
				return null;
			}
			token = token.nextToken;

			/*
			 * If a plain for, ie, not declaring a variable, it's straightforward.
			 */
			if (!(token is TokenType)) {
				tokenStmtFor.initStmt = ParseStmt (ref token);
				if (tokenStmtFor.initStmt == null) return null;
				return ParseStmtFor2 (tokenStmtFor, ref token) ? tokenStmtFor : null;
			}

			/*
			 * Initialization declares a variable, so encapsulate it in a block so
			 * variable has scope only in the for statement, including its body.
			 */
			TokenStmtBlock forStmtBlock = new TokenStmtBlock (tokenStmtFor);
			forStmtBlock.outerStmtBlock = currentStmtBlock;
			forStmtBlock.function       = currentDeclFunc;

			TokenDeclVar tokenDeclVar   = ParseDeclVar (ref token, currentStmtBlock.variables);
			if (tokenDeclVar == null) {
				currentStmtBlock    = forStmtBlock.outerStmtBlock;
				return null;
			}

			forStmtBlock.statements     = tokenDeclVar;
			tokenDeclVar.nextToken      = tokenStmtFor;

			bool ok                     = ParseStmtFor2 (tokenStmtFor, ref token);
			currentStmtBlock            = forStmtBlock.outerStmtBlock;
			return ok ? forStmtBlock : null;
		}

		/**
		 * @brief parse rest of 'for' statement starting with the test expression.
		 * @param tokenStmtFor = token encapsulating the for statement
		 * @param token = points to test expression
		 * @returns false: parse error
		 *           true: successful
		 *          token = points just past body statement
		 */
		private bool ParseStmtFor2 (TokenStmtFor tokenStmtFor, ref Token token)
		{
			if (token is TokenKwSemi) {
				token = token.nextToken;
			} else {
				tokenStmtFor.testRVal = ParseRVal (ref token, semiOnly);
				if (tokenStmtFor.testRVal == null) return false;
			}
			if (token is TokenKwParClose) {
				token = token.nextToken;
			} else {
				tokenStmtFor.incrRVal = ParseRVal (ref token, parCloseOnly);
				if (tokenStmtFor.incrRVal == null) return false;
			}
			tokenStmtFor.bodyStmt = ParseStmt (ref token);
			return tokenStmtFor.bodyStmt != null;
		}

		/**
		 * @brief parse a foreach statement
		 * @param token = points to 'foreach' keyword token
		 * @returns null: parse error
		 *          else: pointer to encapsulated foreach statement token
		 *          token = advanced just past for body statement
		 */
		private TokenStmt ParseStmtForEach (ref Token token)
		{

			/*
			 * Create encapsulating token and skip past 'foreach ('
			 */
			TokenStmtForEach tokenStmtForEach = new TokenStmtForEach (token);
			token = token.nextToken;
			if (!(token is TokenKwParOpen)) {
				ErrorMsg (token, "foreach must be followed by (");
				return null;
			}
			token = token.nextToken;

			if (token is TokenName) {
				tokenStmtForEach.keyLVal = new TokenLValName ((TokenName)token);
				token = token.nextToken;
			}
			if (!(token is TokenKwComma)) {
				ErrorMsg (token, "expecting comma");
				token = SkipPastSemi (token);
				return null;
			}
			token = token.nextToken;
			if (token is TokenName) {
				tokenStmtForEach.valLVal = new TokenLValName ((TokenName)token);
				token = token.nextToken;
			}
			if (!(token is TokenKwIn)) {
				ErrorMsg (token, "expecting 'in'");
				token = SkipPastSemi (token);
				return null;
			}
			token = token.nextToken;
			tokenStmtForEach.arrayRVal = GetOperand (ref token);
			if (tokenStmtForEach.arrayRVal == null) return null;
			if (!(token is TokenKwParClose)) {
				ErrorMsg (token, "expecting )");
				token = SkipPastSemi (token);
				return null;
			}
			token = token.nextToken;
			tokenStmtForEach.bodyStmt = ParseStmt (ref token);
			if (tokenStmtForEach.bodyStmt == null) return null;
			return tokenStmtForEach;
		}

		private TokenStmtIf ParseStmtIf (ref Token token)
		{
			TokenStmtIf tokenStmtIf = new TokenStmtIf (token);
			token = token.nextToken;
			tokenStmtIf.testRVal = ParseRValParen (ref token);
			if (tokenStmtIf.testRVal == null) return null;
			tokenStmtIf.trueStmt = ParseStmt (ref token);
			if (tokenStmtIf.trueStmt == null) return null;
			if (token is TokenKwElse) {
				token = token.nextToken;
				tokenStmtIf.elseStmt = ParseStmt (ref token);
				if (tokenStmtIf.elseStmt == null) return null;
			}
			return tokenStmtIf;
		}

		private TokenStmtJump ParseStmtJump (ref Token token)
		{

			/*
			 * Create jump statement token to encapsulate the whole statement.
			 */
			TokenStmtJump tokenStmtJump = new TokenStmtJump (token);
			token = token.nextToken;
			if (!(token is TokenName) || !(token.nextToken is TokenKwSemi)) {
				ErrorMsg (token, "expecting label;");
				token = SkipPastSemi (token);
				return null;
			}
			tokenStmtJump.label = (TokenName)token;
			token = token.nextToken.nextToken;

			/*
			 * If label is already defined, it means this is a backward (looping)
			 * jump, so remember the label has backward jump references.
			 */
			if (currentDeclFunc.labels.ContainsKey (tokenStmtJump.label.val)) {
				currentDeclFunc.labels[tokenStmtJump.label.val].hasBkwdRefs = true;
			}

			return tokenStmtJump;
		}

		/**
		 * @brief parse a jump target label statement
		 * @param token = points to the '@' token
		 * @returns null: error parsing
		 *          else: the label
		 *          token = advanced just past the ;
		 */
		private TokenStmtLabel ParseStmtLabel (ref Token token)
		{
			if (!(token.nextToken is TokenName) ||
			    !(token.nextToken.nextToken is TokenKwSemi)) {
				ErrorMsg (token, "invalid label");
				token = SkipPastSemi (token);
				return null;
			}
			TokenStmtLabel stmtLabel = new TokenStmtLabel (token);
			stmtLabel.name  = (TokenName)token.nextToken;
			stmtLabel.block = currentStmtBlock;
			if (currentDeclFunc.labels.ContainsKey (stmtLabel.name.val)) {
				ErrorMsg (token.nextToken, "duplicate label");
				ErrorMsg (currentDeclFunc.labels[stmtLabel.name.val], "previously defined here");
				token = SkipPastSemi (token);
				return null;
			}
			currentDeclFunc.labels.Add (stmtLabel.name.val, stmtLabel);
			token = token.nextToken.nextToken.nextToken;
			return stmtLabel;
		}

		private TokenStmtNull ParseStmtNull (ref Token token)
		{
			TokenStmtNull tokenStmtNull = new TokenStmtNull (token);
			token = token.nextToken;
			return tokenStmtNull;
		}

		private TokenStmtRet ParseStmtRet (ref Token token)
		{
			TokenStmtRet tokenStmtRet = new TokenStmtRet (token);
			token = token.nextToken;
			if (token is TokenKwSemi) {
				token = token.nextToken;
			} else {
				tokenStmtRet.rVal = ParseRVal (ref token, semiOnly);
				if (tokenStmtRet.rVal == null) return null;
			}
			return tokenStmtRet;
		}

		private TokenStmtSwitch ParseStmtSwitch (ref Token token)
		{
			TokenStmtSwitch tokenStmtSwitch = new TokenStmtSwitch (token);
			token = token.nextToken;
			tokenStmtSwitch.testRVal = ParseRValParen (ref token);
			if (tokenStmtSwitch.testRVal == null) return null;
			if (!(token is TokenKwBrcOpen)) {
				ErrorMsg (token, "expecting open brace");
				token = SkipPastSemi (token);
				return null;
			}
			token = token.nextToken;
			TokenSwitchCase tokenSwitchCase = null;
			bool haveComplained = false;
			while (!(token is TokenKwBrcClose)) {
				if (token is TokenKwCase) {
					tokenSwitchCase = new TokenSwitchCase (token);
					if (tokenStmtSwitch.lastCase == null) {
						tokenStmtSwitch.cases = tokenSwitchCase;
					} else {
						tokenStmtSwitch.lastCase.nextCase = tokenSwitchCase;
					}
					tokenStmtSwitch.lastCase =  tokenSwitchCase;

					token = token.nextToken;
					tokenSwitchCase.rVal1 = ParseRVal (ref token, colonOrDotDotDot);
					if (tokenSwitchCase.rVal1 == null) return null;
					if (token is TokenKwDotDotDot) {
						token = token.nextToken;
						tokenSwitchCase.rVal2 = ParseRVal (ref token, colonOnly);
						if (tokenSwitchCase.rVal2 == null) return null;
					} else {
						if (!(token is TokenKwColon)) {
							ErrorMsg (token, "expecting : or ...");
							token = SkipPastSemi (token);
							return null;
						}
						token = token.nextToken;
					}
				} else if (token is TokenKwDefault) {
					tokenSwitchCase = new TokenSwitchCase (token);
					if (tokenStmtSwitch.lastCase == null) {
						tokenStmtSwitch.cases = tokenSwitchCase;
					} else {
						tokenStmtSwitch.lastCase.nextCase = tokenSwitchCase;
					}
					tokenStmtSwitch.lastCase =  tokenSwitchCase;

					token = token.nextToken;
					if (!(token is TokenKwColon)) {
						ErrorMsg (token, "expecting :");
						token = SkipPastSemi (token);
						return null;
					}
					token = token.nextToken;
				} else if (tokenSwitchCase != null) {
					TokenStmt bodyStmt = ParseStmt (ref token);
					if (bodyStmt == null) return null;
					if (tokenSwitchCase.lastStmt == null) {
						tokenSwitchCase.stmts = bodyStmt;
					} else {
						tokenSwitchCase.lastStmt.nextToken = bodyStmt;
					}
					tokenSwitchCase.lastStmt = bodyStmt;
					bodyStmt.nextToken = null;
				} else if (!haveComplained) {
					ErrorMsg (token, "expecting case or default label");
					token = SkipPastSemi (token);
					haveComplained = true;
				}
			}
			token = token.nextToken;
			return tokenStmtSwitch;
		}

		private TokenStmtState ParseStmtState (ref Token token)
		{
			TokenStmtState tokenStmtState = new TokenStmtState (token);
			token = token.nextToken;
			if ((!(token is TokenName) && !(token is TokenKwDefault)) || !(token.nextToken is TokenKwSemi)) {
				ErrorMsg (token, "expecting state;");
				token = SkipPastSemi (token);
				return null;
			}
			if (token is TokenName) {
				tokenStmtState.state = (TokenName)token;
			}
			token = token.nextToken.nextToken;
			return tokenStmtState;
		}

		private TokenStmtThrow ParseStmtThrow (ref Token token)
		{
			TokenStmtThrow tokenStmtThrow = new TokenStmtThrow (token);
			token = token.nextToken;
			if (token is TokenKwSemi) {
				token = token.nextToken;
			} else {
				tokenStmtThrow.rVal = ParseRVal (ref token, semiOnly);
				if (tokenStmtThrow.rVal == null) return null;
			}
			return tokenStmtThrow;
		}

		private TokenStmtTry ParseStmtTry (ref Token token)
		{
			TokenStmtTry tokenStmtTry = new TokenStmtTry (token);
			token = token.nextToken;
			tokenStmtTry.tryStmt = ParseStmtBlock (ref token);
			if (tokenStmtTry.tryStmt == null) return null;
			if (token is TokenKwCatch) {
				if (!(token.nextToken is TokenKwParOpen) ||
				    !(token.nextToken.nextToken is TokenTypeStr) ||
				    !(token.nextToken.nextToken.nextToken is TokenName) ||
				    !(token.nextToken.nextToken.nextToken.nextToken is TokenKwParClose)) {
					ErrorMsg (token, "catch must be followed by ( string <varname> ) <statement>");
					return null;
				}
				tokenStmtTry.catchVar = (TokenName) token.nextToken.nextToken.nextToken;
				token = token.nextToken.nextToken.nextToken.nextToken.nextToken;
				tokenStmtTry.catchStmt = ParseStmtBlock (ref token);
				if (tokenStmtTry.catchStmt == null) return null;
			}
			if (token is TokenKwFinally) {
				token = token.nextToken;
				tokenStmtTry.finallyStmt = ParseStmtBlock (ref token);
				if (tokenStmtTry.finallyStmt == null) return null;
			}
			if ((tokenStmtTry.catchStmt == null) && (tokenStmtTry.finallyStmt == null)) {
				ErrorMsg (tokenStmtTry, "try must have a matching catch and/or finally");
				return null;
			}
			return tokenStmtTry;
		}

		private TokenStmtWhile ParseStmtWhile (ref Token token)
		{
			TokenStmtWhile tokenStmtWhile = new TokenStmtWhile (token);
			token = token.nextToken;
			tokenStmtWhile.testRVal = ParseRValParen (ref token);
			if (tokenStmtWhile.testRVal == null) return null;
			tokenStmtWhile.bodyStmt = ParseStmt (ref token);
			if (tokenStmtWhile.bodyStmt == null) return null;
			return tokenStmtWhile;
		}

		/**
		 * @brief parse a variable declaration statement, including init value if any.
		 * @param token = points to type or 'constant' token
		 * @param variables = list of variables to insert it in
		 * @returns null: parsing error
		 *          else: variable declaration encapulating token
		 *          token = advanced just past semi-colon
		 *          variables = modified to include the new variable
		 */
		private TokenDeclVar ParseDeclVar (ref Token token, Dictionary<string, TokenDeclVar> variables)
		{
			TokenDeclVar tokenDeclVar = new TokenDeclVar (token.nextToken, currentDeclFunc);

			/*
			 * Handle constant declaration.
			 * It ends up in the declared variables list for the statement block just like
			 * any other variable, except it has .constant = true.
			 * The code generator will test that the initialization expression is constant.
			 *
			 * 	constant <name> = <value> ;
			 */
			if (token is TokenKwConst) {
				token = token.nextToken;
				if (!(token is TokenName)) {
					ErrorMsg (token, "expecting constant name");
					token = SkipPastSemi (token);
					return null;
				}
				tokenDeclVar.name = (TokenName)token;
				token = token.nextToken;
				if (!(token is TokenKwAssign)) {
					ErrorMsg (token, "expecting =");
					token = SkipPastSemi (token);
					return null;
				}
				token = token.nextToken;
				TokenRVal rVal = ParseRVal (ref token, semiOnly);
				if (rVal == null) return null;
				tokenDeclVar.init = rVal;
				tokenDeclVar.constant = true;
			}

			/*
			 * Otherwise, normal variable declaration with optional initialization value.
			 */
			else {
				/*
				 * Build basic encapsulating token with type and name.
				 */
				tokenDeclVar.type = (TokenType)token;
				token = token.nextToken;
				if (!(token is TokenName)) {
					ErrorMsg (token, "expecting variable name");
					token = SkipPastSemi (token);
					return null;
				}
				tokenDeclVar.name = (TokenName)token;
				token = token.nextToken;

				/*
				 * If just a ;, there is no explicit initialization value.
				 * Otherwise, look for an =RVal; expression that has init value.
				 */
				if (token is TokenKwSemi) {
					token = token.nextToken;
				} else if (token is TokenKwAssign) {
					token = token.nextToken;
					tokenDeclVar.init = ParseRVal (ref token, semiOnly);
					if (tokenDeclVar.init == null) return null;
				} else {
					ErrorMsg (token, "expecting = or ;");
					token = SkipPastSemi (token);
					return null;
				}
			}

			/*
			 * Can't be same name already in block.
			 */
			TokenDeclVar bad;
			if (variables.TryGetValue (tokenDeclVar.name.val, out bad)) {
				ErrorMsg (tokenDeclVar, "duplicate variable definition");
				ErrorMsg (bad.name, "previously defined here");
				return null;
			}
			variables.Add (tokenDeclVar.name.val, tokenDeclVar);

			return tokenDeclVar;
		}

		/**
		 * @brief parse function declaration argument list
		 * @param token = points to TokenKwParOpen
		 * @returns null: parse error
		 *          else: points to token with types and names
		 *          token = updated past the TokenKwParClose
		 */
		private TokenArgDecl ParseFuncArgs (ref Token token)
		{
			int nArgs = 0;
			LinkedList<TokenName> nameList = new LinkedList<TokenName> ();
			LinkedList<TokenType> typeList = new LinkedList<TokenType> ();
			TokenArgDecl tokenArgDecl = new TokenArgDecl (token);

			do {
				token = token.nextToken;
				if ((nArgs == 0) && (token is TokenKwParClose)) break;
				if (!(token is TokenType)) {
					ErrorMsg (token, "expecting arg type");
					token = SkipPastSemi (token);
					return null;
				}
				typeList.AddLast ((TokenType)token);

				token = token.nextToken;
				if (!(token is TokenName)) {
					ErrorMsg (token, "expecting arg name");
					token = SkipPastSemi (token);
					return null;
				}
				foreach (TokenName dupCheck in nameList) {
					if (dupCheck.val == ((TokenName)token).val) {
						ErrorMsg (token, "duplicate arg name");
						break;
					}
				}
				nameList.AddLast ((TokenName)token);
				nArgs ++;

				token = token.nextToken;
			} while (token is TokenKwComma);
			if (!(token is TokenKwParClose)) {
				ErrorMsg (token, "expecting comma or close paren");
				token = SkipPastSemi (token);
				return null;
			}
			token = token.nextToken;

			tokenArgDecl.types = System.Linq.Enumerable.ToArray (typeList);
			tokenArgDecl.names = System.Linq.Enumerable.ToArray (nameList);
			tokenArgDecl.locns = new CompValu[nArgs];
			return tokenArgDecl;
		}

		/**
		 * @brief parse right-hand value expression
		 *        this is where arithmetic-like expressions are processed
		 * @param token = points to first token expression
		 * @param termTokenType = expression termination token type
		 * @returns null: not an RVal
		 *          else: single token representing whole expression
		 *          token = if termTokenType.Length == 1, points just past terminating token
		 *                                          else, points right at terminating token
		 */
		public TokenRVal ParseRVal (ref Token token, Type[] termTokenTypes)
		{
			/*
			 * Start with pushing the first operand on operand stack.
			 */
			BinOp binOps = null;
			TokenRVal operands = GetOperand (ref token);
			if (operands == null) return null;

			/*
			 * Keep scanning until we hit the termination token.
			 */
			while (true) {
				Type tokType = token.GetType();
				for (int i = termTokenTypes.Length; -- i >= 0;) {
					if (tokType == termTokenTypes[i]) goto done;
				}

				/*
				 * Special form:
				 *   <operand> is <typeexp>
				 */
				if (token is TokenKwIs) {
					TokenRValIsType tokenRValIsType = new TokenRValIsType (token);
					token = token.nextToken;

					/*
					 * Parse the <typeexp>.
					 */
					tokenRValIsType.typeExp = ParseTypeExp (ref token);
					if (tokenRValIsType.typeExp == null) return null;

					/*
					 * Replace top operand with result of <operand> is <typeexp>
					 */
					tokenRValIsType.rValExp   = operands;
					tokenRValIsType.nextToken = operands.nextToken;
					operands = tokenRValIsType;

					/*
					 * token points just past <typeexp> so see if it is another operator.
					 */
					continue;
				}

				/*
				 * Peek at next operator.
				 */
				BinOp binOp = GetOperator (ref token);
				if (binOp == null) return null;

				/*
				 * If there are stacked operators of higher or same precedence than new one,
				 * perform their computation then push result back on operand stack.
				 *
				 *  higher or same = left-to-right application of operators
				 *                   eg, a - b - c becomes (a - b) - c
				 *
				 *  higher precedence = right-to-left application of operators
				 *                      eg, a - b - c becomes a - (b - c)
				 *
				 * Now of course, there is some ugliness necessary:
				 *      we want:  a  - b - c  =>  (a - b) - c    so we do 'higher or same'
				 *  but we want:  a += b = c  =>  a += (b = c)   so we do 'higher only'
				 *
				 * binOps is the first operator (or null if only one)
				 * binOp is the second operator (or first if only one)
				 */
				while (binOps != null) {
					if (binOps.preced < binOp.preced) break;       // 1st operator lower than 2nd, so leave 1st on stack to do later
					if (binOps.preced > binOp.preced) goto do1st;  // 1st op higher than 2nd, so we always do 1st op first
					if (binOps.preced == ASNPR) break;             // equal preced, if assignment type, leave 1st on stack to do later
					                                               //               if non-asn type, do 1st op first (ie left-to-right)
				do1st:
					TokenRVal result = PerformBinOp ((TokenRVal)operands.prevToken, binOps, (TokenRVal)operands);
					result.prevToken = operands.prevToken.prevToken;
					operands = result;
					binOps   = binOps.pop;
				}

				/*
				 * Push new operator on its stack.
				 */
				binOp.pop = binOps;
				binOps = binOp;

				/*
				 * Push next operand on its stack.
				 */
				TokenRVal operand = GetOperand (ref token);
				if (operand == null) return null;
				operand.prevToken = operands;
				operands = operand;
			}
		done:

			/*
			 * At end of expression, perform any stacked computations.
			 */
			while (binOps != null) {
				TokenRVal result = PerformBinOp ((TokenRVal)operands.prevToken, binOps, (TokenRVal)operands);
				result.prevToken = operands.prevToken.prevToken;
				operands = result;
				binOps   = binOps.pop;
			}

			/*
			 * There should be exactly one remaining operand on the stack which is our final result.
			 */
			if (operands.prevToken != null) throw new Exception ("too many operands");

			/*
			 * If only one terminator type possible, advance past the terminator.
			 */
			if (termTokenTypes.Length == 1) token = token.nextToken;

			return operands;
		}

		private TokenTypeExp ParseTypeExp (ref Token token)
		{
			TokenTypeExp leftOperand = GetTypeExp (ref token);
			if (leftOperand == null) return null;

			while ((token is TokenKwAnd) || (token is TokenKwOr)) {
				Token typeBinOp = token;
				token = token.nextToken;
				TokenTypeExp rightOperand = GetTypeExp (ref token);
				if (rightOperand == null) return null;
				TokenTypeExpBinOp typeExpBinOp = new TokenTypeExpBinOp (typeBinOp);
				typeExpBinOp.leftOp  = leftOperand;
				typeExpBinOp.binOp   = typeBinOp;
				typeExpBinOp.rightOp = rightOperand;
				leftOperand = typeExpBinOp;
			}
			return leftOperand;
		}

		private TokenTypeExp GetTypeExp (ref Token token)
		{
			if (token is TokenKwTilde) {
				TokenTypeExpNot typeExpNot = new TokenTypeExpNot (token);
				token = token.nextToken;
				typeExpNot.typeExp = GetTypeExp (ref token);
				if (typeExpNot.typeExp == null) return null;
				return typeExpNot;
			}
			if (token is TokenKwParOpen) {
				TokenTypeExpPar typeExpPar = new TokenTypeExpPar (token);
				token = token.nextToken;
				typeExpPar.typeExp = GetTypeExp (ref token);
				if (typeExpPar.typeExp == null) return null;
				if (!(token is TokenKwParClose)) {
					ErrorMsg (token, "expected close parenthesis");
					token = SkipPastSemi (token);
					return null;
				}
				return typeExpPar;
			}
			if (token is TokenKwUndef) {
				TokenTypeExpUndef typeExpUndef = new TokenTypeExpUndef (token);
				token = token.nextToken;
				return typeExpUndef;
			}
			if (token is TokenType) {
				TokenTypeExpType typeExpType = new TokenTypeExpType (token);
				typeExpType.typeToken = (TokenType)token;
				token = token.nextToken;
				return typeExpType;
			}
			ErrorMsg (token, "expected type");
			token = SkipPastSemi (token);
			return null;
		}

		/**
		 * @brief get a right-hand operand expression token
		 * @param token = first token of operand to parse
		 * @returns null: invalid operand
		 *          else: token that bundles or wraps the operand
		 *          token = points to token following last operand token
		 */
		private TokenRVal GetOperand (ref Token token)
		{
			/*
			 * Prefix unary operators (eg ++, --) requiring an L-value.
			 */
			if ((token is TokenKwIncr) || (token is TokenKwDecr)) {
				TokenRValAsnPre asnPre = new TokenRValAsnPre (token);
				asnPre.prefix = token;
				token = token.nextToken;
				TokenRVal op = GetOperand (ref token);
				if (op == null) return null;
				if (!(op is TokenLVal)) {
					ErrorMsg (op, "can pre{in,de}crement only an L-value");
					return null;
				}
				asnPre.lVal = (TokenLVal)op;
				return asnPre;
			}

			/*
			 * Get the bulk of the operand, ie, without any of the below suffixes.
			 */
			TokenRVal operand = GetOperandNoMods (ref token);
			if (operand == null) return null;
		modifiers:

			/*
			 * If followed by '++' or '--', it is post-{in,de}cremented.
			 */
			if ((token is TokenKwIncr) || (token is TokenKwDecr)) {
				TokenRValAsnPost asnPost = new TokenRValAsnPost (token);
				asnPost.postfix = token;
				token = token.nextToken;
				if (!(operand is TokenLVal)) {
					ErrorMsg (operand, "can post{in,de}crement only an L-value");
					return null;
				}
				asnPost.lVal = (TokenLVal)operand;
				return asnPost;
			}

			/*
			 * If followed by a '.', it is an instance field or instance method reference.
			 */
			if (token is TokenKwDot) {
				token = token.nextToken;
				if (!(token is TokenName)) {
					ErrorMsg (token, ". must be followed by field/method name");
					return null;
				}
				TokenLValIField field = new TokenLValIField (token);
				field.baseRVal = operand;
				field.field = (TokenName)token;
				operand = field;
				token = token.nextToken;
				goto modifiers;
			}

			/*
			 * If follwed by a '[', it is an array subscript.
			 */
			if (token is TokenKwBrkOpen) {
				TokenLValArEle tokenLValArEle = new TokenLValArEle (token);
				token = token.nextToken;

				/*
				 * Parse subscript(s) expression.
				 */
				tokenLValArEle.subRVal = ParseRVal (ref token, brkCloseOnly);
				if (tokenLValArEle.subRVal == null) {
					ErrorMsg (tokenLValArEle, "invalid subscript");
					return null;
				}

				/*
				 * See if comma-separated list of values.
				 */
				bool sideEffects = false;
				TokenRVal subscriptRVals;
				int numSubscripts = SplitCommaRVals (tokenLValArEle.subRVal, out subscriptRVals, ref sideEffects);
				if (numSubscripts > 1) {

					/*
					 * If so, put the values in an LSL_List object.
					 */
					TokenRValList rValList = new TokenRValList (tokenLValArEle);
					rValList.rVal = subscriptRVals;
					rValList.nItems = numSubscripts;
					rValList.sideEffects = sideEffects;
					tokenLValArEle.subRVal = rValList;
				}

				/*
				 * Either way, save array variable name
				 * and substitute whole reference for L-value
				 */
				tokenLValArEle.baseRVal = operand;
				operand = tokenLValArEle;
				goto modifiers;
			}

			/*
			 * If followed by a '(', it is a function/method call.
			 */
			if (token is TokenKwParOpen) {
				operand = ParseRValCall (ref token, operand);
				goto modifiers;
			}

			return operand;
		}

		/**
		 * @brief same as GetOperand() except doesn't check for any modifiers
		 */
		private TokenRVal GetOperandNoMods (ref Token token)
		{
			/*
			 * Simple unary operators.
			 */
			if ((token is TokenKwSub) || 
			    (token is TokenKwTilde) ||
			    (token is TokenKwExclam)) {
				Token uop = token;
				token = token.nextToken;
				TokenRVal rVal = GetOperand (ref token);
				if (rVal == null) return null;
				return PerformUnOp (uop, rVal);
			}

			/*
			 * Type casting.
			 */
			if ((token is TokenKwParOpen) &&
			    (token.nextToken is TokenType) &&
			    (token.nextToken.nextToken is TokenKwParClose)) {
				TokenType type = (TokenType)token.nextToken;
				token = token.nextToken.nextToken.nextToken;
				TokenRVal rVal = GetOperand (ref token);
				if (rVal == null) return null;
				return new TokenRValCast (type, rVal);
			}

			/*
			 * Parenthesized expression.
			 */
			if (token is TokenKwParOpen) {
				return ParseRValParen (ref token);
			}

			/*
			 * Constants.
			 */
			if (token is TokenFloat) {
				TokenRValConst rValConst = new TokenRValConst (token, ((TokenFloat)token).val);
				token = token.nextToken;
				return rValConst;
			}
			if (token is TokenInt) {
				TokenRValConst rValConst = new TokenRValConst (token, ((TokenInt)token).val);
				token = token.nextToken;
				return rValConst;
			}
			if (token is TokenStr) {
				TokenRValConst rValConst = new TokenRValConst (token, ((TokenStr)token).val);
				token = token.nextToken;
				return rValConst;
			}
			if (token is TokenKwUndef) {
				TokenRValUndef rValUndef = new TokenRValUndef ((TokenKwUndef)token);
				token = token.nextToken;
				return rValUndef;
			}

			/*
			 * '<'value,...'>', ie, rotation or vector
			 */
			if (token is TokenKwCmpLT) {
				Token openBkt = token;
				token = token.nextToken;
				TokenRVal rValAll = ParseRVal (ref token, cmpGTOnly);
				if (rValAll == null) return null;
				TokenRVal rVals;
				bool sideEffects = false;
				int nVals = SplitCommaRVals (rValAll, out rVals, ref sideEffects);
				switch (nVals) {
					case 3: {
						TokenRValVec rValVec = new TokenRValVec (openBkt);
						rValVec.xRVal = rVals;
						rValVec.yRVal = (TokenRVal)rVals.nextToken;
						rValVec.zRVal = (TokenRVal)rVals.nextToken.nextToken;
						rValVec.sideEffects = sideEffects;
						return rValVec;
					}
					case 4: {
						TokenRValRot rValRot = new TokenRValRot (openBkt);
						rValRot.xRVal = rVals;
						rValRot.yRVal = (TokenRVal)rVals.nextToken;
						rValRot.zRVal = (TokenRVal)rVals.nextToken.nextToken;
						rValRot.wRVal = (TokenRVal)rVals.nextToken.nextToken.nextToken;
						rValRot.sideEffects = sideEffects;
						return rValRot;
					}
					default: {
						ErrorMsg (openBkt, "bad rotation/vector");
						token = SkipPastSemi (token);
						return null;
					}
				}
			}

			/*
			 * '['value,...']', ie, list
			 */
			if (token is TokenKwBrkOpen) {
				TokenRValList rValList = new TokenRValList (token);
				token = token.nextToken;
				if (token is TokenKwBrkClose) {
					token = token.nextToken;  // empty list
				} else {
					TokenRVal rValAll = ParseRVal (ref token, brkCloseOnly);
					if (rValAll == null) return null;
					rValList.nItems = SplitCommaRVals (rValAll, out rValList.rVal, ref rValList.sideEffects);
				}
				return rValList;
			}

			/*
			 * Maybe we have <type>.<name> referencing a static field or method of some type.
			 */
			if ((token is TokenType) && (token.nextToken is TokenKwDot) && (token.nextToken.nextToken is TokenName)) {
				TokenLValSField field = new TokenLValSField (token.nextToken.nextToken);
				field.baseType = (TokenType)token;
				field.fieldName = (TokenName)token.nextToken.nextToken;
				token = token.nextToken.nextToken.nextToken;
				return field;
			}

			/*
			 * Maybe we have 'this' referring to the object of the instance method.
			 */
			if (token is TokenKwThis) {
				TokenRValThis zhis = new TokenRValThis (token);
				token = token.nextToken;
				return zhis;
			}

			/*
			 * Maybe we have 'base' referring to a field/method of the extended class.
			 */
			if (token is TokenKwBase) {
				if (!(token.nextToken is TokenKwDot) || !(token.nextToken.nextToken is TokenName)) {
					ErrorMsg (token, "base must be followed by . then field or method name");
					TokenRValThis zhis = new TokenRValThis (token);
					token = token.nextToken;
					return zhis;
				}
				TokenRValBaseField baseField = new TokenRValBaseField (token, (TokenName)token.nextToken.nextToken);
				token = token.nextToken.nextToken.nextToken;
				return baseField;
			}

			/*
			 * Maybe we have 'new <script-defined-type>' saying to create an object instance.
			 * This ends up generating a call to static function <script-defined-type>.new(...)
			 * whose CIL code is generated by GenerateNewobjBody().
			 */
			if ((token is TokenKwNew) && (token.nextToken is TokenType)) {
				TokenLValSField field = new TokenLValSField (token.nextToken.nextToken);
				field.baseType  = (TokenType)token.nextToken;
				field.fieldName = new TokenName (token, "new");
				token = token.nextToken.nextToken;
				return field;
			}

			/*
			 * All we got left is <name>, eg, arg, function, global or local variable reference
			 */
			if (token is TokenName) {
				TokenLValName name = new TokenLValName ((TokenName)token);
				token = token.nextToken;
				return name;
			}

			/*
			 * Who knows what it is supposed to be?
			 */
			ErrorMsg (token, "invalid operand token");
			token = SkipPastSemi (token);
			return null;
		}

		/**
		 * @brief Parse a call expression
		 * @param token = points to arg list '('
		 * @param meth = points to method name being called
		 * @returns call expression value
		 *          token = points just past arg list ')'
		 */
		private TokenRValCall ParseRValCall (ref Token token, TokenRVal meth)
		{
			/*
			 * Set up basic function call struct with function name.
			 */
			TokenRValCall rValCall = new TokenRValCall (token);
			rValCall.meth = meth;

			/*
			 * Parse the call parameters, if any.
			 */
			token = token.nextToken;
			if (token is TokenKwParClose) {
				token = token.nextToken;
			} else {
				rValCall.args = ParseRVal (ref token, parCloseOnly);
				if (rValCall.args == null) return null;
				rValCall.nArgs = SplitCommaRVals (rValCall.args, out rValCall.args, ref rValCall.sideEffects);
			}

			return rValCall;
		}

		/**
		 * @brief decode binary operator token
		 * @param token = points to token to decode
		 * @returns null: invalid operator token
		 *          else: operator token and precedence
		 */
		private BinOp GetOperator (ref Token token)
		{
			BinOp binOp = new BinOp ();
			if (precedence.TryGetValue (token.GetType (), out binOp.preced)) {
				binOp.token = (TokenKw)token;
				token = token.nextToken;
				return binOp;
			}

			if ((token is TokenKwSemi) || (token is TokenKwBrcOpen) || (token is TokenKwBrcClose)) {
				ErrorMsg (token, "premature expression end");
			} else {
				ErrorMsg (token, "invalid operator");
			}
			token = SkipPastSemi (token);
			return null;
		}

		private class BinOp {
			public BinOp pop;
			public TokenKw token;
			public int preced;
		}

		/**
		 * @brief Return an R-value expression token that will be used to
		 *        generate code to perform the operation at runtime.
		 * @param left  = left-hand operand
		 * @param binOp = operator
		 * @param right = right-hand operand
		 * @returns resultant expression
		 */
		private TokenRVal PerformBinOp (TokenRVal left, BinOp binOp, TokenRVal right)
		{
			return new TokenRValOpBin (left, binOp.token, right);
		}

		/**
		 * @brief Return an R-value expression token that will be used to
		 *        generate code to perform the operation at runtime.
		 * @param unOp  = operator
		 * @param right = right-hand operand
		 * @returns resultant constant or expression
		 */
		private TokenRVal PerformUnOp (Token unOp, TokenRVal right)
		{
			return new TokenRValOpUn ((TokenKw)unOp, right);
		}

		/**
		 * @brief parse out a parenthesized expression.
		 * @param token = points to open parenthesis
		 * @returns null: invalid expression
		 *          else: parenthesized expression token or constant token
		 *          token = points past the close parenthesis
		 */
		private TokenRVal ParseRValParen (ref Token token)
		{
			if (!(token is TokenKwParOpen)) {
				ErrorMsg (token, "expecting (");
				token = SkipPastSemi (token);
				return null;
			}
			TokenRValParen tokenRValParen = new TokenRValParen (token);
			token = token.nextToken;
			tokenRValParen.rVal = ParseRVal (ref token, parCloseOnly);
			if (tokenRValParen.rVal == null) return null;
			tokenRValParen.sideEffects = tokenRValParen.rVal.sideEffects;
			return tokenRValParen;
		}

		/**
		 * @brief Split a comma'd RVal into separate expressions
		 * @param rValAll = expression containing commas
		 * @returns number of comma separated values
		 *          rVals = values in a null-terminated list linked by rVals.nextToken
		 *          sideEffects |= some of the values have side effects
		 */
		private int SplitCommaRVals (TokenRVal rValAll, out TokenRVal rVals, ref bool sideEffects)
		{
			if (!(rValAll is TokenRValOpBin) || !(((TokenRValOpBin)rValAll).opcode is TokenKwComma)) {
				rVals = rValAll;
				if (rVals.nextToken != null) throw new Exception ("expected null");
				sideEffects |= rValAll.sideEffects;
				return 1;
			}
			TokenRValOpBin opBin = (TokenRValOpBin)rValAll;
			TokenRVal rValLeft, rValRight;
			bool sel = false;
			bool ser = false;
			int leftCount  = SplitCommaRVals (opBin.rValLeft,  out rValLeft,  ref sel);
			int rightCount = SplitCommaRVals (opBin.rValRight, out rValRight, ref ser);
			rVals = rValLeft;
			while (rValLeft.nextToken != null) rValLeft = (TokenRVal)rValLeft.nextToken;
			rValLeft.nextToken = rValRight;
			sideEffects |= sel | ser;
			return leftCount + rightCount;
		}

		/**
		 * @brief output error message and remember that there is an error.
		 * @param token = what token is associated with the error
		 * @param message = error message string
		 */
		private void ErrorMsg (Token token, string message)
		{
			errors = true;
			token.ErrorMsg (message);
		}

		/**
		 * @brief Skip past the next semicolon (or matched braces)
		 * @param token = points to token to skip over
		 * @returns token just after the semicolon or close brace
		 */
		private Token SkipPastSemi (Token token)
		{
			int braceLevel = 0;

			while (!(token is TokenEnd)) {
				if ((token is TokenKwSemi) && (braceLevel == 0)) {
					return token.nextToken;
				}
				if (token is TokenKwBrcOpen) {
					braceLevel ++;
				}
				if ((token is TokenKwBrcClose) && (-- braceLevel <= 0)) {
					return token.nextToken;
				}
				token = token.nextToken;
			}
			return token;
		}
	}

	/**
	 * @brief Script-defined type declarations
	 */
	public abstract class TokenDeclSDType : Token {
		protected const byte CLASS     = 0;
		protected const byte DELEGATE  = 1;
		protected const byte INTERFACE = 2;

		/*
		 * Dictionary used when reading from object file that holds all script-defined types.
		 * Not complete though until all types have been read from the object file.
		 */
		private Dictionary<string, TokenDeclSDType> sdTypes;

		public TokenDeclSDType (Token t) : base (t) { }
		public abstract TokenTypeSDType MakeRefToken (Token t);
		public abstract Type GetSysType ();
		public abstract void WriteToFile (BinaryWriter objFileWriter);
		public abstract void ReadFromFile (BinaryReader objFileReader, TextWriter asmFileWriter);

		/**
		 * @brief Read one of these in from the object file.
		 * @param sdTypes = dictionary of script-defined types, not yet complete
		 * @param name = script-visible name of this type
		 * @param objFileReader = reads from the object file
		 * @param asmFileWriter = writes to the disassembly file (might be null)
		 */
		public static TokenDeclSDType ReadFromFile (Dictionary<string, TokenDeclSDType> sdTypes, string name, 
		                                            BinaryReader objFileReader, TextWriter asmFileWriter)
		{
			string file = objFileReader.ReadString ();
			int    line = objFileReader.ReadInt32 ();
			int    posn = objFileReader.ReadInt32 ();
			byte   code = objFileReader.ReadByte ();
			TokenName n = new TokenName (null, file, line, posn, name);
			TokenDeclSDType sdt;
			switch (code) {
				case CLASS: {
					sdt = new TokenDeclSDTypeClass (n);
					break;
				}
				case DELEGATE: {
					sdt = new TokenDeclSDTypeDelegate (n);
					break;
				}
				case INTERFACE: {
					sdt = new TokenDeclSDTypeInterface (n);
					break;
				}
				default: throw new Exception ();
			}
			sdt.sdTypes = sdTypes;
			sdt.ReadFromFile (objFileReader, asmFileWriter);
			return sdt;
		}

		/**
		 * @brief Convert a typename string to a type token
		 * @param name = script-visible name of token to create, 
		 *               either a script-defined type or an LSL-defined type
		 * @returns type token
		 */
		protected TokenType MakeTypeToken (string name)
		{
			TokenDeclSDType sdtdecl;
			if (sdTypes.TryGetValue (name, out sdtdecl)) return sdtdecl.MakeRefToken (this);
			return TokenType.FromLSLType (this, name);
		}
	}

	public class TokenDeclSDTypeClass : TokenDeclSDType {
		public TokenName name;
		public TokenDeclSDTypeClass extends;
		public bool isAbstract;
		public List<TokenDeclSDTypeInterface> implements = new List<TokenDeclSDTypeInterface> ();
		public Dictionary<string, TokenDeclVar>  fields  = new Dictionary<string, TokenDeclVar>  ();
		public Dictionary<string, TokenDeclFunc> methods = new Dictionary<string, TokenDeclFunc> ();

		public Dictionary<string, int> intfIndices = new Dictionary<string, int> ();
		public TokenDeclFunc[][] iImplFunc;  // iImplFunc[i][j]:
		                                     //   low-end [i] entries copied from rootward classes
		                                     //   i = interface number from this.intfIndices[name]
		                                     //   j = method of interface from iface.methods[name].vTableIndex
		public TokenDeclSDTypeInterface[] iFaces;  // array of implemented interfaces
		                                           //   low-end entries copied from rootward classes

		public bool slotsAssigned;    // set true when slots have been assigned...
		public int numInstArrays;     // number of non-static array fields
		public int numInstFloats;     // number of non-static float fields
		public int numInstIntegers;   // number of non-static integer fields
		public int numInstLists;      // number of non-static list fields
		public int numInstObjects;    // number of non-static object fields
		public int numInstRotations;  // number of non-static rotation fields
		public int numInstStrings;    // number of non-static string fields
		public int numInstVectors;    // number of non-static vector fields
		public int numInstSDTClasses; // number of non-static sdt-class fields
		public int numVirtFuncs;      // number of virtual functions
		public int numInterfaces;     // number of implemented interfaces

		private string extendsStr;
		private List<StackedMethod> stackedMethods;
		private List<StackedIFace>  stackedIFaces;

		public DynamicMethod[] vDynMeths;    // virtual method entrypoints
		public Type[] vMethTypes;            // virtual method delegate types
		public DynamicMethod[][] iDynMeths;  // interface method entrypoints
		public Type[][] iMethTypes;          // interface method types
		                                     //   low-end [i] entries copied from rootward classes
		                                     //   i = interface number from this.intfIndices[name]
		                                     //   j = method of interface from iface.methods[name].vTableIndex

		public TokenDeclSDTypeClass (TokenName name) : base (name)
		{
			this.name = name;
		}

		public override TokenTypeSDType MakeRefToken (Token t)
		{
			return new TokenTypeSDTypeClass (t, this);
		}

		public override Type GetSysType ()
		{
			return typeof (XMRSDTypeClassInstance);
		}

		/**
		 * @brief Write enough out so we can reconstruct with ReadFromFile.
		 */
		public override void WriteToFile (BinaryWriter objFileWriter)
		{
			objFileWriter.Write (this.file);
			objFileWriter.Write (this.line);
			objFileWriter.Write (this.posn);
			objFileWriter.Write ((byte)CLASS);

			objFileWriter.Write (numInstArrays);
			objFileWriter.Write (numInstFloats);
			objFileWriter.Write (numInstIntegers);
			objFileWriter.Write (numInstLists);
			objFileWriter.Write (numInstObjects);
			objFileWriter.Write (numInstRotations);
			objFileWriter.Write (numInstStrings);
			objFileWriter.Write (numInstVectors);
			objFileWriter.Write (numInstSDTClasses);
			objFileWriter.Write (numVirtFuncs);

			if (extends == null) {
				objFileWriter.Write ("");
			} else {
				objFileWriter.Write (extends.name.val);
			}

			foreach (KeyValuePair<string, TokenDeclFunc> kvp in methods) {
				TokenDeclFunc meth = kvp.Value;
				if (meth.vTableIndex >= 0) {
					objFileWriter.Write (meth.vTableIndex);
					objFileWriter.Write (meth.GetObjCodeName ());
					objFileWriter.Write (meth.GetDelType ().decl.GetWholeSig ());
				}
			}
			objFileWriter.Write (-1);

			int numIFaces = iImplFunc.Length;
			objFileWriter.Write (numIFaces);
			for (int i = 0; i < numIFaces; i ++) {
				objFileWriter.Write (iFaces[i].name.val);
				TokenDeclFunc[] meths = iImplFunc[i];
				int numMeths = 0;
				if (meths != null) numMeths = meths.Length;
				objFileWriter.Write (numMeths);
				for (int j = 0; j < numMeths; j ++) {
					TokenDeclFunc meth = meths[j];
					objFileWriter.Write (meth.GetObjCodeName ());
					objFileWriter.Write (meth.GetDelType ().decl.GetWholeSig ());
				}
			}
		}

		/**
		 * @brief Reconstruct from the file.
		 */
		public override void ReadFromFile (BinaryReader objFileReader, TextWriter asmFileWriter)
		{
			numInstArrays     = objFileReader.ReadInt32 ();
			numInstFloats     = objFileReader.ReadInt32 ();
			numInstIntegers   = objFileReader.ReadInt32 ();
			numInstLists      = objFileReader.ReadInt32 ();
			numInstObjects    = objFileReader.ReadInt32 ();
			numInstRotations  = objFileReader.ReadInt32 ();
			numInstStrings    = objFileReader.ReadInt32 ();
			numInstVectors    = objFileReader.ReadInt32 ();
			numInstSDTClasses = objFileReader.ReadInt32 ();
			numVirtFuncs      = objFileReader.ReadInt32 ();

			extendsStr = objFileReader.ReadString ();

			stackedMethods = new List<StackedMethod> ();
			int vTableIndex;
			while ((vTableIndex = objFileReader.ReadInt32 ()) >= 0) {
				StackedMethod sm;
				sm.methVTI  = vTableIndex;
				sm.methName = objFileReader.ReadString ();
				sm.methSig  = objFileReader.ReadString ();
				stackedMethods.Add (sm);
			}

			int numIFaces = objFileReader.ReadInt32 ();
			if (numIFaces > 0) {
				iDynMeths  = new DynamicMethod[numIFaces][];
				iMethTypes = new Type[numIFaces][];
				stackedIFaces = new List<StackedIFace> ();
				for (int i = 0; i < numIFaces; i ++) {
					string iFaceName = objFileReader.ReadString ();
					intfIndices[iFaceName] = i;
					int numMeths  = objFileReader.ReadInt32 ();
					iDynMeths[i]  = new DynamicMethod[numMeths];
					iMethTypes[i] = new Type[numMeths];
					for (int j = 0; j < numMeths; j ++) {
						StackedIFace si;
						si.iFaceIndex = i;
						si.methIndex  = j;
						si.methName   = objFileReader.ReadString ();
						si.methSig    = objFileReader.ReadString ();
						stackedIFaces.Add (si);
					}
				}
			}
		}

		private struct StackedMethod {
			public int methVTI;
			public string methName;
			public string methSig;
		}

		private struct StackedIFace {
			public int iFaceIndex;
			public int methIndex;
			public string methName;
			public string methSig;
		}

		/**
		 * @brief Called after all dynamic method code has been generated to fill in vDynMeths and vMethTypes
		 *        Also fills in iDynMeths, iMethTypes.
		 */
		public void FillVTables (ScriptObjCode scriptObjCode)
		{
			if (extendsStr != null) {
				if (extendsStr != "") {
					extends = (TokenDeclSDTypeClass)scriptObjCode.sdObjTypes[extendsStr];
					extends.FillVTables (scriptObjCode);
				}
				extendsStr = null;
			}

			if ((numVirtFuncs > 0) && (stackedMethods != null)) {

				/*
				 * Allocate arrays big enough for mine plus type we are extending.
				 */
				vDynMeths  = new DynamicMethod[numVirtFuncs];
				vMethTypes = new Type[numVirtFuncs];

				/*
				 * Fill in low parts from type we are extending.
				 */
				if (extends != null) {
					int n = extends.numVirtFuncs;
					for (int i = 0; i < n; i ++) {
						vDynMeths[i]  = extends.vDynMeths[i];
						vMethTypes[i] = extends.vMethTypes[i];
					}
				}

				/*
				 * Fill in high parts with my own methods.
				 * Might also overwrite lower ones with 'override' methods.
				 */
				foreach (StackedMethod sm in stackedMethods) {
					int i = sm.methVTI;
					string methName  = sm.methName;
					DynamicMethod dm = scriptObjCode.dynamicMethods[methName];
					vDynMeths[i]  = dm;
					vMethTypes[i] = GetDynamicMethodDelegateType (dm, sm.methSig);
				}
				stackedMethods = null;
			}

			if (stackedIFaces != null) {
				foreach (StackedIFace si in stackedIFaces) {
					int i = si.iFaceIndex;
					int j = si.methIndex;
					string methName  = si.methName;
					DynamicMethod dm = scriptObjCode.dynamicMethods[methName];
					iDynMeths[i][j]  = dm;
					iMethTypes[i][j] = GetDynamicMethodDelegateType (dm, si.methSig);
				}
				stackedIFaces = null;
			}
		}

		private Type GetDynamicMethodDelegateType (DynamicMethod dm, string methSig)
		{
			Type retType = dm.ReturnType;
			ParameterInfo[] pi = dm.GetParameters ();
			Type[] argTypes = new Type[pi.Length];
			for (int j = 0; j < pi.Length; j ++) {
				argTypes[j] = pi[j].ParameterType;
			}
			return DelegateCommon.GetType (retType, argTypes, methSig);
		}
	}

	public class TokenDeclSDTypeDelegate : TokenDeclSDType {
		public TokenName name;

		private TokenType retType;
		private TokenType[] argTypes;

		private string argSig;
		private string wholeSig;
		private Type sysType;
		private Type retSysType;
		private Type[] argSysTypes;

		private string retStr;
		private string[] argStrs;

		private static Dictionary<string, TokenDeclSDTypeDelegate> inlines = new Dictionary<string, TokenDeclSDTypeDelegate> ();
		private static Dictionary<Type, string> inlrevs = new Dictionary<Type, string> ();

		public TokenDeclSDTypeDelegate (TokenName name) : base (name)
		{
			this.name = name;
		}
		public void SetRetArgTypes (TokenType retType, TokenType[] argTypes)
		{
			this.retType  = retType;
			this.argTypes = argTypes;
		}

		public override TokenTypeSDType MakeRefToken (Token t)
		{
			return new TokenTypeSDTypeDelegate (t, this);
		}

		/**
		 * @brief Get system type for the whole delegate.
		 */
		public override Type GetSysType ()
		{
			if (sysType == null) FillInStuff ();
			return sysType;
		}

		/**
		 * @brief Get the function's return value type (TokenTypeVoid if void, never null)
		 */
		public TokenType GetRetType ()
		{
			if (retType == null) FillInStuff ();
			return retType;
		}

		/**
		 * @brief Get the function's argument types
		 */
		public TokenType[] GetArgTypes ()
		{
			if (argTypes == null) FillInStuff ();
			return argTypes;
		}

		/**
		 * @brief Get signature for the whole delegate, eg, "void(integer,list)"
		 */
		public string GetWholeSig ()
		{
			if (wholeSig == null) FillInStuff ();
			return wholeSig;
		}

		/**
		 * @brief Get signature for the arguments, eg, "(integer,list)"
		 */
		public string GetArgSig ()
		{
			if (argSig == null) FillInStuff ();
			return argSig;
		}

		/**
		 * @brief Find out how to create one of these delegates.
		 */
		public ConstructorInfo GetConstructorInfo ()
		{
			if (sysType == null) FillInStuff ();
			return sysType.GetConstructor (DelegateCommon.constructorArgTypes);
		}

		/**
		 * @brief Find out how to call what one of these delegates points to.
		 */
		public MethodInfo GetInvokerInfo ()
		{
			if (sysType == null) FillInStuff ();
			return sysType.GetMethod ("Invoke", argSysTypes);
		}

		/**
		 * @brief Write enough out to a file so delegate can be reconstructed in ReadFromFile().
		 */
		public override void WriteToFile (BinaryWriter objFileWriter)
		{
			objFileWriter.Write (this.file);
			objFileWriter.Write (this.line);
			objFileWriter.Write (this.posn);
			objFileWriter.Write ((byte)DELEGATE);

			objFileWriter.Write (retType.ToString ());
			int nArgs = argTypes.Length;
			objFileWriter.Write (nArgs);
			for (int i = 0; i < nArgs; i ++) {
				objFileWriter.Write (argTypes[i].ToString ());
			}
		}

		/**
		 * @brief Read that data from file so we can reconstruct.
		 *        Don't actually reconstruct yet in case any forward-referenced types are undefined.
		 */
		public override void ReadFromFile (BinaryReader objFileReader, TextWriter asmFileWriter)
		{
			retStr = objFileReader.ReadString ();
			int nArgs = objFileReader.ReadInt32 ();
			if (asmFileWriter != null) {
				asmFileWriter.Write ("  delegate " + retStr + " " + name.val + "(");
			}
			argStrs = new string[nArgs];
			for (int i = 0; i < nArgs; i ++) {
				argStrs[i] = objFileReader.ReadString ();
				if (asmFileWriter != null) {
					if (i > 0) asmFileWriter.Write (",");
					asmFileWriter.Write (argStrs[i]);
				}
			}
			if (asmFileWriter != null) {
				asmFileWriter.WriteLine (");");
			}
		}

		/**
		 * @brief Fill in missing internal data.
		 */
		private void FillInStuff ()
		{
			int nArgs;

			/*
			 * This happens when the node was restored via ReadFromFile().
			 * It leaves the types in retStr/argStrs for resolution after
			 * all definitions have been read from the object file in case
			 * there are forward references.
			 */
			if (retType == null) {
				retType = MakeTypeToken (retStr);
			}
			if (argTypes == null) {
				nArgs = argStrs.Length;
				argTypes = new TokenType[nArgs];
				for (int i = 0; i < nArgs; i ++) {
					argTypes[i] = MakeTypeToken (argStrs[i]);
				}
			}

			/*
			 * Fill in system types from token types.
			 * Might as well build the signature strings too from token types.
			 */
			retSysType = retType.ToSysType();

			nArgs = argTypes.Length;
			StringBuilder sb = new StringBuilder ();
			argSysTypes = new Type[nArgs];
			sb.Append ('(');
			for (int i = 0; i < nArgs; i ++) {
				if (i > 0) sb.Append (',');
				sb.Append (argTypes[i].ToString ());
				argSysTypes[i] = argTypes[i].ToSysType ();
			}
			sb.Append (')');
			argSig = sb.ToString ();
			wholeSig = retType.ToString () + argSig;

			/*
			 * Now we can create a system delegate type from the given
			 * return and argument types.  Give it an unique name using
			 * the whole signature string.
			 */
			sysType = DelegateCommon.GetType (retSysType, argSysTypes, wholeSig);
		}

		/**
		 * @brief create delegate reference token for inline functions.
		 *        there is just one instance of these per inline function
		 *        shared by all scripts, and it is just used when the
		 *        script engine is just loaded.
		 */
		public static TokenDeclSDTypeDelegate CreateInline (Type retType, string argsigst)
		{
			TokenDeclSDTypeDelegate decldel;

			/*
			 * Name it after the whole signature string.
			 * Fortunately retType is a basic LSL type.
			 */
			string retsig = TokenType.FromSysType (null, retType).ToString ();
			string inlname = "$inlines$" + retsig + argsigst;
			if (!inlines.TryGetValue (inlname, out decldel)) {

				TokenName name = new TokenName (null, "inlines", 0, 0, inlname);

				/*
				 * Fortunately argsigst is simply formed by (type,...)
				 * and consists of only the basic LSL types.
				 */
				List<TokenType> args = new List<TokenType> ();
				for (int i = 0; i < argsigst.Length; i ++) {
					char c = argsigst[i];
					if (c == '(') continue;
					if (c == ')') continue;
					if (c == ',') continue;
					int j = argsigst.IndexOf (',', i);
					if (j < 0) j = argsigst.IndexOf (')');
					args.Add (TokenType.FromLSLType (name, argsigst.Substring (i, j - i)));
					i = j;
				}

				/*
				 * Now we can create the corresponding declaration and link to it
				 */
				decldel          = new TokenDeclSDTypeDelegate (name);
				decldel.retType  = TokenType.FromSysType (name, retType);
				decldel.argTypes = args.ToArray ();
				inlines.Add (inlname, decldel);
				inlrevs.Add (decldel.GetSysType(), inlname);
			}
			return decldel;
		}

		public static string TryGetInlineName (Type sysType)
		{
			string name;
			if (!inlrevs.TryGetValue (sysType, out name)) return null;
			return name;
		}

		public static Type TryGetInlineSysType (string name)
		{
			TokenDeclSDTypeDelegate decl;
			if (!inlines.TryGetValue (name, out decl)) return null;
			return decl.GetSysType ();
		}
	}

	public class TokenDeclSDTypeInterface : TokenDeclSDType {
		public TokenName name;
		public Dictionary<string, TokenDeclFunc> methods = new Dictionary<string, TokenDeclFunc> ();

		public TokenDeclSDTypeInterface (TokenName name) : base (name)
		{
			this.name = name;
		}

		public override TokenTypeSDType MakeRefToken (Token t)
		{
			return new TokenTypeSDTypeInterface (t, this);
		}

		public override Type GetSysType ()
		{
			// interfaces are implemented as arrays of delegates
			// they are taken from iDynMeths[interfaceIndex] of a script-defined class object
			return typeof (Delegate[]);
		}

		public override void WriteToFile (BinaryWriter objFileWriter)
		{
			objFileWriter.Write (this.file);
			objFileWriter.Write (this.line);
			objFileWriter.Write (this.posn);
			objFileWriter.Write ((byte)INTERFACE);
		}

		public override void ReadFromFile (BinaryReader objFileReader, TextWriter asmFileWriter)
		{ }
	}

	/**
	 * @brief Script-defined type references.
	 *        These occur in the source code wherever it specifies (eg, variable declaration) a script-defined type.
	 */
	public abstract class TokenTypeSDType : TokenType {
		public TokenTypeSDType (TokenErrorMessage emsg, string file, int line, int posn) : base (emsg, file, line, posn) { }
		public TokenTypeSDType (Token t) : base (t) { }
	}

	public class TokenTypeSDTypeClass : TokenTypeSDType {
		private static readonly FieldInfo gblSDTClassesFieldInfo  = typeof (XMRInstAbstract).GetField ("gblSDTClasses");
		private static readonly FieldInfo sdtcSDTClassesFieldInfo = typeof (XMRSDTypeClassInstance).GetField ("sdtcSDTClasses");
 
		public TokenDeclSDTypeClass decl;
		public TokenTypeSDTypeClass (Token t, TokenDeclSDTypeClass decl) : base (t)
		{
			this.decl = decl;
		}
		public override string ToString ()
		{
			return decl.name.val;
		}
		public override Type ToSysType ()
		{
			return typeof (XMRSDTypeClassInstance);
		}
		public override void AssignGlobalVarSlot (TokenDeclVar declVar, ScriptObjCode scriptObjCode)
		{
			declVar.vTableArray = gblSDTClassesFieldInfo;
			declVar.vTableIndex = scriptObjCode.numGblSDTClasses ++;
		}
		public override void AssignSDTClassFieldSlot (TokenDeclVar declVar, TokenDeclSDTypeClass sdtClass)
		{
			declVar.vTableArray = sdtcSDTClassesFieldInfo;
			declVar.vTableIndex = sdtClass.numInstSDTClasses ++;
		}
	}

	public class TokenTypeSDTypeDelegate : TokenTypeSDType {
		private static readonly FieldInfo gblObjectsFieldInfo  = typeof (XMRInstAbstract).GetField ("gblObjects");
		private static readonly FieldInfo sdtcObjectsFieldInfo = typeof (XMRSDTypeClassInstance).GetField ("sdtcObjects");

		public TokenDeclSDTypeDelegate decl;

		private static ulong anonDeclDel = 0;

		/**
		 * @brief create a reference to an explicitly declared delegate
		 * @param t = where the reference is being made in the source file
		 * @param decl = the explicit delegate declaration
		 */
		public TokenTypeSDTypeDelegate (Token t, TokenDeclSDTypeDelegate decl) : base (t)
		{
			this.decl = decl;
		}

		/**
		 * @brief create a reference to a possibly anonymous delegate
		 * @param t = where the reference is being made in the source file
		 * @param retType = return type (TokenTypeVoid if void, never null)
		 * @param argTypes = script-visible argument types
		 * @param tokenScript = what script this is part of
		 */
		public TokenTypeSDTypeDelegate (Token t, TokenType retType, TokenType[] argTypes, TokenScript tokenScript) : base (t)
		{
			TokenDeclSDTypeDelegate decldel;

			/*
			 * See if we already have a matching declared one cataloged.
			 */
			int nArgs = argTypes.Length;
			foreach (TokenDeclSDType decl in tokenScript.sdSrcTypes.Values) {
				if (decl is TokenDeclSDTypeDelegate) {
					decldel         = (TokenDeclSDTypeDelegate)decl;
					TokenType   rt  = decldel.GetRetType  ();
					TokenType[] ats = decldel.GetArgTypes ();
					if ((rt.ToSysType () == retType.ToSysType ()) && (ats.Length == nArgs)) {
						for (int i = 0; i < nArgs; i ++) {
							if (ats[i].ToSysType () != argTypes[i].ToSysType ()) goto nomatch;
						}
						this.decl = decldel;
						return;
					}
				}
			nomatch:;
			}

			/*
			 * No such luck, create a new anonymous declaration.
			 */
			string namestr = ".anondel." + (++ anonDeclDel);
			TokenName name = new TokenName (t, namestr);
			decldel        = new TokenDeclSDTypeDelegate (name);
			decldel.SetRetArgTypes (retType, argTypes);
			this.decl = decldel;
		}

		public override Type ToSysType ()
		{
			return decl.GetSysType ();
		}

		public override string ToString ()
		{
			return decl.name.val;
		}

		/**
		 * @brief Assign slots in the gblObjects[] array because we have to typecast out in any case.
		 *        Likewise with the sdtcObjects[] array.
		 */
		public override void AssignGlobalVarSlot (TokenDeclVar declVar, ScriptObjCode scriptObjCode)
		{
			declVar.vTableArray = gblObjectsFieldInfo;
			declVar.vTableIndex = scriptObjCode.numGblObjects ++;
		}
		public override void AssignSDTClassFieldSlot (TokenDeclVar declVar, TokenDeclSDTypeClass sdtClass)
		{
			declVar.vTableArray = sdtcObjectsFieldInfo;
			declVar.vTableIndex = sdtClass.numInstObjects ++;
		}

		/**
		 * @brief create delegate reference token for inline functions.
		 */
		public TokenTypeSDTypeDelegate (Type retType, string argsigst) : base (null, "inlines", 0, 0)
		{
			this.decl = TokenDeclSDTypeDelegate.CreateInline (retType, argsigst);
		}
	}

	public class TokenTypeSDTypeInterface : TokenTypeSDType {
		public TokenDeclSDTypeInterface decl;
		public TokenTypeSDTypeInterface (Token t, TokenDeclSDTypeInterface decl) : base (t)
		{
			this.decl = decl;
		}

		public override string ToString ()
		{
			return decl.name.val;
		}
		public override Type ToSysType ()
		{
			return typeof (Delegate[]);
		}
	}

	/**
	 * @brief function argument list declaration
	 */
	public class TokenArgDecl : Token
	{
		public TokenType[] types;
		public TokenName[] names;
		public CompValu[]  locns;  // used by codegen to keep track of locations

		public TokenArgDecl (Token original) : base (original) { }

		/**
		 * @brief Get argument signature string, eg, "(list,vector,integer)"
		 */
		private string argSig = null;
		public string GetArgSig ()
		{
			if (argSig == null) {
				StringBuilder sb = new StringBuilder ("(");
				bool first = true;
				foreach (TokenType t in types) {
					if (!first) sb.Append (',');
					sb.Append (t.ToString ());
					first = false;
				}
				sb.Append (")");
				argSig = sb.ToString ();
			}
			return argSig;
		}

		public override void WriteOut (TokenWriter writer)
		{
			int n = types.Length;
			writer.Write (n);
			for (int i = 0; i < n; i ++) {
				writer.Write (types[i]);
				writer.Write (names[i]);
			}
		}

		public override void ReadIn (TokenReader reader)
		{
			int n = reader.ReadInt ();
			types = new TokenType[n];
			names = new TokenName[n];
			locns = new CompValu[n];
			for (int i = 0; i < n; i ++) {
				types[i] = (TokenType)reader.ReadToken ();
				names[i] = (TokenName)reader.ReadToken ();
			}
		}
	}

	/**
	 * @brief encapsulates a function definition
	 */
	public class TokenDeclFunc : Token {

		public TokenType retType;              // new TokenTypeVoid (token) if void; NEVER null
		public TokenName funcNameSig;          // function name including argumet signature, eg, "PrintStuff(list,string)"
		public TokenArgDecl argDecl;           // argument list prototypes
		public TokenStmtBlock body;            // statements (null iff abstract)
		public TokenScript tokenScript;        // what script this function is part of
		public TokenDeclSDTypeClass sdtClass;  // null: script global function
		                                       // else: method is part of this script-defined type
		public uint sdtFlags;                  // abstract/override/static/virtual
		public Dictionary<string, TokenStmtLabel> labels = new Dictionary<string, TokenStmtLabel> ();
		                                       // all labels defined in the function
		public LinkedList<TokenDeclVar> localVars = new LinkedList<TokenDeclVar> ();
		                                       // all local variables declared by this function
		                                       // - doesn't include argument variables
		public TokenIntfImpl implements;       // if script-defined type method, what interface method(s) this func implements
		public TokenRValCall baseCtorCall;     // if script-defined type constructor, call to base constructor, if any

		public int vTableIndex = -1;           // if script-defined type method, vtable index
		                                       //  <0: non-virtual; >=0: virtual
		public ScriptMyILGen ilGen;            // codegen stores emitted code here

		public TokenDeclFunc (Token original, TokenScript ts) : base (original)
		{
			tokenScript = ts;
		}

		/**
		 * @brief The bare function name, ie, without any signature info
		 */
		public string GetSimpleName ()
		{
			string nameWithSig = funcNameSig.val;
			string simpleName  = nameWithSig.Substring (0, nameWithSig.IndexOf ('('));
			return simpleName;
		}

		/**
		 * @brief The function name as it appears in the object code,
		 *        ie, including "__fun_", script-defined type name if any,
		 *        bare function name and argument signature, 
		 *        eg, "__fun_MyClass.PrintStuff(string)"
		 */
		public string GetObjCodeName ()
		{
                        string objCodeName  = "__fun_";
                        if (sdtClass != null) {
                                objCodeName += sdtClass.name.val + ".";
                        }
                        objCodeName += funcNameSig.val;
			return objCodeName;
		}

		/**
		 * @brief Get delegate type.
		 *        This is the function's script-visible type,
		 *        It includes return type and all script-visible argument types.
		 */
		private TokenTypeSDTypeDelegate delType;
		public TokenTypeSDTypeDelegate GetDelType ()
		{
			if (delType == null) {
				delType = new TokenTypeSDTypeDelegate (this, retType, argDecl.types, tokenScript);
			}
			return delType;
		}

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (retType);
			writer.Write (funcNameSig);
			writer.Write (argDecl);
			writer.Write (body);

			////???? the below probably should be rederived when reconstructed
			writer.Write (labels.Count);
			foreach (KeyValuePair<string, TokenStmtLabel> kvp in labels) {
				writer.Write (kvp.Value);
			}
			writer.Write (localVars.Count);
			foreach (TokenDeclVar val in localVars) {
				writer.Write (val);
			}
		}

		public override void ReadIn (TokenReader reader)
		{
			retType     = (TokenType)     reader.ReadToken ();
			funcNameSig = (TokenName)     reader.ReadToken ();
			argDecl     = (TokenArgDecl)  reader.ReadToken ();
			body        = (TokenStmtBlock)reader.ReadToken ();

			////???? the below probably should be rederived when reconstructed

			int nLabels = reader.ReadInt ();
			while (-- nLabels >= 0) {
				TokenStmtLabel label = (TokenStmtLabel)reader.ReadToken ();
				labels[label.name.val] = label;
			}
			int nLocals = reader.ReadInt ();
			while (-- nLocals >= 0) {
				TokenDeclVar local = (TokenDeclVar)reader.ReadToken ();
				localVars.AddLast (local);
			}
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			if (!(retType is TokenTypeVoid)) {
				writeSrc (retType.ToString () + " ");
			}
			writeSrc (GetSimpleName () + " (");
			for (int i = 0; i < argDecl.types.Length; i ++) {
				if (i > 0) writeSrc (", ");
				writeSrc (argDecl.types[i].ToString () + " " + argDecl.names[i].val);
			}
			writeSrc (")\n");
			body.Reconst (writeSrc);
			writeSrc ("\n");
		}
#endif
	}

	/**
	 * @brief encapsulate a state declaration in a single token
	 */
	public class TokenDeclState : Token {

		public TokenName name;  // null for default state
		public TokenStateBody body;

		public TokenDeclState (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (name);
			writer.Write (body);
		}

		public override void ReadIn (TokenReader reader)
		{
			name = (TokenName)     reader.ReadToken ();
			body = (TokenStateBody)reader.ReadToken ();
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			if (name == null) {
				writeSrc ("default {");
			} else {
				writeSrc ("state " + name.val + " {");
			}
			body.Reconst (writeSrc);
			writeSrc ("}");
		}
#endif
	}

	public class TokenDeclVar : Token {

		public TokenType type;
		public TokenName name;
		public TokenRVal init;  // null if none
		public bool constant;
		public uint sdtFlags;

		public CompValu location;  // used by codegen to keep track of location
		public FieldInfo vTableArray;
		public int vTableIndex;

		public TokenDeclVar heapTracker;

		/**
		 * @brief Set up a variable declaration statement token.
		 * @param original = original source token that triggered definition
		 *                   (for error messages)
		 * @param func = null: global variable
		 *               else: local to the given function
		 */
		public TokenDeclVar (Token original, TokenDeclFunc func) : base (original)
		{
			if (func != null) {
				func.localVars.AddLast (this);
			}
		}

		/**
		 * @brief Serialization/Deserialization.
		 */
		public TokenDeclVar (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (type);
			writer.Write (name);
			writer.Write (init);
		}

		public override void ReadIn (TokenReader reader)
		{
			type = (TokenType)reader.ReadToken ();
			name = (TokenName)reader.ReadToken ();
			init = (TokenRVal)reader.ReadToken ();
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			writeSrc (type.ToString () + " " + name.val);
			if (init != null) {
				writeSrc (" = ");
				init.Reconst (writeSrc);
			}
			writeSrc (";");
		}
#endif
	}

	/**
	 * @brief Indicates an interface type.method that is implemented by the function
	 */
	public class TokenIntfImpl : Token {
		public TokenTypeSDTypeInterface intfType;
		public TokenName methName;
		public TokenIntfImpl (TokenTypeSDTypeInterface intfType, TokenName methName) : base (intfType)
		{
			this.intfType = intfType;
			this.methName = methName;
		}
	}

	/**
	 * @brief any expression that can go on left side of an "="
	 */
	public class TokenLVal : TokenRVal {

		public TokenLVal (Token original) : base (original) { }
	}

	/**
	 * @brief an element of an array is an L-value
	 */
	public class TokenLValArEle : TokenLVal {
		public TokenRVal baseRVal;
		public TokenRVal subRVal;

		public TokenLValArEle (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (baseRVal);
			writer.Write (subRVal);
		}

		public override void ReadIn (TokenReader reader)
		{
			baseRVal = (TokenRVal)reader.ReadToken ();
			subRVal  = (TokenRVal)reader.ReadToken ();
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			baseRVal.Reconst (writeSrc);
			writeSrc ("[");
			subRVal.Reconst (writeSrc);
			writeSrc ("]");
		}
#endif
	}

	/**
	 * @brief a field within an L-value struct is an L-value
	 */
	public class TokenLValIField : TokenLVal {
		public TokenRVal baseRVal;
		public TokenName field;

		public TokenLValIField (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (baseRVal);
			writer.Write (field);
		}

		public override void ReadIn (TokenReader reader)
		{
			baseRVal = (TokenRVal)reader.ReadToken ();
			field    = (TokenName)reader.ReadToken ();
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			baseRVal.Reconst (writeSrc);
			writeSrc (".");
			writeSrc (field.val);
		}
#endif
	}

	/**
	 * @brief a name is being used as an L-value
	 */
	public class TokenLValName : TokenLVal {
		public TokenName name;

		public TokenLValName (TokenName original) : base (original)
		{
			this.name = original;
		}

		/**
		 * @brief Serialization/Deserialization.
		 */
		public TokenLValName (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (name);
		}

		public override void ReadIn (TokenReader reader)
		{
			name = (TokenName)reader.ReadToken ();
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			writeSrc (name.val);
		}
#endif
	}

	/**
	 * @brief a static field within a struct is an L-value
	 */
	public class TokenLValSField : TokenLVal {
		public TokenType baseType;
		public TokenName fieldName;

		public TokenLValSField (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (baseType);
			writer.Write (fieldName);
		}

		public override void ReadIn (TokenReader reader)
		{
			baseType  = (TokenType)reader.ReadToken ();
			fieldName = (TokenName)reader.ReadToken ();
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			writeSrc (baseType.ToString ());
			writeSrc (".");
			writeSrc (fieldName.val);
		}
#endif
	}

	/**
	 * @brief any expression that can go on right side of "="
	 */
	public delegate TokenRVal TCCLookup (TokenRVal rVal, ref bool didOne);
	public class TokenRVal : Token {
		public bool sideEffects = false;  // the value (or some sub-value) has side effects
		                                  // - constants are always false
		                                  // - we assume calls always have side effects
		                                  // - post increment/decrement are always true
		                                  // - any assignment operator (=, +=, etc) always true
		                                  // - all others inherit from their operands
		public TokenRVal (Token original) : base (original) { }

		/**
		 * @brief If the result of the expression is a constant,
		 *        create a TokenRValConst equivalent, set didOne, and return that.
		 *        Otherwise, just return the original without changing didOne.
		 */
		public virtual TokenRVal TryComputeConstant (TCCLookup lookup, ref bool didOne)
		{
			return lookup (this, ref didOne);
		}
	}

	/**
	 * @brief a postfix operator and corresponding L-value
	 */
	public class TokenRValAsnPost : TokenRVal {
		public TokenLVal lVal;
		public Token postfix;

		public TokenRValAsnPost (Token original) : base (original) {
			sideEffects = true;
		}

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (lVal);
			writer.Write (postfix);
		}

		public override void ReadIn (TokenReader reader)
		{
			lVal = (TokenLVal)reader.ReadToken ();
			postfix = reader.ReadToken ();
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			lVal.Reconst (writeSrc);
			writeSrc (" " + postfix.ToString ());
		}
#endif
	}

	/**
	 * @brief a prefix operator and corresponding L-value
	 */
	public class TokenRValAsnPre : TokenRVal {
		public Token prefix;
		public TokenLVal lVal;

		public TokenRValAsnPre (Token original) : base (original) {
			sideEffects = true;
		}

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (prefix);
			writer.Write (lVal);
		}

		public override void ReadIn (TokenReader reader)
		{
			prefix = reader.ReadToken ();
			lVal = (TokenLVal)reader.ReadToken ();
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			writeSrc (prefix.ToString () + " ");
			lVal.Reconst (writeSrc);
		}
#endif
	}

	/**
	 * @brief 'base.' being used to reference a field/method of the extended class.
	 */
	public class TokenRValBaseField : TokenRVal {
		public TokenName field;
		public TokenRValBaseField (Token original, TokenName field) : base (original)
		{
			this.field = field;
		}
	}

	/**
	 * @brief calling a function or method, ie, may have side-effects
	 */
	public class TokenRValCall : TokenRVal {

		public TokenRVal meth;  // TokenLValName or TokenLValField
		public TokenRVal args;  // null-terminated TokenRVal list
		public int nArgs;       // number of elements in args

		public TokenRValCall (Token original) : base (original) {
			sideEffects = true;
		}

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (meth);
			writer.Write (nArgs);
			TokenRVal arg = args;
			for (int i = 0; i < nArgs; i ++) {
				writer.Write (arg);
				arg = (TokenRVal)arg.nextToken;
			}
		}

		public override void ReadIn (TokenReader reader)
		{
			meth  = (TokenLVal)reader.ReadToken ();
			nArgs = reader.ReadInt ();
			Token lastArg = null;
			for (int i = 0; i < nArgs; i ++) {
				TokenRVal arg = (TokenRVal)reader.ReadToken ();
				if (lastArg == null) {
					args = arg;
				} else {
					lastArg.nextToken = arg;
				}
				lastArg = arg;
			}
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			meth.Reconst (writeSrc);
			writeSrc (" (");
			for (Token t = args; t != null; t = t.nextToken) {
				if (t != args) writeSrc (", ");
				t.Reconst (writeSrc);
			}
			writeSrc (")");
		}
#endif
	}

	/**
	 * @brief encapsulates a typecast, ie, (type)
	 */
	public class TokenRValCast : TokenRVal {
		public TokenType castTo;
		public TokenRVal rVal;

		public TokenRValCast (TokenType type, TokenRVal value) : base (type)
		{
			castTo = type;
			rVal   = value;
			sideEffects = value.sideEffects;
		}

		/**
		 * @brief If operand is constant, maybe we can say the whole thing is a constant.
		 */
		public override TokenRVal TryComputeConstant (TCCLookup lookup, ref bool didOne)
		{
			rVal = rVal.TryComputeConstant (lookup, ref didOne);
			if (rVal is TokenRValConst) {
				try {
					object val = ((TokenRValConst)rVal).val;
					if (castTo is TokenTypeFloat) {
						if (val is int)         val = (SCRIPTFLOAT)(int)val;
						if (val is string)      val = new LSL_Float ((string)val).value;
					}
					if (castTo is TokenTypeInt) {
						if (val is SCRIPTFLOAT) val = (int)(SCRIPTFLOAT)val;
						if (val is string)      val = new LSL_Integer ((string)val).value;
					}
					if (castTo is TokenTypeStr) {
						if (val is SCRIPTFLOAT) val = TypeCast.FloatToString ((SCRIPTFLOAT)val);
						if (val is int)         val = TypeCast.IntegerToString ((int)val);
					}
					TokenRVal rValConst = new TokenRValConst (castTo, val);
					didOne = true;
					return rValConst;
				} catch {
				}
			}
			return this;
		}

		/**
		 * @brief Serialization/Deserialization.
		 */
		public TokenRValCast (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (castTo);
			writer.Write (rVal);
		}

		public override void ReadIn (TokenReader reader)
		{
			castTo = (TokenType)reader.ReadToken ();
			rVal   = (TokenRVal)reader.ReadToken ();
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			writeSrc ("(" + castTo.ToString () + ")");
			rVal.Reconst (writeSrc);
		}
#endif
	}

	/**
	 * @brief all constants supposed to end up here
	 */
	public enum TokenRValConstType : byte { FLOAT = 0, INT = 1, STRING = 2 };
	public class TokenRValConst : TokenRVal {
		public object val;	// always a system type (int, SCRIPTFLOAT, string)
		public TokenRValConstType type;
		public TokenType tokType;

		public TokenRValConst (Token original, object value) : base (original) {
			val = value;
			     if (val is int)         { type = TokenRValConstType.INT;    tokType = new TokenTypeInt   (this); }
			else if (val is SCRIPTFLOAT) { type = TokenRValConstType.FLOAT;  tokType = new TokenTypeFloat (this); }
			else if (val is string)      { type = TokenRValConstType.STRING; tokType = new TokenTypeStr   (this); }
			else throw new Exception ("invalid constant type " + val.GetType ());
		}

		public CompValu GetCompValu ()
		{
			switch (type) {
				case TokenRValConstType.FLOAT:  { return new CompValuFloat   (tokType, (SCRIPTFLOAT)val); }
				case TokenRValConstType.INT:    { return new CompValuInteger (tokType, (int)val);         }
				case TokenRValConstType.STRING: { return new CompValuString  (tokType, (string)val);      }
				default: throw new Exception ("unknown type");
			}
		}

		public override TokenRVal TryComputeConstant (TCCLookup lookup, ref bool didOne)
		{
			// gotta end somewhere
			return this;
		}

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write ((byte)type);
			switch (type) {
				case TokenRValConstType.FLOAT:  { writer.Write ((SCRIPTFLOAT)val); break; }
				case TokenRValConstType.INT:    { writer.Write ((int)val);         break; }
				case TokenRValConstType.STRING: { writer.Write ((string)val);      break; }
				default: throw new Exception ("unknown type");
			}
		}

		public override void ReadIn (TokenReader reader)
		{
			type = (TokenRValConstType)reader.ReadByte ();
			switch (type) {
				case TokenRValConstType.FLOAT:  { val = reader.ReadScriptFloat (); break; }
				case TokenRValConstType.INT:    { val = reader.ReadInt ();         break; }
				case TokenRValConstType.STRING: { val = reader.ReadString ();      break; }
				default: throw new Exception ("unknown type");
			}
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			object v = val;
			     if (v is int) writeSrc (((int)v).ToString());
			else if (v is SCRIPTFLOAT) writeSrc (((SCRIPTFLOAT)v).ToString());
			else if (v is string) ReconstString ((string)v, writeSrc);
			else throw new Exception ("unknown const type " + v.GetType ());
		}

		private static void ReconstString (string s, SrcWriter writeSrc)
		{
			StringBuilder sb = new StringBuilder ();
			sb.Append ('"');
			for (int i = 0; i < s.Length; i ++) {
				char c = s[i];
				if ((c == '"') || (c == '\\')) {
					sb.Append ('\\');
				}
				if (c == '\n') {
					sb.Append ('\\');
					c = 'n';
				}
				sb.Append (c);
			}
			sb.Append ('"');
			writeSrc (sb.ToString ());
		}
#endif
	}

	/**
	 * @brief encapsulation of <rval> is <typeexp>
	 */
	public class TokenRValIsType : TokenRVal {
		public TokenRVal    rValExp;
		public TokenTypeExp typeExp;

		public TokenRValIsType (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (rValExp);
			writer.Write (typeExp);
		}

		public override void ReadIn (TokenReader reader)
		{
			rValExp = (TokenRVal)   reader.ReadToken ();
			typeExp = (TokenTypeExp)reader.ReadToken ();
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			rValExp.Reconst (writeSrc);
			writeSrc (" is ");
			typeExp.Reconst (writeSrc);
		}
#endif
	}

	/**
	 * @brief an R-value enclosed in brackets is an LSLList
	 */
	public class TokenRValList : TokenRVal {

		public TokenRVal rVal;  // null-terminated list of TokenRVal objects
		public int nItems;

		public TokenRValList (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (nItems);
			Token t = rVal;
			for (int i = 0; i < nItems; i ++) {
				writer.Write (t);
				t = t.nextToken;
			}
		}

		public override void ReadIn (TokenReader reader)
		{
			nItems = reader.ReadInt ();
			Token lastRVal = null;
			for (int i = 0; i < nItems; i ++) {
				TokenRVal thisRVal = (TokenRVal)reader.ReadToken ();
				if (lastRVal == null) {
					rVal = thisRVal;
				} else {
					lastRVal.nextToken = thisRVal;
				}
				lastRVal = thisRVal;
			}
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			bool first = true;
			writeSrc ("[");
			for (Token t = rVal; t != null; t = t.nextToken) {
				if (!first) writeSrc (", ");
				t.Reconst (writeSrc);
				first = false;
			}
			writeSrc ("]");
		}
#endif
	}

	/**
	 * @brief a binary operator and its two operands
	 */
	public class TokenRValOpBin : TokenRVal {
		public TokenRVal rValLeft;
		public TokenKw opcode;
		public TokenRVal rValRight;

		public TokenRValOpBin (TokenRVal left, TokenKw op, TokenRVal right) : base (op)
		{
			rValLeft  = left;
			opcode    = op;
			rValRight = right;

			CalcSideEffects();
		}

		/**
		 * @brief If both operands are constants, maybe we can say the whole thing is a constant.
		 */
		public override TokenRVal TryComputeConstant (TCCLookup lookup, ref bool didOne)
		{
			rValLeft  = rValLeft.TryComputeConstant  (lookup, ref didOne);
			rValRight = rValRight.TryComputeConstant (lookup, ref didOne);
			if ((rValLeft is TokenRValConst) && (rValRight is TokenRValConst)) {
				try {
					object val = opcode.binOpConst (((TokenRValConst)rValLeft).val, 
					                                ((TokenRValConst)rValRight).val);
					TokenRVal rValConst = new TokenRValConst (opcode, val);
					didOne = true;
					return rValConst;
				} catch {
				}
			}
			return this;
		}

		/**
		 * @brief Serialization/Deserialization.
		 */
		public TokenRValOpBin (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (rValLeft);
			writer.Write (opcode);
			writer.Write (rValRight);
		}

		public override void ReadIn (TokenReader reader)
		{
			rValLeft  = (TokenRVal)reader.ReadToken ();
			opcode    = (TokenKw)  reader.ReadToken ();
			rValRight = (TokenRVal)reader.ReadToken ();

			CalcSideEffects();
		}

		private void CalcSideEffects()
		{
			sideEffects = rValLeft.sideEffects || rValRight.sideEffects;
			if (!sideEffects) {
				string opStr = opcode.ToString ();
				sideEffects = opStr.EndsWith ("=") && (opStr != ">=") && 
				              (opStr != "<=") && (opStr != "!=") && (opStr != "==");
			}
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			rValLeft.Reconst (writeSrc);
			writeSrc (" " + opcode.ToString () + " ");
			rValRight.Reconst (writeSrc);
		}
#endif
	}

	/**
	 * @brief an unary operator and its one operand
	 */
	public class TokenRValOpUn : TokenRVal {
		public TokenKw opcode;
		public TokenRVal rVal;

		public TokenRValOpUn (TokenKw op, TokenRVal right) : base (op)
		{
			opcode      = op;
			rVal        = right;
			sideEffects = right.sideEffects;
		}

		/**
		 * @brief If operand is constant, maybe we can say the whole thing is a constant.
		 */
		public override TokenRVal TryComputeConstant (TCCLookup lookup, ref bool didOne)
		{
			rVal = rVal.TryComputeConstant (lookup, ref didOne);
			if (rVal is TokenRValConst) {
				try {
					object val = opcode.unOpConst (((TokenRValConst)rVal).val);
					TokenRVal rValConst = new TokenRValConst (opcode, val);
					didOne = true;
					return rValConst;
				} catch {
				}
			}
			return this;
		}

		/**
		 * @brief Serialization/Deserialization.
		 */
		public TokenRValOpUn (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (opcode);
			writer.Write (rVal);
		}

		public override void ReadIn (TokenReader reader)
		{
			opcode      = (TokenKw)  reader.ReadToken ();
			rVal        = (TokenRVal)reader.ReadToken ();
			sideEffects = rVal.sideEffects;
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			writeSrc (opcode.ToString () + " ");
			rVal.Reconst (writeSrc);
		}
#endif
	}

	/**
	 * @brief an R-value enclosed in parentheses
	 */
	public class TokenRValParen : TokenRVal {

		public TokenRVal rVal;

		public TokenRValParen (Token original) : base (original) { }

		/**
		 * @brief If operand is constant, we can say the whole thing is a constant.
		 */
		public override TokenRVal TryComputeConstant (TCCLookup lookup, ref bool didOne)
		{
			rVal = rVal.TryComputeConstant (lookup, ref didOne);
			if (rVal is TokenRValConst) {
				didOne = true;
				return rVal;
			}
			return this;
		}

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (rVal);
		}

		public override void ReadIn (TokenReader reader)
		{
			rVal = (TokenRVal)reader.ReadToken ();
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			writeSrc ("(");
			rVal.Reconst (writeSrc);
			writeSrc (")");
		}
#endif
	}

	public class TokenRValRot : TokenRVal {

		public TokenRVal xRVal;
		public TokenRVal yRVal;
		public TokenRVal zRVal;
		public TokenRVal wRVal;

		public TokenRValRot (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (xRVal);
			writer.Write (yRVal);
			writer.Write (zRVal);
			writer.Write (wRVal);
		}

		public override void ReadIn (TokenReader reader)
		{
			xRVal = (TokenRVal)reader.ReadToken ();
			yRVal = (TokenRVal)reader.ReadToken ();
			zRVal = (TokenRVal)reader.ReadToken ();
			wRVal = (TokenRVal)reader.ReadToken ();
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			writeSrc ("<");
			xRVal.Reconst (writeSrc);
			writeSrc (", ");
			yRVal.Reconst (writeSrc);
			writeSrc (", ");
			zRVal.Reconst (writeSrc);
			writeSrc (", ");
			wRVal.Reconst (writeSrc);
			writeSrc (">");
		}
#endif
	}

	/**
	 * @brief 'this' is being used as an rval inside an instance method.
	 */
	public class TokenRValThis : TokenRVal {
		public TokenRValThis (Token original) : base (original) { }
	}

	/**
	 * @brief the 'undef' keyword is being used as a value in an expression.
	 */
	public class TokenRValUndef : TokenRVal {
		public TokenRValUndef (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
		}

		public override void ReadIn (TokenReader reader)
		{
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			writeSrc ("undef");
		}
#endif
	}

	/**
	 * @brief put 3 RVals together as a Vector value.
	 */
	public class TokenRValVec : TokenRVal {

		public TokenRVal xRVal;
		public TokenRVal yRVal;
		public TokenRVal zRVal;

		public TokenRValVec (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (xRVal);
			writer.Write (yRVal);
			writer.Write (zRVal);
		}

		public override void ReadIn (TokenReader reader)
		{
			xRVal = (TokenRVal)reader.ReadToken ();
			yRVal = (TokenRVal)reader.ReadToken ();
			zRVal = (TokenRVal)reader.ReadToken ();
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			writeSrc ("<");
			xRVal.Reconst (writeSrc);
			writeSrc (", ");
			yRVal.Reconst (writeSrc);
			writeSrc (", ");
			zRVal.Reconst (writeSrc);
			writeSrc (">");
		}
#endif
	}
	
	/**
	 * @brief encapsulates the whole script in a single token
	 */
	public class TokenScript : Token {
		public Dictionary<string, TokenDeclVar>    vars       = new Dictionary<string, TokenDeclVar>    ();
		public Dictionary<string, TokenDeclFunc>   funcs      = new Dictionary<string, TokenDeclFunc>   ();
		public TokenDeclState defaultState;
		public Dictionary<string, TokenDeclState>  states     = new Dictionary<string, TokenDeclState>  ();
		public Dictionary<string, TokenDeclSDType> sdSrcTypes = new Dictionary<string, TokenDeclSDType> ();

		public TokenScript (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			int numVars = 0;
			foreach (KeyValuePair<string, TokenDeclVar> kvp in vars) {
				if (!kvp.Value.constant) numVars ++;
			}
			writer.Write (numVars);
			foreach (KeyValuePair<string, TokenDeclVar> kvp in vars) {
				if (!kvp.Value.constant) writer.Write (kvp.Value);
			}
			writer.Write (funcs.Count);
			foreach (KeyValuePair<string, TokenDeclFunc> kvp in funcs) {
				writer.Write (kvp.Value);
			}
			writer.Write (defaultState);
			writer.Write (states.Count);
			foreach (KeyValuePair<string, TokenDeclState> kvp in states) {
				writer.Write (kvp.Value);
			}
		}

		public override void ReadIn (TokenReader reader)
		{
			int nVars = reader.ReadInt ();
			while (-- nVars >= 0) {
				TokenDeclVar var = (TokenDeclVar)reader.ReadToken ();
				vars[var.name.val] = var;
			}
			int nFuncs = reader.ReadInt ();
			while (-- nFuncs >= 0) {
				TokenDeclFunc func = (TokenDeclFunc)reader.ReadToken ();
				funcs[func.funcNameSig.val] = func;
			}
			defaultState = (TokenDeclState)reader.ReadToken ();
			int nStates = reader.ReadInt ();
			while (-- nStates >= 0) {
				TokenDeclState state = (TokenDeclState)reader.ReadToken ();
				states[state.name.val] = state;
			}
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			/*
			 * Global variables.
			 */
			foreach (KeyValuePair<string, TokenDeclVar> kvp in vars) {
				TokenDeclVar declVar = kvp.Value;
				declVar.Reconst (writeSrc);
			}

			/*
			 * Functions.
			 */
			foreach (KeyValuePair<string, TokenDeclFunc> kvp in funcs) {
				TokenDeclFunc declFunc = kvp.Value;
				declFunc.Reconst (writeSrc);
			}

			/*
			 * States.
			 */
			defaultState.Reconst (writeSrc);
			foreach (KeyValuePair<string, TokenDeclState> kvp in states) {
				TokenDeclState declState = kvp.Value;
				declState.Reconst (writeSrc);
			}
		}
#endif
	}

	/**
	 * @brief state body declaration
	 */
	public class TokenStateBody : Token {

		public TokenDeclFunc eventFuncs;

		public int index = -1;  // (codegen) row in ScriptHandlerEventTable (0=default)

		public TokenStateBody (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			Token t;
			for (t = eventFuncs; t != null; t = t.nextToken) {
				writer.Write (t);
			}
			writer.Write (t);
		}

		public override void ReadIn (TokenReader reader)
		{
			TokenDeclFunc lastT, thisT;

			lastT = null;
			while ((thisT = (TokenDeclFunc)reader.ReadToken ()) != null) {
				if (lastT == null) {
					eventFuncs = thisT;
				} else {
					lastT.nextToken = thisT;
				}
				lastT = thisT;
			}
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			for (Token t = eventFuncs; t != null; t = t.nextToken) {
				t.Reconst (writeSrc);
			}
		}
#endif
	}

	/**
	 * @brief a single statement, such as ending on a semicolon or enclosed in braces
	 * TokenStmt includes the terminating semicolon or the enclosing braces
	 * Also includes @label: for jump targets.
	 * Also includes stray ; null statements.
	 */
	public class TokenStmt : Token {

		public TokenStmt (Token original) : base (original) { }
	}

	/**
	 * @brief a group of statements enclosed in braces
	 */
	public class TokenStmtBlock : TokenStmt {

		public Token statements;               // null-terminated list of statements, can also have TokenDeclVar's in here
		public TokenStmtBlock outerStmtBlock;  // next outer stmtBlock or null if top-level, ie, function definition
		public TokenDeclFunc function;         // function it is part of
		public Dictionary<string, TokenDeclVar> variables = new Dictionary<string, TokenDeclVar> ();  // variables declared herein
		public bool isTry;                     // true iff it's a try statement block
		public bool isCatch;                   // true iff it's a catch statement block
		public bool isFinally;                 // true iff it's a finally statement block

		public TokenStmtBlock (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			Token t;
			for (t = statements; t != null; t = t.nextToken) {
				writer.Write (t);
			}
			writer.Write (t);
			writer.Write (outerStmtBlock);
			writer.Write (function);
			writer.Write (variables.Count);
			foreach (KeyValuePair<string, TokenDeclVar> kvp in variables) {
				writer.Write (kvp.Value);
			}
		}

		public override void ReadIn (TokenReader reader)
		{
			Token lastT, thisT;

			lastT = null;
			while ((thisT = reader.ReadToken ()) != null) {
				if (lastT == null) {
					statements = thisT;
				} else {
					lastT.nextToken = thisT;
				}
				lastT = thisT;
			}
			outerStmtBlock = (TokenStmtBlock)reader.ReadToken ();
			function = (TokenDeclFunc)reader.ReadToken ();
			int nVars = reader.ReadInt ();
			while (-- nVars >= 0) {
				TokenDeclVar var = (TokenDeclVar)reader.ReadToken ();
				variables[var.name.val] = var;
			}
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			writeSrc ("{");
			for (Token t = statements; t != null; t = t.nextToken) {
				t.Reconst (writeSrc);
			}
			writeSrc ("}");
		}
#endif
	}

	/**
	 * @brief definition of branch target name
	 */
	public class TokenStmtLabel : TokenStmt {

		public TokenName name;        // the label's name
		public TokenStmtBlock block;  // which block it is defined in
		public bool hasBkwdRefs = false;

		public bool labelTagged;      // code gen: location of label
		public ScriptMyLabel labelStruct;

		public TokenStmtLabel (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (name);
			writer.Write (block);
			writer.Write (hasBkwdRefs);  ///??? recompute on readin
		}

		public override void ReadIn (TokenReader reader)
		{
			name        = (TokenName)reader.ReadToken ();
			block       = (TokenStmtBlock)reader.ReadToken ();
			hasBkwdRefs = reader.ReadBool ();
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			writeSrc ("@" + name.val + ";");
		}
#endif
	}

	/**
	 * @brief those types of RVals with a semi-colon on the end
	 *        that are allowed to stand alone as statements
	 */
	public class TokenStmtRVal : TokenStmt {
		public TokenRVal rVal;

		public TokenStmtRVal (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (rVal);
		}

		public override void ReadIn (TokenReader reader)
		{
			rVal = (TokenRVal)reader.ReadToken ();
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			rVal.Reconst (writeSrc);
			writeSrc (";");
		}
#endif
	}

	public class TokenStmtBreak : TokenStmt {
		public TokenStmtBreak (Token original) : base (original) { }
		public override void WriteOut (TokenWriter writer) { }
		public override void ReadIn (TokenReader reader) { }

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			writeSrc ("break;");
		}
#endif
	}

	public class TokenStmtCont : TokenStmt {
		public TokenStmtCont (Token original) : base (original) { }
		public override void WriteOut (TokenWriter writer) { }
		public override void ReadIn (TokenReader reader) { }

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			writeSrc ("continue;");
		}
#endif
	}

	/**
	 * @brief "do" statement
	 */
	public class TokenStmtDo : TokenStmt {

		public TokenStmt bodyStmt;
		public TokenRVal testRVal;

		public TokenStmtDo (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (bodyStmt);
			writer.Write (testRVal);
		}

		public override void ReadIn (TokenReader reader)
		{
			bodyStmt = (TokenStmt)reader.ReadToken ();
			testRVal = (TokenRVal)reader.ReadToken ();
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			writeSrc ("do ");
			bodyStmt.Reconst (writeSrc);
			writeSrc ("while ");
			testRVal.Reconst (writeSrc);
			writeSrc (";");
		}
#endif
	}

	/**
	 * @brief "for" statement
	 */
	public class TokenStmtFor : TokenStmt {

		public TokenStmt initStmt;  // there is always an init statement, though it may be a null statement
		public TokenRVal testRVal;  // there may or may not be a test (null if not)
		public TokenRVal incrRVal;  // there may or may not be an increment (null if not)
		public TokenStmt bodyStmt;  // there is always a body statement, though it may be a null statement

		public TokenStmtFor (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (initStmt);
			writer.Write (testRVal);
			writer.Write (incrRVal);
			writer.Write (bodyStmt);
		}

		public override void ReadIn (TokenReader reader)
		{
			initStmt = (TokenStmt)reader.ReadToken ();
			testRVal = (TokenRVal)reader.ReadToken ();
			incrRVal = (TokenRVal)reader.ReadToken ();
			bodyStmt = (TokenStmt)reader.ReadToken ();
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			writeSrc ("for (");
			if (initStmt == null) writeSrc (";");
			else initStmt.Reconst (writeSrc);
			if (testRVal != null) {
				writeSrc (" ");
				testRVal.Reconst (writeSrc);
			}
			writeSrc (";");
			if (incrRVal != null) {
				writeSrc (" ");
				incrRVal.Reconst (writeSrc);
			}
			writeSrc (") ");
			bodyStmt.Reconst (writeSrc);
		}
#endif
	}

	/**
	 * @brief "foreach" statement
	 */
	public class TokenStmtForEach : TokenStmt {

		public TokenLVal keyLVal;
		public TokenLVal valLVal;
		public TokenRVal arrayRVal;
		public TokenStmt bodyStmt;  // there is always a body statement, though it may be a null statement

		public TokenStmtForEach (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (keyLVal);
			writer.Write (valLVal);
			writer.Write (arrayRVal);
			writer.Write (bodyStmt);
		}

		public override void ReadIn (TokenReader reader)
		{
			keyLVal   = (TokenLVal)reader.ReadToken ();
			valLVal   = (TokenLVal)reader.ReadToken ();
			arrayRVal = (TokenRVal)reader.ReadToken ();
			bodyStmt  = (TokenStmt)reader.ReadToken ();
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			writeSrc ("foreach (");
			if (keyLVal != null) {
				keyLVal.Reconst (writeSrc);
			}
			writeSrc (",");
			if (valLVal != null) {
				valLVal.Reconst (writeSrc);
			}
			writeSrc (" in ");
			arrayRVal.Reconst (writeSrc);
			writeSrc (") ");
			bodyStmt.Reconst (writeSrc);
		}
#endif
	}

	public class TokenStmtIf : TokenStmt {

		public TokenRVal testRVal;
		public TokenStmt trueStmt;
		public TokenStmt elseStmt;

		public TokenStmtIf (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (testRVal);
			writer.Write (trueStmt);
			writer.Write (elseStmt);
		}

		public override void ReadIn (TokenReader reader)
		{
			testRVal = (TokenRVal)reader.ReadToken ();
			trueStmt = (TokenStmt)reader.ReadToken ();
			elseStmt = (TokenStmt)reader.ReadToken ();
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			writeSrc ("if ");
			testRVal.Reconst (writeSrc);
			writeSrc (" ");
			trueStmt.Reconst (writeSrc);
			if (elseStmt != null) {
				writeSrc (" else ");
				elseStmt.Reconst (writeSrc);
			}
		}
#endif
	}

	public class TokenStmtJump : TokenStmt {

		public TokenName label;

		public TokenStmtJump (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (label);
		}

		public override void ReadIn (TokenReader reader)
		{
			label = (TokenName)reader.ReadToken ();
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			writeSrc ("jump " + label.val + ";");
		}
#endif
	}

	public class TokenStmtNull : TokenStmt {

		public TokenStmtNull (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
		}

		public override void ReadIn (TokenReader reader)
		{
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			writeSrc (";");
		}
#endif
	}

	public class TokenStmtRet : TokenStmt {

		public TokenRVal rVal;  // null if void

		public TokenStmtRet (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (rVal);
		}

		public override void ReadIn (TokenReader reader)
		{
			rVal = (TokenRVal)reader.ReadToken ();
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			writeSrc ("return");
			if (rVal != null) {
				writeSrc (" ");
				rVal.Reconst (writeSrc);
			}
			writeSrc (";");
		}
#endif
	}

	/**
	 * @brief statement that changes the current state.
	 */
	public class TokenStmtState : TokenStmt {

		public TokenName state;  // null for default

		public TokenStmtState (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (state);
		}

		public override void ReadIn (TokenReader reader)
		{
			state = (TokenName)reader.ReadToken ();
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			writeSrc ("state " + ((state == null) ? "default" : state.val) + ";");
		}
#endif
	}

	/**
	 * @brief Encapsulates a whole switch statement including the body and all cases.
	 */
	public class TokenStmtSwitch : TokenStmt {

		public TokenRVal testRVal;               // the integer index expression
		public TokenSwitchCase cases = null;     // list of all cases, linked by .nextCase
		public TokenSwitchCase lastCase = null;  // used during reduce to point to last in 'cases' list

		public TokenStmtSwitch (Token original) : base (original) { }

		/**
		 * @brief Write abstract syntax tree representation
		 */
		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (testRVal);
			for (TokenSwitchCase thisCase = cases; thisCase != null; thisCase = thisCase.nextCase) {
				writer.Write (thisCase);
			}
			writer.Write ((Token)null);
		}

		/**
		 * @brief Read abstract syntax tree representation
		 */
		public override void ReadIn (TokenReader reader)
		{
			TokenSwitchCase thisCase;

			testRVal = (TokenRVal)reader.ReadToken ();
			while ((thisCase = (TokenSwitchCase)reader.ReadToken ()) != null) {
				if (lastCase == null) {
					cases = thisCase;
				} else {
					lastCase.nextCase = thisCase;
				}
				lastCase = thisCase;
			}
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			writeSrc ("switch ");
			testRVal.Reconst (writeSrc);
			writeSrc (" {");
			for (TokenSwitchCase thisCase = cases; thisCase != null; thisCase = thisCase.nextCase) {
				if (thisCase.rVal1 == null) {
					writeSrc ("default:");
				} else {
					writeSrc ("case ");
					thisCase.rVal1.Reconst (writeSrc);
					if (thisCase.rVal2 != null) {
						writeSrc (" ... ");
						thisCase.rVal2.Reconst (writeSrc);
					}
					writeSrc (":");
				}
				for (TokenStmt stmt = thisCase.stmts; stmt != null; stmt = (TokenStmt)stmt.nextToken) {
					stmt.Reconst (writeSrc);
				}
			}
			writeSrc ("}");
		}
#endif
	}

	/**
	 * @brief Encapsulates a case/default clause from a switch statement including the
	 *        two values and the corresponding body statements.
	 */
	public class TokenSwitchCase : Token {
		public TokenSwitchCase nextCase;  // next case in source-code order
		public TokenRVal rVal1;           // null means 'default', else 'case'
		public TokenRVal rVal2;           // null means 'case expr:', else 'case expr ... expr:'
		public TokenStmt stmts;           // statements associated with the case
		public TokenStmt lastStmt;        // used during reduce for building statement list

		public int val1;                        // codegen: value of rVal1 here
		public int val2;                        // codegen: value of rVal2 here
		public ScriptMyLabel label;             // codegen: target label here
		public TokenSwitchCase nextSortedCase;  // codegen: next case in ascending val order

		public TokenSwitchCase (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (rVal1);
			writer.Write (rVal2);
			for (TokenStmt stmt = stmts; stmt != null; stmt = (TokenStmt)stmt.nextToken) {
				writer.Write (stmt);
			}
			writer.Write ((Token)null);
		}

		public override void ReadIn (TokenReader reader)
		{
			TokenStmt stmt;

			rVal1 = (TokenRVal)reader.ReadToken ();
			rVal2 = (TokenRVal)reader.ReadToken ();
			while ((stmt = (TokenStmt)reader.ReadToken ()) != null) {
				if (lastStmt == null) {
					stmts = stmt;
				} else {
					lastStmt.nextToken = stmt;
				}
				lastStmt = stmt;
			}
		}
	}

	public class TokenStmtThrow : TokenStmt {

		public TokenRVal rVal;  // null if rethrow style

		public TokenStmtThrow (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (rVal);
		}

		public override void ReadIn (TokenReader reader)
		{
			rVal = (TokenRVal)reader.ReadToken ();
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			writeSrc ("throw");
			if (rVal != null) {
				writeSrc (" ");
				rVal.Reconst (writeSrc);
			}
			writeSrc (";");
		}
#endif
	}

	/**
	 * @brief Encapsulates related try, catch and finally statements.
	 */
	public class TokenStmtTry : TokenStmt {

		public TokenStmtBlock tryStmt;
		public TokenName catchVar;		// null iff catchStmt is null
		public TokenStmtBlock catchStmt;	// can be null
		public TokenStmtBlock finallyStmt;	// can be null

		public TokenStmtTry (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (tryStmt);
			writer.Write (catchVar);
			writer.Write (catchStmt);
			writer.Write (finallyStmt);
		}

		public override void ReadIn (TokenReader reader)
		{
			tryStmt     = (TokenStmtBlock)reader.ReadToken ();
			catchVar    = (TokenName)reader.ReadToken ();
			catchStmt   = (TokenStmtBlock)reader.ReadToken ();
			finallyStmt = (TokenStmtBlock)reader.ReadToken ();
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			writeSrc ("try ");
			tryStmt.Reconst (writeSrc);
			if (catchStmt != null) {
				writeSrc (" catch (string ");
				writeSrc (catchVar.val);
				writeSrc (") ");
				catchStmt.Reconst (writeSrc);
			}
			if (finallyStmt != null) {
				writeSrc (" finally ");
				finallyStmt.Reconst (writeSrc);
			}
		}
#endif
	}

	public class TokenStmtWhile : TokenStmt {

		public TokenRVal testRVal;
		public TokenStmt bodyStmt;

		public TokenStmtWhile (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (testRVal);
			writer.Write (bodyStmt);
		}

		public override void ReadIn (TokenReader reader)
		{
			testRVal = (TokenRVal)reader.ReadToken ();
			bodyStmt = (TokenStmt)reader.ReadToken ();
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			writeSrc ("while (");
			testRVal.Reconst (writeSrc);
			writeSrc (") ");
			bodyStmt.Reconst (writeSrc);
		}
#endif
	}

	/**
	 * @brief type expressions (right-hand of 'is' keyword).
	 */
	public class TokenTypeExp : Token {
		public TokenTypeExp (Token original) : base (original) { }
	}

	public class TokenTypeExpBinOp : TokenTypeExp {
		public TokenTypeExp leftOp;
		public Token        binOp;
		public TokenTypeExp rightOp;

		public TokenTypeExpBinOp (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (leftOp);
			writer.Write (binOp);
			writer.Write (rightOp);
		}

		public override void ReadIn (TokenReader reader)
		{
			leftOp  = (TokenTypeExp)reader.ReadToken ();
			binOp   =               reader.ReadToken ();
			rightOp = (TokenTypeExp)reader.ReadToken ();
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			leftOp.Reconst (writeSrc);
			writeSrc (" " + binOp.ToString () + " ");
			rightOp.Reconst (writeSrc);
		}
#endif
	}

	public class TokenTypeExpNot : TokenTypeExp {
		public TokenTypeExp typeExp;

		public TokenTypeExpNot (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (typeExp);
		}

		public override void ReadIn (TokenReader reader)
		{
			typeExp = (TokenTypeExp)reader.ReadToken ();
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			writeSrc ("~");
			typeExp.Reconst (writeSrc);
		}
#endif
	}

	public class TokenTypeExpPar : TokenTypeExp {
		public TokenTypeExp typeExp;

		public TokenTypeExpPar (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (typeExp);
		}

		public override void ReadIn (TokenReader reader)
		{
			typeExp = (TokenTypeExp)reader.ReadToken ();
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			writeSrc ("(");
			typeExp.Reconst (writeSrc);
			writeSrc (")");
		}
#endif
	}

	public class TokenTypeExpType : TokenTypeExp {
		public TokenType typeToken;

		public TokenTypeExpType (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
			writer.Write (typeToken);
		}

		public override void ReadIn (TokenReader reader)
		{
			typeToken = (TokenType)reader.ReadToken ();
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			writeSrc (typeToken.ToString ());
		}
#endif
	}

	public class TokenTypeExpUndef : TokenTypeExp {
		public TokenTypeExpUndef (Token original) : base (original) { }

		public override void WriteOut (TokenWriter writer)
		{
		}

		public override void ReadIn (TokenReader reader)
		{
		}

#ifdef SECRET_STUFF
		public override void Reconst (SrcWriter writeSrc)
		{
			writeSrc ("undef");
		}
#endif
	}
}
