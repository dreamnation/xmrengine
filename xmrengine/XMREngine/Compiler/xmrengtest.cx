/********************************************************\
 *  COPYRIGHT 2012, Mike Rieker, Beverly, MA, USA       *
 *  All rights reserved.                                *
\********************************************************/

/**
 * @brief Main program for the script compiler.
 */

using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection.Emit;
using System.Text;

#include "lsltypes.h"

namespace OpenSim.Region.ScriptEngine.XMREngine
{

    public class XMREngTest
    {
        /**
         * @brief Stand-alone test program.
         *
         * mono xmrengtest.exe <xmrobjfile> -checkrun -serialize -obj <xmrobjoutput> -asm <xmrasmoutput> <sourcefile>
         */
        public static void Main (string[] args)
        {
            bool doCheckRun = false;
            bool serialize = false;
            string asmFileName = null;
            string objFileName = null;
            string srcFileName = null;

            for (int i = 0; i < args.Length; i ++) {
                string arg = args[i];
                if (arg == "-asm") {
                    if (++ i >= args.Length) goto usage;
                    asmFileName = args[i];
                    continue;
                }
                if (arg == "-checkrun") {
                    doCheckRun = true;
                    continue;
                }
                if (arg == "-obj") {
                    if (++ i >= args.Length) goto usage;
                    objFileName = args[i];
                    continue;
                }
                if (arg == "-serialize") {
                    serialize  = true;
                    doCheckRun = true;
                    continue;
                }
                if (arg[0] == '-') goto usage;
                if (srcFileName != null) goto usage;
                srcFileName = arg;
            }
            if (srcFileName == null) goto usage;

            /*
             * Read whole source into memory.
             */
            string source = "# 1 \"" + srcFileName + "\"\n" + File.ReadAllText (srcFileName);

            /*
             * Parse source string into tokens.
             */
            Console.WriteLine ("Compiling...");
            TokenBegin tokenBegin = TokenBegin.Construct (StandAloneErrorMessage, source);
            if (tokenBegin == null) {
                Console.WriteLine ("Parsing errors.");
                Environment.Exit (1);
            }

            /*
             * Create abstract syntax tree from raw tokens.
             */
            TokenScript tokenScript = ScriptReduce.Reduce( tokenBegin);
            if (tokenScript == null) {
                Console.WriteLine ("Reduction errors.");
                Environment.Exit (1);
            }

            /*
             * Attempt to compile AST to object code.
             */
            Stream objFileStream;
            if (objFileName != null) {
                objFileStream = File.Create (objFileName);
            } else {
                objFileStream = new MemoryStream ();
            }
            BinaryWriter objFileWriter = new BinaryWriter (objFileStream);
            bool ok;
            ok = ScriptCodeGen.CodeGen (tokenScript, objFileWriter);
            if (objFileName != null) objFileWriter.Close ();
            if (!ok) {
                Console.WriteLine ("Compilation errors.");
                Environment.Exit (1);
            }

            /*
             * Load object code into memory.
             * Maybe also output disassembly.
             */
            if (objFileName != null) {
                objFileStream = File.OpenRead (objFileName);
            } else {
                objFileStream.Seek (0, SeekOrigin.Begin);
            }
            BinaryReader objFileReader = new BinaryReader (objFileStream);
            TextWriter asmFileWriter = null;
            if (asmFileName != null) {
                asmFileWriter = (asmFileName != "-") ? File.CreateText (asmFileName) : Console.Out;
            }
            ScriptObjCode scriptObjCode = ScriptCodeGen.PerformGeneration ("", objFileReader, asmFileWriter);
            objFileReader.Close ();
            if (asmFileWriter != null) asmFileWriter.Close ();

            /*
             * Instantiate the script and run its default state_entry() handler.
             */
            Console.WriteLine ("Running...");
            TestInstance inst = new TestInstance (scriptObjCode);
            inst.ehArgs = new object[0];
            inst.testCheckRun = doCheckRun;
            MemoryStream serializeStream = null;
            if (serialize) {
                serializeStream = new MemoryStream ();
            }
            while (true) {
                try {
                    scriptObjCode.scriptEventHandlerTable[0,(int)ScriptEventCode.state_entry](inst);
                    break;
                } catch (StackCaptureException) {

                    /*
                     * Make sure we were called because CheckRun() threw and 
                     * the code built inst.StackFrames.
                     */
                    if (inst.callMode != XMRInstAbstract.CALLMODE_SAVE) throw;

                    /*
                     * If -serialize, make sure stack frame serialization works.
                     */
                    if (serialize) {

                        /*
                         * Write global variables and stack frames out and discard them.
                         */
                        serializeStream.Position = 0;
                        inst.migrateOutWriter    = new BinaryWriter (serializeStream);
                        inst.migrateOutObjects   = new Dictionary<object, int> ();
                        inst.glblVars.SendArrays (inst.SendObjArray);
                        for (XMRStackFrame thisSF = inst.stackFrames; thisSF != null; thisSF = thisSF.nextSF) {
                            inst.SendObjValue (thisSF.funcName);
                            inst.SendObjValue (thisSF.callNo);
                            inst.SendObjArray (thisSF.objArray);
                        }
                        inst.SendObjValue ("");
                        inst.migrateOutWriter  = null;
                        inst.migrateOutObjects = null;
                        inst.stackFrames       = null;

                        /*
                         * Read global variables and stack frames back in and reconstruct.
                         */
                        serializeStream.Position = 0;
                        inst.migrateInReader     = new BinaryReader (serializeStream);
                        inst.migrateInObjects    = new Dictionary<int, object> ();
                        inst.glblVars.RecvArrays (inst.RecvObjArray);
                        XMRStackFrame lastSF     = null;
                        string funcName;
                        while ((funcName = (string)inst.RecvObjValue ()) != "") {
                            XMRStackFrame thisSF = new XMRStackFrame ();
                            thisSF.funcName = funcName;
                            thisSF.callNo   = (int)inst.RecvObjValue ();
                            thisSF.objArray = (object[])inst.RecvObjArray (typeof (object));
                            if (lastSF == null) inst.stackFrames = thisSF;
                                           else lastSF.nextSF = thisSF;
                            lastSF = thisSF;
                        }
                        inst.migrateInReader  = null;
                        inst.migrateInObjects = null;
                    }

                    /*
                     * Tell code to restore from inst.stackFrames when it is called back.
                     */
                    inst.callMode = XMRInstAbstract.CALLMODE_RESTORE;
                }
            }
            return;

        usage:
            Console.WriteLine ("usage: mono xmrengtest.exe [ -asm <asmoutfile>|- ] [ -checkrun ] [ -obj <objoutfile> ] [ -serialize] <sourcefile>");
            Environment.Exit (1);
        }

        public static void StandAloneErrorMessage (Token token, string message)
        {
            Console.WriteLine ("{0} {1}", token.SrcLoc, message);
        }
    }

    public class StackCaptureException : Exception, IXMRUncatchable { }

    public class TestInstance : XMRInstAbstract {
        public bool testCheckRun;

        public TestInstance (ScriptObjCode soc)
        {
            glblVars.AllocVarArrays (ref soc.glblSizes);
            m_ObjCode = soc;
        }

        /*********************\
         *  XMRInstAbstract  *
        \*********************/

        public override void CheckRun (int line)
        {
            if (testCheckRun) {
                switch (this.callMode) {

                    /*
                     * Code was running normally.
                     * Suspend and write stack frames to this.StackFrames.
                     */
                    case CALLMODE_NORMAL: {
                        this.callMode = CALLMODE_SAVE;
                        this.stackFrames = null;
                        throw new StackCaptureException ();
                    }

                    /*
                     * Code just restored itself from this.StackFrames.
                     * Resume where it left off until it calls CheckRun() again.
                     */
                    case CALLMODE_RESTORE: {
                        if (this.stackFrames != null) throw new Exception ("frames left over");
                        this.callMode = CALLMODE_NORMAL;
                        break;
                    }

                    default: throw new Exception ("bad callMode " + this.callMode);
                }
            }
        }

        public override int  StackLeft ()
        {
            return 1000000;
        }
        public override LSL_List XMREventDequeue (SCRIPTFLOAT timeout, int returnMask1, int returnMask2,
                                                  int backgroundMask1, int backgroundMask2, int line)
        {
            return new LSL_List (new object[0]);
        }
        public override void XMREventEnqueue (LSL_List ev)
        { }
        public override void XMREventCallHandler (LSL_List ev)
        { }
        public override LSL_List XMREventSaveDets ()
        {
            return new LSL_List (new object[0]);
        }
        public override void XMREventLoadDets (LSL_List dpList)
        { }
    }

    public class SCRIPTBASECLASS {
        public static readonly LSL_Rotation ZERO_ROTATION = new LSL_Rotation (0.0, 0.0, 0.0, 1.0);
        public static readonly LSL_Vector   ZERO_VECTOR   = new LSL_Vector (0.0, 0.0, 0.0);

        public void llOwnerSay (string msg)
        {
            Console.WriteLine ("llOwnerSay: " + msg);
        }
    }
}
