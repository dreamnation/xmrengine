/********************************************************\
 *  COPYRIGHT 2012, Mike Rieker, Beverly, MA, USA       *
 *  All rights reserved.                                *
\********************************************************/

/**
 * @brief Main program for the script compiler.
 */

using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection.Emit;
using System.Text;

#include "lsltypes.h"

namespace OpenSim.Region.ScriptEngine.XMREngine
{

    public class XMREngTest
    {
        /**
         * @brief Stand-alone test program.
         *
         * mono xmrengtest.exe <xmrobjfile> < testscript
         */
        public static void Main (string[] args)
        {
            string asmFileName = null;
            string objFileName = null;
            string srcFileName = null;

            for (int i = 0; i < args.Length; i ++) {
                string arg = args[i];
                if (arg == "-asm") {
                    if (++ i >= args.Length) goto usage;
                    asmFileName = args[i];
                    continue;
                }
                if (arg == "-obj") {
                    if (++ i >= args.Length) goto usage;
                    objFileName = args[i];
                    continue;
                }
                if (srcFileName != null) goto usage;
                srcFileName = arg;
            }
            if (srcFileName == null) goto usage;

            /*
             * Read whole source into memory.
             */
            string source = "# 1 \"" + srcFileName + "\"\n" + File.ReadAllText (srcFileName);

            /*
             * Parse source string into tokens.
             */
            Console.WriteLine ("Compiling...");
            TokenBegin tokenBegin = TokenBegin.Construct (StandAloneErrorMessage, source);
            if (tokenBegin == null) {
                Console.WriteLine ("Parsing errors.");
                Environment.Exit (1);
            }

            /*
             * Create abstract syntax tree from raw tokens.
             */
            TokenScript tokenScript = ScriptReduce.Reduce( tokenBegin);
            if (tokenScript == null) {
                Console.WriteLine ("Reduction errors.");
                Environment.Exit (1);
            }

            /*
             * Attempt to compile AST to object code.
             */
            Stream objFileStream;
            if (objFileName != null) {
                objFileStream = File.Create (objFileName);
            } else {
                objFileStream = new MemoryStream ();
            }
            BinaryWriter objFileWriter = new BinaryWriter (objFileStream);
            bool ok;
            ok = ScriptCodeGen.CodeGen (tokenScript, objFileWriter);
            if (objFileName != null) objFileWriter.Close ();
            if (!ok) {
                Console.WriteLine ("Compilation errors.");
                Environment.Exit (1);
            }

            /*
             * Load object code into memory.
             * Maybe also output disassembly.
             */
            if (objFileName != null) {
                objFileStream = File.OpenRead (objFileName);
            } else {
                objFileStream.Seek (0, SeekOrigin.Begin);
            }
            BinaryReader objFileReader = new BinaryReader (objFileStream);
            TextWriter asmFileWriter = null;
            if (asmFileName != null) {
                asmFileWriter = (asmFileName != "-") ? File.CreateText (asmFileName) : Console.Out;
            }
            ScriptObjCode scriptObjCode = ScriptCodeGen.PerformGeneration ("", objFileReader, asmFileWriter);
            objFileReader.Close ();
            if (asmFileWriter != null) asmFileWriter.Close ();

            /*
             * Instantiate the script and run its default state_entry() handler.
             */
            Console.WriteLine ("Running...");
            TestInstance inst = new TestInstance (scriptObjCode);
            inst.ehArgs = new object[0];
            scriptObjCode.scriptEventHandlerTable[0,(int)ScriptEventCode.state_entry](inst);
            return;

        usage:
            Console.WriteLine ("usage: mono xmrengtest.exe [ -asm <asmoutfile>|- ] [ -obj <objoutfile> ] <sourcefile>");
            Environment.Exit (1);
        }

        public static void StandAloneErrorMessage (Token token, string message)
        {
            Console.WriteLine ("{0} {1}", token.SrcLoc, message);
        }
    }

    public class TestInstance : XMRInstAbstract {
        public TestInstance (ScriptObjCode soc)
        {
            m_ObjCode = soc;

            gblArrays    = new XMR_Array    [soc.numGblArrays];
            gblFloats    = new SCRIPTFLOAT  [soc.numGblFloats];
            gblIntegers  = new int          [soc.numGblIntegers];
            gblLists     = new LSL_List     [soc.numGblLists];
            gblObjects   = new object       [soc.numGblObjects];
            gblRotations = new LSL_Rotation [soc.numGblRotations];
            gblStrings   = new string       [soc.numGblStrings];
            gblVectors   = new LSL_Vector   [soc.numGblVectors];
            gblSDTClObjs = new XMRSDTypeClassInstance [soc.numGblSDTClObjs];
        }

        /*********************\
         *  XMRInstAbstrace  *
        \*********************/

        public override object[] CaptureStackFrame (string funcName, int callNo, int nSaves)
        {
            XMRStackFrame sf = new XMRStackFrame ();
            sf.nextSF   = stackFrames;
            sf.funcName = funcName;
            sf.callNo   = callNo;
            sf.objArray = new object[nSaves];
            stackFrames = sf;
            return sf.objArray;
        }
        public override object[] RestoreStackFrame (string funcName, out int callNo)
        {
            XMRStackFrame sf = stackFrames;
            if (sf.funcName != funcName) throw new Exception ("frame mismatch");
            callNo = sf.callNo;
            stackFrames = sf.nextSF;
            return sf.objArray;
        }

        public override void ConsoleWrite (string s)
        {
            Console.Write (s);
        }
        public override void CheckRun (int line)
        { }
        public override int  StackLeft ()
        {
            return 1000000;
        }
        public override LSL_List XMREventDequeue (SCRIPTFLOAT timeout, int returnMask1, int returnMask2,
                                                  int backgroundMask1, int backgroundMask2, int line)
        {
            return new LSL_List (new object[0]);
        }
        public override void XMREventEnqueue (LSL_List ev)
        { }
        public override void XMREventCallHandler (LSL_List ev)
        { }
        public override LSL_List XMREventSaveDets ()
        {
            return new LSL_List (new object[0]);
        }
        public override void XMREventLoadDets (LSL_List dpList)
        { }
        public override XMR_Array XMRosParseJSON (string s)
        {
            return new XMR_Array ();
        }

        public override string XMRTypeName (object o)
        {
            /*
             * Basic types return constant strings of the script-visible type name.
             */
            if (o is LSL_List)     return "list";
            if (o is LSL_Rotation) return "rotation";
            if (o is LSL_Vector)   return "vector";
            if (o is float)        return "float";
            if (o is int)          return "integer";
            if (o is string)       return "string";
            if (o is double)       return "float";
            if (o is bool)         return "bool";
            if (o is XMR_Array)    return "array";
            if (o is LSL_Integer)  return "integer";
            if (o is LSL_Float)    return "float";
            if (o is LSL_String)   return "string";

            /*
             * A script-defined interface is represented as an array of delegates.
             * If that is the case, convert it to the object of the script-defined 
             * class that is implementing the interface.  This should let the next 
             * step get the script-defined type name of the object.
             */
            if (o is Delegate[]) {
                o = ((Delegate[])o)[0].Target;
            }

            /*
             * If script-defined class instance, get the script-defined 
             * type name.
             */
            if (o is XMRSDTypeClassInstance) {
                return ((XMRSDTypeClassInstance)o).sdtcClass.longName.val;
            }

            /*
             * If it's a delegate, maybe we can look up its script-defined type name.
             */
            Type ot = o.GetType ();
            if (o is Delegate) {
                String os;
                if (m_ObjCode.sdDelTypes.TryGetValue (ot, out os)) return os;
            }

            /*
             * Don't know what it is, get the C#-level type name.
             */
            return ot.ToString ();
        }

        /**
         * @brief Get a delegate for a script-defined function.
         * @param name = name of the function including arg types, eg,
         *               "Verify(array,list,string)"
         * @param sig  = script-defined type name
         * @param targ = function's 'this' pointer or null if static
         * @returns delegate for the script-defined function
         */
        public override Delegate GetScriptMethodDelegate (string name, string sig, object targ)
        {
            DynamicMethod dm = m_ObjCode.dynamicMethods[name];
            TokenDeclSDTypeDelegate dt = (TokenDeclSDTypeDelegate)m_ObjCode.sdObjTypes[sig];
            return dm.CreateDelegate (dt.GetSysType (), targ);
        }
    }

    public class SCRIPTBASECLASS {
        public static readonly LSL_Rotation ZERO_ROTATION = new LSL_Rotation (0.0, 0.0, 0.0, 1.0);
        public static readonly LSL_Vector   ZERO_VECTOR   = new LSL_Vector (0.0, 0.0, 0.0);

        public void llOwnerSay (string msg)
        {
            Console.WriteLine ("llOwnerSay: " + msg);
        }
    }
}
