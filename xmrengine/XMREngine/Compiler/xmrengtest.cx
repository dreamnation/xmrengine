/********************************************************\
 *  COPYRIGHT 2012, Mike Rieker, Beverly, MA, USA       *
 *  All rights reserved.                                *
\********************************************************/

/**
 * @brief Main program for the script tester.
 */

using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Reflection.Emit;
using System.Text;

#include "lsltypes.h"

namespace OpenSim.Region.ScriptEngine.XMREngine
{

    public class XMREngTest
    {
        public static int consoleLine = 0;

        /**
         * @brief Stand-alone test program.
         *
         * mono xmrengtest.exe <xmrobjfile> -checkrun -serialize -obj <xmrobjoutput> -asm <xmrasmoutput> <sourcefile>
         */
        public static void Main (string[] args)
        {
            bool doCheckRun = false;
            bool eventIO    = false;
            bool serialize  = false;
            string asmFileName = null;
            string objFileName = null;
            string savFileName = null;
            string srcFileName = null;
            string sourceHash  = null;

            for (int i = 0; i < args.Length; i ++) {
                string arg = args[i];
                if (arg == "-asm") {
                    if (++ i >= args.Length) goto usage;
                    asmFileName = args[i];
                    continue;
                }
                if (arg == "-builtins") {
                    PrintBuiltins ();
                    return;
                }
                if (arg == "-checkrun") {
                    doCheckRun = true;
                    continue;
                }
                if (arg == "-eventio") {
                    eventIO = true;
                    continue;
                }
                if (arg == "-obj") {
                    if (++ i >= args.Length) goto usage;
                    objFileName = args[i];
                    continue;
                }
                if (arg == "-save") {
                    if (++ i >= args.Length) goto usage;
                    savFileName = args[i];
                    continue;
                }
                if (arg == "-serialize") {
                    serialize  = true;
                    doCheckRun = true;
                    continue;
                }
                if (arg == "-version") {
                    Console.WriteLine ("commit " + GITCOMMITHASH + ((GITCOMMITCLEAN != 0) ? "" : "(dirty)") + " " + GITCOMMITDATE);
                    return;
                }
                if (arg[0] == '-') goto usage;
                if (srcFileName != null) goto usage;
                srcFileName = arg;
            }
            if (srcFileName == null) goto usage;

            /*
             * Read whole source into memory.
             */
            FileInfo srcFileInfo = new FileInfo (srcFileName);
            string source = "# 1 \"" + srcFileName + "\"\n" + File.ReadAllText (srcFileInfo.FullName);

            /*
             * Parse source string into tokens.
             */
            Console.WriteLine ("Compiling...");
            string cameFrom = "file://" + srcFileInfo.FullName;
            TextWriter saveSource = null;
            if (savFileName != null) saveSource = File.CreateText (savFileName);
            TokenBegin tokenBegin;
            try {
                tokenBegin = TokenBegin.Construct (cameFrom, saveSource, StandAloneErrorMessage, source, out sourceHash);
            } finally {
                if (saveSource != null) saveSource.Close ();
            }
            if (tokenBegin == null) {
                Console.WriteLine ("Parsing errors.");
                Environment.Exit (1);
            }

            /*
             * Create abstract syntax tree from raw tokens.
             */
            TokenScript tokenScript = ScriptReduce.Reduce(tokenBegin);
            if (tokenScript == null) {
                Console.WriteLine ("Reduction errors.");
                Environment.Exit (1);
            }

            /*
             * Attempt to compile AST to object code.
             */
            Stream objFileStream;
            if (objFileName != null) {
                objFileStream = File.Create (objFileName);
            } else {
                objFileStream = new MemoryStream ();
            }
            BinaryWriter objFileWriter = new BinaryWriter (objFileStream);
            bool ok;
            ok = ScriptCodeGen.CodeGen (tokenScript, objFileWriter, sourceHash);
            if (objFileName != null) objFileWriter.Close ();
            if (!ok) {
                Console.WriteLine ("Compilation errors.");
                Environment.Exit (1);
            }

            /*
             * Load object code into memory.
             * Maybe also output disassembly.
             */
            if (objFileName != null) {
                objFileStream = File.OpenRead (objFileName);
            } else {
                objFileStream.Seek (0, SeekOrigin.Begin);
            }
            BinaryReader objFileReader = new BinaryReader (objFileStream);
            TextWriter asmFileWriter = null;
            if (asmFileName != null) {
                asmFileWriter = (asmFileName != "-") ? File.CreateText (asmFileName) : Console.Out;
            }
            ScriptObjCode scriptObjCode;
            try {
                scriptObjCode = ScriptCodeGen.PerformGeneration (objFileReader, asmFileWriter);
            } finally {
                objFileReader.Close ();
                if (asmFileWriter != null) asmFileWriter.Close ();
            }

            /*
             * Instantiate the script and run its default state_entry() handler.
             */
            Console.WriteLine ("Running...");
            TestInstance inst = new TestInstance (scriptObjCode);
            inst.testCheckRun = doCheckRun;
            inst.heapTotal    = inst.glblVars.AllocVarArrays (ref scriptObjCode.glblSizes);
            inst.ehArgs       = new object[0];
            inst.stateCode    = 0;  // default
            inst.eventCode    = ScriptEventCode.state_entry;
            MemoryStream serializeStream = null;
            if (serialize) {
                serializeStream = new MemoryStream ();
            }
            while (true) {

                /*
                 * Call event handler and wait for it to finish.
                 */
                while (true) {
                    try {
                        RunScriptEventHandler (ref inst, serializeStream);
                        break;
                    } catch (ScriptChangeStateException scse) {
                        inst.eventCode = ScriptEventCode.state_exit;
                        inst.ehArgs    = new object[0];
                        try {
                            RunScriptEventHandler (ref inst, serializeStream);
                        } catch (ScriptChangeStateException) {
                            Console.WriteLine ("State change in state_exit handler ignored");
                        }
                        inst.stateCode = scse.newState;
                        inst.eventCode = ScriptEventCode.state_entry;
                        Console.WriteLine ("Change to state " + inst.m_ObjCode.stateNames[inst.stateCode]);
                    } catch (ScriptResetException) {
                        inst.stateCode = 0;
                        inst.eventCode = ScriptEventCode.state_entry;
                        inst.doGblInit = true;
                        Console.WriteLine ("Script called llResetScript()");
                    } catch (ScriptDieException) {
                        Console.WriteLine ("Script called llDie()");
                        return;
                    } catch (Exception e) {
                        Console.WriteLine ("Uncaught exception in script: " + inst.XMRExceptionFixString (e.ToString (), true));
                        return;
                    }
                }

                if (!eventIO) return;

                /*
                 * Read eventname(eventargs) from stdin.
                 */
            readLine:
                string eventLine = Console.ReadLine ();
                if (eventLine == null) return;
                ++ consoleLine;
                Console.WriteLine (eventLine);

                /*
                 * Parse into tokens.
                 */
                eventLine = "# " + consoleLine + " \"console events\"\n" + eventLine;
                tokenBegin = TokenBegin.Construct ("console events", null, StandAloneErrorMessage, eventLine, out sourceHash);
                if (tokenBegin == null) continue;
                Token t = tokenBegin.nextToken;

                /*
                 * Get event handler name and validate.
                 */
                if (!(t is TokenName)) {
                    t.ErrorMsg ("expecting event name");
                    goto readLine;
                }
                TokenName eventName = (TokenName)t;
                MethodInfo[] ifaceMethods = typeof (IEventHandlers).GetMethods ();
                MethodInfo ifaceMethod;
                foreach (MethodInfo ifm in ifaceMethods) {
                    ifaceMethod = ifm;
                    if (ifaceMethod.Name == eventName.val) goto gotEvent;
                }
                eventName.ErrorMsg ("unknown event");
                goto readLine;
            gotEvent:
                inst.eventCode = (ScriptEventCode)Enum.Parse (typeof (ScriptEventCode), eventName.val);
                if (scriptObjCode.scriptEventHandlerTable[inst.stateCode,(int)inst.eventCode] == null) {
                    eventName.ErrorMsg ("event handler not defined for state " + scriptObjCode.stateNames[inst.stateCode]);
                    goto readLine;
                }
                t = t.nextToken;

                /*
                 * Parse argument list.
                 */
                if (!(t is TokenKwParOpen)) {
                    t.ErrorMsg ("expecting ( after event name");
                    goto readLine;
                }
                List<object> argList = new List<object> ();
                do {
                    t = t.nextToken;
                    if ((argList.Count == 0) && (t is TokenKwParClose)) break;
                    object val = ParseEHArg (ref t);
                    if (val == null) goto readLine;
                    argList.Add (val);
                } while (t is TokenKwComma);
                if (!(t is TokenKwParClose)) {
                    t.ErrorMsg ("expecting , or ) in arg list");
                    goto readLine;
                }
                inst.ehArgs = argList.ToArray ();
                t = t.nextToken;
                if (!(t is TokenEnd)) {
                    t.ErrorMsg ("extra stuff after event args");
                    goto readLine;
                }
            }

        usage:
            Console.WriteLine ("usage: mono xmrengtest.exe [ -builtins ] [ -checkrun ] [ -eventio ] [ -save <sourceoutfile> ] [ -serialize ] [ -version ] <sourcefile>");
            Console.WriteLine ("     -builtins : print list of built-in functions and constants then exit");
            Console.WriteLine ("     -checkrun : simulate a thread slice at every opportunity");
            Console.WriteLine ("      -eventio : when default state_entry completes, read next event from stdin and keep doing so until eof");
            Console.WriteLine ("                 format is:  event_name ( arg1 , arg2 , ... )");
            Console.WriteLine ("                   example:  http_response(\"firstone\",3,[0,<1,2,3>,\"456\"],\"body\")");
            Console.WriteLine ("         -save : save copy of source file to sourceoutfile");
            Console.WriteLine ("    -serialize : serialize and deserialize stack at every opportunity");
            Console.WriteLine ("      -version : print version number then exit");
            Environment.Exit (1);
        }

        public static void StandAloneErrorMessage (Token token, string message)
        {
            Console.WriteLine ("{0} {1}", token.SrcLoc, message);
        }

        public static void PrintBuiltins ()
        {
            Console.WriteLine ("\nBuilt-in functions:\n");
            SortedDictionary<string, TokenDeclInline> bifs = new SortedDictionary<string, TokenDeclInline> ();
            foreach (TokenDeclVar bif in TokenDeclInline.inlineFunctions) {
                bifs.Add (bif.fullName, (TokenDeclInline)bif);
            }
            foreach (TokenDeclInline bif in bifs.Values) {
                char noisy = !IsTaggedNoisy (bif.methInfo) ? ' ' : (bif.retType is TokenTypeVoid) ? 'N' : 'R';
                Console.WriteLine (noisy + "   " + bif.retType.ToString ().PadLeft (8) + " " + bif.fullName);
            }
            Console.WriteLine ("\nN - stub that writes name and arguments to stdout");
            Console.WriteLine ("R - stub that writes name and arguments to stdout then reads return value from stdin");
            Console.WriteLine ("    format is:  function_name : return_value");
            Console.WriteLine ("      example:  llKey2Name:\"Kunta Kinte\"");

            Console.WriteLine ("\nBuilt-in constants:\n");
            SortedDictionary<string, ScriptConst> scs = new SortedDictionary<string, ScriptConst> ();
            int widest = 0;
            foreach (ScriptConst sc in ScriptConst.scriptConstants.Values) {
                if (widest < sc.name.Length) widest = sc.name.Length;
                scs.Add (sc.name, sc);
            }
            foreach (ScriptConst sc in scs.Values) {
                Console.WriteLine ("    " + sc.rVal.type.ToString ().PadLeft (8) + " " + sc.name.PadRight (widest) + " = " + BuiltInConstVal (sc.rVal));
            }
            Console.WriteLine ("");
        }

        public static bool IsTaggedNoisy (MethodInfo methInfo)
        {
            if (methInfo != null) {
                foreach (Attribute attr in Attribute.GetCustomAttributes (methInfo)) {
                    if (attr is xmrMethodIsNoisyAttribute) return true;
                }
            }
            return false;
        }

        public static string BuiltInConstVal (CompValu rVal)
        {
            if (rVal is CompValuInteger) {
                int x = ((CompValuInteger)rVal).x;
                return "0x" + x.ToString ("X8") + " = " + x.ToString ().PadLeft (11);
            }
            if (rVal is CompValuFloat) return ((CompValuFloat)rVal).x.ToString ();
            if (rVal is CompValuSField) {
                FieldInfo fi = ((CompValuSField)rVal).field;
                StringBuilder sb = new StringBuilder ();
                SCRIPTBASECLASS.PrintParam (sb, fi.GetValue (null));
                return sb.ToString ();
            }
            return rVal.ToString ();  // just prints the type
        }

        /**
         * @brief Run current state event handler until it completes or throws an exception
         * @param inst = script instance
         *        inst.stateCode = which state it is in
         *        inst.eventCode = which handler of that event to run
         *        inst.ehArgs    = arguments to pass to the event handler
         * @returns when event handler completes or throws an exception
         */
        public static void RunScriptEventHandler (ref TestInstance inst, MemoryStream serializeStream)
        {
            while (true) {
                try {
                    inst.m_ObjCode.scriptEventHandlerTable[inst.stateCode,(int)inst.eventCode](inst);
                    break;
                } catch (StackCaptureException) {

                    /*
                     * Make sure we were called because CheckRun() threw and 
                     * the code built inst.StackFrames.
                     */
                    if (inst.callMode != XMRInstAbstract.CALLMODE_SAVE) throw;

                    /*
                     * If -serialize, make sure script instance serialization works.
                     */
                    if (serializeStream != null) {

                        /*
                         * Write global variables and stack frames out and discard them.
                         */
                        serializeStream.Position = 0;
                        inst.MigrateOut (new BinaryWriter (serializeStream));
                        long savePos = serializeStream.Position;

                        /*
                         * Read global variables and stack frames back in and reconstruct.
                         */
                        serializeStream.Position = 0;
                        inst = new TestInstance (inst.m_ObjCode);
                        inst.testCheckRun = true;
                        inst.MigrateIn (new BinaryReader (serializeStream));
                        if (savePos != serializeStream.Position) throw new Exception ("save/restore positions different");
                    }

                    /*
                     * Tell code to restore from inst.stackFrames when it is called back.
                     */
                    inst.callMode = XMRInstAbstract.CALLMODE_RESTORE;
                }
            }
        }

        /**
         * @brief Parse out constant for event handler argument value.
         * @param token = points to beginning of constant
         * @returns null: error parsing constant
         *          else: constant value
         *                token = points just past constant
         */
        public static object ParseEHArg (ref Token token)
        {
            /*
             * Simple unary operators.
             */
            if (token is TokenKwSub) {
                token = token.nextToken;
                Token opTok = token;
                object val = ParseEHArg (ref token);
                if (val is int) return -(int)val;
                if (val is SCRIPTFLOAT) return -(SCRIPTFLOAT)val;
                opTok.ErrorMsg ("invalid - operand");
                return null;
            }
            if (token is TokenKwTilde) {
                token = token.nextToken;
                Token opTok = token;
                object val = ParseEHArg (ref token);
                if (val is int) return ~(int)val;
                opTok.ErrorMsg ("invalid ~ operand");
                return null;
            }

            /*
             * Constants.
             */
            if (token is TokenFloat) {
                object v = ((TokenFloat)token).val;
                token = token.nextToken;
                return v;
            }
            if (token is TokenInt) {
                object v = ((TokenInt)token).val;
                token = token.nextToken;
                return v;
            }
            if (token is TokenStr) {
                object v = ((TokenStr)token).val;
                token = token.nextToken;
                return v;
            }

            /*
             * '<'value,...'>', ie, rotation or vector
             */
            if (token is TokenKwCmpLT) {
                List<SCRIPTFLOAT> valist = new List<SCRIPTFLOAT> ();
                Token openBkt = token;
                do {
                    token = token.nextToken;
                    Token valTok = token;
                    object val = ParseEHArg (ref token);
                    if (val == null) return null;
                    if (val is int) val = (SCRIPTFLOAT)(int)val;
                    if (!(val is SCRIPTFLOAT)) {
                        valTok.ErrorMsg ("invalid rotation/vector constant");
                        return null;
                    }
                    valist.Add ((SCRIPTFLOAT)val);
                } while (token is TokenKwComma);
                if (!(token is TokenKwCmpGT)) {
                    token.ErrorMsg ("expecting , or > at end of rotation or vector");
                    return null;
                }
                token = token.nextToken;
                SCRIPTFLOAT[] valarr = valist.ToArray ();
                switch (valarr.Length) {
                    case 3: {
                        return new LSL_Vector (valarr[0], valarr[1], valarr[2]);
                    }
                    case 4: {
                        return new LSL_Rotation (valarr[0], valarr[1], valarr[2], valarr[3]);
                    }
                    default: {
                        openBkt.ErrorMsg ("bad rotation/vector");
                        return null;
                    }
                }
            }

            /*
             * '['value,...']', ie, list
             */
            if (token is TokenKwBrkOpen) {
                List<object> values = new List<object> ();
                do {
                    token = token.nextToken;
                    if ((values.Count == 0) && (token is TokenKwBrkClose)) break;
                    object val = ParseEHArg (ref token);
                    if (val == null) return null;
                    if (val is int)         val = new LSL_Integer ((int)val);
                    if (val is SCRIPTFLOAT) val = new LSL_Float   ((SCRIPTFLOAT)val);
                    if (val is string)      val = new LSL_String  ((string)val);
                    values.Add (val);
                } while (token is TokenKwComma);
                if (!(token is TokenKwBrkClose)) {
                    token.ErrorMsg ("expecting , or ] in list");
                    return null;
                }
                token = token.nextToken;
                return new LSL_List (values.ToArray ());
            }

            /*
             * All we got left is <name>, lookup pre-defined constant.
             */
            if (token is TokenName) {
                FieldInfo fi = typeof (SCRIPTBASECLASS).GetField (((TokenName)token).val);
                if ((fi == null) || !fi.IsPublic || !fi.IsStatic) {
                    token.ErrorMsg ("unknown constant");
                    return null;
                }
                token = token.nextToken;
                object val = fi.GetValue (null);
                if (val is LSL_Float)   val = (SCRIPTFLOAT)((LSL_Float)  val);
                if (val is LSL_Integer) val = (int)        ((LSL_Integer)val);
                if (val is LSL_String)  val = (string)     ((LSL_String) val);
                return val;
            }

            /*
             * Who knows what it is supposed to be?
             */
            token.ErrorMsg ("invalid operand token " + token.ToString ());
            return null;
        }
    }

    public class StackCaptureException : Exception, IXMRUncatchable { }
    public class ScriptResetException  : Exception, IXMRUncatchable { }
    public class ScriptDieException    : Exception, IXMRUncatchable { }

    public class TestInstance : XMRInstAbstract {
        private const int HEAPLIMIT = 50000;
        public bool testCheckRun;

        public TestInstance (ScriptObjCode soc)
        {
            m_ObjCode = soc;
            heapLimit = HEAPLIMIT;
        }

        /*********************\
         *  XMRInstAbstract  *
        \*********************/

        public override void CheckRun (int line)
        {
            if (testCheckRun) {
                switch (this.callMode) {

                    /*
                     * Code was running normally.
                     * Suspend and write stack frames to this.StackFrames.
                     */
                    case CALLMODE_NORMAL: {
                        this.callMode = CALLMODE_SAVE;
                        this.stackFrames = null;
                        throw new StackCaptureException ();
                    }

                    /*
                     * Code just restored itself from this.StackFrames.
                     * Resume where it left off until it calls CheckRun() again.
                     */
                    case CALLMODE_RESTORE: {
                        if (this.stackFrames != null) throw new Exception ("frames left over");
                        this.callMode = CALLMODE_NORMAL;
                        break;
                    }

                    default: throw new Exception ("bad callMode " + this.callMode);
                }
            }
        }

        public override int xmrStackLeft ()
        {
            return 1000000;
        }

        [xmrMethodIsNoisyAttribute]  // calls Stub<somethingorother>
        public override LSL_List xmrEventDequeue (SCRIPTFLOAT timeout, int returnMask1, int returnMask2,
                                                  int backgroundMask1, int backgroundMask2)
        {
            return StubLSLList ("xmrEventDequeue", timeout, returnMask1, returnMask2, backgroundMask1, backgroundMask2);
        }

        [xmrMethodIsNoisyAttribute]  // calls Stub<somethingorother>
        public override void xmrEventEnqueue (LSL_List ev)
        {
            StubVoid ("xmrEventEnqueue", ev);
        }

        [xmrMethodIsNoisyAttribute]  // calls Stub<somethingorother>
        public override LSL_List xmrEventSaveDets ()
        {
            return StubLSLList ("xmrEventSaveDets");
        }

        [xmrMethodIsNoisyAttribute]  // calls Stub<somethingorother>
        public override void xmrEventLoadDets (LSL_List dpList)
        {
            StubVoid ("xmrEventLoadDets", dpList);
        }
    }

    public class SCRIPTBASECLASS : OpenSim.Region.ScriptEngine.Shared.Api.Interfaces.ILSL_Api, OpenSim.Region.ScriptEngine.Shared.Api.Interfaces.IOSSL_Api {

        public void llOwnerSay (string msg)
        {
            Console.WriteLine ("llOwnerSay: " + msg);
        }

        public void llResetScript ()
        {
            throw new ScriptResetException ();
        }

        public void llDie ()
        {
            throw new ScriptDieException ();
        }

        public System.Collections.Hashtable osParseJSON (string json)
        {
            throw new Exception ("not implemented - should be using XMRInstAbstract.osParseJSON()");
        }

        public void state (string newstate)
        {
            string[] stateNames = ((TestInstance)this).m_ObjCode.stateNames;
            for (int i = 0; i < stateNames.Length; i ++) {
                if (stateNames[i] == newstate) {
                    throw new ScriptChangeStateException (i);
                }
            }
            throw new ScriptUndefinedStateException (newstate);
        }

        /*************************\
         *  Copied from OpenSim  *
        \*************************/

        public LSL_Integer llSubStringIndex(string source, string pattern)
        {
            return source.IndexOf(pattern);
        }

        public LSL_String llGetSubString(string src, int start, int end)
        {
            // Normalize indices (if negative).
            // After normlaization they may still be
            // negative, but that is now relative to
            // the start, rather than the end, of the
            // sequence.

            if (start < 0)
            {
                start = src.Length+start;
            }
            if (end < 0)
            {
                end = src.Length+end;
            }

            // Conventional substring
            if (start <= end)
            {
                // Implies both bounds are out-of-range.
                if (end < 0 || start >= src.Length)
                {
                    return String.Empty;
                }
                // If end is positive, then it directly
                // corresponds to the lengt of the substring
                // needed (plus one of course). BUT, it
                // must be within bounds.
                if (end >= src.Length)
                {
                    end = src.Length-1;
                }

                if (start < 0)
                {
                    return src.Substring(0,end+1);
                }
                // Both indices are positive
                return src.Substring(start, (end+1) - start);
            }

            // Inverted substring (end < start)
            else
            {
                // Implies both indices are below the
                // lower bound. In the inverted case, that
                // means the entire string will be returned
                // unchanged.
                if (start < 0)
                {
                    return src;
                }
                // If both indices are greater than the upper
                // bound the result may seem initially counter
                // intuitive.
                if (end >= src.Length)
                {
                    return src;
                }

                if (end < 0)
                {
                    if (start < src.Length)
                    {
                        return src.Substring(start);
                    }
                    else
                    {
                        return String.Empty;
                    }
                }
                else
                {
                    if (start < src.Length)
                    {
                        return src.Substring(0,end+1) + src.Substring(start);
                    }
                    else
                    {
                        return src.Substring(0,end+1);
                    }
                }
            }
        }

        protected static readonly int[] c2itable =
        {
            -1,-1,-1,-1,-1,-1,-1,-1,    // 0x
            -1,-1,-1,-1,-1,-1,-1,-1,
            -1,-1,-1,-1,-1,-1,-1,-1,    // 1x
            -1,-1,-1,-1,-1,-1,-1,-1,
            -1,-1,-1,-1,-1,-1,-1,-1,    // 2x
            -1,-1,-1,63,-1,-1,-1,64,
            53,54,55,56,57,58,59,60,    // 3x
            61,62,-1,-1,-1,0,-1,-1,
            -1,1,2,3,4,5,6,7,           // 4x
            8,9,10,11,12,13,14,15,
            16,17,18,19,20,21,22,23,    // 5x
            24,25,26,-1,-1,-1,-1,-1,
            -1,27,28,29,30,31,32,33,    // 6x
            34,35,36,37,38,39,40,41,
            42,43,44,45,46,47,48,49,    // 7x
            50,51,52,-1,-1,-1,-1,-1,
            -1,-1,-1,-1,-1,-1,-1,-1,    // 8x
            -1,-1,-1,-1,-1,-1,-1,-1,
            -1,-1,-1,-1,-1,-1,-1,-1,    // 9x
            -1,-1,-1,-1,-1,-1,-1,-1,
            -1,-1,-1,-1,-1,-1,-1,-1,    // Ax
            -1,-1,-1,-1,-1,-1,-1,-1,
            -1,-1,-1,-1,-1,-1,-1,-1,    // Bx
            -1,-1,-1,-1,-1,-1,-1,-1,
            -1,-1,-1,-1,-1,-1,-1,-1,    // Cx
            -1,-1,-1,-1,-1,-1,-1,-1,
            -1,-1,-1,-1,-1,-1,-1,-1,    // Dx
            -1,-1,-1,-1,-1,-1,-1,-1,
            -1,-1,-1,-1,-1,-1,-1,-1,    // Ex
            -1,-1,-1,-1,-1,-1,-1,-1,
            -1,-1,-1,-1,-1,-1,-1,-1,    // Fx
            -1,-1,-1,-1,-1,-1,-1,-1
        };
        protected static readonly char[] i2ctable =
        {
            'A','B','C','D','E','F','G','H',
            'I','J','K','L','M','N','O','P',
            'Q','R','S','T','U','V','W','X',
            'Y','Z',
            'a','b','c','d','e','f','g','h',
            'i','j','k','l','m','n','o','p',
            'q','r','s','t','u','v','w','x',
            'y','z',
            '0','1','2','3','4','5','6','7',
            '8','9',
            '+','/'
        };

        public LSL_Float llAcos (double val)
        {
            return (double)Math.Acos(val);
        }
        public LSL_Float llAngleBetween (LSL_Rotation a, LSL_Rotation b)
        {
            double angle = Math.Acos(a.x * b.x + a.y * b.y + a.z * b.z + a.s * b.s) * 2;
            if (angle < 0) angle = -angle;
            if (angle > Math.PI) return (Math.PI * 2 - angle);
            return angle;
        }
        public LSL_Float llAsin (double val)
        {
            return (double)Math.Asin(val);
        }
        public LSL_Float llAtan2 (double x, double y)
        {
            return (double)Math.Atan2(x, y);
        }
        public LSL_Float llCos (double f)
        { 
            return (double)Math.Cos(f);
        }
        public LSL_Float llFabs (double f)
        {
            return (double)Math.Abs(f);
        }
        public LSL_Float llList2Float (LSL_List src, int index)
        {
            if (index < 0)
            {
                index = src.Length + index;
            }
            if (index >= src.Length || index < 0)
            {
                return 0.0;
            }
            try
            {
                if (src.Data[index] is LSL_Integer)
                    return Convert.ToDouble(((LSL_Integer) src.Data[index]).value);
                else if (src.Data[index] is LSL_Float)
                    return Convert.ToDouble(((LSL_Float) src.Data[index]).value);
                else if (src.Data[index] is LSL_String)
                    return Convert.ToDouble(((LSL_String) src.Data[index]).m_string);
                return Convert.ToDouble(src.Data[index]);
            }
            catch (FormatException)
            {
                return 0.0;
            }
        }
        public LSL_Float llListStatistics (int operation, LSL_List src)
        {
            LSL_List nums = LSL_List.ToDoubleList(src);
            switch (operation)
            {
                case LIST_STAT_RANGE:
                    return nums.Range();
                case LIST_STAT_MIN:
                    return nums.Min();
                case LIST_STAT_MAX:
                    return nums.Max();
                case LIST_STAT_MEAN:
                    return nums.Mean();
                case LIST_STAT_MEDIAN:
                    return nums.Median();
                case LIST_STAT_NUM_COUNT:
                    return nums.NumericLength();
                case LIST_STAT_STD_DEV:
                    return nums.StdDev();
                case LIST_STAT_SUM:
                    return nums.Sum();
                case LIST_STAT_SUM_SQUARES:
                    return nums.SumSqrs();
                case LIST_STAT_GEOMETRIC_MEAN:
                    return nums.GeometricMean();
                case LIST_STAT_HARMONIC_MEAN:
                    return nums.HarmonicMean();
                default:
                    return 0.0;
            }
        }
        public LSL_Float llLog10 (double val)
        {
            return (double)Math.Log10(val);
        }
        public LSL_Float llLog (double val)
        {
            return (double)Math.Log(val);
        }
        public LSL_Float llPow (double fbase, double fexponent)
        {
            return (double)Math.Pow(fbase, fexponent);
        }
        public LSL_Float llRot2Angle (LSL_Rotation rot)
        {

            if (rot.s > 1) // normalization needed
            {
                double length = Math.Sqrt(rot.x * rot.x + rot.y * rot.y +
                        rot.z * rot.z + rot.s * rot.s);

                rot.x /= length;
                rot.y /= length;
                rot.z /= length;
                rot.s /= length;
            }

            double angle = 2 * Math.Acos(rot.s);

            return angle;
        }
        public LSL_Float llSin (double f)
        {
            return (double)Math.Sin(f);
        }
        public LSL_Float llSqrt (double f)
        {
            return (double)Math.Sqrt(f);
        }
        public LSL_Float llTan (double f)
        {
            return (double)Math.Tan(f);
        }
        public LSL_Float llVecDist (LSL_Vector a, LSL_Vector b)
        {
            double dx = a.x - b.x;
            double dy = a.y - b.y;
            double dz = a.z - b.z;
            return Math.Sqrt(dx * dx + dy * dy + dz * dz);
        }
        public LSL_Float llVecMag (LSL_Vector v)
        {
            return LSL_Vector.Mag(v);
        }
        public LSL_Integer llAbs (int i)
        {
            // changed to replicate LSL behaviour whereby minimum int value is returned untouched.
            if (i == Int32.MinValue)
                return i;
            else
                return (int)Math.Abs(i);
        }
        public LSL_Integer llBase64ToInteger (string str)
        {
            int number = 0;
            int digit;


            //    Require a well-fromed base64 string

            if (str.Length > 8)
                return 0;

            //    The loop is unrolled in the interests
            //    of performance and simple necessity.
            //
            //    MUST find 6 digits to be well formed
            //      -1 == invalid
            //       0 == padding

            if ((digit = c2itable[str[0]]) <= 0)
            {
                return digit < 0 ? (int)0 : number;
            }
            number += --digit<<26;

            if ((digit = c2itable[str[1]]) <= 0)
            {
                return digit < 0 ? (int)0 : number;
            }
            number += --digit<<20;

            if ((digit = c2itable[str[2]]) <= 0)
            {
                return digit < 0 ? (int)0 : number;
            }
            number += --digit<<14;

            if ((digit = c2itable[str[3]]) <= 0)
            {
                return digit < 0 ? (int)0 : number;
            }
            number += --digit<<8;

            if ((digit = c2itable[str[4]]) <= 0)
            {
                return digit < 0 ? (int)0 : number;
            }
            number += --digit<<2;

            if ((digit = c2itable[str[5]]) <= 0)
            {
                return digit < 0 ? (int)0 : number;
            }
            number += --digit>>4;

            // ignore trailing padding

            return number;
        }
        public LSL_Integer llCeil (double f)
        {
            return (int)Math.Ceiling(f);
        }
        public LSL_Integer llFloor (double f)
        {
            return (int)Math.Floor(f);
        }
        public LSL_Integer llGetListEntryType (LSL_List src, int index)
        {
            if (index < 0)
            {
                index = src.Length + index;
            }
            if (index >= src.Length)
            {
                return 0;
            }

            if (src.Data[index] is LSL_Integer || src.Data[index] is Int32)
                return 1;
            if (src.Data[index] is LSL_Float || src.Data[index] is Single || src.Data[index] is Double)
                return 2;
            if (src.Data[index] is LSL_String || src.Data[index] is String)
            {
                OpenMetaverse.UUID tuuid;
                if (OpenMetaverse.UUID.TryParse(src.Data[index].ToString(), out tuuid))
                {
                    return 4;
                }
                else
                {
                    return 3;
                }
            }
            if (src.Data[index] is LSL_Vector)
                return 5;
            if (src.Data[index] is LSL_Rotation)
                return 6;
            if (src.Data[index] is LSL_List)
                return 7;
            return 0;

        }
        public LSL_Integer llGetListLength (LSL_List src)
        {

            if (src == null)
            {
                return 0;
            }
            else
            {
                return src.Length;
            }
        }
        public LSL_Integer llList2Integer (LSL_List src, int index)
        {
            if (index < 0)
            {
                index = src.Length + index;
            }
            if (index >= src.Length || index < 0)
            {
                return 0;
            }
            try
            {
                if (src.Data[index] is LSL_Integer)
                    return (LSL_Integer) src.Data[index];
                else if (src.Data[index] is LSL_Float)
                    return Convert.ToInt32(((LSL_Float) src.Data[index]).value);
                return new LSL_Integer(src.Data[index].ToString());
            }
            catch (FormatException)
            {
                return 0;
            }
        }
        public LSL_Integer llListFindList (LSL_List src, LSL_List test)
        {

            int index  = -1;
            int length = src.Length - test.Length + 1;


            // If either list is empty, do not match

            if (src.Length != 0 && test.Length != 0)
            {
                for (int i = 0; i < length; i++)
                {
                    if (src.Data[i].Equals(test.Data[0]))
                    {
                        int j;
                        for (j = 1; j < test.Length; j++)
                            if (!src.Data[i+j].Equals(test.Data[j]))
                                break;
                        if (j == test.Length)
                        {
                            index = i;
                            break;
                        }
                    }
                }
            }

            return index;

        }
        public LSL_Integer llModPow (int a, int b, int c)
        {
            Int64 tmp = 0;
            Math.DivRem(Convert.ToInt64(Math.Pow(a, b)), c, out tmp);
            return Convert.ToInt32(tmp);
        }
        public LSL_Integer llRound (double f)
        {
            return (int)Math.Round(f, MidpointRounding.AwayFromZero);
        }
        public LSL_Integer llStringLength (string str)
        {
            if (str.Length > 0)
            {
                return str.Length;
            }
            else
            {
                return 0;
            }
        }
        public LSL_List llCSV2List (string src)
        {

            LSL_List result = new LSL_List();
            int parens = 0;
            int start  = 0;
            int length = 0;


            for (int i = 0; i < src.Length; i++)
            {
                switch (src[i])
                {
                    case '<':
                        parens++;
                        length++;
                        break;
                    case '>':
                        if (parens > 0)
                            parens--;
                        length++;
                        break;
                    case ',':
                        if (parens == 0)
                        {
                            result.Add(new LSL_String(src.Substring(start,length).Trim()));
                            start += length+1;
                            length = 0;
                        }
                        else
                        {
                            length++;
                        }
                        break;
                    default:
                        length++;
                        break;
                }
            }

            result.Add(new LSL_String(src.Substring(start,length).Trim()));

            return result;
        }
        public LSL_List llDeleteSubList (LSL_List src, int start, int end)
        {
            return src.DeleteSublist(start, end);
        }
        public LSL_List llList2List (LSL_List src, int start, int end)
        {
            return src.GetSublist(start, end);
        }
        public LSL_List llList2ListStrided (LSL_List src, int start, int end, int stride)
        {

            LSL_List result = new LSL_List();
            int[] si = new int[2];
            int[] ei = new int[2];
            bool twopass = false;


            //  First step is always to deal with negative indices

            if (start < 0)
                start = src.Length+start;
            if (end   < 0)
                end   = src.Length+end;

            //  Out of bounds indices are OK, just trim them
            //  accordingly

            if (start > src.Length)
                start = src.Length;

            if (end > src.Length)
                end = src.Length;

            if (stride == 0)
                stride = 1;

            //  There may be one or two ranges to be considered

            if (start != end)
            {

                if (start <= end)
                {
                   si[0] = start;
                   ei[0] = end;
                }
                else
                {
                   si[1] = start;
                   ei[1] = src.Length;
                   si[0] = 0;
                   ei[0] = end;
                   twopass = true;
                }

                //  The scan always starts from the beginning of the
                //  source list, but members are only selected if they
                //  fall within the specified sub-range. The specified
                //  range values are inclusive.
                //  A negative stride reverses the direction of the
                //  scan producing an inverted list as a result.

                if (stride > 0)
                {
                    for (int i = 0; i < src.Length; i += stride)
                    {
                        if (i<=ei[0] && i>=si[0])
                            result.Add(src.Data[i]);
                        if (twopass && i>=si[1] && i<=ei[1])
                            result.Add(src.Data[i]);
                    }
                }
                else if (stride < 0)
                {
                    for (int i = src.Length - 1; i >= 0; i += stride)
                    {
                        if (i <= ei[0] && i >= si[0])
                            result.Add(src.Data[i]);
                        if (twopass && i >= si[1] && i <= ei[1])
                            result.Add(src.Data[i]);
                    }
                }
            }
            else
            {
                if (start%stride == 0)
                {
                    result.Add(src.Data[start]);
                }
            }

            return result;
        }
        public LSL_List llListInsertList (LSL_List dest, LSL_List src, int index)
        {

            LSL_List pref = null;
            LSL_List suff = null;


            if (index < 0)
            {
                index = index+dest.Length;
                if (index < 0)
                {
                    index = 0;
                }
            }

            if (index != 0)
            {
                pref = dest.GetSublist(0,index-1);
                if (index < dest.Length)
                {
                    suff = dest.GetSublist(index,-1);
                    return pref + src + suff;
                }
                else
                {
                    return pref + src;
                }
            }
            else
            {
                if (index < dest.Length)
                {
                    suff = dest.GetSublist(index,-1);
                    return src + suff;
                }
                else
                {
                    return src;
                }
            }

        }
        public LSL_List llListReplaceList (LSL_List dest, LSL_List src, int start, int end)
        {
            LSL_List pref = null;


            // Note that although we have normalized, both
            // indices could still be negative.
            if (start < 0)
            {
                start = start+dest.Length;
            }

            if (end < 0)
            {
                end = end+dest.Length;
            }
            // The comventional case, remove a sequence starting with
            // start and ending with end. And then insert the source
            // list.
            if (start <= end)
            {
                // If greater than zero, then there is going to be a
                // surviving prefix. Otherwise the inclusive nature
                // of the indices mean that we're going to add the
                // source list as a prefix.
                if (start > 0)
                {
                    pref = dest.GetSublist(0,start-1);
                    // Only add a suffix if there is something
                    // beyond the end index (it's inclusive too).
                    if (end + 1 < dest.Length)
                    {
                        return pref + src + dest.GetSublist(end + 1, -1);
                    }
                    else
                    {
                        return pref + src;
                    }
                }
                // If start is less than or equal to zero, then
                // the new list is simply a prefix. We still need to
                // figure out any necessary surgery to the destination
                // based upon end. Note that if end exceeds the upper
                // bound in this case, the entire destination list
                // is removed.
                else
                {
                    if (end + 1 < dest.Length)
                    {
                        return src + dest.GetSublist(end + 1, -1);
                    }
                    else
                    {
                        return src;
                    }
                }
            }
            // Finally, if start > end, we strip away a prefix and
            // a suffix, to leave the list that sits <between> ens
            // and start, and then tag on the src list. AT least
            // that's my interpretation. We can get sublist to do
            // this for us. Note that one, or both of the indices
            // might have been negative.
            else
            {
                return dest.GetSublist(end + 1, start - 1) + src;
            }
        }
        public LSL_List llListSort (LSL_List src, int stride, int ascending)
        {

            if (stride <= 0)
            {
                stride = 1;
            }
            return src.Sort(stride, ascending);
        }
        public LSL_List llParseString2List (string src, LSL_List separators, LSL_List spacers)
        {
            return ParseString(src, separators, spacers, false);
        }
        public LSL_List llParseStringKeepNulls (string src, LSL_List separators, LSL_List spacers)
        {
            return ParseString(src, separators, spacers, true);
        }
        public LSL_Rotation llAxes2Rot (LSL_Vector fwd, LSL_Vector left, LSL_Vector up)
        {
            double s;
            double tr = fwd.x + left.y + up.z + 1.0;

            if (tr >= 1.0)
            {
                s = 0.5 / Math.Sqrt(tr);
                return new LSL_Rotation(
                        (left.z - up.y) * s,
                        (up.x - fwd.z) * s,
                        (fwd.y - left.x) * s,
                        0.25 / s);
            }
            else
            {
                double max = (left.y > up.z) ? left.y : up.z;

                if (max < fwd.x)
                {
                    s = Math.Sqrt(fwd.x - (left.y + up.z) + 1.0);
                    double x = s * 0.5;
                    s = 0.5 / s;
                    return new LSL_Rotation(
                            x,
                            (fwd.y + left.x) * s,
                            (up.x + fwd.z) * s,
                            (left.z - up.y) * s);
                }
                else if (max == left.y)
                {
                    s = Math.Sqrt(left.y - (up.z + fwd.x) + 1.0);
                    double y = s * 0.5;
                    s = 0.5 / s;
                    return new LSL_Rotation(
                            (fwd.y + left.x) * s,
                            y,
                            (left.z + up.y) * s,
                            (up.x - fwd.z) * s);
                }
                else
                {
                    s = Math.Sqrt(up.z - (fwd.x + left.y) + 1.0);
                    double z = s * 0.5;
                    s = 0.5 / s;
                    return new LSL_Rotation(
                            (up.x + fwd.z) * s,
                            (left.z + up.y) * s,
                            z,
                            (fwd.y - left.x) * s);
                }
            }
        }
        public LSL_Rotation llAxisAngle2Rot (LSL_Vector axis, double angle)
        {

            double x, y, z, s, t;

            s = Math.Cos(angle * 0.5);
            t = Math.Sin(angle * 0.5); // temp value to avoid 2 more sin() calcs
            x = axis.x * t;
            y = axis.y * t;
            z = axis.z * t;

            return new LSL_Rotation(x,y,z,s);
        }
        public LSL_Rotation llEuler2Rot (LSL_Vector v)
        {

            double x,y,z,s;

            double c1 = Math.Cos(v.x * 0.5);
            double c2 = Math.Cos(v.y * 0.5);
            double c3 = Math.Cos(v.z * 0.5);
            double s1 = Math.Sin(v.x * 0.5);
            double s2 = Math.Sin(v.y * 0.5);
            double s3 = Math.Sin(v.z * 0.5);

            x = s1 * c2 * c3 + c1 * s2 * s3;
            y = c1 * s2 * c3 - s1 * c2 * s3;
            z = s1 * s2 * c3 + c1 * c2 * s3;
            s = c1 * c2 * c3 - s1 * s2 * s3;

            return new LSL_Rotation(x, y, z, s);
        }
        public LSL_Rotation llList2Rot (LSL_List src, int index)
        {
            if (index < 0)
            {
                index = src.Length + index;
            }
            if (index >= src.Length || index < 0)
            {
                return new LSL_Rotation(0, 0, 0, 1);
            }
            if (src.Data[index].GetType() == typeof(LSL_Rotation))
            {
                return (LSL_Rotation)src.Data[index];
            }
            else
            {
                return new LSL_Rotation(src.Data[index].ToString());
            }
        }
        public LSL_Rotation llRotBetween (LSL_Vector a, LSL_Vector b)
        {
            //A and B should both be normalized
            LSL_Rotation rotBetween;
            // Check for zero vectors. If either is zero, return zero rotation. Otherwise,
            // continue calculation.
            if (a == new LSL_Vector(0.0f, 0.0f, 0.0f) || b == new LSL_Vector(0.0f, 0.0f, 0.0f))
            {
                rotBetween = new LSL_Rotation(0.0f, 0.0f, 0.0f, 1.0f);
            }
            else
            {
                a = LSL_Vector.Norm(a);
                b = LSL_Vector.Norm(b);
                double dotProduct = LSL_Vector.Dot(a, b);
                // There are two degenerate cases possible. These are for vectors 180 or
                // 0 degrees apart. These have to be detected and handled individually.
                //
                // Check for vectors 180 degrees apart.
                // A dot product of -1 would mean the angle between vectors is 180 degrees.
                if (dotProduct < -0.9999999f)
                {
                    // First assume X axis is orthogonal to the vectors.
                    LSL_Vector orthoVector = new LSL_Vector(1.0f, 0.0f, 0.0f);
                    orthoVector = orthoVector - a * (a.x / LSL_Vector.Dot(a, a));
                    // Check for near zero vector. A very small non-zero number here will create
                    // a rotation in an undesired direction.
                    if (LSL_Vector.Mag(orthoVector) > 0.0001)
                    {
                        rotBetween = new LSL_Rotation(orthoVector.x, orthoVector.y, orthoVector.z, 0.0f);
                    }
                    // If the magnitude of the vector was near zero, then assume the X axis is not
                    // orthogonal and use the Z axis instead.
                    else
                    {
                        // Set 180 z rotation.
                        rotBetween = new LSL_Rotation(0.0f, 0.0f, 1.0f, 0.0f);
                    }
                }
                // Check for parallel vectors.
                // A dot product of 1 would mean the angle between vectors is 0 degrees.
                else if (dotProduct > 0.9999999f)
                {
                    // Set zero rotation.
                    rotBetween = new LSL_Rotation(0.0f, 0.0f, 0.0f, 1.0f);
                }
                else
                {
                    // All special checks have been performed so get the axis of rotation.
                    LSL_Vector crossProduct = LSL_Vector.Cross(a, b);
                    // Quarternion s value is the length of the unit vector + dot product.
                    double qs = 1.0 + dotProduct;
                    rotBetween = new LSL_Rotation(crossProduct.x, crossProduct.y, crossProduct.z, qs);
                    // Normalize the rotation.
                    double mag = LSL_Rotation.Mag(rotBetween);
                    // We shouldn't have to worry about a divide by zero here. The qs value will be
                    // non-zero because we already know if we're here, then the dotProduct is not -1 so
                    // qs will not be zero. Also, we've already handled the input vectors being zero so the
                    // crossProduct vector should also not be zero.
                    rotBetween.x = rotBetween.x / mag;
                    rotBetween.y = rotBetween.y / mag;
                    rotBetween.z = rotBetween.z / mag;
                    rotBetween.s = rotBetween.s / mag;
                    // Check for undefined values and set zero rotation if any found. This code might not actually be required
                    // any longer since zero vectors are checked for at the top.
                    if (Double.IsNaN(rotBetween.x) || Double.IsNaN(rotBetween.y) || Double.IsNaN(rotBetween.z) || Double.IsNaN(rotBetween.s))
                    {
                        rotBetween = new LSL_Rotation(0.0f, 0.0f, 0.0f, 1.0f);
                    }
                }
            }
            return rotBetween;
        }
        public LSL_String llBase64ToString (string str)
        {
            try
            {
                return Util.Base64ToString(str);
            }
            catch (Exception e)
            {
                throw new Exception("Error in base64Decode" + e.Message);
            }
        }
        public LSL_String llDeleteSubString (string src, int start, int end)
        {

            // Normalize indices (if negative).
            // After normlaization they may still be
            // negative, but that is now relative to
            // the start, rather than the end, of the
            // sequence.
            if (start < 0)
            {
                start = src.Length+start;
            }
            if (end < 0)
            {
                end = src.Length+end;
            }
            // Conventionally delimited substring
            if (start <= end)
            {
                // If both bounds are outside of the existing
                // string, then return unchanges.
                if (end < 0 || start >= src.Length)
                {
                    return src;
                }
                // At least one bound is in-range, so we
                // need to clip the out-of-bound argument.
                if (start < 0)
                {
                    start = 0;
                }

                if (end >= src.Length)
                {
                    end = src.Length-1;
                }

                return src.Remove(start,end-start+1);
            }
            // Inverted substring
            else
            {
                // In this case, out of bounds means that
                // the existing string is part of the cut.
                if (start < 0 || end >= src.Length)
                {
                    return String.Empty;
                }

                if (end > 0)
                {
                    if (start < src.Length)
                    {
                        return src.Remove(start).Remove(0,end+1);
                    }
                    else
                    {
                        return src.Remove(0,end+1);
                    }
                }
                else
                {
                    if (start < src.Length)
                    {
                        return src.Remove(start);
                    }
                    else
                    {
                        return src;
                    }
                }
            }
        }
        public LSL_String llDumpList2String (LSL_List src, string seperator)
        {
            if (src.Length == 0)
            {
                return String.Empty;
            }
            string ret = String.Empty;
            foreach (object o in src.Data)
            {
                ret = ret + o.ToString() + seperator;
            }
            ret = ret.Substring(0, ret.Length - seperator.Length);
            return ret;
        }
        public LSL_String llEscapeURL (string url)
        {
            try
            {
                return Uri.EscapeDataString(url);
            }
            catch (Exception ex)
            {
                return "llEscapeURL: " + ex.ToString();
            }
        }
        public LSL_String llInsertString (string dest, int index, string src)
        {

            // Normalize indices (if negative).
            // After normlaization they may still be
            // negative, but that is now relative to
            // the start, rather than the end, of the
            // sequence.
            if (index < 0)
            {
                index = dest.Length+index;

                // Negative now means it is less than the lower
                // bound of the string.

                if (index < 0)
                {
                    return src+dest;
                }

            }

            if (index >= dest.Length)
            {
                return dest+src;
            }

            // The index is in bounds.
            // In this case the index refers to the index that will
            // be assigned to the first character of the inserted string.
            // So unlike the other string operations, we do not add one
            // to get the correct string length.
            return dest.Substring(0,index)+src+dest.Substring(index);

        }
        public LSL_String llIntegerToBase64 (int number)
        {
            // uninitialized string

            char[] imdt = new char[8];


            // Manually unroll the loop

            imdt[7] = '=';
            imdt[6] = '=';
            imdt[5] = i2ctable[number<<4  & 0x3F];
            imdt[4] = i2ctable[number>>2  & 0x3F];
            imdt[3] = i2ctable[number>>8  & 0x3F];
            imdt[2] = i2ctable[number>>14 & 0x3F];
            imdt[1] = i2ctable[number>>20 & 0x3F];
            imdt[0] = i2ctable[number>>26 & 0x3F];

            return new string(imdt);
        }
        public LSL_String llList2CSV (LSL_List src)
        {

            string ret = String.Empty;
            int    x   = 0;


            if (src.Data.Length > 0)
            {
                ret = src.Data[x++].ToString();
                for (; x < src.Data.Length; x++)
                {
                    ret += ", "+src.Data[x].ToString();
                }
            }

            return ret;
        }
        public LSL_String llList2Key (LSL_List src, int index)
        {
            if (index < 0)
            {
                index = src.Length + index;
            }
            if (index >= src.Length || index < 0)
            {
                return "";
            }
            return src.Data[index].ToString();
        }
        public LSL_String llList2String (LSL_List src, int index)
        {
            if (index < 0)
            {
                index = src.Length + index;
            }
            if (index >= src.Length || index < 0)
            {
                return String.Empty;
            }
            return src.Data[index].ToString();
        }
        public LSL_String llMD5String (string src, int nonce)
        {
            return Util.Md5Hash(String.Format("{0}:{1}", src, nonce.ToString()));
        }
        public LSL_String llSHA1String (string src)
        {
            return Util.SHA1Hash(src).ToLower();
        }
        public LSL_String llStringToBase64 (string str)
        {
            try
            {
                byte[] encData_byte = new byte[str.Length];
                encData_byte = Util.UTF8.GetBytes(str);
                string encodedData = Convert.ToBase64String(encData_byte);
                return encodedData;
            }
            catch (Exception e)
            {
                throw new Exception("Error in base64Encode" + e.Message);
            }
        }
        public LSL_String llStringTrim (string src, int type)
        {
            if (type == (int)STRING_TRIM_HEAD) { return src.TrimStart(); }
            if (type == (int)STRING_TRIM_TAIL) { return src.TrimEnd(); }
            if (type == (int)STRING_TRIM) { return src.Trim(); }
            return src;
        }
        public LSL_String llToLower (string src)
        {
            return src.ToLower();
        }
        public LSL_String llToUpper (string src)
        {
            return src.ToUpper();
        }
        public LSL_String llUnescapeURL (string url)
        {
            try
            {
                return Uri.UnescapeDataString(url);
            }
            catch (Exception ex)
            {
                return "llUnescapeURL: " + ex.ToString();
            }
        }
        public LSL_String llXorBase64StringsCorrect (string str1, string str2)
        {
            string ret = String.Empty;
            string src1 = llBase64ToString(str1);
            string src2 = llBase64ToString(str2);
            int c = 0;
            for (int i = 0; i < src1.Length; i++)
            {
                ret += (char) (src1[i] ^ src2[c]);

                c++;
                if (c >= src2.Length)
                    c = 0;
            }
            return llStringToBase64(ret);
        }
        public LSL_Vector llList2Vector (LSL_List src, int index)
        {
            if (index < 0)
            {
                index = src.Length + index;
            }
            if (index >= src.Length || index < 0)
            {
                return new LSL_Vector(0, 0, 0);
            }
            if (src.Data[index].GetType() == typeof(LSL_Vector))
            {
                return (LSL_Vector)src.Data[index];
            }
            else
            {
                return new LSL_Vector(src.Data[index].ToString());
            }
        }
        public LSL_Vector llRot2Axis (LSL_Rotation rot)
        {
            double x,y,z;

            if (rot.s > 1) // normalization needed
            {
                double length = Math.Sqrt(rot.x * rot.x + rot.y * rot.y +
                        rot.z * rot.z + rot.s * rot.s);

                rot.x /= length;
                rot.y /= length;
                rot.z /= length;
                rot.s /= length;

            }

            // double angle = 2 * Math.Acos(rot.s);
            double s = Math.Sqrt(1 - rot.s * rot.s);
            if (s < 0.001)
            {
                x = 1;
                y = z = 0;
            }
            else
            {
                x = rot.x / s; // normalise axis
                y = rot.y / s;
                z = rot.z / s;
            }

            return new LSL_Vector(x,y,z);
        }
        public LSL_Vector llRot2Euler (LSL_Rotation r)
        {
            //This implementation is from http://lslwiki.net/lslwiki/wakka.php?wakka=LibraryRotationFunctions. ckrinke
            LSL_Rotation t = new LSL_Rotation(r.x * r.x, r.y * r.y, r.z * r.z, r.s * r.s);
            double m = (t.x + t.y + t.z + t.s);
            if (m == 0) return new LSL_Vector();
            double n = 2 * (r.y * r.s + r.x * r.z);
            double p = m * m - n * n;
            if (p > 0)
                return new LSL_Vector(Math.Atan2(2.0 * (r.x * r.s - r.y * r.z), (-t.x - t.y + t.z + t.s)),
                                             Math.Atan2(n, Math.Sqrt(p)),
                                             Math.Atan2(2.0 * (r.z * r.s - r.x * r.y), (t.x - t.y - t.z + t.s)));
            else if (n > 0)
                return new LSL_Vector(0.0, Math.PI * 0.5, Math.Atan2((r.z * r.s + r.x * r.y), 0.5 - t.x - t.z));
            else
                return new LSL_Vector(0.0, -Math.PI * 0.5, Math.Atan2((r.z * r.s + r.x * r.y), 0.5 - t.x - t.z));
        }
        public LSL_Vector llRot2Fwd (LSL_Rotation r)
        {

            double x, y, z, m;

            m = r.x * r.x + r.y * r.y + r.z * r.z + r.s * r.s;
            // m is always greater than zero
            // if m is not equal to 1 then Rotation needs to be normalized
            if (Math.Abs(1.0 - m) > 0.000001) // allow a little slop here for calculation precision
            {
                m = 1.0 / Math.Sqrt(m);
                r.x *= m;
                r.y *= m;
                r.z *= m;
                r.s *= m;
            }

            // Fast Algebric Calculations instead of Vectors & Quaternions Product
            x = r.x * r.x - r.y * r.y - r.z * r.z + r.s * r.s;
            y = 2 * (r.x * r.y + r.z * r.s);
            z = 2 * (r.x * r.z - r.y * r.s);
            return (new LSL_Vector(x, y, z));
        }
        public LSL_Vector llRot2Left (LSL_Rotation r)
        {

            double x, y, z, m;

            m = r.x * r.x + r.y * r.y + r.z * r.z + r.s * r.s;
            // m is always greater than zero
            // if m is not equal to 1 then Rotation needs to be normalized
            if (Math.Abs(1.0 - m) > 0.000001) // allow a little slop here for calculation precision
            {
                m = 1.0 / Math.Sqrt(m);
                r.x *= m;
                r.y *= m;
                r.z *= m;
                r.s *= m;
            }

            // Fast Algebric Calculations instead of Vectors & Quaternions Product
            x = 2 * (r.x * r.y - r.z * r.s);
            y = -r.x * r.x + r.y * r.y - r.z * r.z + r.s * r.s;
            z = 2 * (r.x * r.s + r.y * r.z);
            return (new LSL_Vector(x, y, z));
        }
        public LSL_Vector llRot2Up (LSL_Rotation r)
        {
            double x, y, z, m;

            m = r.x * r.x + r.y * r.y + r.z * r.z + r.s * r.s;
            // m is always greater than zero
            // if m is not equal to 1 then Rotation needs to be normalized
            if (Math.Abs(1.0 - m) > 0.000001) // allow a little slop here for calculation precision
            {
                m = 1.0 / Math.Sqrt(m);
                r.x *= m;
                r.y *= m;
                r.z *= m;
                r.s *= m;
            }

            // Fast Algebric Calculations instead of Vectors & Quaternions Product
            x = 2 * (r.x * r.z + r.y * r.s);
            y = 2 * (-r.x * r.s + r.y * r.z);
            z = -r.x * r.x - r.y * r.y + r.z * r.z + r.s * r.s;
            return (new LSL_Vector(x, y, z));
        }
        public LSL_Vector llVecNorm (LSL_Vector v)
        {
            return LSL_Vector.Norm(v);
        }


        private LSL_List ParseString(string src, LSL_List separators, LSL_List spacers, bool keepNulls)
        {
            int         beginning = 0;
            int         srclen    = src.Length;
            int         seplen    = separators.Length;
            object[]    separray  = separators.Data;
            int         spclen    = spacers.Length;
            object[]    spcarray  = spacers.Data;
            int         mlen      = seplen+spclen;

            int[]       offset    = new int[mlen+1];
            bool[]      active    = new bool[mlen];

            int         best;
            int         j;

            //    Initial capacity reduces resize cost

            LSL_List tokens = new LSL_List();

            //    All entries are initially valid

            for (int i = 0; i < mlen; i++)
                active[i] = true;

            offset[mlen] = srclen;

            while (beginning < srclen)
            {

                best = mlen;    // as bad as it gets

                //    Scan for separators

                for (j = 0; j < seplen; j++)
                {
                    if (separray[j].ToString() == String.Empty)
                        active[j] = false;

                    if (active[j])
                    {
                        // scan all of the markers
                        if ((offset[j] = src.IndexOf(separray[j].ToString(), beginning)) == -1)
                        {
                            // not present at all
                            active[j] = false;
                        }
                        else
                        {
                            // present and correct
                            if (offset[j] < offset[best])
                            {
                                // closest so far
                                best = j;
                                if (offset[best] == beginning)
                                    break;
                            }
                        }
                    }
                }

                //    Scan for spacers

                if (offset[best] != beginning)
                {
                    for (j = seplen; (j < mlen) && (offset[best] > beginning); j++)
                    {
                        if (spcarray[j-seplen].ToString() == String.Empty)
                            active[j] = false;

                        if (active[j])
                        {
                            // scan all of the markers
                            if ((offset[j] = src.IndexOf(spcarray[j-seplen].ToString(), beginning)) == -1)
                            {
                                // not present at all
                                active[j] = false;
                            }
                            else
                            {
                                // present and correct
                                if (offset[j] < offset[best])
                                {
                                    // closest so far
                                    best = j;
                                }
                            }
                        }
                    }
                }

                //    This is the normal exit from the scanning loop

                if (best == mlen)
                {
                    // no markers were found on this pass
                    // so we're pretty much done
                    if ((keepNulls) || ((!keepNulls) && (srclen - beginning) > 0))
                        tokens.Add(new LSL_String(src.Substring(beginning, srclen - beginning)));
                    break;
                }

                //    Otherwise we just add the newly delimited token
                //    and recalculate where the search should continue.
                if ((keepNulls) || ((!keepNulls) && (offset[best] - beginning) > 0))
                    tokens.Add(new LSL_String(src.Substring(beginning,offset[best]-beginning)));

                if (best < seplen)
                {
                    beginning = offset[best] + (separray[best].ToString()).Length;
                }
                else
                {
                    beginning = offset[best] + (spcarray[best - seplen].ToString()).Length;
                    string str = spcarray[best - seplen].ToString();
                    if ((keepNulls) || ((!keepNulls) && (str.Length > 0)))
                        tokens.Add(new LSL_String(str));
                }
            }

            //    This an awkward an not very intuitive boundary case. If the
            //    last substring is a tokenizer, then there is an implied trailing
            //    null list entry. Hopefully the single comparison will not be too
            //    arduous. Alternatively the 'break' could be replced with a return
            //    but that's shabby programming.

            if ((beginning == srclen) && (keepNulls))
            {
                if (srclen != 0)
                    tokens.Add(new LSL_String(""));
            }

            return tokens;
        }

        ////////////////////////////

        public string osMovePen(string drawList, int x, int y)
        {
            drawList += "MoveTo " + x + "," + y + ";";
            return drawList;
        }

        public string osDrawLine(string drawList, int startX, int startY, int endX, int endY)
        {
            drawList += "MoveTo "+ startX+","+ startY +"; LineTo "+endX +","+endY +"; ";
            return drawList;
        }

        public string osDrawLine(string drawList, int endX, int endY)
        {
            drawList += "LineTo " + endX + "," + endY + "; ";
            return drawList;
        }

        public string osDrawText(string drawList, string text)
        {
            drawList += "Text " + text + "; ";
            return drawList;
        }

        public string osDrawEllipse(string drawList, int width, int height)
        {
            drawList += "Ellipse " + width + "," + height + "; ";
            return drawList;
        }

        public string osDrawRectangle(string drawList, int width, int height)
        {
            drawList += "Rectangle " + width + "," + height + "; ";
            return drawList;
        }

        public string osDrawFilledRectangle(string drawList, int width, int height)
        {
            drawList += "FillRectangle " + width + "," + height + "; ";
            return drawList;
        }

        public string osDrawFilledPolygon(string drawList, LSL_List x, LSL_List y)
        {
            if (x.Length != y.Length || x.Length < 3)
            {
                return "";
            }
            drawList += "FillPolygon " + x.GetLSLStringItem(0) + "," + y.GetLSLStringItem(0);
            for (int i = 1; i < x.Length; i++)
            {
                drawList += "," + x.GetLSLStringItem(i) + "," + y.GetLSLStringItem(i);
            }
            drawList += "; ";
            return drawList;
        }

        public string osDrawPolygon(string drawList, LSL_List x, LSL_List y)
        {
            if (x.Length != y.Length || x.Length < 3)
            {
                return "";
            }
            drawList += "Polygon " + x.GetLSLStringItem(0) + "," + y.GetLSLStringItem(0);
            for (int i = 1; i < x.Length; i++)
            {
                drawList += "," + x.GetLSLStringItem(i) + "," + y.GetLSLStringItem(i);
            }
            drawList += "; ";
            return drawList;
        }

        public string osSetFontSize(string drawList, int fontSize)
        {
            drawList += "FontSize "+ fontSize +"; ";
            return drawList;
        }

        public string osSetFontName(string drawList, string fontName)
        {
            drawList += "FontName "+ fontName +"; ";
            return drawList;
        }

        public string osSetPenSize(string drawList, int penSize)
        {
            drawList += "PenSize " + penSize + "; ";
            return drawList;
        }

        public string osSetPenColor(string drawList, string color)
        {
            drawList += "PenColor " + color + "; ";
            return drawList;
        }

        // Deprecated
        public string osSetPenColour(string drawList, string colour)
        {
            drawList += "PenColour " + colour + "; ";
            return drawList;
        }

        public string osSetPenCap(string drawList, string direction, string type)
        {
            drawList += "PenCap " + direction + "," + type + "; ";
            return drawList;
        }

        public string osDrawImage(string drawList, int width, int height, string imageUrl)
        {
            drawList +="Image " +width + "," + height+ ","+ imageUrl +"; " ;
            return drawList;
        }

        public double osList2Double(LSL_List src, int index)
        {
            // There is really no double type in OSSL. C# and other
            // have one, but the current implementation of LSL_Types.list
            // is not allowed to contain any.
            // This really should be removed.
            //
            if (index < 0)
            {
                index = src.Length + index;
            }
            if (index >= src.Length)
            {
                return 0.0;
            }
            return Convert.ToDouble(src.Data[index]);
        }

        public LSL_String osFormatString(string str, LSL_List strings)
        {
            return String.Format(str, strings.Data);
        }

        public LSL_List osMatchString(string src, string pattern, int start)
        {
            LSL_List result = new LSL_List();

            // Normalize indices (if negative).
            // After normlaization they may still be
            // negative, but that is now relative to
            // the start, rather than the end, of the
            // sequence.
            if (start < 0)
            {
                start = src.Length + start;
            }

            if (start < 0 || start >= src.Length)
            {
                return result;  // empty list
            }

            // Find matches beginning at start position
            System.Text.RegularExpressions.Regex matcher = new System.Text.RegularExpressions.Regex(pattern);
            System.Text.RegularExpressions.Match match = matcher.Match(src, start);
            while (match.Success)
            {
                foreach (System.Text.RegularExpressions.Group g in match.Groups)
                {
                    if (g.Success)
                    {
                        result.Add(new LSL_String(g.Value));
                        result.Add(new LSL_Integer(g.Index));
                    }
                }

                match = match.NextMatch();
            }

            return result;
        }

        public LSL_String osUnixTimeToTimestamp(long time)
        {
            long baseTicks = 621355968000000000;
            long tickResolution = 10000000;
            long epochTicks = (time * tickResolution) + baseTicks;
            DateTime date = new DateTime(epochTicks);

            return date.ToString("yyyy-MM-ddTHH:mm:ss.fffffffZ");
        }

        /**************************\
         *  The rest of ILSL_Api  *
        \**************************/

#include "makexmrengtestilslapi.inc"

        /**
         * @brief Called by the various ILSL_Api functions to print their parameters
         *        and if non-void return value, read return value from stdin.
         */

        protected static void StubVoid (string name, params object[] parms)
        {
            PrintParms (name, parms);
        }
        protected static LSL_Float StubLSLFloat (string name, params object[] parms)
        {
            PrintParms (name, parms);
            object val = ReadRetVal (name);
            if (val is int) val = (SCRIPTFLOAT)(int)val;
            return new LSL_Float ((SCRIPTFLOAT)val);
        }
        protected static LSL_Integer StubLSLInteger (string name, params object[] parms)
        {
            PrintParms (name, parms);
            return new LSL_Integer ((int)ReadRetVal (name));
        }
        protected static LSL_List StubLSLList (string name, params object[] parms)
        {
            PrintParms (name, parms);
            return (LSL_List)ReadRetVal (name);
        }
        protected static LSL_Rotation StubLSLRotation (string name, params object[] parms)
        {
            PrintParms (name, parms);
            return (LSL_Rotation)ReadRetVal (name);
        }
        protected static LSL_String StubLSLString (string name, params object[] parms)
        {
            PrintParms (name, parms);
            return new LSL_String ((string)ReadRetVal (name));
        }
        protected static LSL_Vector StubLSLVector (string name, params object[] parms)
        {
            PrintParms (name, parms);
            return (LSL_Vector)ReadRetVal (name);
        }
        protected static bool StubSysBoolean (string name, params object[] parms)
        {
            PrintParms (name, parms);
            return (int)ReadRetVal (name) != 0;
        }
        protected static double StubSysDouble (string name, params object[] parms)
        {
            PrintParms (name, parms);
            object val = ReadRetVal (name);
            if (val is int) val = (SCRIPTFLOAT)(int)val;
            return (double)(SCRIPTFLOAT)val;
        }
        protected static int StubSysInteger (string name, params object[] parms)
        {
            PrintParms (name, parms);
            return (int)ReadRetVal (name);
        }
        protected static string StubSysString (string name, params object[] parms)
        {
            PrintParms (name, parms);
            return (string)ReadRetVal (name);
        }

        /**
         * @brief Print api function and parameter values.
         */
        private static void PrintParms (string name, object[] parms)
        {
            StringBuilder sb = new StringBuilder ();
            sb.Append (name);
            sb.Append ('(');
            for (int i = 0; i < parms.Length; i ++) {
                object p = parms[i];
                if (i > 0) sb.Append (", ");
                PrintParam (sb, p);
            }
            sb.Append (')');
            Console.WriteLine (sb.ToString ());
        }
        public static void PrintParam (StringBuilder sb, object p)
        {
            if (p == null) {
                sb.Append ("null");
            } else if (p is LSL_List) {
                sb.Append ('[');
                object[] d = ((LSL_List)p).Data;
                for (int i = 0; i < d.Length; i ++) {
                    if (i > 0) sb.Append (',');
                    PrintParam (sb, d[i]);
                }
                sb.Append (']');
            } else if (p is LSL_Rotation) {
                LSL_Rotation r = (LSL_Rotation)p;
                sb.Append ('<');
                sb.Append (r.x);
                sb.Append (',');
                sb.Append (r.y);
                sb.Append (',');
                sb.Append (r.z);
                sb.Append (',');
                sb.Append (r.s);
                sb.Append ('>');
            } else if (p is LSL_String) {
                PrintParamString (sb, (string)(LSL_String)p);
            } else if (p is LSL_Vector) {
                LSL_Vector v = (LSL_Vector)p;
                sb.Append ('<');
                sb.Append (v.x);
                sb.Append (',');
                sb.Append (v.y);
                sb.Append (',');
                sb.Append (v.z);
                sb.Append ('>');
            } else if (p is string) {
                PrintParamString (sb, (string)p);
            } else {
                sb.Append (p.ToString ());
            }
        }
        private static void PrintParamString (StringBuilder sb, string p)
        {
            sb.Append ('"');
            foreach (char c in p) {
                if (c == '\n') {
                    sb.Append ("\\n");
                    continue;
                }
                if (c == '"') {
                    sb.Append ("\\\"");
                    continue;
                }
                if (c == '\\') {
                    sb.Append ("\\\\");
                    continue;
                }
                sb.Append (c);
            }
            sb.Append ('"');
        }

        /**
         * @brief Read return value from stdin.
         *        Must be in form <funcname>:<value>
         * @param name = name of function that the return value is for
         * @returns value read from stdin
         */
        private static object ReadRetVal (string name)
        {
            string line = Console.ReadLine ();
            if (line == null) throw new Exception ("end of input");
            ++ XMREngTest.consoleLine;
            Console.WriteLine (line);

            /*
             * Parse into tokens.
             */
            string sourceHash;
            line = "# " + XMREngTest.consoleLine + " \"console events\"\n" + line;
            TokenBegin tokenBegin = TokenBegin.Construct ("console events", null, XMREngTest.StandAloneErrorMessage, line, out sourceHash);
            if (tokenBegin == null) throw new Exception ("parse error");
            Token t = tokenBegin.nextToken;

            /*
             * Get function name and validate.
             */
            if (!(t is TokenName) || !(t.nextToken is TokenKwColon)) {
                throw new Exception ("expecting function name :");
            }
            if (((TokenName)t).val != name) {
                throw new Exception ("expecting function " + name);
            }
            t = t.nextToken.nextToken;

            /*
             * Parse out the value.
             */
            object val = XMREngTest.ParseEHArg (ref t);
            if (val == null) throw new Exception ("value parse error");
            if (!(t is TokenEnd)) {
                throw new Exception ("extra stuff at end of line " + t.ToString ());
            }
            return val;
        }
    }

    /*************************\
     *  Copied from OpenSim  *
    \*************************/

    public class Util {
        public static Encoding UTF8 = Encoding.UTF8;

        public static string Base64ToString(string str)
        {
            UTF8Encoding encoder = new UTF8Encoding();
            Decoder utf8Decode = encoder.GetDecoder();

            byte[] todecode_byte = Convert.FromBase64String(str);
            int charCount = utf8Decode.GetCharCount(todecode_byte, 0, todecode_byte.Length);
            char[] decoded_char = new char[charCount];
            utf8Decode.GetChars(todecode_byte, 0, todecode_byte.Length, decoded_char, 0);
            string result = new String(decoded_char);
            return result;
        }

        public static string Md5Hash(string data)
        {
            byte[] dataMd5 = ComputeMD5Hash(data);
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < dataMd5.Length; i++)
                sb.AppendFormat("{0:x2}", dataMd5[i]);
            return sb.ToString();
        }
        private static byte[] ComputeMD5Hash(string data)
        {
            System.Security.Cryptography.MD5 md5 = System.Security.Cryptography.MD5.Create();
            return md5.ComputeHash(Encoding.Default.GetBytes(data));
        }

        public static string SHA1Hash(string data)
        {
            return SHA1Hash(Encoding.Default.GetBytes(data));
        }
        public static string SHA1Hash(byte[] data)
        {
            byte[] hash = ComputeSHA1Hash(data);
            return BitConverter.ToString(hash).Replace("-", String.Empty);
        }
        private static byte[] ComputeSHA1Hash(byte[] src)
        {
            System.Security.Cryptography.SHA1CryptoServiceProvider SHA1 = 
                    new System.Security.Cryptography.SHA1CryptoServiceProvider();
            return SHA1.ComputeHash(src);
        }
    }
}
