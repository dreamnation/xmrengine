/********************************************************\
 *  COPYRIGHT 2012, Mike Rieker, Beverly, MA, USA       *
 *  All rights reserved.                                *
\********************************************************/

/**
 * @brief Main program for the script compiler.
 */

using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection.Emit;
using System.Text;

#include "lsltypes.h"

namespace OpenSim.Region.ScriptEngine.XMREngine
{

    public class XMREngTest
    {
        public static int consoleLine = 0;

        /**
         * @brief Stand-alone test program.
         *
         * mono xmrengtest.exe <xmrobjfile> -checkrun -serialize -obj <xmrobjoutput> -asm <xmrasmoutput> <sourcefile>
         */
        public static void Main (string[] args)
        {
            bool doCheckRun = false;
            bool eventIO    = false;
            bool serialize  = false;
            string asmFileName = null;
            string objFileName = null;
            string savFileName = null;
            string srcFileName = null;
            string sourceHash  = null;

            for (int i = 0; i < args.Length; i ++) {
                string arg = args[i];
                if (arg == "-asm") {
                    if (++ i >= args.Length) goto usage;
                    asmFileName = args[i];
                    continue;
                }
                if (arg == "-checkrun") {
                    doCheckRun = true;
                    continue;
                }
                if (arg == "-eventio") {
                    eventIO = true;
                    continue;
                }
                if (arg == "-obj") {
                    if (++ i >= args.Length) goto usage;
                    objFileName = args[i];
                    continue;
                }
                if (arg == "-save") {
                    if (++ i >= args.Length) goto usage;
                    savFileName = args[i];
                    continue;
                }
                if (arg == "-serialize") {
                    serialize  = true;
                    doCheckRun = true;
                    continue;
                }
                if (arg[0] == '-') goto usage;
                if (srcFileName != null) goto usage;
                srcFileName = arg;
            }
            if (srcFileName == null) goto usage;

            /*
             * Read whole source into memory.
             */
            FileInfo srcFileInfo = new FileInfo (srcFileName);
            string source = "# 1 \"" + srcFileName + "\"\n" + File.ReadAllText (srcFileInfo.FullName);

            /*
             * Parse source string into tokens.
             */
            Console.WriteLine ("Compiling...");
            string cameFrom = "file://" + srcFileInfo.FullName;
            TextWriter saveSource = null;
            if (savFileName != null) saveSource = File.CreateText (savFileName);
            TokenBegin tokenBegin;
            try {
                tokenBegin = TokenBegin.Construct (cameFrom, saveSource, StandAloneErrorMessage, source, out sourceHash);
            } finally {
                if (saveSource != null) saveSource.Close ();
            }
            if (tokenBegin == null) {
                Console.WriteLine ("Parsing errors.");
                Environment.Exit (1);
            }

            /*
             * Create abstract syntax tree from raw tokens.
             */
            TokenScript tokenScript = ScriptReduce.Reduce(tokenBegin);
            if (tokenScript == null) {
                Console.WriteLine ("Reduction errors.");
                Environment.Exit (1);
            }

            /*
             * Attempt to compile AST to object code.
             */
            Stream objFileStream;
            if (objFileName != null) {
                objFileStream = File.Create (objFileName);
            } else {
                objFileStream = new MemoryStream ();
            }
            BinaryWriter objFileWriter = new BinaryWriter (objFileStream);
            bool ok;
            ok = ScriptCodeGen.CodeGen (tokenScript, objFileWriter, sourceHash);
            if (objFileName != null) objFileWriter.Close ();
            if (!ok) {
                Console.WriteLine ("Compilation errors.");
                Environment.Exit (1);
            }

            /*
             * Load object code into memory.
             * Maybe also output disassembly.
             */
            if (objFileName != null) {
                objFileStream = File.OpenRead (objFileName);
            } else {
                objFileStream.Seek (0, SeekOrigin.Begin);
            }
            BinaryReader objFileReader = new BinaryReader (objFileStream);
            TextWriter asmFileWriter = null;
            if (asmFileName != null) {
                asmFileWriter = (asmFileName != "-") ? File.CreateText (asmFileName) : Console.Out;
            }
            ScriptObjCode scriptObjCode;
            try {
                scriptObjCode = ScriptCodeGen.PerformGeneration (objFileReader, asmFileWriter);
            } finally {
                objFileReader.Close ();
                if (asmFileWriter != null) asmFileWriter.Close ();
            }

            /*
             * Instantiate the script and run its default state_entry() handler.
             */
            Console.WriteLine ("Running...");
            TestInstance inst = new TestInstance (scriptObjCode);
            inst.testCheckRun = doCheckRun;
            inst.heapTotal    = inst.glblVars.AllocVarArrays (ref scriptObjCode.glblSizes);
            inst.ehArgs       = new object[0];
            inst.stateCode    = 0;  // default
            inst.eventCode    = ScriptEventCode.state_entry;
            MemoryStream serializeStream = null;
            if (serialize) {
                serializeStream = new MemoryStream ();
            }
            while (true) {

                /*
                 * Call event handler and wait for it to finish.
                 */
                while (true) {
                    try {
                        RunScriptEventHandler (ref inst, serializeStream);
                        break;
                    } catch (ScriptChangeStateException scse) {
                        inst.eventCode = ScriptEventCode.state_exit;
                        inst.ehArgs    = new object[0];
                        try {
                            RunScriptEventHandler (ref inst, serializeStream);
                        } catch (ScriptChangeStateException) {
                            Console.WriteLine ("State change in state_exit handler ignored");
                        }
                        inst.stateCode = scse.newState;
                        inst.eventCode = ScriptEventCode.state_entry;
                        Console.WriteLine ("Change to state " + inst.m_ObjCode.stateNames[inst.stateCode]);
                    } catch (Exception e) {
                        Console.WriteLine ("Uncaught exception in script: " + inst.XMRExceptionFixString (e.ToString (), true));
                        return;
                    }
                }

                if (!eventIO) return;

                /*
                 * Read eventname(eventargs) from stdin.
                 */
            readLine:
                string eventLine = Console.ReadLine ();
                if (eventLine == null) return;
                ++ consoleLine;
                Console.WriteLine (eventLine);

                /*
                 * Parse into tokens.
                 */
                eventLine = "# " + consoleLine + " \"console events\"\n" + eventLine;
                tokenBegin = TokenBegin.Construct ("console events", null, StandAloneErrorMessage, eventLine, out sourceHash);
                if (tokenBegin == null) continue;
                Token t = tokenBegin.nextToken;

                /*
                 * Get event handler name and validate.
                 */
                if (!(t is TokenName)) {
                    t.ErrorMsg ("expecting event name");
                    goto readLine;
                }
                TokenName eventName = (TokenName)t;
                System.Reflection.MethodInfo[] ifaceMethods = typeof (IEventHandlers).GetMethods ();
                System.Reflection.MethodInfo ifaceMethod;
                foreach (System.Reflection.MethodInfo ifm in ifaceMethods) {
                    ifaceMethod = ifm;
                    if (ifaceMethod.Name == eventName.val) goto gotEvent;
                }
                eventName.ErrorMsg ("unknown event");
                goto readLine;
            gotEvent:
                inst.eventCode = (ScriptEventCode)Enum.Parse (typeof (ScriptEventCode), eventName.val);
                if (scriptObjCode.scriptEventHandlerTable[inst.stateCode,(int)inst.eventCode] == null) {
                    eventName.ErrorMsg ("event handler not defined for state " + scriptObjCode.stateNames[inst.stateCode]);
                    goto readLine;
                }
                t = t.nextToken;

                /*
                 * Parse argument list.
                 */
                if (!(t is TokenKwParOpen)) {
                    t.ErrorMsg ("expecting ( after event name");
                    goto readLine;
                }
                List<object> argList = new List<object> ();
                do {
                    t = t.nextToken;
                    if ((argList.Count == 0) && (t is TokenKwParClose)) break;
                    object val = ParseEHArg (ref t);
                    if (val == null) goto readLine;
                    argList.Add (val);
                } while (t is TokenKwComma);
                if (!(t is TokenKwParClose)) {
                    t.ErrorMsg ("expecting , or ) in arg list");
                    goto readLine;
                }
                inst.ehArgs = argList.ToArray ();
                t = t.nextToken;
                if (!(t is TokenEnd)) {
                    t.ErrorMsg ("extra stuff after event args");
                    goto readLine;
                }
            }

        usage:
            Console.WriteLine ("usage: mono xmrengtest.exe [ -asm <asmoutfile>|- ] [ -checkrun ] [ -eventio ] [ -obj <objoutfile> ] [ -save <sourceoutfile> ] [ -serialize] <sourcefile>");
            Environment.Exit (1);
        }

        public static void StandAloneErrorMessage (Token token, string message)
        {
            Console.WriteLine ("{0} {1}", token.SrcLoc, message);
        }

        /**
         * @brief Run current state event handler until it completes or throws an exception
         * @param inst = script instance
         *        inst.stateCode = which state it is in
         *        inst.eventCode = which handler of that event to run
         *        inst.ehArgs    = arguments to pass to the event handler
         * @returns when event handler completes or throws an exception
         */
        public static void RunScriptEventHandler (ref TestInstance inst, MemoryStream serializeStream)
        {
            while (true) {
                try {
                    inst.m_ObjCode.scriptEventHandlerTable[inst.stateCode,(int)inst.eventCode](inst);
                    break;
                } catch (StackCaptureException) {

                    /*
                     * Make sure we were called because CheckRun() threw and 
                     * the code built inst.StackFrames.
                     */
                    if (inst.callMode != XMRInstAbstract.CALLMODE_SAVE) throw;

                    /*
                     * If -serialize, make sure script instance serialization works.
                     */
                    if (serializeStream != null) {

                        /*
                         * Write global variables and stack frames out and discard them.
                         */
                        serializeStream.Position = 0;
                        inst.MigrateOut (new BinaryWriter (serializeStream));
                        long savePos = serializeStream.Position;

                        /*
                         * Read global variables and stack frames back in and reconstruct.
                         */
                        serializeStream.Position = 0;
                        inst = new TestInstance (inst.m_ObjCode);
                        inst.testCheckRun = true;
                        inst.MigrateIn (new BinaryReader (serializeStream));
                        if (savePos != serializeStream.Position) throw new Exception ("save/restore positions different");
                    }

                    /*
                     * Tell code to restore from inst.stackFrames when it is called back.
                     */
                    inst.callMode = XMRInstAbstract.CALLMODE_RESTORE;
                }
            }
        }

        /**
         * @brief Parse out constant for event handler argument value.
         * @param token = points to beginning of constant
         * @returns null: error parsing constant
         *          else: constant value
         *                token = points just past constant
         */
        public static object ParseEHArg (ref Token token)
        {
            /*
             * Simple unary operators.
             */
            if (token is TokenKwSub) {
                token = token.nextToken;
                Token opTok = token;
                object val = ParseEHArg (ref token);
                if (val is int) return -(int)val;
                if (val is SCRIPTFLOAT) return -(SCRIPTFLOAT)val;
                opTok.ErrorMsg ("invalid - operand");
                return null;
            }
            if (token is TokenKwTilde) {
                token = token.nextToken;
                Token opTok = token;
                object val = ParseEHArg (ref token);
                if (val is int) return ~(int)val;
                opTok.ErrorMsg ("invalid ~ operand");
                return null;
            }

            /*
             * Constants.
             */
            if (token is TokenFloat) {
                object v = ((TokenFloat)token).val;
                token = token.nextToken;
                return v;
            }
            if (token is TokenInt) {
                object v = ((TokenInt)token).val;
                token = token.nextToken;
                return v;
            }
            if (token is TokenStr) {
                object v = ((TokenStr)token).val;
                token = token.nextToken;
                return v;
            }

            /*
             * '<'value,...'>', ie, rotation or vector
             */
            if (token is TokenKwCmpLT) {
                List<SCRIPTFLOAT> valist = new List<SCRIPTFLOAT> ();
                Token openBkt = token;
                do {
                    token = token.nextToken;
                    Token valTok = token;
                    object val = ParseEHArg (ref token);
                    if (val == null) return null;
                    if (val is int) val = (SCRIPTFLOAT)(int)val;
                    if (!(val is SCRIPTFLOAT)) {
                        valTok.ErrorMsg ("invalid rotation/vector constant");
                        return null;
                    }
                    valist.Add ((SCRIPTFLOAT)val);
                } while (token is TokenKwComma);
                if (!(token is TokenKwCmpGT)) {
                    token.ErrorMsg ("expecting , or > at end of rotation or vector");
                    return null;
                }
                token = token.nextToken;
                SCRIPTFLOAT[] valarr = valist.ToArray ();
                switch (valarr.Length) {
                    case 3: {
                        return new LSL_Vector (valarr[0], valarr[1], valarr[2]);
                    }
                    case 4: {
                        return new LSL_Rotation (valarr[0], valarr[1], valarr[2], valarr[3]);
                    }
                    default: {
                        openBkt.ErrorMsg ("bad rotation/vector");
                        return null;
                    }
                }
            }

            /*
             * '['value,...']', ie, list
             */
            if (token is TokenKwBrkOpen) {
                List<object> values = new List<object> ();
                token = token.nextToken;
                if (!(token is TokenKwBrkClose)) {
                    do {
                        token = token.nextToken;
                        object val = ParseEHArg (ref token);
                        if (val == null) return null;
                        if (val is int)         val = new LSL_Integer ((int)val);
                        if (val is SCRIPTFLOAT) val = new LSL_Float   ((SCRIPTFLOAT)val);
                        if (val is string)      val = new LSL_String  ((string)val);
                        values.Add (val);
                        token = token.nextToken;
                    } while (token is TokenKwComma);
                    if (!(token is TokenKwBrkClose)) {
                        token.ErrorMsg ("expecting , or ] in list");
                        return null;
                    }
                }
                token = token.nextToken;
                return new LSL_List (values.ToArray ());
            }

            /*
             * All we got left is <name>, lookup pre-defined constant.
             */
            if (token is TokenName) {
                System.Reflection.FieldInfo fi = typeof (SCRIPTBASECLASS).GetField (((TokenName)token).val);
                if ((fi == null) || !fi.IsPublic || !fi.IsStatic) {
                    token.ErrorMsg ("unknown constant");
                    return null;
                }
                token = token.nextToken;
                object val = fi.GetValue (null);
                if (val is LSL_Float)   val = (SCRIPTFLOAT)((LSL_Float)  val);
                if (val is LSL_Integer) val = (int)        ((LSL_Integer)val);
                if (val is LSL_String)  val = (string)     ((LSL_String) val);
                return val;
            }

            /*
             * Who knows what it is supposed to be?
             */
            token.ErrorMsg ("invalid operand token " + token.ToString ());
            return null;
        }
    }

    public class StackCaptureException : Exception, IXMRUncatchable { }

    public class TestInstance : XMRInstAbstract {
        private const int HEAPLIMIT = 50000;
        public bool testCheckRun;

        public TestInstance (ScriptObjCode soc)
        {
            m_ObjCode = soc;
            heapLimit = HEAPLIMIT;
        }

        /*********************\
         *  XMRInstAbstract  *
        \*********************/

        public override void CheckRun (int line)
        {
            if (testCheckRun) {
                switch (this.callMode) {

                    /*
                     * Code was running normally.
                     * Suspend and write stack frames to this.StackFrames.
                     */
                    case CALLMODE_NORMAL: {
                        this.callMode = CALLMODE_SAVE;
                        this.stackFrames = null;
                        throw new StackCaptureException ();
                    }

                    /*
                     * Code just restored itself from this.StackFrames.
                     * Resume where it left off until it calls CheckRun() again.
                     */
                    case CALLMODE_RESTORE: {
                        if (this.stackFrames != null) throw new Exception ("frames left over");
                        this.callMode = CALLMODE_NORMAL;
                        break;
                    }

                    default: throw new Exception ("bad callMode " + this.callMode);
                }
            }
        }

        public override int xmrStackLeft ()
        {
            return 1000000;
        }
        public override LSL_List xmrEventDequeue (SCRIPTFLOAT timeout, int returnMask1, int returnMask2,
                                                  int backgroundMask1, int backgroundMask2)
        {
            return new LSL_List (new object[0]);
        }
        public override void xmrEventEnqueue (LSL_List ev)
        { }
        public override void xmrEventCallHandler (LSL_List ev)
        { }
        public override LSL_List xmrEventSaveDets ()
        {
            return new LSL_List (new object[0]);
        }
        public override void xmrEventLoadDets (LSL_List dpList)
        { }
    }

    public class SCRIPTBASECLASS {

        public void llOwnerSay (string msg)
        {
            Console.WriteLine ("llOwnerSay: " + msg);
        }

        public LSL_List llParcelMediaQuery (LSL_List query)
        {
            int len = query.Length;
            object[] data = query.Data;
            List<object> output = new List<object> ();
            for (int i = 0; i < len; i ++) {
                Console.WriteLine ("llParcelMediaQuery: [" + i + "]=" + data[i].GetType().Name + " " + data[i].ToString ());
                switch ((int)data[i]) {
                    case PARCEL_MEDIA_COMMAND_TEXTURE: {
                        output.Add (new LSL_String ("uuid Texture"));
                        break;
                    }
                    case PARCEL_MEDIA_COMMAND_URL: {
                        output.Add (new LSL_String ("U-R-L"));
                        break;
                    }
                    case PARCEL_MEDIA_COMMAND_TYPE: {
                        output.Add (new LSL_String ("mime type"));
                        break;
                    }
                    case PARCEL_MEDIA_COMMAND_SIZE: {
                        output.Add (new LSL_Integer (11));
                        output.Add (new LSL_Integer (20));
                        break;
                    }
                    case PARCEL_MEDIA_COMMAND_DESC: {
                        output.Add (new LSL_String ("description"));
                        break;
                    }
                    case PARCEL_MEDIA_COMMAND_LOOP_SET: {
                        output.Add (new LSL_Float ("29.92"));
                        break;
                    }
                }
            }
            return new LSL_List (output.ToArray ());
        }

        public void llParcelMediaCommandList (LSL_List query)
        {
            int len = query.Length;
            object[] data = query.Data;
            for (int i = 0; i < len; i ++) {
                Console.WriteLine ("llParcelMediaCommandList: [" + i + "]=" + data[i].GetType().Name + " " + data[i].ToString ());
            }
        }

        /************************\
         *  Taken from OpenSim  *
        \************************/

        public const int PARCEL_MEDIA_COMMAND_LOOP_SET = 13;

        public LSL_Integer llSubStringIndex(string source, string pattern)
        {
            return source.IndexOf(pattern);
        }

        public LSL_String llGetSubString(string src, int start, int end)
        {
            // Normalize indices (if negative).
            // After normlaization they may still be
            // negative, but that is now relative to
            // the start, rather than the end, of the
            // sequence.

            if (start < 0)
            {
                start = src.Length+start;
            }
            if (end < 0)
            {
                end = src.Length+end;
            }

            // Conventional substring
            if (start <= end)
            {
                // Implies both bounds are out-of-range.
                if (end < 0 || start >= src.Length)
                {
                    return String.Empty;
                }
                // If end is positive, then it directly
                // corresponds to the lengt of the substring
                // needed (plus one of course). BUT, it
                // must be within bounds.
                if (end >= src.Length)
                {
                    end = src.Length-1;
                }

                if (start < 0)
                {
                    return src.Substring(0,end+1);
                }
                // Both indices are positive
                return src.Substring(start, (end+1) - start);
            }

            // Inverted substring (end < start)
            else
            {
                // Implies both indices are below the
                // lower bound. In the inverted case, that
                // means the entire string will be returned
                // unchanged.
                if (start < 0)
                {
                    return src;
                }
                // If both indices are greater than the upper
                // bound the result may seem initially counter
                // intuitive.
                if (end >= src.Length)
                {
                    return src;
                }

                if (end < 0)
                {
                    if (start < src.Length)
                    {
                        return src.Substring(start);
                    }
                    else
                    {
                        return String.Empty;
                    }
                }
                else
                {
                    if (start < src.Length)
                    {
                        return src.Substring(0,end+1) + src.Substring(start);
                    }
                    else
                    {
                        return src.Substring(0,end+1);
                    }
                }
            }
        }

        /**************************\
         *  The rest of ILSL_Api  *
        \**************************/

#include "makexmrengtestilslapi.inc"

        /**
         * @brief Called by the various ILSL_Api functions to print their parameters
         *        and if non-void return value, read return value from stdin.
         */

        private static void ComVoid (string name, params object[] parms)
        {
            PrintParms (name, parms);
        }
        private static LSL_Float ComLSLFloat (string name, params object[] parms)
        {
            PrintParms (name, parms);
            object val = ReadRetVal (name);
            if (val is int) val = (SCRIPTFLOAT)(int)val;
            return new LSL_Float ((SCRIPTFLOAT)val);
        }
        private static LSL_Integer ComLSLInteger (string name, params object[] parms)
        {
            PrintParms (name, parms);
            return new LSL_Integer ((int)ReadRetVal (name));
        }
        private static LSL_List ComLSLList (string name, params object[] parms)
        {
            PrintParms (name, parms);
            return (LSL_List)ReadRetVal (name);
        }
        private static LSL_Rotation ComLSLRotation (string name, params object[] parms)
        {
            PrintParms (name, parms);
            return (LSL_Rotation)ReadRetVal (name);
        }
        private static LSL_String ComLSLString (string name, params object[] parms)
        {
            PrintParms (name, parms);
            return new LSL_String ((string)ReadRetVal (name));
        }
        private static LSL_Vector ComLSLVector (string name, params object[] parms)
        {
            PrintParms (name, parms);
            return (LSL_Vector)ReadRetVal (name);
        }

        /**
         * @brief Print api function and parameter values.
         */
        private static void PrintParms (string name, object[] parms)
        {
            StringBuilder sb = new StringBuilder ();
            sb.Append (name);
            sb.Append ('(');
            for (int i = 0; i < parms.Length; i ++) {
                object p = parms[i];
                if (i > 0) sb.Append (", ");
                PrintParam (sb, p);
            }
            sb.Append (')');
            Console.WriteLine (sb.ToString ());
        }
        private static void PrintParam (StringBuilder sb, object p)
        {
            if (p == null) {
                sb.Append ("null");
            } else if (p is LSL_List) {
                sb.Append ('[');
                object[] d = ((LSL_List)p).Data;
                for (int i = 0; i < d.Length; i ++) {
                    if (i > 0) sb.Append (',');
                    PrintParam (sb, d[i]);
                }
                sb.Append (']');
            } else if (p is LSL_String) {
                PrintParamString (sb, (string)(LSL_String)p);
            } else if (p is string) {
                PrintParamString (sb, (string)p);
            } else {
                sb.Append (p.ToString ());
            }
        }
        private static void PrintParamString (StringBuilder sb, string p)
        {
            sb.Append ('"');
            foreach (char c in p) {
                if (c == '\n') {
                    sb.Append ("\\n");
                    continue;
                }
                if (c == '"') {
                    sb.Append ("\\\"");
                    continue;
                }
                if (c == '\\') {
                    sb.Append ("\\\\");
                    continue;
                }
                sb.Append (c);
            }
            sb.Append ('"');
        }

        /**
         * @brief Read return value from stdin.
         *        Must be in form <funcname>:<value>
         * @param name = name of function that the return value is for
         * @returns value read from stdin
         */
        private static object ReadRetVal (string name)
        {
            string line = Console.ReadLine ();
            if (line == null) throw new Exception ("end of input");
            ++ XMREngTest.consoleLine;
            Console.WriteLine (line);

            /*
             * Parse into tokens.
             */
            string sourceHash;
            line = "# " + XMREngTest.consoleLine + " \"console events\"\n" + line;
            TokenBegin tokenBegin = TokenBegin.Construct ("console events", null, XMREngTest.StandAloneErrorMessage, line, out sourceHash);
            if (tokenBegin == null) throw new Exception ("parse error");
            Token t = tokenBegin.nextToken;

            /*
             * Get function name and validate.
             */
            if (!(t is TokenName) || !(t.nextToken is TokenKwColon)) {
                throw new Exception ("expecting function name :");
            }
            if (((TokenName)t).val != name) {
                throw new Exception ("expecting function " + name);
            }
            t = t.nextToken.nextToken;

            /*
             * Parse out the value.
             */
            object val = XMREngTest.ParseEHArg (ref t);
            if (val == null) throw new Exception ("value parse error");
            if (!(t is TokenEnd)) {
                throw new Exception ("extra stuff at end of line " + t.ToString ());
            }
            return val;
        }
    }
}
