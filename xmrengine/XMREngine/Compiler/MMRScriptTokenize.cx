/***************************************************\
 *  COPYRIGHT 2012, Mike Rieker, Beverly, MA, USA  *
 *  All rights reserved.                           *
\***************************************************/

/**
 * @brief Parse raw source file string into token list.
 *
 * Usage:
 *
 *    emsg = some function to output error messages to
 *    source = string containing entire source file
 *
 *    TokenBegin tokenBegin = TokenBegin.Construct (emsg, source);
 *
 *    tokenBegin = null: tokenizing error
 *                 else: first (dummy) token in file
 *                       the rest are chained by nextToken,prevToken
 *                       final token is always a (dummy) TokenEnd
 */

using System;
using System.Collections.Generic;
using System.IO;
using System.Net;
using System.Reflection;
using System.Reflection.Emit;
using System.Text;

#include "lsltypes.h"

#define strcasecmp(s,t) String.Compare(s,t,StringComparison.OrdinalIgnoreCase)

namespace OpenSim.Region.ScriptEngine.XMREngine {

    public delegate void TokenErrorMessage (Token token, string message);

    /**
     * @brief base class for all tokens
     */
    public class Token {
        public static readonly int MAX_NAME_LEN = 255;
        public static readonly int MAX_STRING_LEN = 4096;

        public Token nextToken;
        public Token prevToken;
        public int macroLevel;

        // used for error message printing
        public TokenErrorMessage emsg;
        public string file = "";
        public int line;
        public int posn;
        public Token copiedFrom;

        /**
         * @brief construct a token coming directly from a source file
         * @param emsg = object that error messages get sent to
         * @param file = source file name (or "" if none)
         * @param line = source file line number
         * @param posn = token's position within that source line
         */
        public Token (TokenErrorMessage emsg, string file, int line, int posn)
        {
            this.emsg = emsg;
            this.file = file;
            this.line = line;
            this.posn = posn;
        }

        /**
         * @brief construct a token with same error message parameters
         * @param original = original token to create from
         */
        public Token (Token original)
        {
            if (original != null) {
                this.emsg = original.emsg;
                this.file = original.file;
                this.line = original.line;
                this.posn = original.posn;
            }
        }

        /**
         * @brief output an error message associated with this token
         *        sends the message to the token's error object
         * @param message = error message string
         */
        public void ErrorMsg (string message)
        {
            if (emsg != null) {
                emsg (this, message);
            }
        }

        /*
         * Generate a unique string (for use in CIL label names, etc)
         */
        public string Unique
        {
            get { return file + "_" + line + "_" + posn; }
        }

        /*
         * Generate source location string (for use in error messages)
         */
        public string SrcLoc
        {
            get {
                string loc = file + "(" + line + "," + posn + ")";
                if (copiedFrom == null) return loc;
                string fromLoc = copiedFrom.SrcLoc;
                if (fromLoc.StartsWith (loc)) return fromLoc;
                return loc + ":" + fromLoc;
            }
        }

        /*
         * Used in generic instantiation to copy token.
         * Only valid for parsing tokens, not reduction tokens 
         * because it is a shallow copy.
         */
        public Token CopyToken (Token src)
        {
            Token t = (Token)this.MemberwiseClone ();
            t.file  = src.file;
            t.line  = src.line;
            t.posn  = src.posn;
            t.copiedFrom = this;
            return t;
        }

        /*
         * Generate debugging string - should look like source code.
         */
        public virtual void DebString (StringBuilder sb)
        {
            sb.Append (this.ToString ());
        }
    }


    /**
     * @brief token that begins a source file
     *        Along with TokenEnd, it keeps insertion/removal of intermediate tokens
     *        simple as the intermediate tokens always have non-null nextToken,prevToken.
     */
    public class TokenBegin : Token {

        public int expiryDays = Int32.MaxValue;  // has seen 'XMROption expiryDays;'

        private class Options {
            public bool arrays;         // has seen 'XMROption arrays;'
            public bool advFlowCtl;     // has seen 'XMROption advFlowCtl;'
            public bool tryCatch;       // has seen 'XMROption tryCatch;'
            public bool objects;        // has seen 'XMROption objects;'
            public bool chars;          // has seen 'XMROption chars;'
        }

        private bool youveAnError;      // there was some error tokenizing
        private int bolIdx;             // index in 'source' at begining of current line
        private int lineNo;             // current line in source file, starting at 0
        private string filNam;          // current source file name
        private string source;          // the whole script source code
        private Token lastToken;        // last token created so far
        private string cameFrom;        // where the source came from
        private TextWriter saveSource;  // save copy of source here (or null)
        private Options options = new Options ();

        /**
         * @brief convert a source file in the form of a string
         *        to a list of raw tokens
         * @param cameFrom = where the source came from
         * @param emsg     = where to output messages to
         * @param source   = whole source file contents
         * @returns null: conversion error, message already output
         *          else: list of tokens, starting with TokenBegin, ending with TokenEnd.
         */
        public static TokenBegin Construct (string cameFrom, TextWriter saveSource, TokenErrorMessage emsg, string source, out string sourceHash)
        {
            sourceHash = null;

            /*
             * Now do the tokenization.
             */
            TokenBegin tokenBegin = new TokenBegin (emsg, "", 0, 0);
            tokenBegin.cameFrom   = cameFrom;
            tokenBegin.saveSource = saveSource;
            tokenBegin.lastToken  = tokenBegin;
            tokenBegin.source     = source;
            tokenBegin.filNam     = cameFrom;
            if (saveSource != null) saveSource.WriteLine (source);
            tokenBegin.Tokenize ();
            if (tokenBegin.youveAnError) return null;
            tokenBegin.AppendToken (new TokenEnd (emsg, tokenBegin.filNam, ++ tokenBegin.lineNo, 0));

            /*
             * Return source hash so caller can know if source changes.
             */
            System.Security.Cryptography.MD5 md5 = System.Security.Cryptography.MD5.Create ();
            byte[] hashBytes = md5.ComputeHash (new TokenStream (tokenBegin));
            int hashBytesLen = hashBytes.Length;
            StringBuilder sb = new StringBuilder (hashBytesLen * 2);
            for (int i = 0; i < hashBytesLen; i ++) {
                sb.Append (hashBytes[i].ToString ("X2"));
            }
            sourceHash = sb.ToString ();
            if (saveSource != null) {
                saveSource.WriteLine ("");
                saveSource.WriteLine ("********************************************************************************");
                saveSource.WriteLine ("****  source hash: " + sourceHash);
                saveSource.WriteLine ("********************************************************************************");
            }

            return tokenBegin;
        }

        private TokenBegin (TokenErrorMessage emsg, string file, int line, int posn) : base (emsg, file, line, posn) { }

        /*
         * Stream consisting of all the tokens.
         * Null delimeters between the tokens.
         * Used for creating the source hash.
         */
        private class TokenStream : Stream {
            private Token curTok;
            private bool delim;
            private byte[] curBuf;
            private int curOfs;
            private int curLen;

            public TokenStream (Token t)
            {
                curTok = t;
            }

            public override bool CanRead  { get { return true;  } }
            public override bool CanSeek  { get { return false; } }
            public override bool CanWrite { get { return false; } }
            public override long Length   { get { return 0; } }
            public override long Position { get { return 0; } set { } }

            public override void Write (byte[] buffer, int offset, int count) { }
            public override void Flush () { }
            public override long Seek (long offset, SeekOrigin origin) { return 0; }
            public override void SetLength (long value) { }

            public override int Read (byte[] buffer, int offset, int count)
            {
                int len, total;
                for (total = 0; total < count; total += len) {
                    while ((len = curLen - curOfs) <= 0) {
                        if (curTok is TokenEnd) goto done;
                        curTok = curTok.nextToken;
                        if (curTok is TokenEnd) goto done;
                        curBuf = System.Text.Encoding.UTF8.GetBytes (curTok.ToString ());
                        curOfs = 0;
                        curLen = curBuf.Length;
                        delim  = true;
                    }
                    if (delim) {
                        buffer[offset+total] = 0;
                        delim = false;
                        len   = 1;
                    } else {
                        if (len > count - total) len = count - total;
                        Array.Copy (curBuf, curOfs, buffer, offset + total, len);
                        curOfs += len;
                    }
                }
              done:
                return total;
            }
        }

        /*
         * Produces raw token stream: names, numbers, strings, keywords/delimeters.
         * @param this.source = whole source file in one string
         * @returns this.nextToken = filled in with tokens
         *          this.youveAnError = true: some tokenizing error
         *                             false: successful
         */
        private void Tokenize ()
        {
            bolIdx = 0;
            lineNo = 0;
            for (int i = 0; i < source.Length; i ++) {
                char c = source[i];
                if (c == '\n') {

                    /*
                     * Increment source line number and set char index of beg of next line.
                     */
                    lineNo ++;
                    bolIdx = i + 1;

                    /*
                     * Check for '#' lineno filename newline
                     * lineno is line number of next line in file
                     * If found, save values and remove tokens from stream
                     */
                    if ((lastToken is TokenStr) &&
                        (lastToken.prevToken is TokenInt) &&
                        (lastToken.prevToken.prevToken is TokenKwHash)) {
                        filNam = ((TokenStr)lastToken).val;
                        lineNo = ((TokenInt)lastToken.prevToken).val;
                        lastToken = lastToken.prevToken.prevToken.prevToken;
                        lastToken.nextToken = null;
                    }
                    continue;
                }

                /*
                 * Skip over whitespace.
                 */
                if (c <= ' ') continue;

                /*
                 * Skip over comments.
                 */
                if ((i + 2 <= source.Length) && source.Substring (i, 2).Equals ("//")) {
                    while ((i < source.Length) && (source[i] != '\n')) i ++;
                    lineNo ++;
                    bolIdx = i + 1;
                    continue;
                }
                if ((i + 2 <= source.Length) && (source.Substring (i, 2).Equals ("/*"))) {
                    while ((i + 1 < source.Length) && (((c = source[i]) != '*') || (source[i+1] != '/'))) {
                        if (c == '\n') {
                            lineNo ++;
                            bolIdx = i + 1;
                        }
                        i ++;
                    }
                    i ++;
                    continue;
                }

                /*
                 * Check for numbers.
                 */
                if ((c >= '0') && (c <= '9')) {
                    int j = TryParseFloat (i);
                    if (j == 0) j = TryParseInt (i);
                    i = -- j;
                    continue;
                }
                if ((c == '.') && (source[i+1] >= '0') && (source[i+1] <= '9')) {
                    int j = TryParseFloat (i);
                    if (j > 0) i = -- j;
                    continue;
                }

                /*
                 * Check for quoted strings.
                 */
                if (c == '"') {
                    StringBuilder sb = new StringBuilder ();
                    bool backslash;
                    int j;

                    backslash = false;
                    for (j = i; ++ j < source.Length;) {
                        c = source[j];
                        if (c == '\\' && !backslash) {
                            backslash = true;
                            continue;
                        }
                        if (c == '\n') {
                            lineNo ++;
                            bolIdx = j + 1;
                        } else {
                            if (!backslash && (c == '"')) break;
                            if (backslash && (c == 'n')) c = '\n';
                            if (backslash && (c == 't')) {
                                sb.Append ("   ");
                                c = ' ';
                            }
                        }
                        backslash = false;
                        sb.Append (c);
                    }
                    if (j - i > MAX_STRING_LEN) {
                        TokenError (i, "string too long, max " + MAX_STRING_LEN);
                    } else {
                        AppendToken (new TokenStr (emsg, filNam, lineNo, i - bolIdx, sb.ToString ()));
                    }
                    i = j;
                    continue;
                }

                /*
                 * Check for quoted characters.
                 */
                if (c == '\'') {
                    char cb = (char)0;
                    bool backslash, overflow, underflow;
                    int j;

                    backslash = false;
                    overflow  = false;
                    underflow = true;
                    for (j = i; ++ j < source.Length;) {
                        c = source[j];
                        if (c == '\\' && !backslash) {
                            backslash = true;
                            continue;
                        }
                        if (c == '\n') {
                            lineNo ++;
                            bolIdx = j + 1;
                        } else {
                            if (!backslash && (c == '\'')) break;
                            if (backslash && (c == 'n')) c = '\n';
                            if (backslash && (c == 't')) c = '\t';
                        }
                        backslash = false;
                        overflow  = !underflow;
                        underflow = false;
                        cb = c;
                    }
                    if (underflow || overflow) {
                        TokenError (i, "character must be exactly one character");
                    } else {
                        AppendToken (new TokenChar (emsg, filNam, lineNo, i - bolIdx, cb));
                    }
                    i = j;
                    continue;
                }

                /*
                 * Check for keywords/names.
                 */
                if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c == '_') || (c == '$')) {
                    int j;

                    for (j = i; ++ j < source.Length;) {
                        c = source[j];
                        if (c >= 'a' && c <= 'z') continue;
                        if (c >= 'A' && c <= 'Z') continue;
                        if (c >= '0' && c <= '9') continue;
                        if (c != '_') break;
                    }
                    if (j - i > MAX_NAME_LEN) {
                        TokenError (i, "name too long, max " + MAX_NAME_LEN);
                    } else {
                        string name = source.Substring (i, j - i);
                        if (keywords.ContainsKey (name)) {
                            Object[] args = new Object[] { emsg, filNam, lineNo, i - bolIdx };
                            AppendToken ((Token)keywords[name].Invoke (args));
                        } else if (options.arrays && arrayKeywords.ContainsKey (name)) {
                            Object[] args = new Object[] { emsg, filNam, lineNo, i - bolIdx };
                            AppendToken ((Token)arrayKeywords[name].Invoke (args));
                        } else if (options.advFlowCtl && advFlowCtlKeywords.ContainsKey (name)) {
                            Object[] args = new Object[] { emsg, filNam, lineNo, i - bolIdx };
                            AppendToken ((Token)advFlowCtlKeywords[name].Invoke (args));
                        } else if (options.tryCatch && tryCatchKeywords.ContainsKey (name)) {
                            Object[] args = new Object[] { emsg, filNam, lineNo, i - bolIdx };
                            AppendToken ((Token)tryCatchKeywords[name].Invoke (args));
                        } else if (options.objects && objectsKeywords.ContainsKey (name)) {
                            Object[] args = new Object[] { emsg, filNam, lineNo, i - bolIdx };
                            AppendToken ((Token)objectsKeywords[name].Invoke (args));
                        } else if (options.chars && charsKeywords.ContainsKey (name)) {
                            Object[] args = new Object[] { emsg, filNam, lineNo, i - bolIdx };
                            AppendToken ((Token)charsKeywords[name].Invoke (args));
                        } else {
                            AppendToken (new TokenName (emsg, filNam, lineNo, i - bolIdx, name));
                        }
                    }
                    i = -- j;
                    continue;
                }

                /*
                 * Check for option enables.
                 */
                if ((c == ';') && (lastToken is TokenName) && 
                    (lastToken.prevToken is TokenName) && 
                    (strcasecmp(((TokenName)lastToken.prevToken).val, "xmroption") == 0)) {
                    string opt = ((TokenName)lastToken).val;
                    if (strcasecmp (opt, "arrays") == 0) {
                        options.arrays = true;
                    } else if (strcasecmp (opt, "advflowctl") == 0) {
                        options.advFlowCtl = true;
                    } else if (strcasecmp (opt, "trycatch") == 0) {
                        options.tryCatch = true;
                    } else if (strcasecmp (opt, "objects") == 0) {
                        options.objects = true;
                    } else if (strcasecmp (opt, "chars") == 0) {
                        options.chars = true;
                    } else {
                        lastToken.ErrorMsg ("unknown XMROption");
                    }
                    lastToken = lastToken.prevToken.prevToken;
                    lastToken.nextToken = null;
                    continue;
                }

                /*
                 * Handle 'xmroption' 'expirydays' numberofdays ';'
                 */
                if ((c == ';') && 
                    (lastToken is TokenInt) && 
                    (lastToken.prevToken is TokenName) && 
                    (lastToken.prevToken.prevToken is TokenName) &&
                    (strcasecmp(((TokenName)lastToken.prevToken.prevToken).val, "xmroption") == 0) && 
                    (strcasecmp(((TokenName)lastToken.prevToken).val, "expirydays") == 0)) {
                    expiryDays = ((TokenInt)lastToken).val;
                    this.lastToken = lastToken.prevToken.prevToken.prevToken;
                    this.lastToken.nextToken = null;
                    continue;
                }


                /*
                 * Handle 'xmroption' 'include' sourceurl ';'
                 */
                if ((c == ';') && 
                    (lastToken is TokenStr) && 
                    (lastToken.prevToken is TokenName) && 
                    (lastToken.prevToken.prevToken is TokenName) &&
                    (strcasecmp(((TokenName)lastToken.prevToken.prevToken).val, "xmroption") == 0) && 
                    (strcasecmp(((TokenName)lastToken.prevToken).val, "include") == 0)) {

                    string newURL      = ((TokenStr)lastToken).val;
                    if (newURL == "") {
                        lastToken.ErrorMsg ("empty URL string");
                        continue;
                    }
                    string newCameFrom = CreateURL (this.cameFrom, newURL);
                    string newSource   = ReadSourceFromURL (newCameFrom);

                    this.lastToken     = lastToken.prevToken.prevToken.prevToken;
                    this.lastToken.nextToken = null;

                    if (newSource != null) {
                        if (saveSource != null) {
                            saveSource.WriteLine ("");
                            saveSource.WriteLine ("********************************************************************************");
                            saveSource.WriteLine ("****  include url: " + newCameFrom);
                            saveSource.WriteLine ("********************************************************************************");
                            saveSource.WriteLine (newSource);
                        }

                        string saveSourc    = this.source;
                        string saveFilNam   = this.filNam;
                        string saveCameFrom = this.cameFrom;
                        int saveBolIdx      = this.bolIdx;
                        int saveLineNo      = this.lineNo;
                        Options saveOptions = this.options;
                        this.source   = newSource;
                        this.filNam   = newURL;
                        this.cameFrom = newCameFrom;
                        this.options  = new Options ();
                        this.Tokenize ();
                        this.source   = saveSourc;
                        this.filNam   = saveFilNam;
                        this.cameFrom = saveCameFrom;
                        this.bolIdx   = saveBolIdx;
                        this.lineNo   = saveLineNo;
                        this.options  = saveOptions;
                    }
                    continue;
                }

                /*
                 * Lastly, check for delimeters.
                 */
                {
                    int j;
                    int len = 0;

                    for (j = 0; j < delims.Length; j ++) {
                        len = delims[j].str.Length;
                        if ((i + len <= source.Length) && (source.Substring (i, len).Equals (delims[j].str))) break;
                    }
                    if (j < delims.Length) {
                        Object[] args = { emsg, filNam, lineNo, i - bolIdx };
                        Token kwToken = (Token)delims[j].ctorInfo.Invoke (args);
                        AppendToken (kwToken);
                        i += -- len;
                        continue;
                    }
                }

                /*
                 * Don't know what it is!
                 */
                TokenError (i, "unknown character '" + c + "'");
            }
        }

        /**
         * @brief try to parse a floating-point number from the source
         * @param i = starting position within this.source of number
         * @returns 0: not a floating point number, try something else
         *       else: position in this.source of terminating character, ie, past number
         *             TokenFloat appended to token list
         *             or error message has been output
         */
        private int TryParseFloat (int i)
        {
            bool decimals, error, negexp, nulexp;
            char c;
            double f, f10;
            int exponent, j, x, y;
            ulong m, mantissa;

            decimals = false;
            error    = false;
            exponent = 0;
            mantissa = 0;
            for (j = i; j < source.Length; j ++) {
                c = source[j];
                if ((c >= '0') && (c <= '9')) {
                    m = mantissa * 10 + (ulong)(c - '0');
                    if (m / 10 != mantissa) {
                        if (!decimals) exponent ++;
                    } else {
                        mantissa = m;
                        if (decimals) exponent --;
                    }
                    continue;
                }
                if (c == '.') {
                    if (decimals) {
                        TokenError (i, "more than one decimal point");
                        return j;
                    }
                    decimals = true;
                    continue;
                }
                if ((c == 'E') || (c == 'e')) {
                    if (++ j >= source.Length) {
                        TokenError (i, "floating exponent off end of source");
                        return j;
                    }
                    c = source[j];
                    negexp = (c == '-');
                    if (negexp || (c == '+')) j ++;
                    y = 0;
                    nulexp = true;
                    for (; j < source.Length; j ++) {
                        c = source[j];
                        if ((c < '0') || (c > '9')) break;
                        x = y * 10 + (c - '0');
                        if (x / 10 != y) {
                            if (!error) TokenError (i, "floating exponent overflow");
                            error = true;
                        }
                        y = x;
                        nulexp = false;
                    }
                    if (nulexp) {
                        TokenError (i, "bad or missing floating exponent");
                        return j;
                    }
                    if (negexp) {
                        x = exponent - y;
                        if (x > exponent) {
                            if (!error) TokenError (i, "floating exponent overflow");
                            error = true;
                        }
                    } else {
                        x = exponent + y;
                        if (x < exponent) {
                            if (!error) TokenError (i, "floating exponent overflow");
                            error = true;
                        }
                    }
                    exponent = x;
                }
                break;
            }
            if (!decimals) {
                return 0;
            }

            f = mantissa;
            if ((exponent != 0) && (mantissa != 0) && !error) {
                f10 = 10.0;
                if (exponent < 0) {
                    exponent = -exponent;
                    while (exponent > 0) {
                        if ((exponent & 1) != 0) {
                            f /= f10;
                        }
                        exponent /= 2;
                        f10 *= f10;
                    }
                } else {
                    while (exponent > 0) {
                        if ((exponent & 1) != 0) {
                            f *= f10;
                        }
                        exponent /= 2;
                        f10 *= f10;
                    }
                }
            }
            if (!error) {
                AppendToken (new TokenFloat (emsg, filNam, lineNo, i - bolIdx, f));
            }
            return j;
        }

        /**
         * @brief try to parse an integer number from the source
         * @param i = starting position within this.source of number
         * @returns 0: not an integer number, try something else
         *       else: position in this.source of terminating character, ie, past number
         *             TokenInt appended to token list
         *             or error message has been output
         */
        private int TryParseInt (int i)
        {
            bool error;
            char c;
            int j;
            uint basse, m, mantissa;

            basse    = 10;
            error    = false;
            mantissa = 0;
            for (j = i; j < source.Length; j ++) {
                c = source[j];
                if ((c >= '0') && (c <= '9')) {
                    m = mantissa * basse + (uint)(c - '0');
                    if (m / basse != mantissa) {
                        if (!error) TokenError (i, "integer overflow");
                        error = true;
                    }
                    mantissa = m;
                    continue;
                }
                if ((basse == 16) && ((c >= 'A') && (c <= 'F'))) {
                    m = mantissa * basse + (uint)(c - 'A') + 10U;
                    if (m / basse != mantissa) {
                        if (!error) TokenError (i, "integer overflow");
                        error = true;
                    }
                    mantissa = m;
                    continue;
                }
                if ((basse == 16) && ((c >= 'a') && (c <= 'f'))) {
                    m = mantissa * basse + (uint)(c - 'a') + 10U;
                    if (m / basse != mantissa) {
                        if (!error) TokenError (i, "integer overflow");
                        error = true;
                    }
                    mantissa = m;
                    continue;
                }
                if (((c == 'x') || (c == 'X')) && (mantissa == 0) && (basse == 10)) {
                    basse = 16;
                    continue;
                }
                break;
            }
            if (!error) {
                AppendToken (new TokenInt (emsg, filNam, lineNo, i - bolIdx, (int)mantissa));
            }
            return j;
        }

        /**
         * @brief append token on to end of list
         * @param newToken = token to append
         * @returns with token appended onto this.lastToken
         */
        private void AppendToken (Token newToken)
        {
            newToken.nextToken  = null;
            newToken.prevToken  = lastToken;
            lastToken.nextToken = newToken;
            lastToken           = newToken;
        }

        /**
         * @brief print tokenizing error message
         *        and remember that we've an error
         * @param i = position within source file of the error
         * @param message = error message text
         * @returns with this.youveAnError set
         */
        private void TokenError (int i, string message)
        {
            Token temp = new Token (this.emsg, this.filNam, this.lineNo, i - this.bolIdx);
            temp.ErrorMsg (message);
            youveAnError = true;
        }

        /**
         * @brief get a token's constructor
         * @param tokenType = token's type
         * @returns token's constructor
         */
        private static Type[] constrTypes = new Type[] {
            typeof (TokenErrorMessage), typeof (string), typeof (int), typeof (int)
        };

        private static System.Reflection.ConstructorInfo GetTokenCtor (Type tokenType)
        {
            return tokenType.GetConstructor (constrTypes);
        }

        /**
         * @brief delimeter table
         */
        private class Delim {
            public string str;
            public System.Reflection.ConstructorInfo ctorInfo;
            public Delim (string str, Type type)
            {
                this.str = str;
                ctorInfo = GetTokenCtor (type);
            }
        }

        private static Delim[] delims = new Delim[] {
            new Delim ("...", typeof (TokenKwDotDotDot)),
            new Delim ("&&&", typeof (TokenKwAndAndAnd)),
            new Delim ("|||", typeof (TokenKwOrOrOr)),
            new Delim ("<<=", typeof (TokenKwAsnLSh)),
            new Delim (">>=", typeof (TokenKwAsnRSh)),
            new Delim ("<=",  typeof (TokenKwCmpLE)),
            new Delim (">=",  typeof (TokenKwCmpGE)),
            new Delim ("==",  typeof (TokenKwCmpEQ)),
            new Delim ("!=",  typeof (TokenKwCmpNE)),
            new Delim ("++",  typeof (TokenKwIncr)),
            new Delim ("--",  typeof (TokenKwDecr)),
            new Delim ("&&",  typeof (TokenKwAndAnd)),
            new Delim ("||",  typeof (TokenKwOrOr)),
            new Delim ("+=",  typeof (TokenKwAsnAdd)),
            new Delim ("&=",  typeof (TokenKwAsnAnd)),
            new Delim ("-=",  typeof (TokenKwAsnSub)),
            new Delim ("*=",  typeof (TokenKwAsnMul)),
            new Delim ("/=",  typeof (TokenKwAsnDiv)),
            new Delim ("%=",  typeof (TokenKwAsnMod)),
            new Delim ("|=",  typeof (TokenKwAsnOr)),
            new Delim ("^=",  typeof (TokenKwAsnXor)),
            new Delim ("<<",  typeof (TokenKwLSh)),
            new Delim (">>",  typeof (TokenKwRSh)),
            new Delim ("~",   typeof (TokenKwTilde)),
            new Delim ("!",   typeof (TokenKwExclam)),
            new Delim ("@",   typeof (TokenKwAt)),
            new Delim ("%",   typeof (TokenKwMod)),
            new Delim ("^",   typeof (TokenKwXor)),
            new Delim ("&",   typeof (TokenKwAnd)),
            new Delim ("*",   typeof (TokenKwMul)),
            new Delim ("(",   typeof (TokenKwParOpen)),
            new Delim (")",   typeof (TokenKwParClose)),
            new Delim ("-",   typeof (TokenKwSub)),
            new Delim ("+",   typeof (TokenKwAdd)),
            new Delim ("=",   typeof (TokenKwAssign)),
            new Delim ("{",   typeof (TokenKwBrcOpen)),
            new Delim ("}",   typeof (TokenKwBrcClose)),
            new Delim ("[",   typeof (TokenKwBrkOpen)),
            new Delim ("]",   typeof (TokenKwBrkClose)),
            new Delim (";",   typeof (TokenKwSemi)),
            new Delim (":",   typeof (TokenKwColon)),
            new Delim ("<",   typeof (TokenKwCmpLT)),
            new Delim (">",   typeof (TokenKwCmpGT)),
            new Delim (",",   typeof (TokenKwComma)),
            new Delim (".",   typeof (TokenKwDot)),
            new Delim ("?",   typeof (TokenKwQMark)),
            new Delim ("/",   typeof (TokenKwDiv)),
            new Delim ("|",   typeof (TokenKwOr)),
            new Delim ("#",   typeof (TokenKwHash))
        };

        /**
         * @brief keyword tables
         *        The keyword tables translate a keyword string
         *        to the corresponding token constructor.
         */
        private static Dictionary<string, System.Reflection.ConstructorInfo> keywords           = BuildKeywords ();
        private static Dictionary<string, System.Reflection.ConstructorInfo> arrayKeywords      = BuildArrayKeywords ();
        private static Dictionary<string, System.Reflection.ConstructorInfo> advFlowCtlKeywords = BuildAdvFlowCtlKeywords ();
        private static Dictionary<string, System.Reflection.ConstructorInfo> tryCatchKeywords   = BuildTryCatchKeywords ();
        private static Dictionary<string, System.Reflection.ConstructorInfo> objectsKeywords    = BuildObjectsKeywords ();
        private static Dictionary<string, System.Reflection.ConstructorInfo> charsKeywords      = BuildCharsKeywords ();

        private static Dictionary<string, System.Reflection.ConstructorInfo> BuildKeywords ()
        {
            Dictionary<string, System.Reflection.ConstructorInfo> kws = new Dictionary<string, System.Reflection.ConstructorInfo> ();

            kws.Add ("default",  GetTokenCtor (typeof (TokenKwDefault)));
            kws.Add ("do",       GetTokenCtor (typeof (TokenKwDo)));
            kws.Add ("else",     GetTokenCtor (typeof (TokenKwElse)));
            kws.Add ("float",    GetTokenCtor (typeof (TokenTypeFloat)));
            kws.Add ("for",      GetTokenCtor (typeof (TokenKwFor)));
            kws.Add ("if",       GetTokenCtor (typeof (TokenKwIf)));
            kws.Add ("integer",  GetTokenCtor (typeof (TokenTypeInt)));
            kws.Add ("list",     GetTokenCtor (typeof (TokenTypeList)));
            kws.Add ("jump",     GetTokenCtor (typeof (TokenKwJump)));
            kws.Add ("key",      GetTokenCtor (typeof (TokenTypeStr)));
            kws.Add ("return",   GetTokenCtor (typeof (TokenKwRet)));
            kws.Add ("rotation", GetTokenCtor (typeof (TokenTypeRot)));
            kws.Add ("state",    GetTokenCtor (typeof (TokenKwState)));
            kws.Add ("string",   GetTokenCtor (typeof (TokenTypeStr)));
            kws.Add ("vector",   GetTokenCtor (typeof (TokenTypeVec)));
            kws.Add ("while",    GetTokenCtor (typeof (TokenKwWhile)));

            return kws;
        }

        private static Dictionary<string, System.Reflection.ConstructorInfo> BuildArrayKeywords ()
        {
            Dictionary<string, System.Reflection.ConstructorInfo> kws = new Dictionary<string, System.Reflection.ConstructorInfo> ();

            kws.Add ("array",   GetTokenCtor (typeof (TokenTypeArray)));
            kws.Add ("foreach", GetTokenCtor (typeof (TokenKwForEach)));
            kws.Add ("in",      GetTokenCtor (typeof (TokenKwIn)));
            kws.Add ("is",      GetTokenCtor (typeof (TokenKwIs)));
            kws.Add ("object",  GetTokenCtor (typeof (TokenTypeObject)));
            kws.Add ("undef",   GetTokenCtor (typeof (TokenKwUndef)));

            return kws;
        }

        private static Dictionary<string, System.Reflection.ConstructorInfo> BuildAdvFlowCtlKeywords ()
        {
            Dictionary<string, System.Reflection.ConstructorInfo> kws = new Dictionary<string, System.Reflection.ConstructorInfo> ();

            kws.Add ("break",    GetTokenCtor (typeof (TokenKwBreak)));
            kws.Add ("case",     GetTokenCtor (typeof (TokenKwCase)));
            kws.Add ("constant", GetTokenCtor (typeof (TokenKwConst)));
            kws.Add ("continue", GetTokenCtor (typeof (TokenKwCont)));
            kws.Add ("switch",   GetTokenCtor (typeof (TokenKwSwitch)));

            return kws;
        }

        private static Dictionary<string, System.Reflection.ConstructorInfo> BuildTryCatchKeywords ()
        {
            Dictionary<string, System.Reflection.ConstructorInfo> kws = new Dictionary<string, System.Reflection.ConstructorInfo> ();

            kws.Add ("catch",     GetTokenCtor (typeof (TokenKwCatch)));
            kws.Add ("exception", GetTokenCtor (typeof (TokenTypeExc)));
            kws.Add ("finally",   GetTokenCtor (typeof (TokenKwFinally)));
            kws.Add ("throw",     GetTokenCtor (typeof (TokenKwThrow)));
            kws.Add ("try",       GetTokenCtor (typeof (TokenKwTry)));

            return kws;
        }

        private static Dictionary<string, System.Reflection.ConstructorInfo> BuildObjectsKeywords ()
        {
            Dictionary<string, System.Reflection.ConstructorInfo> kws = new Dictionary<string, System.Reflection.ConstructorInfo> ();

            kws.Add ("abstract",    GetTokenCtor (typeof (TokenKwAbstract)));
            kws.Add ("base",        GetTokenCtor (typeof (TokenKwBase)));
            kws.Add ("class",       GetTokenCtor (typeof (TokenKwClass)));
            kws.Add ("constructor", GetTokenCtor (typeof (TokenKwConstructor)));
            kws.Add ("delegate",    GetTokenCtor (typeof (TokenKwDelegate)));
            kws.Add ("destructor",  GetTokenCtor (typeof (TokenKwDestructor)));
            kws.Add ("final",       GetTokenCtor (typeof (TokenKwFinal)));
            kws.Add ("get",         GetTokenCtor (typeof (TokenKwGet)));
            kws.Add ("interface",   GetTokenCtor (typeof (TokenKwInterface)));
            kws.Add ("new",         GetTokenCtor (typeof (TokenKwNew)));
            kws.Add ("override",    GetTokenCtor (typeof (TokenKwOverride)));
            kws.Add ("partial",     GetTokenCtor (typeof (TokenKwPartial)));
            kws.Add ("private",     GetTokenCtor (typeof (TokenKwPrivate)));
            kws.Add ("protected",   GetTokenCtor (typeof (TokenKwProtected)));
            kws.Add ("public",      GetTokenCtor (typeof (TokenKwPublic)));
            kws.Add ("set",         GetTokenCtor (typeof (TokenKwSet)));
            kws.Add ("static",      GetTokenCtor (typeof (TokenKwStatic)));
            kws.Add ("this",        GetTokenCtor (typeof (TokenKwThis)));
            kws.Add ("typedef",     GetTokenCtor (typeof (TokenKwTypedef)));
            kws.Add ("virtual",     GetTokenCtor (typeof (TokenKwVirtual)));

            return kws;
        }

        private static Dictionary<string, System.Reflection.ConstructorInfo> BuildCharsKeywords ()
        {
            Dictionary<string, System.Reflection.ConstructorInfo> kws = new Dictionary<string, System.Reflection.ConstructorInfo> ();

            kws.Add ("char", GetTokenCtor (typeof (TokenTypeChar)));

            return kws;
        }

        /**
         * @brief Create a URL from a base URL and a relative string
         * @param oldurl = base url string
         * @param relurl = relative url
         * @returns new url string
         */
        private static string CreateURL (string oldurl, string relurl)
        {
            if (relurl.IndexOf ("://") >= 0) return relurl;
            StringBuilder newurl = new StringBuilder (oldurl.Length + relurl.Length);
            if (relurl[0] == '/') {
                // file:///oldname + /newname => file:///newname
                // http://webserver.com/oldname + /newname => http://webserver.com/newname
                int i = oldurl.IndexOf ("://") + 3;
                int j = oldurl.IndexOf ('/', i);
                if (j < 0) j = oldurl.Length;
                newurl.Append (oldurl.Substring (0, j));
                newurl.Append (relurl);
            } else {
                // file:///oldname + newname => file:///newname
                // http://webserver.com/oldname + newname => http://webserver.com/newname
                int i = oldurl.LastIndexOf ('/') + 1;
                newurl.Append (oldurl.Substring (0, i));
                newurl.Append (relurl);
            }
            return newurl.ToString ();
        }

        /**
         * @brief Read source file from a webserver somewhere out there.
         */
        private const int MAX_INCLUDE_SIZE = 100000;
        private Dictionary<string, string> scriptIncludes = new Dictionary<string, string> ();
        private string ReadSourceFromURL (string url)
        {
            WebResponse response = null;
            Stream stream = null;
            StreamReader reader = null;
            WebRequest request = null;

            try {

                /*
                 * Get stream to read from webserver.
                 */
                if (url.StartsWith ("file://")) {
                    stream   = File.OpenRead (url.Substring (7));
                } else {
                    request  = WebRequest.Create (url);
                    response = request.GetResponse ();
                    stream   = response.GetResponseStream ();
                }
                reader = new StreamReader (stream);

                /*
                 * Read file from stream.
                 */
                char[] buf = new char[4000];
                int len = 0;
                int total = 0;
                List<char[]> fullBuffs = new List<char[]> ();
                string signature = null;

                while (true) {

                    /*
                     * Read a big chunk of characters.
                     */
                    len = reader.ReadBlock (buf, 0, buf.Length);

                    /*
                     * Signature is first line of the first chunk read and must be contained therein.
                     * If an include file with the same signature has already been seen by this script, 
                     * this include file is ignored.
                     */
                    if (signature == null) {
                        signature   = new String (buf, 0, len);
                        int siglen  = signature.IndexOf ('\n');
                        if (siglen <= 0) {
                            throw new Exception ("missing signature in first " + len + " characters: " + url);
                        }
                        signature   = signature.Substring (0, siglen);
                        if (scriptIncludes.ContainsKey (signature)) return null;
                        scriptIncludes.Add (signature, "");
                    }

                    /*
                     * Signature is ok, stash full blocks away and keep reading.
                     * If short read, means we have hit the end of the stream.
                     */
                    total += len;
                    if (total > MAX_INCLUDE_SIZE) {
                        throw new Exception ("script include exceeds maximum " + MAX_INCLUDE_SIZE + ": " + url);
                    }
                    if (len < buf.Length) break;
                    fullBuffs.Add (buf);
                    buf = new char[4000];
                }

                /*
                 * Return the whole thing as one string.
                 */
                StringBuilder sb = new StringBuilder (total + url.Length + 20);
                sb.Append ("# 1 \"");
                sb.Append (url);
                sb.Append ("\"\n");
                foreach (char[] fullBuff in fullBuffs) {
                    sb.Append (fullBuff);
                }
                sb.Append (buf, 0, len);
                return sb.ToString ();
            } finally {
                     if (reader   != null) reader.Close ();
                else if (stream   != null) stream.Close ();
                else if (response != null) response.Close ();
            }
        }
    }

    /**
     * @brief All output token types in addition to TokenBegin.
     *        They are all sub-types of Token.
     */

    public class TokenChar : Token {
        public char val;
        public TokenChar (TokenErrorMessage emsg, string file, int line, int posn, char val) : base (emsg, file, line, posn)
        {
            this.val = val;
        }
        public TokenChar (Token original, char val) : base (original)
        {
            this.val = val;
        }
        public override string ToString ()
        {
            switch (val) {
                case '\'': return "'\\''";
                case '\\': return "'\\\\'";
                case '\n': return "'\\n'";
                case '\t': return "'\\t'";
                default:   return "'" + val + "'";
            }
        }
    }

    public class TokenFloat : Token {
        public SCRIPTFLOAT val;
        public TokenFloat (TokenErrorMessage emsg, string file, int line, int posn, SCRIPTFLOAT val) : base (emsg, file, line, posn)
        {
            this.val = val;
        }
        public override string ToString ()
        {
            return val.ToString ();
        }
    }

    public class TokenInt : Token {
        public int val;
        public TokenInt (TokenErrorMessage emsg, string file, int line, int posn, int val) : base (emsg, file, line, posn)
        {
            this.val = val;
        }
        public TokenInt (Token original, int val) : base (original)
        {
            this.val = val;
        }
        public override string ToString ()
        {
            return val.ToString ();
        }
    }

    public class TokenName : Token {
        public string val;
        public TokenName (TokenErrorMessage emsg, string file, int line, int posn, string val) : base (emsg, file, line, posn)
        {
            this.val = val;
        }
        public TokenName (Token original, string val) : base (original)
        {
            this.val = val;
        }
        public override string ToString ()
        {
            return this.val;
        }
    }

    public class TokenStr : Token {
        public string val;
        public TokenStr (TokenErrorMessage emsg, string file, int line, int posn, string val) : base (emsg, file, line, posn)
        {
            this.val = val;
        }
        public override string ToString ()
        {
            if ((val.IndexOf ('"') < 0) && 
                (val.IndexOf ('\\') < 0) && 
                (val.IndexOf ('\n') < 0) && 
                (val.IndexOf ('\t') < 0)) return "\"" + val + "\"";

            int len = val.Length;
            StringBuilder sb = new StringBuilder (len * 2 + 2);
            sb.Append ('"');
            for (int i = 0; i < len; i ++) {
                char c = val[i];
                switch (c) {
                    case '"': {
                        sb.Append ('\\');
                        sb.Append ('"');
                        break;
                    }
                    case '\\': {
                        sb.Append ('\\');
                        sb.Append ('\\');
                        break;
                    }
                    case '\n': {
                        sb.Append ('\\');
                        sb.Append ('n');
                        break;
                    }
                    case '\t': {
                        sb.Append ('\\');
                        sb.Append ('t');
                        break;
                    }
                    default: {
                        sb.Append (c);
                        break;
                    }
                }
            }
            return sb.ToString ();
        }
    }

    /*
     * This one marks the end-of-file.
     */
    public class TokenEnd : Token { public TokenEnd (TokenErrorMessage emsg, string file, int line, int posn) : base (emsg, file, line, posn) { } }

    /*
     * Various keywords and delimeters.
     */
    public delegate object TokenRValConstBinOpDelegate (object left, object right);
    public delegate object TokenRValConstUnOpDelegate  (object right);

    public class TokenKw : Token {
        public TokenRValConstBinOpDelegate binOpConst;
        public TokenRValConstUnOpDelegate  unOpConst;
        public bool sdtClassOp;
        public TokenKw (TokenErrorMessage emsg, string file, int line, int posn) : base (emsg, file, line, posn) { }
        public TokenKw (Token original) : base (original)  { }
    }
#define DEFTOKENKW(name,str,binopconst,unopconst,sdtcop) \
    public class TokenKw##name : TokenKw {                                                                                \
        public TokenKw##name (TokenErrorMessage emsg, string file, int line, int posn) : base (emsg, file, line, posn) {  \
            binOpConst = TokenRValConstOps.binopconst;                                                                    \
            unOpConst  = TokenRValConstOps.unopconst;                                                                     \
            sdtClassOp = sdtcop;                                                                                          \
        }                                                                                                                 \
        public TokenKw##name (Token original) : base (original) {                                                         \
            binOpConst = TokenRValConstOps.binopconst;                                                                    \
            unOpConst  = TokenRValConstOps.unopconst;                                                                     \
            sdtClassOp = sdtcop;                                                                                          \
        }                                                                                                                 \
        public override string ToString () {                                                                              \
            return str;                                                                                                   \
        }                                                                                                                 \
    }

    DEFTOKENKW(DotDotDot, "...", Null, Null, false)
    DEFTOKENKW(AndAndAnd, "&&&", Null, Null, false)
    DEFTOKENKW(OrOrOr   , "|||", Null, Null, false)
    DEFTOKENKW(AsnLSh   , "<<=", Null, Null, true)
    DEFTOKENKW(AsnRSh   , ">>=", Null, Null, true)
    DEFTOKENKW(CmpLE    , "<=",  Null, Null, true)
    DEFTOKENKW(CmpGE    , ">=",  Null, Null, true)
    DEFTOKENKW(CmpEQ    , "==",  Null, Null, true)
    DEFTOKENKW(CmpNE    , "!=",  Null, Null, true)
    DEFTOKENKW(Incr     , "++",  Null, Null, false)
    DEFTOKENKW(Decr     , "--",  Null, Null, false)
    DEFTOKENKW(AndAnd   , "&&",  Null, Null, true)
    DEFTOKENKW(OrOr     , "||",  Null, Null, true)
    DEFTOKENKW(AsnAdd   , "+=",  Null, Null, true)
    DEFTOKENKW(AsnAnd   , "&=",  Null, Null, true)
    DEFTOKENKW(AsnSub   , "-=",  Null, Null, true)
    DEFTOKENKW(AsnMul   , "*=",  Null, Null, true)
    DEFTOKENKW(AsnDiv   , "/=",  Null, Null, true)
    DEFTOKENKW(AsnMod   , "%=",  Null, Null, true)
    DEFTOKENKW(AsnOr    , "|=",  Null, Null, true)
    DEFTOKENKW(AsnXor   , "^=",  Null, Null, true)
    DEFTOKENKW(LSh      , "<<",  LSh,  Null, true)
    DEFTOKENKW(RSh      , ">>",  RSh,  Null, true)
    DEFTOKENKW(Tilde    , "~",   Null, Not,  true)
    DEFTOKENKW(Exclam   , "!",   Null, Null, true)
    DEFTOKENKW(At       , "@",   Null, Null, false)
    DEFTOKENKW(Mod      , "%",   Mod,  Null, true)
    DEFTOKENKW(Xor      , "^",   Xor,  Null, true)
    DEFTOKENKW(And      , "&",   And,  Null, true)
    DEFTOKENKW(Mul      , "*",   Mul,  Null, true)
    DEFTOKENKW(ParOpen  , "(",   Null, Null, false)
    DEFTOKENKW(ParClose , ")",   Null, Null, false)
    DEFTOKENKW(Sub      , "-",   Sub,  Neg,  true)
    DEFTOKENKW(Add      , "+",   Add,  Null, true)
    DEFTOKENKW(Assign   , "=",   Null, Null, false)
    DEFTOKENKW(BrcOpen  , "{",   Null, Null, false)
    DEFTOKENKW(BrcClose , "}",   Null, Null, false)
    DEFTOKENKW(BrkOpen  , "[",   Null, Null, false)
    DEFTOKENKW(BrkClose , "]",   Null, Null, false)
    DEFTOKENKW(Semi     , ";",   Null, Null, false)
    DEFTOKENKW(Colon    , ":",   Null, Null, false)
    DEFTOKENKW(CmpLT    , "<",   Null, Null, true)
    DEFTOKENKW(CmpGT    , ">",   Null, Null, true)
    DEFTOKENKW(Comma    , ",",   Null, Null, false)
    DEFTOKENKW(Dot      , ".",   Null, Null, false)
    DEFTOKENKW(QMark    , "?",   Null, Null, false)
    DEFTOKENKW(Div      , "/",   Div,  Null, true)
    DEFTOKENKW(Or       , "|",   Or,   Null, true)
    DEFTOKENKW(Hash     , "#",   Null, Null, false)

    DEFTOKENKW(Abstract   , "abstract",    Null, Null, false)
    DEFTOKENKW(Base       , "base",        Null, Null, false)
    DEFTOKENKW(Break      , "break",       Null, Null, false)
    DEFTOKENKW(Case       , "case",        Null, Null, false)
    DEFTOKENKW(Catch      , "catch",       Null, Null, false)
    DEFTOKENKW(Class      , "class",       Null, Null, false)
    DEFTOKENKW(Const      , "constant",    Null, Null, false)
    DEFTOKENKW(Constructor, "constructor", Null, Null, false)
    DEFTOKENKW(Cont       , "continue",    Null, Null, false)
    DEFTOKENKW(Delegate   , "delegate",    Null, Null, false)
    DEFTOKENKW(Default    , "default",     Null, Null, false)
    DEFTOKENKW(Destructor , "destructor",  Null, Null, false)
    DEFTOKENKW(Do         , "do",          Null, Null, false)
    DEFTOKENKW(Else       , "else",        Null, Null, false)
    DEFTOKENKW(Final      , "final",       Null, Null, false)
    DEFTOKENKW(Finally    , "finally",     Null, Null, false)
    DEFTOKENKW(For        , "for",         Null, Null, false)
    DEFTOKENKW(ForEach    , "foreach",     Null, Null, false)
    DEFTOKENKW(Get        , "get",         Null, Null, false)
    DEFTOKENKW(If         , "if",          Null, Null, false)
    DEFTOKENKW(In         , "in",          Null, Null, false)
    DEFTOKENKW(Interface  , "interface",   Null, Null, false)
    DEFTOKENKW(Is         , "is",          Null, Null, false)
    DEFTOKENKW(Jump       , "jump",        Null, Null, false)
    DEFTOKENKW(New        , "new",         Null, Null, false)
    DEFTOKENKW(Override   , "override",    Null, Null, false)
    DEFTOKENKW(Partial    , "partial",     Null, Null, false)
    DEFTOKENKW(Private    , "private",     Null, Null, false)
    DEFTOKENKW(Protected  , "protected",   Null, Null, false)
    DEFTOKENKW(Public     , "public",      Null, Null, false)
    DEFTOKENKW(Ret        , "return",      Null, Null, false)
    DEFTOKENKW(Set        , "set",         Null, Null, false)
    DEFTOKENKW(State      , "state",       Null, Null, false)
    DEFTOKENKW(Static     , "static",      Null, Null, false)
    DEFTOKENKW(Switch     , "switch",      Null, Null, false)
    DEFTOKENKW(This       , "this",        Null, Null, false)
    DEFTOKENKW(Throw      , "throw",       Null, Null, false)
    DEFTOKENKW(Try        , "try",         Null, Null, false)
    DEFTOKENKW(Typedef    , "typedef",     Null, Null, false)
    DEFTOKENKW(Undef      , "undef",       Null, Null, false)
    DEFTOKENKW(Virtual    , "virtual",     Null, Null, false)
    DEFTOKENKW(While      , "while",       Null, Null, false)

    /**
     * @brief These static functions attempt to perform arithmetic on two constant
     *        operands to generate the resultant constant.
     *        Likewise for unary operators.
     *
     * @param left  = left-hand value
     * @param right = right-hand value
     * @returns null: not able to perform computation
     *          else: resultant value object
     *
     * Note: it is ok for these to throw any exception (such as overflow or div-by-zero), 
     *       and it will be treated as the 'not able to perform computation' case.
     */
#define DEFBINOP1(name,op) \
        public static object name (object left, object right)       \
        {                                                           \
            if ((left is int) && (right is int)) {                  \
                return (int)left op (int)right;                     \
            }                                                       \
            if ((left is int) && (right is SCRIPTFLOAT)) {          \
                return (int)left op (SCRIPTFLOAT)right;             \
            }                                                       \
            if ((left is SCRIPTFLOAT) && (right is int)) {          \
                return (SCRIPTFLOAT)left op (int)right;             \
            }                                                       \
            if ((left is SCRIPTFLOAT) && (right is SCRIPTFLOAT)) {  \
                return (SCRIPTFLOAT)left op (SCRIPTFLOAT)right;     \
            }                                                       \
            return null;                                            \
        }

#define DEFBINOP2(name,op) \
        public static object name (object left, object right)              \
        {                                                                  \
            if ((left is int) && (right is int)) {                         \
                return (int)left op (int)right;                            \
            }                                                              \
            if ((left is int) && (right is SCRIPTFLOAT)) {                 \
                return (int)left op (int)(SCRIPTFLOAT)right;               \
            }                                                              \
            if ((left is SCRIPTFLOAT) && (right is int)) {                 \
                return (int)(SCRIPTFLOAT)left op (int)right;               \
            }                                                              \
            if ((left is SCRIPTFLOAT) && (right is SCRIPTFLOAT)) {         \
                return (int)(SCRIPTFLOAT)left op (int)(SCRIPTFLOAT)right;  \
            }                                                              \
            return null;                                                   \
        }

#define DEFBINOP3(name,op) \
        public static object name (object left, object right)                       \
        {                                                                           \
            if ((left is char) && (right is int)) {                                 \
                return (char)((char)left op (int)right);                            \
            }                                                                       \
            if ((left is SCRIPTFLOAT) && (right is SCRIPTFLOAT)) {                  \
                return (SCRIPTFLOAT)left op (SCRIPTFLOAT)right;                     \
            }                                                                       \
            if ((left is SCRIPTFLOAT) && (right is int)) {                          \
                return (SCRIPTFLOAT)left op (int)right;                             \
            }                                                                       \
            if ((left is SCRIPTFLOAT) && (right is string)) {                       \
                return TypeCast.FloatToString((SCRIPTFLOAT)left) op (string)right;  \
            }                                                                       \
            if ((left is int) && (right is SCRIPTFLOAT)) {                          \
                return (int)left op (SCRIPTFLOAT)right;                             \
            }                                                                       \
            if ((left is int) && (right is int)) {                                  \
                return (int)left op (int)right;                                     \
            }                                                                       \
            if ((left is int) && (right is string)) {                               \
                return TypeCast.IntegerToString((int)left) op (string)right;        \
            }                                                                       \
            if ((left is string) && (right is char)) {                              \
                return (string)left op (char)right;                                 \
            }                                                                       \
            if ((left is string) && (right is SCRIPTFLOAT)) {                       \
                return (string)left op TypeCast.FloatToString((SCRIPTFLOAT)right);  \
            }                                                                       \
            if ((left is string) && (right is int)) {                               \
                return (string)left op TypeCast.IntegerToString ((int)right);       \
            }                                                                       \
            if ((left is string) && (right is string)) {                            \
                return (string)left op (string)right;                               \
            }                                                                       \
            return null;                                                            \
        }

#define DEFBINOP4(name,op) \
        public static object name (object left, object right)       \
        {                                                           \
            if ((left is char) && (right is int)) {                 \
                return (char)((char)left op (int)right);            \
            }                                                       \
            if ((left is int) && (right is int)) {                  \
                return (int)left op (int)right;                     \
            }                                                       \
            if ((left is int) && (right is SCRIPTFLOAT)) {          \
                return (int)left op (SCRIPTFLOAT)right;             \
            }                                                       \
            if ((left is SCRIPTFLOAT) && (right is int)) {          \
                return (SCRIPTFLOAT)left op (int)right;             \
            }                                                       \
            if ((left is SCRIPTFLOAT) && (right is SCRIPTFLOAT)) {  \
                return (SCRIPTFLOAT)left op (SCRIPTFLOAT)right;     \
            }                                                       \
            return null;                                            \
        }

#define DEFUNOP1(name,op) \
        public static object name (object right)  \
        {                                         \
            if (right is int) {                   \
                return op (int)right;             \
            }                                     \
            if (right is SCRIPTFLOAT) {           \
                return op (SCRIPTFLOAT)right;     \
            }                                     \
            return null;                          \
        }

#define DEFUNOP2(name,op) \
        public static object name (object right)  \
        {                                         \
            if (right is int) {                   \
                return op (int)right;             \
            }                                     \
            return null;                          \
        }

    public class TokenRValConstOps {
        public static object Null (object left, object right)
        {
            return null;
        }

        DEFBINOP1(Div,/)
        DEFBINOP1(Mod,%)
        DEFBINOP1(Mul,*)

        DEFBINOP2(And,&)
        DEFBINOP2(LSh,<<)
        DEFBINOP2(Or, |)
        DEFBINOP2(RSh,>>)
        DEFBINOP2(Xor,^)

        DEFBINOP3(Add,+)
        DEFBINOP4(Sub,-)

        public static object Null (object right)
        {
            return null;
        }

        DEFUNOP1(Neg,-)
        DEFUNOP2(Not,~)
    }

    /*
     * Various datatypes.
     */
    public abstract class TokenType : Token {

        public TokenType (TokenErrorMessage emsg, string file, int line, int posn) : base (emsg, file, line, posn) { }
        public TokenType (Token original) : base (original) { }

        public static TokenType FromSysType (Token original, System.Type typ)
        {
            if (typ == typeof (LSL_List))     return new TokenTypeList      (original);
            if (typ == typeof (LSL_Rotation)) return new TokenTypeRot       (original);
            if (typ == typeof (void))         return new TokenTypeVoid      (original);
            if (typ == typeof (LSL_Vector))   return new TokenTypeVec       (original);
            if (typ == typeof (float))        return new TokenTypeFloat     (original);
            if (typ == typeof (int))          return new TokenTypeInt       (original);
            if (typ == typeof (string))       return new TokenTypeStr       (original);
            if (typ == typeof (double))       return new TokenTypeFloat     (original);
            if (typ == typeof (bool))         return new TokenTypeBool      (original);
            if (typ == typeof (object))       return new TokenTypeObject    (original);
            if (typ == typeof (XMR_Array))    return new TokenTypeArray     (original);
            if (typ == typeof (LSL_Integer))  return new TokenTypeLSLInt    (original);
            if (typ == typeof (LSL_Float))    return new TokenTypeLSLFloat  (original);
            if (typ == typeof (LSL_String))   return new TokenTypeLSLString (original);
            if (typ == typeof (char))         return new TokenTypeChar      (original);
            if (typ == typeof (Exception))    return new TokenTypeExc       (original);

            throw new Exception ("unknown type " + typ.ToString ());
        }

        public static TokenType FromLSLType (Token original, string typ)
        {
            if (typ == "list")      return new TokenTypeList   (original);
            if (typ == "rotation")  return new TokenTypeRot    (original);
            if (typ == "vector")    return new TokenTypeVec    (original);
            if (typ == "float")     return new TokenTypeFloat  (original);
            if (typ == "integer")   return new TokenTypeInt    (original);
            if (typ == "key")       return new TokenTypeStr    (original);
            if (typ == "string")    return new TokenTypeStr    (original);
            if (typ == "object")    return new TokenTypeObject (original);
            if (typ == "array")     return new TokenTypeArray  (original);
            if (typ == "bool")      return new TokenTypeBool   (original);
            if (typ == "void")      return new TokenTypeVoid   (original);
            if (typ == "char")      return new TokenTypeChar   (original);
            if (typ == "exception") return new TokenTypeExc    (original);

            throw new Exception ("unknown type " + typ);
        }

        /**
         * @brief Estimate the number of bytes of memory taken by one of these
         *        objects.  For objects with widely varying size, return the
         *        smallest it can be.
         */
        public static int StaticSize (System.Type typ)
        {
            if (typ == typeof (LSL_List))     return  96;
            if (typ == typeof (LSL_Rotation)) return  80;
            if (typ == typeof (void))         return   0;
            if (typ == typeof (LSL_Vector))   return  72;
            if (typ == typeof (float))        return   8;
            if (typ == typeof (int))          return   8;
            if (typ == typeof (string))       return  40;
            if (typ == typeof (double))       return   8;
            if (typ == typeof (bool))         return   8;
            if (typ == typeof (XMR_Array))    return  96;
            if (typ == typeof (object))       return  32;
            if (typ == typeof (char))         return   2;

            if (typ == typeof (LSL_Integer))  return  32;
            if (typ == typeof (LSL_Float))    return  32;
            if (typ == typeof (LSL_String))   return  40;

            throw new Exception ("unknown type " + typ.ToString ());
        }

        /**
         * @brief Return the corresponding system type.
         */
        public abstract Type ToSysType ();

        /**
         * @brief Return the equivalent LSL wrapping type.
         *
         *  null: normal
         *  else: LSL-style wrapping, ie, LSL_Integer, LSL_Float, LSL_String
         *        ToSysType()=System.Int32;  lslWrapping=LSL_Integer
         *        ToSysType()=System.Float;  lslWrapping=LSL_Float
         *        ToSysType()=System.String; lslWrapping=LSL_String
         */
        public virtual Type ToLSLWrapType ()
        {
            return null;
        }

        /**
         * @brief Assign slots in either the global variable arrays or the script-defined type instance arrays.
         *        These only need to be implemented for script-visible types, ie, those that a script writer 
         *        can actually define a variable as.
         */
        public virtual void AssignVarSlot (TokenDeclVar declVar, ref XMRInstArSizes arSizes)
        {
            throw new Exception ("not implemented for " + ToString () + " (" + GetType () + ")");
        }
    }

    public class TokenTypeArray : TokenType {
        private static readonly FieldInfo iarArraysFieldInfo = typeof (XMRInstArrays).GetField ("iarArrays");

        public TokenTypeArray (TokenErrorMessage emsg, string file, int line, int posn) : base (emsg, file, line, posn) { }
        public TokenTypeArray (Token original) : base (original) { }
        public override Type ToSysType () { return typeof (XMR_Array); }
        public override string ToString () { return "array"; }
        public override void AssignVarSlot (TokenDeclVar declVar, ref XMRInstArSizes arSizes)
        {
            declVar.vTableArray = iarArraysFieldInfo;
            declVar.vTableIndex = arSizes.iasArrays ++;
        }
    }
    public class TokenTypeBool : TokenType {
        public TokenTypeBool (TokenErrorMessage emsg, string file, int line, int posn) : base (emsg, file, line, posn) { }
        public TokenTypeBool (Token original) : base (original) { }
        public override Type ToSysType () { return typeof (bool); }
        public override string ToString () { return "bool"; }
    }
    public class TokenTypeChar : TokenType {
        private static readonly FieldInfo iarCharsFieldInfo = typeof (XMRInstArrays).GetField ("iarChars");

        public TokenTypeChar (TokenErrorMessage emsg, string file, int line, int posn) : base (emsg, file, line, posn) { }
        public TokenTypeChar (Token original) : base (original) { }
        public override Type ToSysType () { return typeof (char); }
        public override string ToString () { return "char"; }
        public override void AssignVarSlot (TokenDeclVar declVar, ref XMRInstArSizes arSizes)
        {
            declVar.vTableArray = iarCharsFieldInfo;
            declVar.vTableIndex = arSizes.iasChars ++;
        }
    }
    public class TokenTypeExc : TokenType {
        private static readonly FieldInfo iarObjectsFieldInfo = typeof (XMRInstArrays).GetField ("iarObjects");

        public TokenTypeExc (TokenErrorMessage emsg, string file, int line, int posn) : base (emsg, file, line, posn) { }
        public TokenTypeExc (Token original) : base (original) { }
        public override Type ToSysType () { return typeof (Exception); }
        public override string ToString () { return "exception"; }
        public override void AssignVarSlot (TokenDeclVar declVar, ref XMRInstArSizes arSizes)
        {
            declVar.vTableArray = iarObjectsFieldInfo;
            declVar.vTableIndex = arSizes.iasObjects ++;
        }
    }
    public class TokenTypeFloat : TokenType {
        private static readonly FieldInfo iarFloatsFieldInfo = typeof (XMRInstArrays).GetField ("iarFloats");

        public TokenTypeFloat (TokenErrorMessage emsg, string file, int line, int posn) : base (emsg, file, line, posn) { }
        public TokenTypeFloat (Token original) : base (original) { }
        public override Type ToSysType () { return typeof (SCRIPTFLOAT); }
        public override string ToString () { return "float"; }
        public override void AssignVarSlot (TokenDeclVar declVar, ref XMRInstArSizes arSizes)
        {
            declVar.vTableArray = iarFloatsFieldInfo;
            declVar.vTableIndex = arSizes.iasFloats ++;
        }
    }
    public class TokenTypeInt : TokenType {
        private static readonly FieldInfo iarIntegersFieldInfo = typeof (XMRInstArrays).GetField ("iarIntegers");

        public TokenTypeInt (TokenErrorMessage emsg, string file, int line, int posn) : base (emsg, file, line, posn) { }
        public TokenTypeInt (Token original) : base (original) { }
        public override Type ToSysType () { return typeof (int); }
        public override string ToString () { return "integer"; }
        public override void AssignVarSlot (TokenDeclVar declVar, ref XMRInstArSizes arSizes)
        {
            declVar.vTableArray = iarIntegersFieldInfo;
            declVar.vTableIndex = arSizes.iasIntegers ++;
        }
    }
    public class TokenTypeList : TokenType {
        private static readonly FieldInfo iarListsFieldInfo = typeof (XMRInstArrays).GetField ("iarLists");

        public TokenTypeList (TokenErrorMessage emsg, string file, int line, int posn) : base (emsg, file, line, posn) { }
        public TokenTypeList (Token original) : base (original) { }
        public override Type ToSysType () { return typeof (LSL_List); }
        public override string ToString () { return "list"; }
        public override void AssignVarSlot (TokenDeclVar declVar, ref XMRInstArSizes arSizes)
        {
            declVar.vTableArray = iarListsFieldInfo;
            declVar.vTableIndex = arSizes.iasLists ++;
        }
    }
    public class TokenTypeObject : TokenType {
        private static readonly FieldInfo iarObjectsFieldInfo = typeof (XMRInstArrays).GetField ("iarObjects");

        public TokenTypeObject (TokenErrorMessage emsg, string file, int line, int posn) : base (emsg, file, line, posn) { }
        public TokenTypeObject (Token original) : base (original) { }
        public override Type ToSysType () { return typeof (object); }
        public override string ToString () { return "object"; }
        public override void AssignVarSlot (TokenDeclVar declVar, ref XMRInstArSizes arSizes)
        {
            declVar.vTableArray = iarObjectsFieldInfo;
            declVar.vTableIndex = arSizes.iasObjects ++;
        }
    }
    public class TokenTypeRot : TokenType {
        private static readonly FieldInfo iarRotationsFieldInfo = typeof (XMRInstArrays).GetField ("iarRotations");

        public TokenTypeRot (TokenErrorMessage emsg, string file, int line, int posn) : base (emsg, file, line, posn) { }
        public TokenTypeRot (Token original) : base (original) { }
        public override Type ToSysType () { return typeof (LSL_Rotation); }
        public override string ToString () { return "rotation"; }
        public override void AssignVarSlot (TokenDeclVar declVar, ref XMRInstArSizes arSizes)
        {
            declVar.vTableArray = iarRotationsFieldInfo;
            declVar.vTableIndex = arSizes.iasRotations ++;
        }
    }
    public class TokenTypeStr : TokenType {
        private static readonly FieldInfo iarStringsFieldInfo = typeof (XMRInstArrays).GetField ("iarStrings");

        public TokenTypeStr (TokenErrorMessage emsg, string file, int line, int posn) : base (emsg, file, line, posn) { }
        public TokenTypeStr (Token original) : base (original) { }
        public override Type ToSysType () { return typeof (string); }
        public override string ToString () { return "string"; }
        public override void AssignVarSlot (TokenDeclVar declVar, ref XMRInstArSizes arSizes)
        {
            declVar.vTableArray = iarStringsFieldInfo;
            declVar.vTableIndex = arSizes.iasStrings ++;
        }
    }
    public class TokenTypeUndef : TokenType {  // for the 'undef' constant, ie, null object pointer
        public TokenTypeUndef (TokenErrorMessage emsg, string file, int line, int posn) : base (emsg, file, line, posn) { }
        public TokenTypeUndef (Token original) : base (original) { }
        public override Type ToSysType () { return typeof (object); }
        public override string ToString () { return "undef"; }
    }
    public class TokenTypeVec : TokenType {
        private static readonly FieldInfo iarVectorsFieldInfo = typeof (XMRInstArrays).GetField ("iarVectors");

        public TokenTypeVec (TokenErrorMessage emsg, string file, int line, int posn) : base (emsg, file, line, posn) { } 
        public TokenTypeVec (Token original) : base (original) { }
        public override Type ToSysType () { return typeof (LSL_Vector); }
        public override string ToString () { return "vector"; }
        public override void AssignVarSlot (TokenDeclVar declVar, ref XMRInstArSizes arSizes)
        {
            declVar.vTableArray = iarVectorsFieldInfo;
            declVar.vTableIndex = arSizes.iasVectors ++;
        }
    }
    public class TokenTypeVoid : TokenType {  // used only for function/method return types
        public TokenTypeVoid (TokenErrorMessage emsg, string file, int line, int posn) : base (emsg, file, line, posn) { }
        public TokenTypeVoid (Token original) : base (original) { }
        public override Type ToSysType () { return typeof (void); }
        public override string ToString () { return "void"; }
    }

    public class TokenTypeLSLFloat : TokenTypeFloat {
        public TokenTypeLSLFloat (TokenErrorMessage emsg, string file, int line, int posn) : base (emsg, file, line, posn) { }
        public TokenTypeLSLFloat (Token original) : base (original) { }
        public override Type ToLSLWrapType () { return typeof (LSL_Float); }
    }
    public class TokenTypeLSLInt : TokenTypeInt {
        public TokenTypeLSLInt (TokenErrorMessage emsg, string file, int line, int posn) : base (emsg, file, line, posn) { }
        public TokenTypeLSLInt (Token original) : base (original) { }
        public override Type ToLSLWrapType () { return typeof (LSL_Integer); }
    }
    public class TokenTypeLSLString : TokenTypeStr {
        public TokenTypeLSLString (TokenErrorMessage emsg, string file, int line, int posn) : base (emsg, file, line, posn) { }
        public TokenTypeLSLString (Token original) : base (original) { }
        public override Type ToLSLWrapType () { return typeof (LSL_String); }
    }
}
