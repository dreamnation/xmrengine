/***************************************************\
 *  COPYRIGHT 2009, Mike Rieker, Beverly, MA, USA  *
 *  All rights reserved.                           *
\***************************************************/

/**
 * @brief Parse raw source file string into token list.
 *
 * Usage:
 *
 *    emsg = some function to output error messages to
 *    source = string containing entire source file
 *
 *    TokenBegin tokenBegin = TokenBegin.Construct (emsg, source);
 *
 *    tokenBegin = null: tokenizing error
 *                 else: first (dummy) token in file
 *                       the rest are chained by nextToken,prevToken
 *                       final token is always a (dummy) TokenEnd
 */

using System;
using System.Collections.Generic;
using System.Reflection;
using System.Reflection.Emit;
using System.Text;

#include "lsltypes.h"

#define strcasecmp(s,t) String.Compare(s,t,StringComparison.OrdinalIgnoreCase)

namespace OpenSim.Region.ScriptEngine.XMREngine {

    public delegate void TokenErrorMessage (Token token, string message);

    /**
     * @brief base class for all tokens
     */
    public class Token {
        public static readonly int MAX_NAME_LEN = 255;
        public static readonly int MAX_STRING_LEN = 4096;

        public Token nextToken;
        public Token prevToken;

        // used for error message printing
        public TokenErrorMessage emsg;
        public string file = "";
        public int line;
        public int posn;

        /**
         * @brief construct a token coming directly from a source file
         * @param emsg = object that error messages get sent to
         * @param file = source file name (or "" if none)
         * @param line = source file line number
         * @param posn = token's position within that source line
         */
        public Token (TokenErrorMessage emsg, string file, int line, int posn)
        {
            this.emsg = emsg;
            this.file = file;
            this.line = line;
            this.posn = posn;
        }

        /**
         * @brief construct a token with same error message parameters
         * @param original = original token to create from
         */
        public Token (Token original)
        {
            if (original != null) {
                this.emsg = original.emsg;
                this.file = original.file;
                this.line = original.line;
                this.posn = original.posn;
            }
        }

        /**
         * @brief output an error message associated with this token
         *        sends the message to the token's error object
         * @param message = error message string
         */
        public void ErrorMsg (string message)
        {
            if (emsg != null) {
                emsg (this, message);
            }
        }

        /*
         * Generate a unique string (for use in CIL label names, etc)
         */
        public string Unique
        {
            get { return file + "_" + line + "_" + posn; }
        }

        /*
         * Generate source location string (for use in error messages)
         */
        public string SrcLoc
        {
            get { return file + "(" + line + "," + posn + ")"; }
        }

        /*
         * Generate debugging string - should look like source code.
         */
        public virtual void DebString (StringBuilder sb)
        {
            sb.Append (this.ToString ());
        }
    }


    /**
     * @brief token that begins a source file
     *        Along with TokenEnd, it keeps insertion/removal of intermediate tokens
     *        simple as the intermediate tokens always have non-null nextToken,prevToken.
     */
    public class TokenBegin : Token {

        private bool youveAnError;      // there was some error tokenizing
        private int bolIdx;             // index in 'source' at begining of current line
        private int lineNo;             // current line in source file, starting at 0
        private string filNam;          // current source file name
        private string source;          // the whole script source code
        private Token lastToken;        // last token created so far
        private bool optionArrays;      // has seen 'XMROption arrays;'
        private bool optionAdvFlowCtl;  // has seen 'XMROption advFlowCtl;'
        private bool optionTryCatch;    // has seen 'XMROption tryCatch;'
        private bool optionObjects;     // has seen 'XMROption objects;'

        /**
         * @brief convert a source file in the form of a string
         *        to a list of raw tokens
         * @param emsg   = where to output messages to
         * @param source = whole source file contents
         * @returns null: conversion error, message already output
         *          else: list of tokens, starting with TokenBegin, ending with TokenEnd.
         */
        public static TokenBegin Construct (TokenErrorMessage emsg, string source)
        {
            TokenBegin tokenBegin = new TokenBegin (emsg, "", 0, 0);
            tokenBegin.lastToken  = tokenBegin;
            tokenBegin.source     = source;
            tokenBegin.Tokenize ();
            if (tokenBegin.youveAnError) return null;
            tokenBegin.AppendToken (new TokenEnd (emsg, tokenBegin.filNam, ++ tokenBegin.lineNo, 0));
            return tokenBegin;
        }

        private TokenBegin (TokenErrorMessage emsg, string file, int line, int posn) : base (emsg, file, line, posn) { }

        /*
         * Produces raw token stream: names, numbers, strings, keywords/delimeters.
         * @param this.source = whole source file in one string
         * @returns this.nextToken = filled in with tokens
         *          this.youveAnError = true: some tokenizing error
         *                             false: successful
         */
        private void Tokenize ()
        {
            youveAnError = false;
            bolIdx = 0;
            lineNo = 0;
            filNam = "";
            for (int i = 0; i < source.Length; i ++) {
                char c = source[i];
                if (c == '\n') {

                    /*
                     * Increment source line number and set char index of beg of next line.
                     */
                    lineNo ++;
                    bolIdx = i + 1;

                    /*
                     * Check for '#' lineno filename newline
                     * lineno is line number of next line in file
                     * If found, save values and remove tokens from stream
                     */
                    if ((lastToken is TokenStr) &&
                        (lastToken.prevToken is TokenInt) &&
                        (lastToken.prevToken.prevToken is TokenKwHash)) {
                        filNam = ((TokenStr)lastToken).val;
                        lineNo = ((TokenInt)lastToken.prevToken).val;
                        lastToken = lastToken.prevToken.prevToken.prevToken;
                        lastToken.nextToken = null;
                    }
                    continue;
                }

                /*
                 * Skip over whitespace.
                 */
                if (c <= ' ') continue;

                /*
                 * Skip over comments.
                 */
                if ((i + 2 <= source.Length) && source.Substring (i, 2).Equals ("//")) {
                    while ((i < source.Length) && (source[i] != '\n')) i ++;
                    lineNo ++;
                    bolIdx = i + 1;
                    continue;
                }
                if ((i + 2 <= source.Length) && (source.Substring (i, 2).Equals ("/*"))) {
                    while ((i + 1 < source.Length) && (((c = source[i]) != '*') || (source[i+1] != '/'))) {
                        if (c == '\n') {
                            lineNo ++;
                            bolIdx = i + 1;
                        }
                        i ++;
                    }
                    i ++;
                    continue;
                }

                /*
                 * Check for numbers.
                 */
                if ((c >= '0') && (c <= '9')) {
                    int j = TryParseFloat (i);
                    if (j == 0) j = TryParseInt (i);
                    i = -- j;
                    continue;
                }
                if ((c == '.') && (source[i+1] >= '0') && (source[i+1] <= '9')) {
                    int j = TryParseFloat (i);
                    if (j > 0) i = -- j;
                    continue;
                }

                /*
                 * Check for quoted strings.
                 */
                if (c == '"') {
                    StringBuilder sb = new StringBuilder ();
                    bool backslash;
                    int j;

                    backslash = false;
                    for (j = i; ++ j < source.Length;) {
                        c = source[j];
                        if (c == '\\' && !backslash) {
                            backslash = true;
                            continue;
                        }
                        if (c == '\n') {
                            lineNo ++;
                            bolIdx = j + 1;
                        } else {
                            if (!backslash && (c == '"')) break;
                            if (backslash && (c == 'n')) c = '\n';
                        }
                        backslash = false;
                        sb.Append (c);
                    }
                    if (j - i > MAX_STRING_LEN) {
                        TokenError (i, "string too long, max " + MAX_STRING_LEN);
                    } else {
                        AppendToken (new TokenStr (emsg, filNam, lineNo, i - bolIdx, sb.ToString ()));
                    }
                    i = j;
                    continue;
                }

                /*
                 * Check for keywords/names.
                 */
                if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c == '_') || (c == '$')) {
                    int j;

                    for (j = i; ++ j < source.Length;) {
                        c = source[j];
                        if (c >= 'a' && c <= 'z') continue;
                        if (c >= 'A' && c <= 'Z') continue;
                        if (c >= '0' && c <= '9') continue;
                        if (c == '$') continue;
                        if (c != '_') break;
                    }
                    if (j - i > MAX_NAME_LEN) {
                        TokenError (i, "name too long, max " + MAX_NAME_LEN);
                    } else {
                        string name = source.Substring (i, j - i);
                        if (keywords.ContainsKey (name)) {
                            Object[] args = new Object[] { emsg, filNam, lineNo, i - bolIdx };
                            AppendToken ((Token)keywords[name].Invoke (args));
                        } else if (optionArrays && arrayKeywords.ContainsKey (name)) {
                            Object[] args = new Object[] { emsg, filNam, lineNo, i - bolIdx };
                            AppendToken ((Token)arrayKeywords[name].Invoke (args));
                        } else if (optionAdvFlowCtl && advFlowCtlKeywords.ContainsKey (name)) {
                            Object[] args = new Object[] { emsg, filNam, lineNo, i - bolIdx };
                            AppendToken ((Token)advFlowCtlKeywords[name].Invoke (args));
                        } else if (optionTryCatch && tryCatchKeywords.ContainsKey (name)) {
                            Object[] args = new Object[] { emsg, filNam, lineNo, i - bolIdx };
                            AppendToken ((Token)tryCatchKeywords[name].Invoke (args));
                        } else if (optionObjects && objectsKeywords.ContainsKey (name)) {
                            Object[] args = new Object[] { emsg, filNam, lineNo, i - bolIdx };
                            AppendToken ((Token)objectsKeywords[name].Invoke (args));
                        } else {
                            AppendToken (new TokenName (emsg, filNam, lineNo, i - bolIdx, name));
                        }
                    }
                    i = -- j;
                    continue;
                }

                /*
                 * Check for option enables.
                 */
                if ((c == ';') && (lastToken is TokenName) && 
                    (lastToken.prevToken is TokenName) && 
                    (strcasecmp(((TokenName)lastToken.prevToken).val, "xmroption") == 0)) {
                    string opt = ((TokenName)lastToken).val;
                    if (strcasecmp (opt, "arrays") == 0) {
                        optionArrays = true;
                    } else if (strcasecmp (opt, "advflowctl") == 0) {
                        optionAdvFlowCtl = true;
                    } else if (strcasecmp (opt, "trycatch") == 0) {
                        optionTryCatch = true;
                    } else if (strcasecmp (opt, "objects") == 0) {
                        optionObjects = true;
                    } else {
                        lastToken.ErrorMsg ("unknown XMROption");
                    }
                    lastToken = lastToken.prevToken.prevToken;
                    lastToken.nextToken = null;
                    continue;
                }

                /*
                 * Lastly, check for delimeters.
                 */
                {
                    int j;
                    int len = 0;

                    for (j = 0; j < delims.Length; j ++) {
                        len = delims[j].str.Length;
                        if ((i + len <= source.Length) && (source.Substring (i, len).Equals (delims[j].str))) break;
                    }
                    if (j < delims.Length) {
                        Object[] args = { emsg, filNam, lineNo, i - bolIdx };
                        Token kwToken = (Token)delims[j].ctorInfo.Invoke (args);
                        AppendToken (kwToken);
                        i += -- len;
                        continue;
                    }
                }

                /*
                 * Don't know what it is!
                 */
                TokenError (i, "unknown character '" + c + "'");
            }
        }

        /**
         * @brief try to parse a floating-point number from the source
         * @param i = starting position within this.source of number
         * @returns 0: not a floating point number, try something else
         *       else: position in this.source of terminating character, ie, past number
         *             TokenFloat appended to token list
         *             or error message has been output
         */
        private int TryParseFloat (int i)
        {
            bool decimals, error, negexp, nulexp;
            char c;
            double f, f10;
            int exponent, j, x, y;
            ulong m, mantissa;

            decimals = false;
            error    = false;
            exponent = 0;
            mantissa = 0;
            for (j = i; j < source.Length; j ++) {
                c = source[j];
                if ((c >= '0') && (c <= '9')) {
                    m = mantissa * 10 + (ulong)(c - '0');
                    if (m / 10 != mantissa) {
                        if (!decimals) exponent ++;
                    } else {
                        mantissa = m;
                        if (decimals) exponent --;
                    }
                    continue;
                }
                if (c == '.') {
                    if (decimals) {
                        TokenError (i, "more than one decimal point");
                        return j;
                    }
                    decimals = true;
                    continue;
                }
                if ((c == 'E') || (c == 'e')) {
                    if (++ j >= source.Length) {
                        TokenError (i, "floating exponent off end of source");
                        return j;
                    }
                    c = source[j];
                    negexp = (c == '-');
                    if (negexp || (c == '+')) j ++;
                    y = 0;
                    nulexp = true;
                    for (; j < source.Length; j ++) {
                        c = source[j];
                        if ((c < '0') || (c > '9')) break;
                        x = y * 10 + (c - '0');
                        if (x / 10 != y) {
                            if (!error) TokenError (i, "floating exponent overflow");
                            error = true;
                        }
                        y = x;
                        nulexp = false;
                    }
                    if (nulexp) {
                        TokenError (i, "bad or missing floating exponent");
                        return j;
                    }
                    if (negexp) {
                        x = exponent - y;
                        if (x > exponent) {
                            if (!error) TokenError (i, "floating exponent overflow");
                            error = true;
                        }
                    } else {
                        x = exponent + y;
                        if (x < exponent) {
                            if (!error) TokenError (i, "floating exponent overflow");
                            error = true;
                        }
                    }
                    exponent = x;
                }
                break;
            }
            if (!decimals) {
                return 0;
            }

            f = mantissa;
            if ((exponent != 0) && (mantissa != 0) && !error) {
                f10 = 10.0;
                if (exponent < 0) {
                    exponent = -exponent;
                    while (exponent > 0) {
                        if ((exponent & 1) != 0) {
                            f /= f10;
                        }
                        exponent /= 2;
                        f10 *= f10;
                    }
                } else {
                    while (exponent > 0) {
                        if ((exponent & 1) != 0) {
                            f *= f10;
                        }
                        exponent /= 2;
                        f10 *= f10;
                    }
                }
            }
            if (!error) {
                AppendToken (new TokenFloat (emsg, filNam, lineNo, i - bolIdx, f));
            }
            return j;
        }

        /**
         * @brief try to parse an integer number from the source
         * @param i = starting position within this.source of number
         * @returns 0: not an integer number, try something else
         *       else: position in this.source of terminating character, ie, past number
         *             TokenInt appended to token list
         *             or error message has been output
         */
        private int TryParseInt (int i)
        {
            bool error;
            char c;
            int j;
            uint basse, m, mantissa;

            basse    = 10;
            error    = false;
            mantissa = 0;
            for (j = i; j < source.Length; j ++) {
                c = source[j];
                if ((c >= '0') && (c <= '9')) {
                    m = mantissa * basse + (uint)(c - '0');
                    if (m / basse != mantissa) {
                        if (!error) TokenError (i, "integer overflow");
                        error = true;
                    }
                    mantissa = m;
                    continue;
                }
                if ((basse == 16) && ((c >= 'A') && (c <= 'F'))) {
                    m = mantissa * basse + (uint)(c - 'A') + 10U;
                    if (m / basse != mantissa) {
                        if (!error) TokenError (i, "integer overflow");
                        error = true;
                    }
                    mantissa = m;
                    continue;
                }
                if ((basse == 16) && ((c >= 'a') && (c <= 'f'))) {
                    m = mantissa * basse + (uint)(c - 'a') + 10U;
                    if (m / basse != mantissa) {
                        if (!error) TokenError (i, "integer overflow");
                        error = true;
                    }
                    mantissa = m;
                    continue;
                }
                if (((c == 'x') || (c == 'X')) && (mantissa == 0) && (basse == 10)) {
                    basse = 16;
                    continue;
                }
                break;
            }
            if (!error) {
                AppendToken (new TokenInt (emsg, filNam, lineNo, i - bolIdx, (int)mantissa));
            }
            return j;
        }

        /**
         * @brief append token on to end of list
         * @param newToken = token to append
         * @returns with token appended onto this.lastToken
         */
        private void AppendToken (Token newToken)
        {
            newToken.nextToken  = null;
            newToken.prevToken  = lastToken;
            lastToken.nextToken = newToken;
            lastToken           = newToken;
        }

        /**
         * @brief print tokenizing error message
         *        and remember that we've an error
         * @param i = position within source file of the error
         * @param message = error message text
         * @returns with this.youveAnError set
         */
        private void TokenError (int i, string message)
        {
            Token temp = new Token (this.emsg, this.filNam, this.lineNo, i - this.bolIdx);
            temp.ErrorMsg (message);
            youveAnError = true;
        }

        /**
         * @brief get a token's constructor
         * @param tokenType = token's type
         * @returns token's constructor
         */
        private static Type[] constrTypes = new Type[] {
            typeof (TokenErrorMessage), typeof (string), typeof (int), typeof (int)
        };

        private static System.Reflection.ConstructorInfo GetTokenCtor (Type tokenType)
        {
            return tokenType.GetConstructor (constrTypes);
        }

        /**
         * @brief delimeter table
         */
        private class Delim {
            public string str;
            public System.Reflection.ConstructorInfo ctorInfo;
            public Delim (string str, Type type)
            {
                this.str = str;
                ctorInfo = GetTokenCtor (type);
            }
        }

        private static Delim[] delims = new Delim[] {
            new Delim ("...", typeof (TokenKwDotDotDot)),
            new Delim ("<<=", typeof (TokenKwAsnLSh)),
            new Delim (">>=", typeof (TokenKwAsnRSh)),
            new Delim ("<=",  typeof (TokenKwCmpLE)),
            new Delim (">=",  typeof (TokenKwCmpGE)),
            new Delim ("==",  typeof (TokenKwCmpEQ)),
            new Delim ("!=",  typeof (TokenKwCmpNE)),
            new Delim ("++",  typeof (TokenKwIncr)),
            new Delim ("--",  typeof (TokenKwDecr)),
            new Delim ("&&",  typeof (TokenKwAndAnd)),
            new Delim ("||",  typeof (TokenKwOrOr)),
            new Delim ("+=",  typeof (TokenKwAsnAdd)),
            new Delim ("&=",  typeof (TokenKwAsnAnd)),
            new Delim ("-=",  typeof (TokenKwAsnSub)),
            new Delim ("*=",  typeof (TokenKwAsnMul)),
            new Delim ("/=",  typeof (TokenKwAsnDiv)),
            new Delim ("%=",  typeof (TokenKwAsnMod)),
            new Delim ("|=",  typeof (TokenKwAsnOr)),
            new Delim ("^=",  typeof (TokenKwAsnXor)),
            new Delim ("<<",  typeof (TokenKwLSh)),
            new Delim (">>",  typeof (TokenKwRSh)),
            new Delim ("~",   typeof (TokenKwTilde)),
            new Delim ("!",   typeof (TokenKwExclam)),
            new Delim ("@",   typeof (TokenKwAt)),
            new Delim ("%",   typeof (TokenKwMod)),
            new Delim ("^",   typeof (TokenKwXor)),
            new Delim ("&",   typeof (TokenKwAnd)),
            new Delim ("*",   typeof (TokenKwMul)),
            new Delim ("(",   typeof (TokenKwParOpen)),
            new Delim (")",   typeof (TokenKwParClose)),
            new Delim ("-",   typeof (TokenKwSub)),
            new Delim ("+",   typeof (TokenKwAdd)),
            new Delim ("=",   typeof (TokenKwAssign)),
            new Delim ("{",   typeof (TokenKwBrcOpen)),
            new Delim ("}",   typeof (TokenKwBrcClose)),
            new Delim ("[",   typeof (TokenKwBrkOpen)),
            new Delim ("]",   typeof (TokenKwBrkClose)),
            new Delim (";",   typeof (TokenKwSemi)),
            new Delim (":",   typeof (TokenKwColon)),
            new Delim ("<",   typeof (TokenKwCmpLT)),
            new Delim (">",   typeof (TokenKwCmpGT)),
            new Delim (",",   typeof (TokenKwComma)),
            new Delim (".",   typeof (TokenKwDot)),
            new Delim ("?",   typeof (TokenKwQMark)),
            new Delim ("/",   typeof (TokenKwDiv)),
            new Delim ("|",   typeof (TokenKwOr)),
            new Delim ("#",   typeof (TokenKwHash))
        };

        /**
         * @brief keyword tables
         *        The keyword tables translate a keyword string
         *        to the corresponding token constructor.
         */
        private static Dictionary<string, System.Reflection.ConstructorInfo> keywords           = BuildKeywords ();
        private static Dictionary<string, System.Reflection.ConstructorInfo> arrayKeywords      = BuildArrayKeywords ();
        private static Dictionary<string, System.Reflection.ConstructorInfo> advFlowCtlKeywords = BuildAdvFlowCtlKeywords ();
        private static Dictionary<string, System.Reflection.ConstructorInfo> tryCatchKeywords   = BuildTryCatchKeywords ();
        private static Dictionary<string, System.Reflection.ConstructorInfo> objectsKeywords    = BuildObjectsKeywords ();

        private static Dictionary<string, System.Reflection.ConstructorInfo> BuildKeywords ()
        {
            Dictionary<string, System.Reflection.ConstructorInfo> kws = new Dictionary<string, System.Reflection.ConstructorInfo> ();

            kws.Add ("default",  GetTokenCtor (typeof (TokenKwDefault)));
            kws.Add ("do",       GetTokenCtor (typeof (TokenKwDo)));
            kws.Add ("else",     GetTokenCtor (typeof (TokenKwElse)));
            kws.Add ("float",    GetTokenCtor (typeof (TokenTypeFloat)));
            kws.Add ("for",      GetTokenCtor (typeof (TokenKwFor)));
            kws.Add ("if",       GetTokenCtor (typeof (TokenKwIf)));
            kws.Add ("integer",  GetTokenCtor (typeof (TokenTypeInt)));
            kws.Add ("list",     GetTokenCtor (typeof (TokenTypeList)));
            kws.Add ("jump",     GetTokenCtor (typeof (TokenKwJump)));
            kws.Add ("key",      GetTokenCtor (typeof (TokenTypeStr)));
            kws.Add ("return",   GetTokenCtor (typeof (TokenKwRet)));
            kws.Add ("rotation", GetTokenCtor (typeof (TokenTypeRot)));
            kws.Add ("state",    GetTokenCtor (typeof (TokenKwState)));
            kws.Add ("string",   GetTokenCtor (typeof (TokenTypeStr)));
            kws.Add ("vector",   GetTokenCtor (typeof (TokenTypeVec)));
            kws.Add ("while",    GetTokenCtor (typeof (TokenKwWhile)));

            return kws;
        }

        private static Dictionary<string, System.Reflection.ConstructorInfo> BuildArrayKeywords ()
        {
            Dictionary<string, System.Reflection.ConstructorInfo> kws = new Dictionary<string, System.Reflection.ConstructorInfo> ();

            kws.Add ("array",   GetTokenCtor (typeof (TokenTypeArray)));
            kws.Add ("foreach", GetTokenCtor (typeof (TokenKwForEach)));
            kws.Add ("in",      GetTokenCtor (typeof (TokenKwIn)));
            kws.Add ("is",      GetTokenCtor (typeof (TokenKwIs)));
            kws.Add ("object",  GetTokenCtor (typeof (TokenTypeObject)));
            kws.Add ("undef",   GetTokenCtor (typeof (TokenKwUndef)));

            return kws;
        }

        private static Dictionary<string, System.Reflection.ConstructorInfo> BuildAdvFlowCtlKeywords ()
        {
            Dictionary<string, System.Reflection.ConstructorInfo> kws = new Dictionary<string, System.Reflection.ConstructorInfo> ();

            kws.Add ("break",    GetTokenCtor (typeof (TokenKwBreak)));
            kws.Add ("case",     GetTokenCtor (typeof (TokenKwCase)));
            kws.Add ("constant", GetTokenCtor (typeof (TokenKwConst)));
            kws.Add ("continue", GetTokenCtor (typeof (TokenKwCont)));
            kws.Add ("switch",   GetTokenCtor (typeof (TokenKwSwitch)));

            return kws;
        }

        private static Dictionary<string, System.Reflection.ConstructorInfo> BuildTryCatchKeywords ()
        {
            Dictionary<string, System.Reflection.ConstructorInfo> kws = new Dictionary<string, System.Reflection.ConstructorInfo> ();

            kws.Add ("catch",   GetTokenCtor (typeof (TokenKwCatch)));
            kws.Add ("finally", GetTokenCtor (typeof (TokenKwFinally)));
            kws.Add ("throw",   GetTokenCtor (typeof (TokenKwThrow)));
            kws.Add ("try",     GetTokenCtor (typeof (TokenKwTry)));

            return kws;
        }

        private static Dictionary<string, System.Reflection.ConstructorInfo> BuildObjectsKeywords ()
        {
            Dictionary<string, System.Reflection.ConstructorInfo> kws = new Dictionary<string, System.Reflection.ConstructorInfo> ();

            kws.Add ("abstract",    GetTokenCtor (typeof (TokenKwAbstract)));
            kws.Add ("base",        GetTokenCtor (typeof (TokenKwBase)));
            kws.Add ("class",       GetTokenCtor (typeof (TokenKwClass)));
            kws.Add ("constructor", GetTokenCtor (typeof (TokenKwConstructor)));
            kws.Add ("delegate",    GetTokenCtor (typeof (TokenKwDelegate)));
            kws.Add ("destructor",  GetTokenCtor (typeof (TokenKwDestructor)));
            kws.Add ("final",       GetTokenCtor (typeof (TokenKwFinal)));
            kws.Add ("get",         GetTokenCtor (typeof (TokenKwGet)));
            kws.Add ("interface",   GetTokenCtor (typeof (TokenKwInterface)));
            kws.Add ("new",         GetTokenCtor (typeof (TokenKwNew)));
            kws.Add ("override",    GetTokenCtor (typeof (TokenKwOverride)));
            kws.Add ("private",     GetTokenCtor (typeof (TokenKwPrivate)));
            kws.Add ("protected",   GetTokenCtor (typeof (TokenKwProtected)));
            kws.Add ("public",      GetTokenCtor (typeof (TokenKwPublic)));
            kws.Add ("set",         GetTokenCtor (typeof (TokenKwSet)));
            kws.Add ("static",      GetTokenCtor (typeof (TokenKwStatic)));
            kws.Add ("this",        GetTokenCtor (typeof (TokenKwThis)));
            kws.Add ("virtual",     GetTokenCtor (typeof (TokenKwVirtual)));

            return kws;
        }
    }

    /**
     * @brief All output token types in addition to TokenBegin.
     *        They are all sub-types of Token.
     */

    public class TokenFloat : Token {
        public SCRIPTFLOAT val;
        public TokenFloat (TokenErrorMessage emsg, string file, int line, int posn, SCRIPTFLOAT val) : base (emsg, file, line, posn)
        {
            this.val = val;
        }
        // debugging
        public override string ToString ()
        {
            return val.ToString ();
        }
    }

    public class TokenInt : Token {
        public int val;
        public TokenInt (TokenErrorMessage emsg, string file, int line, int posn, int val) : base (emsg, file, line, posn)
        {
            this.val = val;
        }
        // debugging
        public override string ToString ()
        {
            return val.ToString ();
        }
    }

    public class TokenName : Token {
        public string val;
        public TokenName (TokenErrorMessage emsg, string file, int line, int posn, string val) : base (emsg, file, line, posn)
        {
            this.val = val;
        }
        public TokenName (Token original, string val) : base (original)
        {
            this.val = val;
        }
        public override string ToString ()
        {
            return this.val;
        }
    }

    public class TokenStr : Token {
        public string val;
        public TokenStr (TokenErrorMessage emsg, string file, int line, int posn, string val) : base (emsg, file, line, posn)
        {
            this.val = val;
        }
        // debugging
        public override string ToString ()
        {
            return "\"" + val + "\"";
        }
    }

    /*
     * This one marks the end-of-file.
     */
    public class TokenEnd : Token { public TokenEnd (TokenErrorMessage emsg, string file, int line, int posn) : base (emsg, file, line, posn) { } }

    /*
     * Various keywords and delimeters.
     */
    public delegate object TokenRValConstBinOpDelegate (object left, object right);
    public delegate object TokenRValConstUnOpDelegate  (object right);

    public class TokenKw : Token {
        public TokenRValConstBinOpDelegate binOpConst;
        public TokenRValConstUnOpDelegate  unOpConst;
        public bool sdtClassOp;
        public TokenKw (TokenErrorMessage emsg, string file, int line, int posn) : base (emsg, file, line, posn) { }
        public TokenKw (Token original) : base (original)  { }
    }
#define DEFTOKENKW(name,str,binopconst,unopconst,sdtcop) \
    public class TokenKw##name : TokenKw {                                                                                \
        public TokenKw##name (TokenErrorMessage emsg, string file, int line, int posn) : base (emsg, file, line, posn) {  \
            binOpConst = TokenRValConstOps.binopconst;                                                                    \
            unOpConst  = TokenRValConstOps.unopconst;                                                                     \
            sdtClassOp = sdtcop;                                                                                          \
        }                                                                                                                 \
        public TokenKw##name (Token original) : base (original) {                                                         \
            binOpConst = TokenRValConstOps.binopconst;                                                                    \
            unOpConst  = TokenRValConstOps.unopconst;                                                                     \
        }                                                                                                                 \
        public override string ToString () {                                                                              \
            return str;                                                                                                   \
        }                                                                                                                 \
    }

    DEFTOKENKW(DotDotDot, "...", Null, Null, false)
    DEFTOKENKW(AsnLSh   , "<<=", Null, Null, true)
    DEFTOKENKW(AsnRSh   , ">>=", Null, Null, true)
    DEFTOKENKW(CmpLE    , "<=",  Null, Null, true)
    DEFTOKENKW(CmpGE    , ">=",  Null, Null, true)
    DEFTOKENKW(CmpEQ    , "==",  Null, Null, true)
    DEFTOKENKW(CmpNE    , "!=",  Null, Null, true)
    DEFTOKENKW(Incr     , "++",  Null, Null, false)
    DEFTOKENKW(Decr     , "--",  Null, Null, false)
    DEFTOKENKW(AndAnd   , "&&",  Null, Null, true)
    DEFTOKENKW(OrOr     , "||",  Null, Null, true)
    DEFTOKENKW(AsnAdd   , "+=",  Null, Null, true)
    DEFTOKENKW(AsnAnd   , "&=",  Null, Null, true)
    DEFTOKENKW(AsnSub   , "-=",  Null, Null, true)
    DEFTOKENKW(AsnMul   , "*=",  Null, Null, true)
    DEFTOKENKW(AsnDiv   , "/=",  Null, Null, true)
    DEFTOKENKW(AsnMod   , "%=",  Null, Null, true)
    DEFTOKENKW(AsnOr    , "|=",  Null, Null, true)
    DEFTOKENKW(AsnXor   , "^=",  Null, Null, true)
    DEFTOKENKW(LSh      , "<<",  LSh,  Null, true)
    DEFTOKENKW(RSh      , ">>",  RSh,  Null, true)
    DEFTOKENKW(Tilde    , "~",   Null, Not,  true)
    DEFTOKENKW(Exclam   , "!",   Null, Null, true)
    DEFTOKENKW(At       , "@",   Null, Null, false)
    DEFTOKENKW(Mod      , "%",   Mod,  Null, true)
    DEFTOKENKW(Xor      , "^",   Xor,  Null, true)
    DEFTOKENKW(And      , "&",   And,  Null, true)
    DEFTOKENKW(Mul      , "*",   Mul,  Null, true)
    DEFTOKENKW(ParOpen  , "(",   Null, Null, false)
    DEFTOKENKW(ParClose , ")",   Null, Null, false)
    DEFTOKENKW(Sub      , "-",   Sub,  Neg,  true)
    DEFTOKENKW(Add      , "+",   Add,  Null, true)
    DEFTOKENKW(Assign   , "=",   Null, Null, false)
    DEFTOKENKW(BrcOpen  , "{",   Null, Null, false)
    DEFTOKENKW(BrcClose , "}",   Null, Null, false)
    DEFTOKENKW(BrkOpen  , "[",   Null, Null, false)
    DEFTOKENKW(BrkClose , "]",   Null, Null, false)
    DEFTOKENKW(Semi     , ";",   Null, Null, false)
    DEFTOKENKW(Colon    , ":",   Null, Null, false)
    DEFTOKENKW(CmpLT    , "<",   Null, Null, true)
    DEFTOKENKW(CmpGT    , ">",   Null, Null, true)
    DEFTOKENKW(Comma    , ",",   Null, Null, false)
    DEFTOKENKW(Dot      , ".",   Null, Null, false)
    DEFTOKENKW(QMark    , "?",   Null, Null, false)
    DEFTOKENKW(Div      , "/",   Div,  Null, true)
    DEFTOKENKW(Or       , "|",   Or,   Null, true)
    DEFTOKENKW(Hash     , "#",   Null, Null, false)

    DEFTOKENKW(Abstract   , "abstract",    Null, Null, false)
    DEFTOKENKW(Base       , "base",        Null, Null, false)
    DEFTOKENKW(Break      , "break",       Null, Null, false)
    DEFTOKENKW(Case       , "case",        Null, Null, false)
    DEFTOKENKW(Catch      , "catch",       Null, Null, false)
    DEFTOKENKW(Class      , "class",       Null, Null, false)
    DEFTOKENKW(Const      , "constant",    Null, Null, false)
    DEFTOKENKW(Constructor, "constructor", Null, Null, false)
    DEFTOKENKW(Cont       , "continue",    Null, Null, false)
    DEFTOKENKW(Delegate   , "delegate",    Null, Null, false)
    DEFTOKENKW(Default    , "default",     Null, Null, false)
    DEFTOKENKW(Destructor , "destructor",  Null, Null, false)
    DEFTOKENKW(Do         , "do",          Null, Null, false)
    DEFTOKENKW(Else       , "else",        Null, Null, false)
    DEFTOKENKW(Final      , "final",       Null, Null, false)
    DEFTOKENKW(Finally    , "finally",     Null, Null, false)
    DEFTOKENKW(For        , "for",         Null, Null, false)
    DEFTOKENKW(ForEach    , "foreach",     Null, Null, false)
    DEFTOKENKW(Get        , "get",         Null, Null, false)
    DEFTOKENKW(If         , "if",          Null, Null, false)
    DEFTOKENKW(In         , "in",          Null, Null, false)
    DEFTOKENKW(Interface  , "interface",   Null, Null, false)
    DEFTOKENKW(Is         , "is",          Null, Null, false)
    DEFTOKENKW(Jump       , "jump",        Null, Null, false)
    DEFTOKENKW(New        , "new",         Null, Null, false)
    DEFTOKENKW(Override   , "override",    Null, Null, false)
    DEFTOKENKW(Private    , "private",     Null, Null, false)
    DEFTOKENKW(Protected  , "protected",   Null, Null, false)
    DEFTOKENKW(Public     , "public",      Null, Null, false)
    DEFTOKENKW(Ret        , "return",      Null, Null, false)
    DEFTOKENKW(Set        , "set",         Null, Null, false)
    DEFTOKENKW(State      , "state",       Null, Null, false)
    DEFTOKENKW(Static     , "static",      Null, Null, false)
    DEFTOKENKW(Switch     , "switch",      Null, Null, false)
    DEFTOKENKW(This       , "this",        Null, Null, false)
    DEFTOKENKW(Throw      , "throw",       Null, Null, false)
    DEFTOKENKW(Try        , "try",         Null, Null, false)
    DEFTOKENKW(Undef      , "undef",       Null, Null, false)
    DEFTOKENKW(Virtual    , "virtual",     Null, Null, false)
    DEFTOKENKW(While      , "while",       Null, Null, false)

    /**
     * @brief These static functions attempt to perform arithmetic on two constant
     *        operands to generate the resultant constant.
     *        Likewise for unary operators.
     *
     * @param left  = left-hand value
     * @param right = right-hand value
     * @returns null: not able to perform computation
     *          else: resultant value object
     *
     * Note: it is ok for these to throw any exception (such as overflow or div-by-zero), 
     *       and it will be treated as the 'not able to perform computation' case.
     */
#define DEFBINOP1(name,op) \
        public static object name (object left, object right)       \
        {                                                           \
            if ((left is int) && (right is int)) {                  \
                return (int)left op (int)right;                     \
            }                                                       \
            if ((left is int) && (right is SCRIPTFLOAT)) {          \
                return (int)left op (SCRIPTFLOAT)right;             \
            }                                                       \
            if ((left is SCRIPTFLOAT) && (right is int)) {          \
                return (SCRIPTFLOAT)left op (int)right;             \
            }                                                       \
            if ((left is SCRIPTFLOAT) && (right is SCRIPTFLOAT)) {  \
                return (SCRIPTFLOAT)left op (SCRIPTFLOAT)right;     \
            }                                                       \
            return null;                                            \
        }

#define DEFBINOP2(name,op) \
        public static object name (object left, object right)              \
        {                                                                  \
            if ((left is int) && (right is int)) {                         \
                return (int)left op (int)right;                            \
            }                                                              \
            if ((left is int) && (right is SCRIPTFLOAT)) {                 \
                return (int)left op (int)(SCRIPTFLOAT)right;               \
            }                                                              \
            if ((left is SCRIPTFLOAT) && (right is int)) {                 \
                return (int)(SCRIPTFLOAT)left op (int)right;               \
            }                                                              \
            if ((left is SCRIPTFLOAT) && (right is SCRIPTFLOAT)) {         \
                return (int)(SCRIPTFLOAT)left op (int)(SCRIPTFLOAT)right;  \
            }                                                              \
            return null;                                                   \
        }

#define DEFBINOP3(name,op) \
        public static object name (object left, object right)                       \
        {                                                                           \
            if ((left is SCRIPTFLOAT) && (right is SCRIPTFLOAT)) {                  \
                return (SCRIPTFLOAT)left op (SCRIPTFLOAT)right;                     \
            }                                                                       \
            if ((left is SCRIPTFLOAT) && (right is int)) {                          \
                return (SCRIPTFLOAT)left op (int)right;                             \
            }                                                                       \
            if ((left is SCRIPTFLOAT) && (right is string)) {                       \
                return TypeCast.FloatToString((SCRIPTFLOAT)left) op (string)right;  \
            }                                                                       \
            if ((left is int) && (right is SCRIPTFLOAT)) {                          \
                return (int)left op (SCRIPTFLOAT)right;                             \
            }                                                                       \
            if ((left is int) && (right is int)) {                                  \
                return (int)left op (int)right;                                     \
            }                                                                       \
            if ((left is int) && (right is string)) {                               \
                return TypeCast.IntegerToString((int)left) op (string)right;        \
            }                                                                       \
            if ((left is string) && (right is SCRIPTFLOAT)) {                       \
                return (string)left op TypeCast.FloatToString((SCRIPTFLOAT)right);  \
            }                                                                       \
            if ((left is string) && (right is int)) {                               \
                return (string)left op TypeCast.IntegerToString ((int)right);       \
            }                                                                       \
            if ((left is string) && (right is string)) {                            \
                return (string)left op (string)right;                               \
            }                                                                       \
            return null;                                                            \
        }

#define DEFUNOP1(name,op) \
        public static object name (object right)  \
        {                                         \
            if (right is int) {                   \
                return op (int)right;             \
            }                                     \
            if (right is SCRIPTFLOAT) {           \
                return op (SCRIPTFLOAT)right;     \
            }                                     \
            return null;                          \
        }

#define DEFUNOP2(name,op) \
        public static object name (object right)  \
        {                                         \
            if (right is int) {                   \
                return op (int)right;             \
            }                                     \
            return null;                          \
        }

    public class TokenRValConstOps {
        public static object Null (object left, object right)
        {
            return null;
        }

        DEFBINOP1(Div,/)
        DEFBINOP1(Mod,%)
        DEFBINOP1(Mul,*)
        DEFBINOP1(Sub,-)

        DEFBINOP2(And,&)
        DEFBINOP2(LSh,<<)
        DEFBINOP2(Or, |)
        DEFBINOP2(RSh,>>)
        DEFBINOP2(Xor,^)

        DEFBINOP3(Add,+)

        public static object Null (object right)
        {
            return null;
        }

        DEFUNOP1(Neg,-)
        DEFUNOP2(Not,~)
    }

    /*
     * Various datatypes.
     */
    public abstract class TokenType : Token {

        public TokenType (TokenErrorMessage emsg, string file, int line, int posn) : base (emsg, file, line, posn) { }
        public TokenType (Token original) : base (original) { }

        public static TokenType FromSysType (Token original, System.Type typ)
        {
            if (typ == typeof (LSL_List))     return new TokenTypeList      (original);
            if (typ == typeof (LSL_Rotation)) return new TokenTypeRot       (original);
            if (typ == typeof (void))         return new TokenTypeVoid      (original);
            if (typ == typeof (LSL_Vector))   return new TokenTypeVec       (original);
            if (typ == typeof (float))        return new TokenTypeFloat     (original);
            if (typ == typeof (int))          return new TokenTypeInt       (original);
            if (typ == typeof (string))       return new TokenTypeStr       (original);
            if (typ == typeof (double))       return new TokenTypeFloat     (original);
            if (typ == typeof (bool))         return new TokenTypeBool      (original);
            if (typ == typeof (object))       return new TokenTypeObject    (original);
            if (typ == typeof (XMR_Array))    return new TokenTypeArray     (original);
            if (typ == typeof (LSL_Integer))  return new TokenTypeLSLInt    (original);
            if (typ == typeof (LSL_Float))    return new TokenTypeLSLFloat  (original);
            if (typ == typeof (LSL_String))   return new TokenTypeLSLString (original);

            throw new Exception ("unknown type " + typ.ToString ());
        }

        public static TokenType FromLSLType (Token original, string typ)
        {
            if (typ == "list")     return new TokenTypeList   (original);
            if (typ == "rotation") return new TokenTypeRot    (original);
            if (typ == "vector")   return new TokenTypeVec    (original);
            if (typ == "float")    return new TokenTypeFloat  (original);
            if (typ == "integer")  return new TokenTypeInt    (original);
            if (typ == "key")      return new TokenTypeStr    (original);
            if (typ == "string")   return new TokenTypeStr    (original);
            if (typ == "object")   return new TokenTypeObject (original);
            if (typ == "array")    return new TokenTypeArray  (original);
            if (typ == "bool")     return new TokenTypeBool   (original);
            if (typ == "void")     return new TokenTypeVoid   (original);

            throw new Exception ("unknown type " + typ);
        }

        /**
         * @brief Estimate the number of bytes of memory taken by one of these
         *        objects.  For objects with widely varying size, return the
         *        smallest it can be.
         */
        public static int StaticSize (System.Type typ)
        {
            if (typ == typeof (LSL_List))     return  96;
            if (typ == typeof (LSL_Rotation)) return  80;
            if (typ == typeof (void))         return   0;
            if (typ == typeof (LSL_Vector))   return  72;
            if (typ == typeof (float))        return   8;
            if (typ == typeof (int))          return   8;
            if (typ == typeof (string))       return  40;
            if (typ == typeof (double))       return   8;
            if (typ == typeof (bool))         return   8;
            if (typ == typeof (XMR_Array))    return  96;
            if (typ == typeof (object))       return  32;

            if (typ == typeof (LSL_Integer))  return  32;
            if (typ == typeof (LSL_Float))    return  32;
            if (typ == typeof (LSL_String))   return  40;

            throw new Exception ("unknown type " + typ.ToString ());
        }

        /**
         * @brief Return the corresponding system type.
         */
        public abstract Type ToSysType ();

        /**
         * @brief Can the given type be implicitly cast to this type?
         */
        public abstract bool IsAssignableFrom (TokenType src);

        /**
         * @brief Return the equivalent LSL wrapping type.
         *
         *  null: normal
         *  else: LSL-style wrapping, ie, LSL_Integer, LSL_Float, LSL_String
         *        ToSysType()=System.Int32;  lslWrapping=LSL_Integer
         *        ToSysType()=System.Float;  lslWrapping=LSL_Float
         *        ToSysType()=System.String; lslWrapping=LSL_String
         */
        public virtual Type ToLSLWrapType ()
        {
            return null;
        }

        /**
         * @brief Assign slots in either the global variable arrays or the script-defined type instance arrays.
         *        These only need to be implemented for script-visible types, ie, those that a script writer 
         *        can actually define a variable as.
         */
        public virtual void AssignGlobalVarSlot (TokenDeclVar declVar, ScriptObjCode scriptObjCode)
        {
            throw new Exception ("not implemented for " + ToString () + " (" + GetType () + ")");
        }
        public virtual void AssignSDTClassFieldSlot (TokenDeclVar declVar, TokenDeclSDTypeClass sdtClass)
        {
            throw new Exception ("not implemented for " + ToString () + " (" + GetType () + ")");
        }

        /**
         * @brief For most types, this just returns the same token.
         *        But if it is a generic parameter type, eg, the 'U' in the body of 'Dictionary<T,U>' 
         *        it returns the instantiated type.  genArgs[1] holds the final type, eg, 'integer'.  
         *        genArgs[] never holds any TokenTypeGenParam, ie, nothing recursive.
         */
        public virtual TokenType ResolveGenParam (TokenType[] genArgs)
        {
            return this;
        }
    }

    public class TokenTypeArray : TokenType {
        private static readonly FieldInfo gblArraysFieldInfo  = typeof (XMRInstAbstract).GetField ("gblArrays");
        private static readonly FieldInfo sdtcArraysFieldInfo = typeof (XMRSDTypeClassInstance).GetField ("sdtcArrays");

        public TokenTypeArray (TokenErrorMessage emsg, string file, int line, int posn) : base (emsg, file, line, posn) { }
        public TokenTypeArray (Token original) : base (original) { }
        public override Type ToSysType () { return typeof (XMR_Array); }
        public override bool IsAssignableFrom (TokenType src) { return (src is TokenTypeArray); }
        public override string ToString () { return "array"; }
        public override void AssignGlobalVarSlot (TokenDeclVar declVar, ScriptObjCode scriptObjCode)
        {
            declVar.vTableArray = gblArraysFieldInfo;
            declVar.vTableIndex = scriptObjCode.numGblArrays ++;
        }
        public override void AssignSDTClassFieldSlot (TokenDeclVar declVar, TokenDeclSDTypeClass sdtClass)
        {
            declVar.vTableArray = sdtcArraysFieldInfo;
            declVar.vTableIndex = sdtClass.numInstArrays ++;
        }
    }
    public class TokenTypeBool : TokenType {
        public TokenTypeBool (TokenErrorMessage emsg, string file, int line, int posn) : base (emsg, file, line, posn) { }
        public TokenTypeBool (Token original) : base (original) { }
        public override Type ToSysType () { return typeof (bool); }
        public override bool IsAssignableFrom (TokenType src) { return true; }
        public override string ToString () { return "bool"; }
    }
    public class TokenTypeFloat : TokenType {
        private static readonly FieldInfo gblFloatsFieldInfo  = typeof (XMRInstAbstract).GetField ("gblFloats");
        private static readonly FieldInfo sdtcFloatsFieldInfo = typeof (XMRSDTypeClassInstance).GetField ("sdtcFloats");

        public TokenTypeFloat (TokenErrorMessage emsg, string file, int line, int posn) : base (emsg, file, line, posn) { }
        public TokenTypeFloat (Token original) : base (original) { }
        public override Type ToSysType () { return typeof (SCRIPTFLOAT); }
        public override bool IsAssignableFrom (TokenType src) { return (src is TokenTypeFloat) || (src is TokenTypeInt); }
        public override string ToString () { return "float"; }
        public override void AssignGlobalVarSlot (TokenDeclVar declVar, ScriptObjCode scriptObjCode)
        {
            declVar.vTableArray = gblFloatsFieldInfo;
            declVar.vTableIndex = scriptObjCode.numGblFloats ++;
        }
        public override void AssignSDTClassFieldSlot (TokenDeclVar declVar, TokenDeclSDTypeClass sdtClass)
        {
            declVar.vTableArray = sdtcFloatsFieldInfo;
            declVar.vTableIndex = sdtClass.numInstFloats ++;
        }
    }
    public class TokenTypeInt : TokenType {
        private static readonly FieldInfo gblIntegersFieldInfo  = typeof (XMRInstAbstract).GetField ("gblIntegers");
        private static readonly FieldInfo sdtcIntegersFieldInfo = typeof (XMRSDTypeClassInstance).GetField ("sdtcIntegers");

        public TokenTypeInt (TokenErrorMessage emsg, string file, int line, int posn) : base (emsg, file, line, posn) { }
        public TokenTypeInt (Token original) : base (original) { }
        public override Type ToSysType () { return typeof (int); }
        public override bool IsAssignableFrom (TokenType src) { return (src is TokenTypeBool) || (src is TokenTypeInt); }
        public override string ToString () { return "integer"; }
        public override void AssignGlobalVarSlot (TokenDeclVar declVar, ScriptObjCode scriptObjCode)
        {
            declVar.vTableArray = gblIntegersFieldInfo;
            declVar.vTableIndex = scriptObjCode.numGblIntegers ++;
        }
        public override void AssignSDTClassFieldSlot (TokenDeclVar declVar, TokenDeclSDTypeClass sdtClass)
        {
            declVar.vTableArray = sdtcIntegersFieldInfo;
            declVar.vTableIndex = sdtClass.numInstIntegers ++;
        }
    }
    public class TokenTypeList : TokenType {
        private static readonly FieldInfo gblListsFieldInfo  = typeof (XMRInstAbstract).GetField ("gblLists");
        private static readonly FieldInfo sdtcListsFieldInfo = typeof (XMRSDTypeClassInstance).GetField ("sdtcLists");

        public TokenTypeList (TokenErrorMessage emsg, string file, int line, int posn) : base (emsg, file, line, posn) { }
        public TokenTypeList (Token original) : base (original) { }
        public override Type ToSysType () { return typeof (LSL_List); }
        public override bool IsAssignableFrom (TokenType src) { return (src is TokenTypeList); }
        public override string ToString () { return "list"; }
        public override void AssignGlobalVarSlot (TokenDeclVar declVar, ScriptObjCode scriptObjCode)
        {
            declVar.vTableArray = gblListsFieldInfo;
            declVar.vTableIndex = scriptObjCode.numGblLists ++;
        }
        public override void AssignSDTClassFieldSlot (TokenDeclVar declVar, TokenDeclSDTypeClass sdtClass)
        {
            declVar.vTableArray = sdtcListsFieldInfo;
            declVar.vTableIndex = sdtClass.numInstLists ++;
        }
    }
    public class TokenTypeObject : TokenType {
        private static readonly FieldInfo gblObjectsFieldInfo  = typeof (XMRInstAbstract).GetField ("gblObjects");
        private static readonly FieldInfo sdtcObjectsFieldInfo = typeof (XMRSDTypeClassInstance).GetField ("sdtcObjects");

        public TokenTypeObject (TokenErrorMessage emsg, string file, int line, int posn) : base (emsg, file, line, posn) { }
        public TokenTypeObject (Token original) : base (original) { }
        public override Type ToSysType () { return typeof (object); }
        public override bool IsAssignableFrom (TokenType src) { return true; }
        public override string ToString () { return "object"; }
        public override void AssignGlobalVarSlot (TokenDeclVar declVar, ScriptObjCode scriptObjCode)
        {
            declVar.vTableArray = gblObjectsFieldInfo;
            declVar.vTableIndex = scriptObjCode.numGblObjects ++;
        }
        public override void AssignSDTClassFieldSlot (TokenDeclVar declVar, TokenDeclSDTypeClass sdtClass)
        {
            declVar.vTableArray = sdtcObjectsFieldInfo;
            declVar.vTableIndex = sdtClass.numInstObjects ++;
        }
    }
    public class TokenTypeRot : TokenType {
        private static readonly FieldInfo gblRotationsFieldInfo  = typeof (XMRInstAbstract).GetField ("gblRotations");
        private static readonly FieldInfo sdtcRotationsFieldInfo = typeof (XMRSDTypeClassInstance).GetField ("sdtcRotations");

        public TokenTypeRot (TokenErrorMessage emsg, string file, int line, int posn) : base (emsg, file, line, posn) { }
        public TokenTypeRot (Token original) : base (original) { }
        public override Type ToSysType () { return typeof (LSL_Rotation); }
        public override bool IsAssignableFrom (TokenType src) { return (src is TokenTypeRot); }
        public override string ToString () { return "rotation"; }
        public override void AssignGlobalVarSlot (TokenDeclVar declVar, ScriptObjCode scriptObjCode)
        {
            declVar.vTableArray = gblRotationsFieldInfo;
            declVar.vTableIndex = scriptObjCode.numGblRotations ++;
        }
        public override void AssignSDTClassFieldSlot (TokenDeclVar declVar, TokenDeclSDTypeClass sdtClass)
        {
            declVar.vTableArray = sdtcRotationsFieldInfo;
            declVar.vTableIndex = sdtClass.numInstRotations ++;
        }
    }
    public class TokenTypeStr : TokenType {
        private static readonly FieldInfo gblStringsFieldInfo  = typeof (XMRInstAbstract).GetField ("gblStrings");
        private static readonly FieldInfo sdtcStringsFieldInfo = typeof (XMRSDTypeClassInstance).GetField ("sdtcStrings");

        public TokenTypeStr (TokenErrorMessage emsg, string file, int line, int posn) : base (emsg, file, line, posn) { }
        public TokenTypeStr (Token original) : base (original) { }
        public override Type ToSysType () { return typeof (string); }
        public override bool IsAssignableFrom (TokenType src) { return true; }
        public override string ToString () { return "string"; }
        public override void AssignGlobalVarSlot (TokenDeclVar declVar, ScriptObjCode scriptObjCode)
        {
            declVar.vTableArray = gblStringsFieldInfo;
            declVar.vTableIndex = scriptObjCode.numGblStrings ++;
        }
        public override void AssignSDTClassFieldSlot (TokenDeclVar declVar, TokenDeclSDTypeClass sdtClass)
        {
            declVar.vTableArray = sdtcStringsFieldInfo;
            declVar.vTableIndex = sdtClass.numInstStrings ++;
        }
    }
    public class TokenTypeUndef : TokenType {  // for the 'undef' constant, ie, null object pointer
        public TokenTypeUndef (TokenErrorMessage emsg, string file, int line, int posn) : base (emsg, file, line, posn) { }
        public TokenTypeUndef (Token original) : base (original) { }
        public override Type ToSysType () { return typeof (object); }
        public override bool IsAssignableFrom (TokenType src) { return false; }
        public override string ToString () { return "undef"; }
    }
    public class TokenTypeVec : TokenType {
        private static readonly FieldInfo gblVectorsFieldInfo  = typeof (XMRInstAbstract).GetField ("gblVectors");
        private static readonly FieldInfo sdtcVectorsFieldInfo = typeof (XMRSDTypeClassInstance).GetField ("sdtcVectors");

        public TokenTypeVec (TokenErrorMessage emsg, string file, int line, int posn) : base (emsg, file, line, posn) { } 
        public TokenTypeVec (Token original) : base (original) { }
        public override Type ToSysType () { return typeof (LSL_Vector); }
        public override bool IsAssignableFrom (TokenType src) { return (src is TokenTypeVec); }
        public override string ToString () { return "vector"; }
        public override void AssignGlobalVarSlot (TokenDeclVar declVar, ScriptObjCode scriptObjCode)
        {
            declVar.vTableArray = gblVectorsFieldInfo;
            declVar.vTableIndex = scriptObjCode.numGblVectors ++;
        }
        public override void AssignSDTClassFieldSlot (TokenDeclVar declVar, TokenDeclSDTypeClass sdtClass)
        {
            declVar.vTableArray = sdtcVectorsFieldInfo;
            declVar.vTableIndex = sdtClass.numInstVectors ++;
        }
    }
    public class TokenTypeVoid : TokenType {  // used only for function/method return types
        public TokenTypeVoid (TokenErrorMessage emsg, string file, int line, int posn) : base (emsg, file, line, posn) { }
        public TokenTypeVoid (Token original) : base (original) { }
        public override Type ToSysType () { return typeof (void); }
        public override bool IsAssignableFrom (TokenType src) { return false; }
        public override string ToString () { return "void"; }
    }

    public class TokenTypeLSLFloat : TokenTypeFloat {
        public TokenTypeLSLFloat (TokenErrorMessage emsg, string file, int line, int posn) : base (emsg, file, line, posn) { }
        public TokenTypeLSLFloat (Token original) : base (original) { }
        public override Type ToLSLWrapType () { return typeof (LSL_Float); }
    }
    public class TokenTypeLSLInt : TokenTypeInt {
        public TokenTypeLSLInt (TokenErrorMessage emsg, string file, int line, int posn) : base (emsg, file, line, posn) { }
        public TokenTypeLSLInt (Token original) : base (original) { }
        public override Type ToLSLWrapType () { return typeof (LSL_Integer); }
    }
    public class TokenTypeLSLString : TokenTypeStr {
        public TokenTypeLSLString (TokenErrorMessage emsg, string file, int line, int posn) : base (emsg, file, line, posn) { }
        public TokenTypeLSLString (Token original) : base (original) { }
        public override Type ToLSLWrapType () { return typeof (LSL_String); }
    }
}
