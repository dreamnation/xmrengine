/***************************************************\
 *  COPYRIGHT 2010, Mike Rieker, Beverly, MA, USA  *
 *  All rights reserved.                           *
\***************************************************/

#include "lsltypes.h"

using OpenSim.Region.ScriptEngine.Shared.ScriptBase;
using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection.Emit;
using System.Text;

namespace OpenSim.Region.ScriptEngine.XMREngine
{
    public struct XMRInstArrays {
        public XMR_Array[]      iarArrays;
        public char[]           iarChars;
        public SCRIPTFLOAT[]    iarFloats;
        public int[]            iarIntegers;
        public LSL_List[]       iarLists;
        public object[]         iarObjects;
        public LSL_Rotation[]   iarRotations;
        public string[]         iarStrings;
        public LSL_Vector[]     iarVectors;
        public XMRSDTypeClObj[] iarSDTClObjs;
        public Delegate[][]     iarSDTIntfObjs;

        private static readonly XMR_Array[]      noArrays      = new XMR_Array[0];
        private static readonly char[]           noChars       = new char[0];
        private static readonly SCRIPTFLOAT[]    noFloats      = new SCRIPTFLOAT[0];
        private static readonly int[]            noIntegers    = new int[0];
        private static readonly LSL_List[]       noLists       = new LSL_List[0];
        private static readonly object[]         noObjects     = new object[0];
        private static readonly LSL_Rotation[]   noRotations   = new LSL_Rotation[0];
        private static readonly string[]         noStrings     = new string[0];
        private static readonly LSL_Vector[]     noVectors     = new LSL_Vector[0];
        private static readonly XMRSDTypeClObj[] noSDTClObjs   = new XMRSDTypeClObj[0];
        private static readonly Delegate[][]     noSDTIntfObjs = new Delegate[0][];
        public void AllocVarArrays (ref XMRInstArSizes ars)
        {
            iarArrays      = (ars.iasArrays      > 0) ? new XMR_Array     [ars.iasArrays]        : noArrays;
            iarChars       = (ars.iasChars       > 0) ? new char          [ars.iasChars]         : noChars;
            iarFloats      = (ars.iasFloats      > 0) ? new SCRIPTFLOAT   [ars.iasFloats]        : noFloats;
            iarIntegers    = (ars.iasIntegers    > 0) ? new int           [ars.iasIntegers]      : noIntegers;
            iarLists       = (ars.iasLists       > 0) ? new LSL_List      [ars.iasLists]         : noLists;
            iarObjects     = (ars.iasObjects     > 0) ? new object        [ars.iasObjects]       : noObjects;
            iarRotations   = (ars.iasRotations   > 0) ? new LSL_Rotation  [ars.iasRotations]     : noRotations;
            iarStrings     = (ars.iasStrings     > 0) ? new string        [ars.iasStrings]       : noStrings;
            iarVectors     = (ars.iasVectors     > 0) ? new LSL_Vector    [ars.iasVectors]       : noVectors;
            iarSDTClObjs   = (ars.iasSDTClObjs   > 0) ? new XMRSDTypeClObj[ars.iasSDTClObjs]     : noSDTClObjs;
            iarSDTIntfObjs = (ars.iasSDTIntfObjs > 0) ? new Delegate      [ars.iasSDTIntfObjs][] : noSDTIntfObjs;
        }

        public delegate void Sender (object value);
        public void SendArrays (Sender sender)
        {
            sender (iarArrays);
            sender (iarChars);
            sender (iarFloats);
            sender (iarIntegers);
            sender (iarLists);
            sender (iarObjects);
            sender (iarRotations);
            sender (iarStrings);
            sender (iarVectors);
            sender (iarSDTClObjs);
            sender (iarSDTIntfObjs);
        }

        public delegate object Recver ();
        public void RecvArrays (Recver recver)
        {
            iarArrays      = (XMR_Array[])      recver ();
            iarChars       = (char[])           recver ();
            iarFloats      = (SCRIPTFLOAT[])    recver ();
            iarIntegers    = (int[])            recver ();
            iarLists       = (LSL_List[])       recver ();
            iarObjects     = (object[])         recver ();
            iarRotations   = (LSL_Rotation[])   recver ();
            iarStrings     = (string[])         recver ();
            iarVectors     = (LSL_Vector[])     recver ();
            iarSDTClObjs   = (XMRSDTypeClObj[]) recver ();
            iarSDTIntfObjs = (Delegate[][])     recver ();
        }
    }

    public struct XMRInstArSizes {
        public int iasArrays;
        public int iasChars;
        public int iasFloats;
        public int iasIntegers;
        public int iasLists;
        public int iasObjects;
        public int iasRotations;
        public int iasStrings;
        public int iasVectors;
        public int iasSDTClObjs;
        public int iasSDTIntfObjs;

        public void WriteAsmFile (TextWriter asmFileWriter, string label)
        {
            asmFileWriter.WriteLine ("  {0}Arrays       {1}", label, iasArrays);
            asmFileWriter.WriteLine ("  {0}Chars        {1}", label, iasChars);
            asmFileWriter.WriteLine ("  {0}Floats       {1}", label, iasFloats);
            asmFileWriter.WriteLine ("  {0}Integers     {1}", label, iasIntegers);
            asmFileWriter.WriteLine ("  {0}Lists        {1}", label, iasLists);
            asmFileWriter.WriteLine ("  {0}Objects      {1}", label, iasObjects);
            asmFileWriter.WriteLine ("  {0}Rotations    {1}", label, iasRotations);
            asmFileWriter.WriteLine ("  {0}Strings      {1}", label, iasStrings);
            asmFileWriter.WriteLine ("  {0}Vectors      {1}", label, iasVectors);
            asmFileWriter.WriteLine ("  {0}SDTClObjs    {1}", label, iasSDTClObjs);
            asmFileWriter.WriteLine ("  {0}SDTIntfObjs  {1}", label, iasSDTIntfObjs);
        }
        public void WriteToFile (BinaryWriter objFileWriter)
        {
            objFileWriter.Write (iasArrays);
            objFileWriter.Write (iasChars);
            objFileWriter.Write (iasFloats);
            objFileWriter.Write (iasIntegers);
            objFileWriter.Write (iasLists);
            objFileWriter.Write (iasObjects);
            objFileWriter.Write (iasRotations);
            objFileWriter.Write (iasStrings);
            objFileWriter.Write (iasVectors);
            objFileWriter.Write (iasSDTClObjs);
            objFileWriter.Write (iasSDTIntfObjs);
        }
        public void ReadFromFile (BinaryReader objFileReader)
        {
            iasArrays      = objFileReader.ReadInt32 ();
            iasChars       = objFileReader.ReadInt32 ();
            iasFloats      = objFileReader.ReadInt32 ();
            iasIntegers    = objFileReader.ReadInt32 ();
            iasLists       = objFileReader.ReadInt32 ();
            iasObjects     = objFileReader.ReadInt32 ();
            iasRotations   = objFileReader.ReadInt32 ();
            iasStrings     = objFileReader.ReadInt32 ();
            iasVectors     = objFileReader.ReadInt32 ();
            iasSDTClObjs   = objFileReader.ReadInt32 ();
            iasSDTIntfObjs = objFileReader.ReadInt32 ();
        }
    }

    public class XMRStackFrame {
        public XMRStackFrame nextSF;
        public string funcName;
        public int callNo;
        public object[] objArray;
    }

    /*
     * Contains only items required by the stand-alone compiler
     * so the compiler doesn't need to pull in all of OpenSim.
     *
     * Inherit from SCRIPTBASECLASS so we can be used as 'this'
     * parameter for backend-API calls, eg llSay().
     */
    public abstract class XMRInstAbstract : SCRIPTBASECLASS
    {
        public const int CALLMODE_NORMAL  = 0;  // when function is called, it proceeds normally
        public const int CALLMODE_SAVE    = 1;  // StackSaveException() was thrown, push args/locals to stackFrames
        public const int CALLMODE_RESTORE = 2;  // when function is called, it pops state from stackFrames

        public ScriptObjCode m_ObjCode;     // script object code this instance was created from

        public object[] ehArgs;             // event handler argument array
        public bool doGblInit = true;       // default state_entry() needs to initialize global variables
        public int heapLimit;               // let script use this many bytes of heap maximum
                                            // includes global vars, local vars, that reference heap
                                            // does not include value-type vars, that is part of stackLimit
        public int heapLeft;                // how much of heapLimit remains available
                                            // ...atomic updates only
        public string traceHeapUse = null;  // null: quiet; else: name of script
        public int stateCode = 0;           // state the script is in (0 = 'default')
        public ScriptEventCode eventCode = ScriptEventCode.None;
                                            // what event handler is executing (or None if not)

        public int callMode = CALLMODE_NORMAL;
                                            // to capture stack frames on stackFrames:
                                            //    set to CALLMODE_SAVE just before throwing StackSaveException()
                                            //    from within CheckRun() and cleared to CALLMODE_NORMAL when
                                            //    the exception is caught
                                            // to restore stack frames from stackFrames:
                                            //    set to CALLMODE_RESTORE just before calling CallSEH() and 
                                            //    cleared to CALLMODE_NORMAL by CheckRun()
        public XMRStackFrame stackFrames;   // stack frames being saved/restored

        /*
         * These arrays hold the global variable values for the script instance.
         * The array lengths are determined by the script compilation,
         * and are found in ScriptObjCode.glblSizes.
         */
        public XMRInstArrays glblVars;

        /****************************************************************\
         *  Function prototypes.                                        *
         *  These functions require access to the OpenSim environment.  *
        \****************************************************************/

        public abstract void CheckRun (int line);
        public abstract int  StackLeft ();
        public abstract LSL_List XMREventDequeue (SCRIPTFLOAT timeout, int returnMask1, int returnMask2,
                                                  int backgroundMask1, int backgroundMask2, int line);
        public abstract void XMREventEnqueue (LSL_List ev);
        public abstract void XMREventCallHandler (LSL_List ev);
        public abstract LSL_List XMREventSaveDets ();
        public abstract void XMREventLoadDets (LSL_List dpList);

        /**************************************************\
         *  Functions what don't require runtime support  *
         *  beyond what the compiler provides.            *
        \**************************************************/

        /**
         * @brief Called during CALLMODE_SAVE to create a stackframe save object that saves 
         *        local variables and calling point within the function.
         * @param funcName = name of function whose frame is being saved
         * @param callNo = call number (ie, return address) within function to restart at
         * @param nSaves = number of variables the function will save
         * @returns an object[nSaves] where function can save variables
         */
        public object[] CaptureStackFrame (string funcName, int callNo, int nSaves)
        {
            XMRStackFrame sf = new XMRStackFrame ();
            sf.nextSF   = stackFrames;
            sf.funcName = funcName;
            sf.callNo   = callNo;
            sf.objArray = new object[nSaves];
            stackFrames = sf;
            return sf.objArray;
        }

        /**
         * @brief Called during CALLMODE_RESTORE to pop a stackframe object to restore 
         *        local variables and calling point within the function.
         * @param funcName = name of function whose frame is being restored
         * @returns the object[nSaves] where function can retrieve variables
         *          callNo = as passed to CaptureStackFrame() indicating restart point
         */
        public object[] RestoreStackFrame (string funcName, out int callNo)
        {
            XMRStackFrame sf = stackFrames;
            if (sf.funcName != funcName) {
                throw new Exception ("frame mismatch " + sf.funcName + " vs " + funcName);
            }
            callNo = sf.callNo;
            stackFrames = sf.nextSF;
            return sf.objArray;
        }

        public void ConsoleWrite (string s)
        {
            Console.WriteLine ("XMRInstance.ConsoleWrite: " + s);
        }

        public string XMRTypeName (object o)
        {
            /*
             * Basic types return constant strings of the script-visible type name.
             */
            if (o is XMR_Array)    return "array";
            if (o is bool)         return "bool";
            if (o is char)         return "char";
            if (o is double)       return "float";
            if (o is float)        return "float";
            if (o is LSL_Float)    return "float";
            if (o is int)          return "integer";
            if (o is LSL_Integer)  return "integer";
            if (o is LSL_List)     return "list";
            if (o is LSL_Rotation) return "rotation";
            if (o is LSL_String)   return "string";
            if (o is string)       return "string";
            if (o is LSL_Vector)   return "vector";

            /*
             * A script-defined interface is represented as an array of delegates.
             * If that is the case, convert it to the object of the script-defined 
             * class that is implementing the interface.  This should let the next 
             * step get the script-defined type name of the object.
             */
            if (o is Delegate[]) {
                o = ((Delegate[])o)[0].Target;
            }

            /*
             * If script-defined class instance, get the script-defined 
             * type name.
             */
            if (o is XMRSDTypeClObj) {
                return ((XMRSDTypeClObj)o).sdtcClass.longName.val;
            }

            /*
             * If it's a delegate, maybe we can look up its script-defined type name.
             */
            Type ot = o.GetType ();
            if (o is Delegate) {
                String os;
                if (m_ObjCode.sdDelTypes.TryGetValue (ot, out os)) return os;
            }

            /*
             * Don't know what it is, get the C#-level type name.
             */
            return ot.ToString ();
        }

        /**
         * @brief Get a delegate for a script-defined function.
         * @param name = name of the function including arg types, eg,
         *               "Verify(array,list,string)"
         * @param sig  = script-defined type name
         * @param targ = function's 'this' pointer or null if static
         * @returns delegate for the script-defined function
         */
        public Delegate GetScriptMethodDelegate (string name, string sig, object targ)
        {
            DynamicMethod dm = m_ObjCode.dynamicMethods[name];
            TokenDeclSDTypeDelegate dt = (TokenDeclSDTypeDelegate)m_ObjCode.sdObjTypesName[sig];
            return dm.CreateDelegate (dt.GetSysType (), targ);
        }

        /**
         * @brief Try to cast the thrown object to the given script-defined type.
         * @param thrown = what object was thrown
         * @param inst = what script instance we are running in
         * @param sdtypeindex = script-defined type to try to cast it to
         * @returns null: thrown is not castable to sdtypename
         *          else: an object casted to sdtypename
         */
        public static object XMRSDTypeCatchTryCastToSDType (object thrown, XMRInstAbstract inst, int sdtypeindex)
        {
            TokenDeclSDType sdType = inst.m_ObjCode.sdObjTypesIndx[sdtypeindex];

            /*
             * If it is a script-defined interface object, convert to the original XMRSDTypeClObj.
             */
            if (thrown is Delegate[]) {
                thrown = ((Delegate[])thrown)[0].Target;
            }

            /*
             * If it is a script-defined delegate object, make sure it is an instance of the expected type.
             */
            if (thrown is Delegate) {
                Type ot = thrown.GetType ();
                Type tt = sdType.GetSysType ();
                return (ot == tt) ? thrown : null;
            }

            /*
             * If it is a script-defined class object, make sure it is an instance of the expected class.
             */
            if (thrown is XMRSDTypeClObj) {

                /*
                 * Step from the object's actual class rootward.
                 * If we find the requested class along the way, the cast is valid.
                 * If we run off the end of the root, the cast is not valid.
                 */
                for (TokenDeclSDTypeClass ac = ((XMRSDTypeClObj)thrown).sdtcClass; ac != null; ac = ac.extends) {
                    if (ac == sdType) return thrown;
                }
            }

            /*
             * Don't know what it is, assume it is not what caller wants.
             */
            return null;
        }

        /**
         * @brief Wrap osParseJSON() so we return an array to the script.
         *        No coherent example of its use in scripts on web found.
         * see http://www.json.org/ for more details on JSON
         */
        private static LSL_List nullList = new LSL_List (new object[0]);
        public XMR_Array XMRosParseJSON (string json)
        {
            XMR_Array dict = new XMR_Array (this, 0, 0);
            int idx = ParseJSON (dict, nullList, json, 0);
            while (idx < json.Length) {
                if (json[idx] > ' ') throw new Exception ("left-over json " + json);
                idx ++;
            }
            return dict;
        }

        private static int ParseJSON (XMR_Array dict, LSL_List keys, string json, int idx)
        {
            char c;

            while ((c = json[idx++]) <= ' ') { }
            switch (c) {

                // '{' <keystring> ':' <value> [ ',' <keystring> ':' <value> ... ] '}'
                case '{': {
                    do {
                        string key = ParseJSONString (json, ref idx);
                        while ((c = json[idx++]) <= ' ') { }
                        if (c != ':') throw new Exception ("missing : after key");
                        idx = ParseJSON (dict, ParseJSONKeyAdd (keys, key), json, idx);
                        while ((c = json[idx++]) <= ' ') { }
                    } while (c == ',');
                    if (c != '}') throw new Exception ("missing , or } after value");
                    break;
                }

                // '[' <value> [ ',' <value> ... ] ']'
                case '[': {
                    int index = 0;
                    do {
                        object key = index ++;
                        idx = ParseJSON (dict, ParseJSONKeyAdd (keys, key), json, idx);
                        while ((c = json[idx++]) <= ' ') { }
                    } while (c == ',');
                    if (c != ']') throw new Exception ("missing , or ] after value");
                    break;
                }

                // '"'<string>'"'
                case '"': {
                    -- idx;
                    string val = ParseJSONString (json, ref idx);
                    dict.SetByKey (keys, val);
                    break;
                }

                // true false null
                case 't': {
                    if (json.Substring (idx, 3) != "rue") throw new Exception ("bad true in json");
                    idx += 3;
                    dict.SetByKey (keys, 1);
                    break;
                }

                case 'f': {
                    if (json.Substring (idx, 4) != "alse") throw new Exception ("bad false in json");
                    idx += 4;
                    dict.SetByKey (keys, 0);
                    break;
                }

                case 'n': {
                    if (json.Substring (idx, 3) != "ull") throw new Exception ("bad null in json");
                    idx += 3;
                    dict.SetByKey (keys, null);
                    break;
                }

                // otherwise assume it's a number
                default: {
                    -- idx;
                    object val = ParseJSONNumber (json, ref idx);
                    dict.SetByKey (keys, val);
                    break;
                }
            }

            return idx;
        }

        // Given the key for a whole array, create a key for a given element of the array
        private static LSL_List ParseJSONKeyAdd (LSL_List oldkeys, object key)
        {
            int oldkeyslen = oldkeys.Length;
            object[] array = oldkeys.Data;
            Array.Resize<object> (ref array, oldkeyslen + 1);
            array[oldkeyslen] = key;
            return new LSL_List (array);
        }

        // Parse out a JSON string
        private static string ParseJSONString (string json, ref int idx)
        {
            char c;

            while ((c = json[idx++]) <= ' ') { }
            if (c != '"') throw new Exception ("bad start of json string");

            StringBuilder sb = new StringBuilder ();
            while ((c = json[idx++]) != '"') {
                if (c == '\\') {
                    c = json[idx++];
                    switch (c) {
                        case 'b': {
                            c = '\b';
                            break;
                        }
                        case 'f': {
                            c = '\f';
                            break;
                        }
                        case 'n': {
                            c = '\n';
                            break;
                        }
                        case 'r': {
                            c = '\r';
                            break;
                        }
                        case 't': {
                            c = '\t';
                            break;
                        }
                        case 'u': {
                            c = (char) Int32.Parse (json.Substring (idx, 4), 
                                                    System.Globalization.NumberStyles.HexNumber);
                            idx += 4;
                            break;
                        }
                        default: break;
                    }
                }
                sb.Append (c);
            }
            return sb.ToString ();
        }

        // Parse out a JSON number
        private static object ParseJSONNumber (string json, ref int idx)
        {
            char c;

            while ((c = json[idx++]) <= ' ') { }

            bool expneg = false;
            bool isneg  = false;
            int decpt   = -1;
            int expon   = 0;
            int ival    = 0;
            SCRIPTFLOAT dval = 0;

            if (c == '-') {
                isneg = true;
                c = json[idx++];
            }
            if ((c < '0') || (c > '9')) {
                throw new Exception ("bad json number");
            }
            while ((c >= '0') && (c <= '9')) {
                dval *= 10;
                ival *= 10;
                dval += c - '0';
                ival += c - '0';
                c = '\0';
                if (idx < json.Length) c = json[idx++];
            }
            if (c == '.') {
                decpt = 0;
                c = '\0';
                if (idx < json.Length) c = json[idx++];
                while ((c >= '0') && (c <= '9')) {
                    dval *= 10;
                    dval += c - '0';
                    decpt ++;
                    c = '\0';
                    if (idx < json.Length) c = json[idx++];
                }
            }
            if ((c == 'e') || (c == 'E')) {
                if (decpt < 0) decpt = 0;
                c = json[idx++];
                if (c == '-') expneg = true;
                if ((c == '-') || (c == '+')) c = json[idx++];
                while ((c >= '0') && (c <= '9')) {
                    expon *= 10;
                    expon += c - '0';
                    c = '\0';
                    if (idx < json.Length) c = json[idx++];
                }
                if (expneg) expon = -expon;
            }

            if (c != 0) -- idx;
            if (decpt < 0) {
                if (isneg) ival = -ival;
                return ival;
            } else {
                if (isneg) dval = -dval;
                dval *= Math.Pow (10, expon - decpt);
                return dval;
            }
        }

        /**
         * @brief types of data we serialize
         */
        private enum Ser : byte {
            NULL,
            EVENTCODE,
            LSLFLOAT,
            LSLINT,
            LSLKEY,
            LSLLIST,
            LSLROT,
            LSLSTR,
            LSLVEC,
            SYSARRAY,
            SYSDOUB,
            SYSFLOAT,
            SYSINT,
            SYSSTR,
            XMRARRAY,
            DUPREF,
            SYSBOOL,
            XMRINST,
            DELEGATE,
            SDTCLOBJ,
            SYSCHAR,
            SYSERIAL
        }

        /**
         * @brief Write state out to a stream.
         *        Do not change script state.
         */
        public void MigrateOut (BinaryWriter mow)
        {
            try {
                this.migrateOutWriter  = mow;
                this.migrateOutObjects = new Dictionary<object, int> ();
                this.SendObjValue (this.ehArgs);
                mow.Write (this.doGblInit);
                mow.Write (this.heapLimit - this.heapLeft);
                mow.Write (this.stateCode);
                mow.Write ((int)this.eventCode);
                this.glblVars.SendArrays (this.SendObjValue);
                for (XMRStackFrame thisSF = this.stackFrames; thisSF != null; thisSF = thisSF.nextSF) {
                    mow.Write (thisSF.funcName);
                    mow.Write (thisSF.callNo);
                    this.SendObjValue (thisSF.objArray);
                }
                mow.Write ("");
            } finally {
                this.migrateOutWriter  = null;
                this.migrateOutObjects = null;
            }
        }

        /**
         * @brief Write an object to the output stream.
         * @param graph = object to send
         */
        public BinaryWriter migrateOutWriter;
        public Dictionary<object, int> migrateOutObjects;
        public void SendObjValue (object graph)
        {
            BinaryWriter mow = this.migrateOutWriter;

            /*
             * Value types (including nulls) are always output directly.
             */
            if (graph == null) {
                mow.Write ((byte)Ser.NULL);
                return;
            }
            if (graph is ScriptEventCode) {
                mow.Write ((byte)Ser.EVENTCODE);
                mow.Write ((int)graph);
                return;
            }
            if (graph is LSL_Float) {
                mow.Write ((byte)Ser.LSLFLOAT);
                mow.Write ((double)((LSL_Float)graph).value);
                return;
            }
            if (graph is LSL_Integer) {
                mow.Write ((byte)Ser.LSLINT);
                mow.Write ((int)((LSL_Integer)graph).value);
                return;
            }
            if (graph is LSL_Key) {
                mow.Write ((byte)Ser.LSLKEY);
                LSL_Key key = (LSL_Key)graph;
                SendObjValue (key.m_string);  // m_string can be null
                return;
            }
            if (graph is LSL_Rotation) {
                mow.Write ((byte)Ser.LSLROT);
                mow.Write ((double)((LSL_Rotation)graph).x);
                mow.Write ((double)((LSL_Rotation)graph).y);
                mow.Write ((double)((LSL_Rotation)graph).z);
                mow.Write ((double)((LSL_Rotation)graph).s);
                return;
            }
            if (graph is LSL_String) {
                mow.Write ((byte)Ser.LSLSTR);
                LSL_String str = (LSL_String)graph;
                SendObjValue (str.m_string);  // m_string can be null
                return;
            }
            if (graph is LSL_Vector) {
                mow.Write ((byte)Ser.LSLVEC);
                mow.Write ((double)((LSL_Vector)graph).x);
                mow.Write ((double)((LSL_Vector)graph).y);
                mow.Write ((double)((LSL_Vector)graph).z);
                return;
            }
            if (graph is bool) {
                mow.Write ((byte)Ser.SYSBOOL);
                mow.Write ((bool)graph);
                return;
            }
            if (graph is double) {
                mow.Write ((byte)Ser.SYSDOUB);
                mow.Write ((double)graph);
                return;
            }
            if (graph is float) {
                mow.Write ((byte)Ser.SYSFLOAT);
                mow.Write ((float)graph);
                return;
            }
            if (graph is int) {
                mow.Write ((byte)Ser.SYSINT);
                mow.Write ((int)graph);
                return;
            }
            if (graph is char) {
                mow.Write ((byte)Ser.SYSCHAR);
                mow.Write ((char)graph);
                return;
            }

            /*
             * Script instance pointer is always just that.
             */
            if (graph == this) {
                mow.Write ((byte)Ser.XMRINST);
                return;
            }

            /*
             * If this same exact object was already serialized,
             * just output an index telling the receiver to use
             * that same old object, rather than creating a whole
             * new object with the same values.  Also this prevents
             * self-referencing objects (like arrays) from causing
             * an infinite loop.
             */
            int ident;
            if (this.migrateOutObjects.TryGetValue (graph, out ident)) {
                mow.Write ((byte)Ser.DUPREF);
                mow.Write (ident);
                return;
            }

            /*
             * Object not seen before, save its address with an unique
             * ident number that the receiver can easily regenerate.
             */
            ident = this.migrateOutObjects.Count;
            this.migrateOutObjects.Add (graph, ident);

            /*
             * Now output the object's value(s).
             * If the object self-references, the object is alreay entered
             * in the dictionary and so the self-reference will just emit
             * a DUPREF tag instead of trying to output the whole object 
             * again.
             */
            if (graph is LSL_List) {
                mow.Write ((byte)Ser.LSLLIST);
                LSL_List list = (LSL_List)graph;
                SendObjValue (list.Data);
            } else if (graph is XMR_Array) {
                mow.Write ((byte)Ser.XMRARRAY);
                ((XMR_Array)graph).SendArrayObj (this.SendObjValue);
            } else if (graph is Array) {
                mow.Write ((byte)Ser.SYSARRAY);
                Array array = (Array)graph;
                mow.Write (SysType2String (array.GetType ().GetElementType ()));
                mow.Write ((int)array.Length);
                for (int i = 0; i < array.Length; i ++) {
                    this.SendObjValue (array.GetValue (i));
                }
            } else if (graph is string) {
                mow.Write ((byte)Ser.SYSSTR);
                mow.Write ((string)graph);
            } else if (graph is Delegate) {
                Delegate del = (Delegate)graph;
                mow.Write ((byte)Ser.DELEGATE);
                mow.Write (del.Method.Name);
                Type delType = del.GetType ();
                foreach (KeyValuePair<string, TokenDeclSDType> kvp in m_ObjCode.sdObjTypesName) {
                    TokenDeclSDType sdt = kvp.Value;
                    if (sdt is TokenDeclSDTypeDelegate) {
                        TokenDeclSDTypeDelegate sdtd = (TokenDeclSDTypeDelegate)sdt;
                        if (sdtd.GetSysType () == delType) {
                            mow.Write (kvp.Key);
                            goto found;
                        }
                    }
                }
                throw new Exception ("cant find script-defined delegate for " + del.Method.Name + " type " + del.GetType ());
            found:
                SendObjValue (del.Target);
            } else if (graph is XMRSDTypeClObj) {
                mow.Write ((byte)Ser.SDTCLOBJ);
                ((XMRSDTypeClObj)graph).Capture (this.SendObjValue);
            } else {
                MemoryStream memoryStream = new MemoryStream ();
                System.Runtime.Serialization.Formatters.Binary.BinaryFormatter bformatter = 
                        new System.Runtime.Serialization.Formatters.Binary.BinaryFormatter ();
                bformatter.Serialize (memoryStream, graph);
                byte[] rawBytes = memoryStream.ToArray ();
                mow.Write ((byte)Ser.SYSERIAL);
                mow.Write ((int)rawBytes.Length);
                mow.Write (rawBytes);
            }
        }

        /**
         * @brief Use short strings for known type names.
         */
        private static string SysType2String (Type type)
        {
            if (type.IsArray && (type.GetArrayRank () == 1)) {
                string str = KnownSysType2String (type.GetElementType ());
                if (str != null) return str + "[]";
            } else {
                string str = KnownSysType2String (type);
                if (str != null) return str;
            }
            return type.ToString ();
        }
        private static string KnownSysType2String (Type type)
        {
            if (type == typeof (bool))           return "bo";
            if (type == typeof (char))           return "ch";
            if (type == typeof (Delegate))       return "de";
            if (type == typeof (double))         return "do";
            if (type == typeof (float))          return "fl";
            if (type == typeof (int))            return "in";
            if (type == typeof (LSL_List))       return "li";
            if (type == typeof (object))         return "ob";
            if (type == typeof (LSL_Rotation))   return "ro";
            if (type == typeof (XMRSDTypeClObj)) return "sc";
            if (type == typeof (string))         return "st";
            if (type == typeof (LSL_Vector))     return "ve";
            if (type == typeof (XMR_Array))      return "xa";
            return null;
        }
        private static Type String2SysType (string str)
        {
            if (str.EndsWith ("[]")) {
                return String2SysType (str.Substring (0, str.Length - 2)).MakeArrayType ();
            }
            if (str == "bo") return typeof (bool);
            if (str == "ch") return typeof (char);
            if (str == "de") return typeof (Delegate);
            if (str == "do") return typeof (double);
            if (str == "fl") return typeof (float);
            if (str == "in") return typeof (int);
            if (str == "li") return typeof (LSL_List);
            if (str == "ob") return typeof (object);
            if (str == "ro") return typeof (LSL_Rotation);
            if (str == "sc") return typeof (XMRSDTypeClObj);
            if (str == "st") return typeof (string);
            if (str == "ve") return typeof (LSL_Vector);
            if (str == "xa") return typeof (XMR_Array);
            return Type.GetType (str, true);
        }

        /**
         * @brief Read state in from a stream.
         */
        public void MigrateIn (BinaryReader mir)
        {
            try {
                this.migrateInReader  = mir;
                this.migrateInObjects = new Dictionary<int, object> ();
                this.ehArgs     = (object[])this.RecvObjValue ();
                this.doGblInit  = mir.ReadBoolean ();
                this.heapLeft   = this.heapLimit - mir.ReadInt32 ();
                this.stateCode  = mir.ReadInt32 ();
                this.eventCode  = (ScriptEventCode)mir.ReadInt32 ();
                this.glblVars.RecvArrays (this.RecvObjValue);
                XMRStackFrame lastSF  = null;
                string funcName;
                while ((funcName = mir.ReadString ()) != "") {
                    XMRStackFrame thisSF = new XMRStackFrame ();
                    thisSF.funcName = funcName;
                    thisSF.callNo   = mir.ReadInt32 ();
                    thisSF.objArray = (object[])this.RecvObjValue ();
                    if (lastSF == null) this.stackFrames = thisSF;
                                   else lastSF.nextSF = thisSF;
                    lastSF = thisSF;
                }
            } finally {
                this.migrateInReader  = null;
                this.migrateInObjects = null;
            }
        }

        /**
         * @brief Read a single value from the stream.
         * @returns value (boxed as needed)
         */
        public BinaryReader migrateInReader;
        public Dictionary<int, object> migrateInObjects;
        public object RecvObjValue ()
        {
            BinaryReader mir = this.migrateInReader;
            int ident = this.migrateInObjects.Count;
            Ser code = (Ser)mir.ReadByte ();
            switch (code) {
                case Ser.NULL: {
                    return null;
                }
                case Ser.EVENTCODE: {
                    return (ScriptEventCode)mir.ReadInt32 ();
                }
                case Ser.LSLFLOAT: {
                    return new LSL_Float (mir.ReadDouble ());
                }
                case Ser.LSLINT: {
                    return new LSL_Integer (mir.ReadInt32 ());
                }
                case Ser.LSLKEY: {
                    return new LSL_Key ((string)RecvObjValue ());
                }
                case Ser.LSLLIST: {
                    LSL_List list =  new LSL_List (null);
                    this.migrateInObjects.Add (ident, list);
                    list.Data = (object[])RecvObjValue ();
                    return list;
                }
                case Ser.LSLROT: {
                    double x = mir.ReadDouble ();
                    double y = mir.ReadDouble ();
                    double z = mir.ReadDouble ();
                    double s = mir.ReadDouble ();
                    return new LSL_Rotation (x, y, z, s);
                }
                case Ser.LSLSTR: {
                    return new LSL_String ((string)RecvObjValue ());
                }
                case Ser.LSLVEC: {
                    double x = mir.ReadDouble ();
                    double y = mir.ReadDouble ();
                    double z = mir.ReadDouble ();
                    return new LSL_Vector (x, y, z);
                }
                case Ser.SYSARRAY: {
                    Type eletype = String2SysType (mir.ReadString ());
                    int length = mir.ReadInt32 ();
                    Array array = Array.CreateInstance (eletype, length);
                    this.migrateInObjects.Add (ident, array);
                    for (int i = 0; i < length; i ++) {
                        array.SetValue (RecvObjValue (), i);
                    }
                    return array;
                }
                case Ser.SYSBOOL: {
                    return mir.ReadBoolean ();
                }
                case Ser.SYSDOUB: {
                    return mir.ReadDouble ();
                }
                case Ser.SYSFLOAT: {
                    return mir.ReadSingle ();
                }
                case Ser.SYSINT: {
                    return mir.ReadInt32 ();
                }
                case Ser.SYSCHAR: {
                    return mir.ReadChar ();
                }
                case Ser.SYSSTR: {
                    string s = mir.ReadString ();
                    this.migrateInObjects.Add (ident, s);
                    return s;
                }
                case Ser.XMRARRAY: {
                    XMR_Array array = new XMR_Array (this, 0, 0);
                    this.migrateInObjects.Add (ident, array);
                    array.RecvArrayObj (this.RecvObjValue);
                    return array;
                }
                case Ser.DUPREF: {
                    ident = mir.ReadInt32 ();
                    return this.migrateInObjects[ident];
                }
                case Ser.XMRINST: {
                    return this;
                }
                case Ser.DELEGATE: {
                    this.migrateInObjects.Add (ident, null);  // placeholder
                    string name  = mir.ReadString ();         // function name
                    string sig   = mir.ReadString ();         // delegate type
                    object targ  = this.RecvObjValue ();      // 'this' object
                    Delegate del = this.GetScriptMethodDelegate (name, sig, targ);
                    this.migrateInObjects[ident] = del;       // actual value
                    return del;
                }
                case Ser.SDTCLOBJ: {
                    XMRSDTypeClObj clobj = new XMRSDTypeClObj ();
                    this.migrateInObjects.Add (ident, clobj);
                    clobj.Restore (this, this.RecvObjValue);
                    return clobj;
                }
                case Ser.SYSERIAL: {
                    int rawLength   = mir.ReadInt32 ();
                    byte[] rawBytes = mir.ReadBytes (rawLength);
                    MemoryStream memoryStream = new MemoryStream (rawBytes);
                    System.Runtime.Serialization.Formatters.Binary.BinaryFormatter bformatter = 
                            new System.Runtime.Serialization.Formatters.Binary.BinaryFormatter ();
                    object graph = bformatter.Deserialize (memoryStream);
                    this.migrateInObjects.Add (ident, graph);
                    return graph;
                }
                default: throw new Exception ("bad stream code " + code.ToString ());
            }
        }
    }
}
