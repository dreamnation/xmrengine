/***************************************************\
 *  COPYRIGHT 2010, Mike Rieker, Beverly, MA, USA  *
 *  All rights reserved.                           *
\***************************************************/

#include "lsltypes.h"

using OpenSim.Region.ScriptEngine.Shared.ScriptBase;
using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection.Emit;
using System.Text;

namespace OpenSim.Region.ScriptEngine.XMREngine
{
    public struct XMRInstArrays {
        public XMR_Array[]      iarArrays;
        public SCRIPTFLOAT[]    iarFloats;
        public int[]            iarIntegers;
        public LSL_List[]       iarLists;
        public object[]         iarObjects;
        public LSL_Rotation[]   iarRotations;
        public string[]         iarStrings;
        public LSL_Vector[]     iarVectors;
        public XMRSDTypeClObj[] iarSDTClObjs;
        public Delegate[][]     iarSDTIntfObjs;

        private static readonly XMR_Array[]      noArrays      = new XMR_Array[0];
        private static readonly SCRIPTFLOAT[]    noFloats      = new SCRIPTFLOAT[0];
        private static readonly int[]            noIntegers    = new int[0];
        private static readonly LSL_List[]       noLists       = new LSL_List[0];
        private static readonly object[]         noObjects     = new object[0];
        private static readonly LSL_Rotation[]   noRotations   = new LSL_Rotation[0];
        private static readonly string[]         noStrings     = new string[0];
        private static readonly LSL_Vector[]     noVectors     = new LSL_Vector[0];
        private static readonly XMRSDTypeClObj[] noSDTClObjs   = new XMRSDTypeClObj[0];
        private static readonly Delegate[][]     noSDTIntfObjs = new Delegate[0][];
        public void AllocVarArrays (ref XMRInstArSizes ars)
        {
            iarArrays      = (ars.iasArrays      > 0) ? new XMR_Array     [ars.iasArrays]        : noArrays;
            iarFloats      = (ars.iasFloats      > 0) ? new SCRIPTFLOAT   [ars.iasFloats]        : noFloats;
            iarIntegers    = (ars.iasIntegers    > 0) ? new int           [ars.iasIntegers]      : noIntegers;
            iarLists       = (ars.iasLists       > 0) ? new LSL_List      [ars.iasLists]         : noLists;
            iarObjects     = (ars.iasObjects     > 0) ? new object        [ars.iasObjects]       : noObjects;
            iarRotations   = (ars.iasRotations   > 0) ? new LSL_Rotation  [ars.iasRotations]     : noRotations;
            iarStrings     = (ars.iasStrings     > 0) ? new string        [ars.iasStrings]       : noStrings;
            iarVectors     = (ars.iasVectors     > 0) ? new LSL_Vector    [ars.iasVectors]       : noVectors;
            iarSDTClObjs   = (ars.iasSDTClObjs   > 0) ? new XMRSDTypeClObj[ars.iasSDTClObjs]     : noSDTClObjs;
            iarSDTIntfObjs = (ars.iasSDTIntfObjs > 0) ? new Delegate      [ars.iasSDTIntfObjs][] : noSDTIntfObjs;
        }

        public delegate void Sender (Array array);
        public void SendArrays (Sender sender)
        {
            sender (iarArrays);
            sender (iarFloats);
            sender (iarIntegers);
            sender (iarLists);
            sender (iarObjects);
            sender (iarRotations);
            sender (iarStrings);
            sender (iarVectors);
            sender (iarSDTClObjs);
            sender (iarSDTIntfObjs);
        }

        public delegate Array Recver (Type eleType);
        public void RecvArrays (Recver recver)
        {
            iarArrays      = (XMR_Array[])      recver (typeof (XMR_Array));
            iarFloats      = (SCRIPTFLOAT[])    recver (typeof (SCRIPTFLOAT));
            iarIntegers    = (int[])            recver (typeof (int));
            iarLists       = (LSL_List[])       recver (typeof (LSL_List));
            iarObjects     = (object[])         recver (typeof (object));
            iarRotations   = (LSL_Rotation[])   recver (typeof (LSL_Rotation));
            iarStrings     = (string[])         recver (typeof (string));
            iarVectors     = (LSL_Vector[])     recver (typeof (LSL_Vector));
            iarSDTClObjs   = (XMRSDTypeClObj[]) recver (typeof (XMRSDTypeClObj));
            iarSDTIntfObjs = (Delegate[][])     recver (typeof (Delegate[]));
        }
    }

    public struct XMRInstArSizes {
        public int iasArrays;
        public int iasFloats;
        public int iasIntegers;
        public int iasLists;
        public int iasObjects;
        public int iasRotations;
        public int iasStrings;
        public int iasVectors;
        public int iasSDTClObjs;
        public int iasSDTIntfObjs;

        public void WriteAsmFile (TextWriter asmFileWriter, string label)
        {
            asmFileWriter.WriteLine ("  {0}Arrays       {1}", label, iasArrays);
            asmFileWriter.WriteLine ("  {0}Floats       {1}", label, iasFloats);
            asmFileWriter.WriteLine ("  {0}Integers     {1}", label, iasIntegers);
            asmFileWriter.WriteLine ("  {0}Lists        {1}", label, iasLists);
            asmFileWriter.WriteLine ("  {0}Objects      {1}", label, iasObjects);
            asmFileWriter.WriteLine ("  {0}Rotations    {1}", label, iasRotations);
            asmFileWriter.WriteLine ("  {0}Strings      {1}", label, iasStrings);
            asmFileWriter.WriteLine ("  {0}Vectors      {1}", label, iasVectors);
            asmFileWriter.WriteLine ("  {0}SDTClObjs    {1}", label, iasSDTClObjs);
            asmFileWriter.WriteLine ("  {0}SDTIntfObjs  {1}", label, iasSDTIntfObjs);
        }
        public void WriteToFile (BinaryWriter objFileWriter)
        {
            objFileWriter.Write (iasArrays);
            objFileWriter.Write (iasFloats);
            objFileWriter.Write (iasIntegers);
            objFileWriter.Write (iasLists);
            objFileWriter.Write (iasObjects);
            objFileWriter.Write (iasRotations);
            objFileWriter.Write (iasStrings);
            objFileWriter.Write (iasVectors);
            objFileWriter.Write (iasSDTClObjs);
            objFileWriter.Write (iasSDTIntfObjs);
        }
        public void ReadFromFile (BinaryReader objFileReader)
        {
            iasArrays      = objFileReader.ReadInt32 ();
            iasFloats      = objFileReader.ReadInt32 ();
            iasIntegers    = objFileReader.ReadInt32 ();
            iasLists       = objFileReader.ReadInt32 ();
            iasObjects     = objFileReader.ReadInt32 ();
            iasRotations   = objFileReader.ReadInt32 ();
            iasStrings     = objFileReader.ReadInt32 ();
            iasVectors     = objFileReader.ReadInt32 ();
            iasSDTClObjs   = objFileReader.ReadInt32 ();
            iasSDTIntfObjs = objFileReader.ReadInt32 ();
        }
    }

    public class XMRStackFrame {
        public XMRStackFrame nextSF;
        public string funcName;
        public int callNo;
        public object[] objArray;
    }

    /*
     * Contains only items required by the stand-alone compiler
     * so the compiler doesn't need to pull in all of OpenSim.
     *
     * Inherit from SCRIPTBASECLASS so we can be used as 'this'
     * parameter for backend-API calls, eg llSay().
     */
    public abstract class XMRInstAbstract : SCRIPTBASECLASS
    {
        public const int CALLMODE_NORMAL  = 0;  // when function is called, it proceeds normally
        public const int CALLMODE_SAVE    = 1;  // StackSaveException() was thrown, push args/locals to stackFrames
        public const int CALLMODE_RESTORE = 2;  // when function is called, it pops state from stackFrames

        public ScriptObjCode m_ObjCode;     // script object code this instance was created from

        public object[] ehArgs;             // event handler argument array
        public bool doGblInit = true;       // default state_entry() needs to initialize global variables
        public uint stackLimit;             // CheckRun() must always see this much stack available
        public int heapLimit;               // let script use this many bytes of heap maximum
                                            // includes global vars, local vars, that reference heap
                                            // does not include value-type vars, that is part of stackLimit
        public int heapLeft;                // how much of heapLimit remains available
                                            // ...atomic updates only
        public string traceHeapUse = null;  // null: quiet; else: name of script
        public int stateCode = 0;           // state the script is in (0 = 'default')

        public int callMode = CALLMODE_NORMAL;
                                            // to capture stack frames on stackFrames:
                                            //    set to CALLMODE_SAVE just before throwing StackSaveException()
                                            //    from within CheckRun() and cleared to CALLMODE_NORMAL when
                                            //    the exception is caught
                                            // to restore stack frames from stackFrames:
                                            //    set to CALLMODE_RESTORE just before calling CallSEH() and 
                                            //    cleared to CALLMODE_NORMAL by CheckRun()
        public XMRStackFrame stackFrames;   // stack frames being saved/restored

        /*
         * These arrays hold the global variable values for the script instance.
         * The array lengths are determined by the script compilation,
         * and are found in ScriptObjCode.glblSizes.
         */
        public XMRInstArrays glblVars;

        /****************************************************************\
         *  Function prototypes.                                        *
         *  These functions require access to the OpenSim environment.  *
        \****************************************************************/

        public abstract void CheckRun (int line);
        public abstract int  StackLeft ();
        public abstract LSL_List XMREventDequeue (SCRIPTFLOAT timeout, int returnMask1, int returnMask2,
                                                  int backgroundMask1, int backgroundMask2, int line);
        public abstract void XMREventEnqueue (LSL_List ev);
        public abstract void XMREventCallHandler (LSL_List ev);
        public abstract LSL_List XMREventSaveDets ();
        public abstract void XMREventLoadDets (LSL_List dpList);

        /**************************************************\
         *  Functions what don't require runtime support  *
         *  beyond what the compiler provides.            *
        \**************************************************/

        /**
         * @brief Called during CALLMODE_SAVE to create a stackframe save object that saves 
         *        local variables and calling point within the function.
         * @param funcName = name of function whose frame is being saved
         * @param callNo = call number (ie, return address) within function to restart at
         * @param nSaves = number of variables the function will save
         * @returns an object[nSaves] where function can save variables
         */
        public object[] CaptureStackFrame (string funcName, int callNo, int nSaves)
        {
            XMRStackFrame sf = new XMRStackFrame ();
            sf.nextSF   = stackFrames;
            sf.funcName = funcName;
            sf.callNo   = callNo;
            sf.objArray = new object[nSaves];
            stackFrames = sf;
            return sf.objArray;
        }

        /**
         * @brief Called during CALLMODE_RESTORE to pop a stackframe object to restore 
         *        local variables and calling point within the function.
         * @param funcName = name of function whose frame is being restored
         * @returns the object[nSaves] where function can retrieve variables
         *          callNo = as passed to CaptureStackFrame() indicating restart point
         */
        public object[] RestoreStackFrame (string funcName, out int callNo)
        {
            XMRStackFrame sf = stackFrames;
            if (sf.funcName != funcName) {
                throw new Exception ("frame mismatch " + sf.funcName + " vs " + funcName);
            }
            callNo = sf.callNo;
            stackFrames = sf.nextSF;
            return sf.objArray;
        }

        public void ConsoleWrite (string s)
        {
            Console.WriteLine ("XMRInstance.ConsoleWrite: " + s);
        }

        public string XMRTypeName (object o)
        {
            /*
             * Basic types return constant strings of the script-visible type name.
             */
            if (o is LSL_List)     return "list";
            if (o is LSL_Rotation) return "rotation";
            if (o is LSL_Vector)   return "vector";
            if (o is float)        return "float";
            if (o is int)          return "integer";
            if (o is string)       return "string";
            if (o is double)       return "float";
            if (o is bool)         return "bool";
            if (o is XMR_Array)    return "array";
            if (o is LSL_Integer)  return "integer";
            if (o is LSL_Float)    return "float";
            if (o is LSL_String)   return "string";

            /*
             * A script-defined interface is represented as an array of delegates.
             * If that is the case, convert it to the object of the script-defined 
             * class that is implementing the interface.  This should let the next 
             * step get the script-defined type name of the object.
             */
            if (o is Delegate[]) {
                o = ((Delegate[])o)[0].Target;
            }

            /*
             * If script-defined class instance, get the script-defined 
             * type name.
             */
            if (o is XMRSDTypeClObj) {
                return ((XMRSDTypeClObj)o).sdtcClass.longName.val;
            }

            /*
             * If it's a delegate, maybe we can look up its script-defined type name.
             */
            Type ot = o.GetType ();
            if (o is Delegate) {
                String os;
                if (m_ObjCode.sdDelTypes.TryGetValue (ot, out os)) return os;
            }

            /*
             * Don't know what it is, get the C#-level type name.
             */
            return ot.ToString ();
        }

        /**
         * @brief Get a delegate for a script-defined function.
         * @param name = name of the function including arg types, eg,
         *               "Verify(array,list,string)"
         * @param sig  = script-defined type name
         * @param targ = function's 'this' pointer or null if static
         * @returns delegate for the script-defined function
         */
        public Delegate GetScriptMethodDelegate (string name, string sig, object targ)
        {
            DynamicMethod dm = m_ObjCode.dynamicMethods[name];
            TokenDeclSDTypeDelegate dt = (TokenDeclSDTypeDelegate)m_ObjCode.sdObjTypesName[sig];
            return dm.CreateDelegate (dt.GetSysType (), targ);
        }

        /**
         * @brief Wrap osParseJSON() so we return an array to the script.
         *        No coherent example of its use in scripts on web found.
         * see http://www.json.org/ for more details on JSON
         */
        private static LSL_List nullList = new LSL_List (new object[0]);
        public XMR_Array XMRosParseJSON (string json)
        {
            XMR_Array dict = new XMR_Array (this, 0, 0);
            int idx = ParseJSON (dict, nullList, json, 0);
            while (idx < json.Length) {
                if (json[idx] > ' ') throw new Exception ("left-over json " + json);
                idx ++;
            }
            return dict;
        }

        private static int ParseJSON (XMR_Array dict, LSL_List keys, string json, int idx)
        {
            char c;

            while ((c = json[idx++]) <= ' ') { }
            switch (c) {

                // '{' <keystring> ':' <value> [ ',' <keystring> ':' <value> ... ] '}'
                case '{': {
                    do {
                        string key = ParseJSONString (json, ref idx);
                        while ((c = json[idx++]) <= ' ') { }
                        if (c != ':') throw new Exception ("missing : after key");
                        idx = ParseJSON (dict, ParseJSONKeyAdd (keys, key), json, idx);
                        while ((c = json[idx++]) <= ' ') { }
                    } while (c == ',');
                    if (c != '}') throw new Exception ("missing , or } after value");
                    break;
                }

                // '[' <value> [ ',' <value> ... ] ']'
                case '[': {
                    int index = 0;
                    do {
                        object key = index ++;
                        idx = ParseJSON (dict, ParseJSONKeyAdd (keys, key), json, idx);
                        while ((c = json[idx++]) <= ' ') { }
                    } while (c == ',');
                    if (c != ']') throw new Exception ("missing , or ] after value");
                    break;
                }

                // '"'<string>'"'
                case '"': {
                    -- idx;
                    string val = ParseJSONString (json, ref idx);
                    dict.SetByKey (keys, val);
                    break;
                }

                // true false null
                case 't': {
                    if (json.Substring (idx, 3) != "rue") throw new Exception ("bad true in json");
                    idx += 3;
                    dict.SetByKey (keys, 1);
                    break;
                }

                case 'f': {
                    if (json.Substring (idx, 4) != "alse") throw new Exception ("bad false in json");
                    idx += 4;
                    dict.SetByKey (keys, 0);
                    break;
                }

                case 'n': {
                    if (json.Substring (idx, 3) != "ull") throw new Exception ("bad null in json");
                    idx += 3;
                    dict.SetByKey (keys, null);
                    break;
                }

                // otherwise assume it's a number
                default: {
                    -- idx;
                    object val = ParseJSONNumber (json, ref idx);
                    dict.SetByKey (keys, val);
                    break;
                }
            }

            return idx;
        }

        // Given the key for a whole array, create a key for a given element of the array
        private static LSL_List ParseJSONKeyAdd (LSL_List oldkeys, object key)
        {
            int oldkeyslen = oldkeys.Length;
            object[] array = oldkeys.Data;
            Array.Resize<object> (ref array, oldkeyslen + 1);
            array[oldkeyslen] = key;
            return new LSL_List (array);
        }

        // Parse out a JSON string
        private static string ParseJSONString (string json, ref int idx)
        {
            char c;

            while ((c = json[idx++]) <= ' ') { }
            if (c != '"') throw new Exception ("bad start of json string");

            StringBuilder sb = new StringBuilder ();
            while ((c = json[idx++]) != '"') {
                if (c == '\\') {
                    c = json[idx++];
                    switch (c) {
                        case 'b': {
                            c = '\b';
                            break;
                        }
                        case 'f': {
                            c = '\f';
                            break;
                        }
                        case 'n': {
                            c = '\n';
                            break;
                        }
                        case 'r': {
                            c = '\r';
                            break;
                        }
                        case 't': {
                            c = '\t';
                            break;
                        }
                        case 'u': {
                            c = (char) Int32.Parse (json.Substring (idx, 4), 
                                                    System.Globalization.NumberStyles.HexNumber);
                            idx += 4;
                            break;
                        }
                        default: break;
                    }
                }
                sb.Append (c);
            }
            return sb.ToString ();
        }

        // Parse out a JSON number
        private static object ParseJSONNumber (string json, ref int idx)
        {
            char c;

            while ((c = json[idx++]) <= ' ') { }

            bool expneg = false;
            bool isneg  = false;
            int decpt   = -1;
            int expon   = 0;
            int ival    = 0;
            SCRIPTFLOAT dval = 0;

            if (c == '-') {
                isneg = true;
                c = json[idx++];
            }
            if ((c < '0') || (c > '9')) {
                throw new Exception ("bad json number");
            }
            while ((c >= '0') && (c <= '9')) {
                dval *= 10;
                ival *= 10;
                dval += c - '0';
                ival += c - '0';
                c = '\0';
                if (idx < json.Length) c = json[idx++];
            }
            if (c == '.') {
                decpt = 0;
                c = '\0';
                if (idx < json.Length) c = json[idx++];
                while ((c >= '0') && (c <= '9')) {
                    dval *= 10;
                    dval += c - '0';
                    decpt ++;
                    c = '\0';
                    if (idx < json.Length) c = json[idx++];
                }
            }
            if ((c == 'e') || (c == 'E')) {
                if (decpt < 0) decpt = 0;
                c = json[idx++];
                if (c == '-') expneg = true;
                if ((c == '-') || (c == '+')) c = json[idx++];
                while ((c >= '0') && (c <= '9')) {
                    expon *= 10;
                    expon += c - '0';
                    c = '\0';
                    if (idx < json.Length) c = json[idx++];
                }
                if (expneg) expon = -expon;
            }

            if (c != 0) -- idx;
            if (decpt < 0) {
                if (isneg) ival = -ival;
                return ival;
            } else {
                if (isneg) dval = -dval;
                dval *= Math.Pow (10, expon - decpt);
                return dval;
            }
        }

        /**
         * @brief types of data we serialize
         */
        private enum Ser : byte {
            NULL,
            EVENTCODE,
            LSLFLOAT,
            LSLINT,
            LSLKEY,
            LSLLIST,
            LSLROT,
            LSLSTR,
            LSLVEC,
            OBJARRAY,
            SYSDOUB,
            SYSFLOAT,
            SYSINT,
            SYSSTR,
            XMRARRAY,
            DUPREF,
            SYSBOOL,
            XMRINST,
            DELEGATE,
            SDTCLOBJ
        }

        /**
         * @brief Write an array to the output stream.
         */
        public void SendObjArray (Array array)
        {
            SendObjValue ((object)(int)array.Length);
            for (int i = 0; i < array.Length; i ++) {
                SendObjValue (array.GetValue (i));
            }
        }

        /**
         * @brief Write an object to the output stream.
         * @param graph = object to send
         */
        public BinaryWriter migrateOutWriter;
        public Dictionary<object, int> migrateOutObjects;
        public void SendObjValue (object graph)
        {
            /*
             * Value types (including nulls) are always output directly.
             */
            if (graph == null) {
                this.migrateOutWriter.Write ((byte)Ser.NULL);
                return;
            }
            if (graph is ScriptEventCode) {
                this.migrateOutWriter.Write ((byte)Ser.EVENTCODE);
                this.migrateOutWriter.Write ((int)graph);
                return;
            }
            if (graph is LSL_Float) {
                this.migrateOutWriter.Write ((byte)Ser.LSLFLOAT);
                this.migrateOutWriter.Write ((double)((LSL_Float)graph).value);
                return;
            }
            if (graph is LSL_Integer) {
                this.migrateOutWriter.Write ((byte)Ser.LSLINT);
                this.migrateOutWriter.Write ((int)((LSL_Integer)graph).value);
                return;
            }
            if (graph is LSL_Key) {
                this.migrateOutWriter.Write ((byte)Ser.LSLKEY);
                LSL_Key key = (LSL_Key)graph;
                SendObjValue (key.m_string);  // m_string can be null
                return;
            }
            if (graph is LSL_Rotation) {
                this.migrateOutWriter.Write ((byte)Ser.LSLROT);
                this.migrateOutWriter.Write ((double)((LSL_Rotation)graph).x);
                this.migrateOutWriter.Write ((double)((LSL_Rotation)graph).y);
                this.migrateOutWriter.Write ((double)((LSL_Rotation)graph).z);
                this.migrateOutWriter.Write ((double)((LSL_Rotation)graph).s);
                return;
            }
            if (graph is LSL_String) {
                this.migrateOutWriter.Write ((byte)Ser.LSLSTR);
                LSL_String str = (LSL_String)graph;
                SendObjValue (str.m_string);  // m_string can be null
                return;
            }
            if (graph is LSL_Vector) {
                this.migrateOutWriter.Write ((byte)Ser.LSLVEC);
                this.migrateOutWriter.Write ((double)((LSL_Vector)graph).x);
                this.migrateOutWriter.Write ((double)((LSL_Vector)graph).y);
                this.migrateOutWriter.Write ((double)((LSL_Vector)graph).z);
                return;
            }
            if (graph is bool) {
                this.migrateOutWriter.Write ((byte)Ser.SYSBOOL);
                this.migrateOutWriter.Write ((bool)graph);
                return;
            }
            if (graph is double) {
                this.migrateOutWriter.Write ((byte)Ser.SYSDOUB);
                this.migrateOutWriter.Write ((double)graph);
                return;
            }
            if (graph is float) {
                this.migrateOutWriter.Write ((byte)Ser.SYSFLOAT);
                this.migrateOutWriter.Write ((float)graph);
                return;
            }
            if (graph is int) {
                this.migrateOutWriter.Write ((byte)Ser.SYSINT);
                this.migrateOutWriter.Write ((int)graph);
                return;
            }

            /*
             * Script instance pointer is always just that.
             */
            if (graph == this) {
                this.migrateOutWriter.Write ((byte)Ser.XMRINST);
                return;
            }

            /*
             * If this same exact object was already serialized,
             * just output an index telling the receiver to use
             * that same old object, rather than creating a whole
             * new object with the same values.  Also this prevents
             * self-referencing objects (like arrays) from causing
             * an infinite loop.
             */
            int ident;
            if (this.migrateOutObjects.TryGetValue (graph, out ident)) {
                this.migrateOutWriter.Write ((byte)Ser.DUPREF);
                this.migrateOutWriter.Write (ident);
                return;
            }

            /*
             * Object not seen before, save its address with an unique
             * ident number that the receiver can easily regenerate.
             */
            ident = this.migrateOutObjects.Count;
            this.migrateOutObjects.Add (graph, ident);
            Console.WriteLine ("SendObjValue*: " + ident + " is a " + graph.GetType ().Name);

            /*
             * Now output the object's value(s).
             * If the object self-references, the object is alreay entered
             * in the dictionary and so the self-reference will just emit
             * a DUPREF tag instead of trying to output the whole object 
             * again.
             */
            if (graph is LSL_List) {
                this.migrateOutWriter.Write ((byte)Ser.LSLLIST);
                LSL_List list = (LSL_List)graph;
                SendObjValue (list.Data);
            } else if (graph is XMR_Array) {
                this.migrateOutWriter.Write ((byte)Ser.XMRARRAY);
                ((XMR_Array)graph).SendArrayObj (this.SendObjValue);
            } else if (graph is object[]) {
                this.migrateOutWriter.Write ((byte)Ser.OBJARRAY);
                object[] array = (object[])graph;
                int len = array.Length;
                this.migrateOutWriter.Write (len);
                for (int i = 0; i < len; i ++) {
                    SendObjValue (array[i]);
                }
            } else if (graph is string) {
                this.migrateOutWriter.Write ((byte)Ser.SYSSTR);
                this.migrateOutWriter.Write ((string)graph);
            } else if (graph is Delegate) {
                Delegate del = (Delegate)graph;
                this.migrateOutWriter.Write ((byte)Ser.DELEGATE);
                this.migrateOutWriter.Write (del.Method.Name);
                Type delType = del.GetType ();
                foreach (KeyValuePair<string, TokenDeclSDType> kvp in m_ObjCode.sdObjTypesName) {
                    TokenDeclSDType sdt = kvp.Value;
                    if (sdt is TokenDeclSDTypeDelegate) {
                        TokenDeclSDTypeDelegate sdtd = (TokenDeclSDTypeDelegate)sdt;
                        if (sdtd.GetSysType () == delType) {
                            this.migrateOutWriter.Write (kvp.Key);
                            goto found;
                        }
                    }
                }
                throw new Exception ("cant find script-defined delegate for " + del.Method.Name + " type " + del.GetType ());
            found:
                SendObjValue (del.Target);
            } else if (graph is XMRSDTypeClObj) {
                this.migrateOutWriter.Write ((byte)Ser.SDTCLOBJ);
                ((XMRSDTypeClObj)graph).Send (this.SendObjValue, this.SendObjArray);
            } else {
                throw new Exception ("unhandled type " + graph.GetType().ToString());
            }
        }

        /**
         * @brief Read an array of values from the stream.
         * @param eleType = type of each element
         * @returns array of the elements
         */
        public Array RecvObjArray (Type eleType)
        {
            int length = (int)RecvObjValue ();
            Array array = Array.CreateInstance (eleType, length);
            for (int i = 0; i < length; i ++) {
                array.SetValue (RecvObjValue (), i);
            }
            return array;
        }

        /**
         * @brief Read a single value from the stream.
         * @returns value (boxed as needed)
         */
        public BinaryReader migrateInReader;
        public Dictionary<int, object> migrateInObjects;
        public object RecvObjValue ()
        {
            int ident = this.migrateInObjects.Count;
            Ser code = (Ser)this.migrateInReader.ReadByte ();
            switch (code) {
                case Ser.NULL: {
                    return null;
                }
                case Ser.EVENTCODE: {
                    return (ScriptEventCode)this.migrateInReader.ReadInt32 ();
                }
                case Ser.LSLFLOAT: {
                    return new LSL_Float (this.migrateInReader.ReadDouble ());
                }
                case Ser.LSLINT: {
                    return new LSL_Integer (this.migrateInReader.ReadInt32 ());
                }
                case Ser.LSLKEY: {
                    return new LSL_Key ((string)RecvObjValue ());
                }
                case Ser.LSLLIST: {
                    LSL_List list =  new LSL_List (null);
                    this.migrateInObjects.Add (ident, list);
                    Console.WriteLine ("RecvObjValue*: " + ident + " is a list");
                    list.Data = (object[])RecvObjValue ();
                    return list;
                }
                case Ser.LSLROT: {
                    double x = this.migrateInReader.ReadDouble ();
                    double y = this.migrateInReader.ReadDouble ();
                    double z = this.migrateInReader.ReadDouble ();
                    double s = this.migrateInReader.ReadDouble ();
                    return new LSL_Rotation (x, y, z, s);
                }
                case Ser.LSLSTR: {
                    return new LSL_String ((string)RecvObjValue ());
                }
                case Ser.LSLVEC: {
                    double x = this.migrateInReader.ReadDouble ();
                    double y = this.migrateInReader.ReadDouble ();
                    double z = this.migrateInReader.ReadDouble ();
                    return new LSL_Vector (x, y, z);
                }
                case Ser.OBJARRAY: {
                    int len = this.migrateInReader.ReadInt32 ();
                    object[] array = new object[len];
                    this.migrateInObjects.Add (ident, array);
                    Console.WriteLine ("RecvObjValue*: " + ident + " is a object[]");
                    for (int i = 0; i < len; i ++) {
                        array[i] = RecvObjValue ();
                    }
                    return array;
                }
                case Ser.SYSBOOL: {
                    return this.migrateInReader.ReadBoolean ();
                }
                case Ser.SYSDOUB: {
                    return this.migrateInReader.ReadDouble ();
                }
                case Ser.SYSFLOAT: {
                    return this.migrateInReader.ReadSingle ();
                }
                case Ser.SYSINT: {
                    return this.migrateInReader.ReadInt32 ();
                }
                case Ser.SYSSTR: {
                    string s = this.migrateInReader.ReadString ();
                    this.migrateInObjects.Add (ident, s);
                    Console.WriteLine ("RecvObjValue*: " + ident + " is a string");
                    return s;
                }
                case Ser.XMRARRAY: {
                    XMR_Array array = new XMR_Array (this, 0, 0);
                    this.migrateInObjects.Add (ident, array);
                    Console.WriteLine ("RecvObjValue*: " + ident + " is a XMR_Array");
                    array.RecvArrayObj (this.RecvObjValue);
                    return array;
                }
                case Ser.DUPREF: {
                    ident = this.migrateInReader.ReadInt32 ();
                    return this.migrateInObjects[ident];
                }
                case Ser.XMRINST: {
                    return this;
                }
                case Ser.DELEGATE: {
                    string name = this.migrateInReader.ReadString ();
                    string sig  = this.migrateInReader.ReadString ();
                    object targ = RecvObjValue ();
                    Delegate del = GetScriptMethodDelegate (name, sig, targ);
                    this.migrateInObjects.Add (ident, del);
                    Console.WriteLine ("RecvObjValue*: " + ident + " is a delegate");
                    return del;
                }
                case Ser.SDTCLOBJ: {
                    XMRSDTypeClObj clobj = new XMRSDTypeClObj (this, this.RecvObjValue, this.RecvObjArray);
                    this.migrateInObjects.Add (ident, clobj);
                    Console.WriteLine ("RecvObjValue*: " + ident + " is a XMRSDTypeClObj");
                    return clobj;
                }
                default: throw new Exception ("bad stream code " + code.ToString ());
            }
        }
    }
}
