
CLASSES

    class <classname> : <extends>, <interface> ... {

        <accessquals> class ... { ... }

        <accessquals> constant <fieldname> = <constinitvalue> ;

        <accessquals> constructor ( <arglist> ) [ : [ base ] ( <callargs> ) ] { <methodbody> }

        <accessquals> delegate ... ( ... ) ;

        <accessquals> interface ... { ... }

        <fieldquals>  <type> <fieldname> [ = <initvalue> ] ;

        <methodquals> <type> <propertyname> { [ get { <methodbody> } ] [ set { <methodbody> } ] }

        <methodquals> [ <rettype> ] <methodname> [ : <intftype> [ . <intfmeth> ] ]
                ( <arglist> ) [ ; | { <methodbody> } ]
    }

    Instance methods and instance field initializers have 'base' and 'this' available.
    'this.' is implied when accessing instance fields or methods from within an instance 
    method or field initializer as is common with similar oo languages.

DELEGATES

    delegate [ <rettype> ] <delegatename> ( <arglist> ) ;

FIXED-DIMENSION ARRAYS

    <basetype>[]      - one dimension
    <basetype>[,]     - two dimensions
    <basetype>[,,]    - three dimensions
        ... etc

    declare variable or field example:

        integer rows = number of rows wanted;
        integer cols = number of columns wanted;
        float[,] mat = new float[,] (rows,cols);  // note: NOT new float[rows,cols]

    access element example:

        mat[row,col]

    methods and properties:

        .Length = number of elements in array (all dimensions multiplied)
        .Length(n) = number of elements in dimension n, n=0 for leftmost dimension

            float[,] mat = new float[,](2,3);
                mat.Length    -> 6
                mat.Length(0) -> 2
                mat.Length(1) -> 3

    Jagged arrays are also possible, they are simlar to C#:

        in XMRE:
            string[,][] jagged = new string[,][](3,4);

        equivalent C#:
            string[,][] jagged = new string[3,4][];

        Both yield a 3x4 matrix 'jagged' where each of the 12 elements can hold 
        an one-dimensional array of strings.

        The elements are referenced with indices in the same order as the 
        declaration:

            jagged[i,j]      yields a value of type string[]
            jagged[i,j][k]   yields a value of type string

INTERFACES

    interface <intfname> {

        class ... { ... }

        delegate ... ( ... ) ;

        interface ... { ... }

        [ <rettype> ] <methodname> ( <arglist> ) ;

    }

PROPERTIES

    <methodquals> <type> <propertyname> { [ get { <methodbody> } ] [ set { <methodbody> } ] }

        properties can be defined at top-level for global properties
        properties can be defined abstract, instance, static, virtual within a class

Generics

    Class, Delegate, Interfaces definitions can have generic prototypes in their names 
    and the prototypes can be referenced in the body of the definition as is common with 
    similar oo languages.

    Example:

        public class ArrayMapper<K,V> {
            public K[] keyArray;
            public V[] valArray;

            public constructor (integer len)
            {
                keyArray = new K[] (len);
                valArray = new V[] (len);
            }
            public SetEntry (integer index, K kee, V val)
            {
                keyArray[index] = kee;
                valArray[index] = val;
            }
            ...
        }

        and to access it...

            ArrayMapper<string,integer> am = new ArrayMapper<string,integer> (10);
            am.SetEntry (6, "tree-fife-niner", 359);

Other Definitions

    <accessquals> := { public | protected | private }
    <fieldquals>  := <accessquals> [ static ]
    <methodquals> := <accessquals> [ <methodalloc> ]
    <methodalloc> := abstract | new | new abstract | override | override abstract | 
                     override final | static | static new | virtual | virtual new

      - qualifier keywords can appear in any order, eg, public new abstract and abstract public new are equally valid
      - exactly one of public, protected, private must be specified for each member of a class

      - methodalloc can be any one of these combinations:
                  (omitted) : error if any overshadowed method, cannot be overridden
                   abstract : error if any overshadowed method, must be overridden
                        new : ignore any overshadowed method, cannot be overridden
               new abstract : ignore any overshadowed method, must be overridden
                   override : must have overshadowed abstract/virtual, may be overidden
          override abstract : must have overshadowed abstract, must be overridden
             override final : must have overshadowed abstract/virtual, cannot be overridden
                     static : error if any overshadowed method, cannot be overridden
                 static new : ignore any overshadowed method, cannot be overridden
                    virtual : error if any overshadowed method, may be overidden
                virtual new : ignore any overshadowed method, may be overidden

          'new' says to ignore any rootward overshadowed method.

          'final' says to prohibit any non-new overiding by leafward methods that would 
              otherwise allow it.  'override' is the only such case.

      - fieldalloc can be any one of these combinations:
           (omitted) : one per instance of allocated object
              static : one shared by all instances of the object

    <methodbody> : must use 'this' to refer to instance fields and methods
                   can use 'base' to refer to extended class's fields and methods


XMROption objects;  // to enable

Keywords:

    abstract    - declares a script-defined class's method as being abstract
    base        - used to access fields and methods of rootward class
    class       - declares a script-defined class's contents
    constructor - declares a script-defined class's constructor method
    delegate    - defines a type that can hold a function/method entrypoint
    final       - declares that a script-defined class's method may not be overidden by leafward classes
    get         - defines property's getter function
    interface   - defines a script-defined interface's method prototypes
    new         - allocates a new instance of a script-defined class and calls a constructor
                - also used on member declaration to ignore any rootward definition override
    override    - declares a script-defined class's method as overriding a rootward method
    private     - declares a member can be accessed only from within class
    protected   - declares a member can be accessed only from within class or a leafward class
    public      - declares a member can be accessed anywhere
    set         - defines property's setter function
    static      - declares a script-defined class's method as being static
    this        - used to access the current script-defined class's object instance
    virtual     - declares a script-defined class's method may be overridden by leafward classes

Note:  Use 'undef' instead of 'null' to mean no object present.

