/***************************************************\
 *  COPYRIGHT 2012, Mike Rieker, Beverly, MA, USA  *
 *  All rights reserved.                           *
\***************************************************/

using System;
using System.Collections;
using System.Collections.Generic;

/**
 * @brief Collection of variable/function/method definitions
 */

namespace OpenSim.Region.ScriptEngine.XMREngine
{
	public class VarDict : IEnumerable {
		public VarDict outerVarDict;            // next outer VarDict to search
		public TokenDeclSDTypeClass thisClass;  // this VarDict is for members of thisClass

		private struct ArgTypes {
			public TokenType[] argTypes;

			public bool CanBeCalledBy (TokenType[] calledBy)
			{
				if ((argTypes == null) && (calledBy == null)) return true;
				if ((argTypes == null) || (calledBy == null)) return false;
				if (argTypes.Length != calledBy.Length) return false;
				for (int i = argTypes.Length; -- i >= 0;) {
					if (!TypeCast.IsAssignableFrom (argTypes[i], calledBy[i])) return false;
				}
				return true;
			}

			public override bool Equals (Object that)
			{
				if (that == null) return false;
				if (that.GetType () != typeof (ArgTypes)) return false;
				TokenType[] at = this.argTypes;
				TokenType[] bt = ((ArgTypes)that).argTypes;
				if ((at == null) && (bt == null)) return true;
				if ((at == null) || (bt == null)) return false;
				if (at.Length != bt.Length) return false;
				for (int i = at.Length; -- i >= 0;) {
					if (at[i].ToString () != bt[i].ToString ()) return false;
				}
				return true;
			}

			public override int GetHashCode ()
			{
				TokenType[] at = this.argTypes;
				if (at == null) return -1;
				int hc = 0;
				for (int i = at.Length; -- i >= 0;) {
					int c = (hc < 0) ? 1 : 0;
					hc  = hc * 2 + c;
					hc ^= at[i].ToString ().GetHashCode ();
				}
				return hc;
			}
		}

		private Dictionary<string, Dictionary<ArgTypes, TokenDeclVar>> master = new Dictionary<string, Dictionary<ArgTypes, TokenDeclVar>> ();
		private int count = 0;

		public bool AddEntry (TokenDeclVar var)
		{
			/*
			 * Make sure we have a sub-dictionary based on the bare name (ie, no signature)
			 */
			Dictionary<ArgTypes, TokenDeclVar> typedic;
			if (!master.TryGetValue (var.name.val, out typedic)) {
				typedic = new Dictionary<ArgTypes, TokenDeclVar> ();
				master.Add (var.name.val, typedic);
			}

			/*
			 * See if there is an entry in the sub-dictionary that matches the argument signature.
			 * Note that fields have null argument lists.
			 * Methods always have a non-null argument list, even if only 0 entries long.
			 */
			ArgTypes types;
			types.argTypes = (var.argDecl == null) ? null : KeyTypesToStringTypes (var.argDecl.types);
			if (typedic.ContainsKey (types)) return false;

			/*
			 * It is unique, add to its name-specific sub-dictionary.
			 */
			typedic.Add (types, var);
			count ++;
			return true;
		}

		public int Count { get { return count; } }

		/**
		 * @brief Find all functions/variables that are callable
		 * @param name = name of function/variable to look for
		 * @param argTypes = the argument types the function is being called with
		 *                   null to look for a variable
		 * @returns null: no matching function/variable found
		 *          else: list of matching functions/variables
		 *                for variables, always of length 1
		 */
		private List<TokenDeclVar> found = new List<TokenDeclVar> ();
		public TokenDeclVar[] FindCallables (string name, TokenType[] argTypes)
		{
			argTypes = KeyTypesToStringTypes (argTypes);
			TokenDeclVar var = FindExact (name, argTypes);
			if (var != null) return new TokenDeclVar[] { var };

			Dictionary<ArgTypes, TokenDeclVar> typedic;
			if (!master.TryGetValue (name, out typedic)) return null;

			found.Clear ();
			foreach (KeyValuePair<ArgTypes, TokenDeclVar> kvp in typedic) {
				if (kvp.Key.CanBeCalledBy (argTypes)) found.Add (kvp.Value);
			}
			return (found.Count > 0) ? found.ToArray () : null;
		}

		/**
		 * @brief Find exact matching function/variable
		 * @param name = name of function to look for
		 * @param argTypes = argument types the function was declared with
		 *                   null to look for a variable
		 * @returns null: no matching function/variable found
		 *          else: the matching function/variable
		 */
		public TokenDeclVar FindExact (string name, TokenType[] argTypes)
		{
			Dictionary<ArgTypes, TokenDeclVar> typedic;
			if (!master.TryGetValue (name, out typedic)) return null;
			ArgTypes types;
			types.argTypes = KeyTypesToStringTypes (argTypes);
			TokenDeclVar var;
			if (!typedic.TryGetValue (types, out var)) return null;
			return var;
		}

		/**
		 * @brief Replace any TokenTypeKey elements with TokenTypeStr so that
		 *        it doesn't matter if functions are declared with key or string,
		 *        they will accept either.
		 * @param argTypes = argument types as declared in source code
		 * @returns argTypes with any key replaced by string
		 */
		private static TokenType[] KeyTypesToStringTypes (TokenType[] argTypes)
		{
			if (argTypes != null) {
				int i;
				int nats = argTypes.Length;
				for (i = nats; -- i >= 0;) {
					if (argTypes[i] is TokenTypeKey) break;
				}
				if (i >= 0) {
					TokenType[] at = new TokenType[nats];
					for (i = nats; -- i >= 0;) {
						at[i] = argTypes[i];
						if (argTypes[i] is TokenTypeKey) {
							at[i] = new TokenTypeStr (argTypes[i]);
						}
					}
					return at;
				}
			}
			return argTypes;
		}

		// foreach goes through all the TokenDeclVars that were added

		// IEnumerable
		public IEnumerator GetEnumerator ()
		{
			return new VarDictEnumerator (this.master);
		}

		private class VarDictEnumerator : IEnumerator {
			private IEnumerator masterEnum;
			private IEnumerator typedicEnum;

			public VarDictEnumerator (Dictionary<string, Dictionary<ArgTypes, TokenDeclVar>> master)
			{
				masterEnum = master.Values.GetEnumerator ();
			}

			// IEnumerator
			public void Reset ()
			{
				masterEnum.Reset ();
				typedicEnum = null;
			}

			// IEnumerator
			public bool MoveNext ()
			{
				while ((typedicEnum == null) || !typedicEnum.MoveNext ()) {
					typedicEnum = null;
					if (!masterEnum.MoveNext ()) return false;
					Dictionary<ArgTypes, TokenDeclVar> ctd;
					ctd = (Dictionary<ArgTypes, TokenDeclVar>)masterEnum.Current;
					typedicEnum = ctd.Values.GetEnumerator ();
				}
				return true;
			}

			// IEnumerator
			public object Current { get { return typedicEnum.Current; } }
		}
	}
}
