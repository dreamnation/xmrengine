
XMRE supports several extensions to the LSL to make it easier to write scripts.

    advflowctl - provide traditional break/continue/switch/case statements
    arrays - provide an associative mutable datatype
    chars - provide the character datatype
    fetchsource - script source can be stored on arbirary web server
    inline events - handle event processing inline instead of using event 
                    handlers
    objects - provide mechanism to create script-definable class types
              ...including generics and fixed-dimension arrays
    trycatch - provide mechanism to catch exceptions

Note:  The keywords that are part of the extensions will not be recognized 
       until the corresponding XMROption statement has been given, so the 
       new keywords don't interfere with existing scripts.

       The parts of the XMROption statement are case-insensitive.



Provide advanced flow-control statements similar to other programming 
languages.

Enabled by 'XMROption' 'advFlowCtl' ';'

Keywords:

    break
    case
    constant
    continue
    switch
    ...
    :

'break'    : valid in 'do', 'for', 'foreach', 'switch', 'while'
'continue' : valid in 'do', 'for', 'foreach', 'while'

'constant' usage as follows:

    'constant' name '=' constantexpr ';'

    constantexpr := floatconstant | integerconstant | stringconstant | constantexpr constbinop constantexpr | constunop constantexpr
    constbinop   := '+' | '-' | '*' | '/' | '%' | '&' | '|' | '^'
    constunop    := '-' | '~'

    name is defined to be the same type as constantexpr

    Note: & | ^ ~ require all integer operands
          - * / % require either integer or float operands
          only + is valid for strings

'switch' usage as follows :

    'switch' '(' integerexpression ')' '{'
        [ 'case' integerconstantexpression [ '...' integerconstantexpression ']' ':' singlestatement ]*
        [ 'default' ':' singlestatement ]
    '}'



Arrays are associative in that the index can be any immutable type, and any 
given array can have a mix of index types and a mix of value types.  In 
particular, the index of an array can be a list to provide multiple-dimension 
array functionality.

Unlike other LSL script types, arrays are mutable.  So, unlike lists, arrays 
can be passed to a function, the function can modify the array, and the caller 
will see the changes made by the function.

Enabled by 'XMROption' 'arrays' ';'

Keywords:

    array       declare variable to be an array, and make it initially empty
    foreach     iterate through all elements in an array
    in          keyword part of foreach statement
    is          test array element to be a particular type
    object      declare variable that can hold any type
    undef       test object or array element to hold undefined element

Declare an array:

    'array' name ';'

    Example:

        array ar;

Insert element:

    name '[' index ']' '=' value ';'

        name  : was declared with 'array' statement
        index : lsl value of any type other than array
        value : lsl value of any type

    Examples:

        ar[3] = "abcdef";
        ar["five"] = [ "one", "two", "three" ];
        ar[5.0,"six"] = 7;

Delete element:

    name '[' index ']' '=' undef ';'

        it is not an error to delete an element that does not exist

    Example:

        ar["five"] = undef;

Retrieve element:

    name '[' index ']'

        if element not defined, return value is 'undef'

    Example:

        llSay(0, (string)ar[3]);

Test type of object:

    <object> is <type>  =>  integer 0 or 1
    <object> is undef   =>  integer 0 or 1

    object o;
    if (o is integer) ...
    if (o is string) ... etc

Misc functions:

    ar.clear    // empty array, returns type void
    ar.count    // get number of elements in array, returns type integer
    ar.index(i) // get index of i'th (zero based) element, returns type object
    ar.value(i) // get value of i'th (zero based) element, returns type object

Iterate through all elements:

    array ar;
    object k, v;
    foreach (k,v in ar) {
        k holds the index
        v holds the value
        llSay(0, "ar[" + (string)k + "]=" + (string)v);
    }

    // alternatively:

    object k, v;
    integer n = ar.count;
    for (integer i = 0; i < n; i ++) {
        k = ar.index(i);
        v = ar.value(i);
        llSay(0, (string)i + ": ar[" + (string)k + "]=" + (string)v);
    }



Enable with:

    'xmroption' 'chars' ';'

Keyword:

    char - primitive datatype

Permitted operators -> result type (bool is an integer with value of 0 or 1):

    char == char    -> bool
    char != char    -> bool
    char <  char    -> bool
    char <= char    -> bool
    char >  char    -> bool
    char >= char    -> bool
    char + integer  -> char
    char - integer  -> char
    string + char   -> string
    string[integer] -> char
    char ++         -> char
    char --         -> char
    -- char         -> char
    ++ char         -> char

Permitted casts:

    (integer)char
    (object)char
    (string)char
    (char)integer
    (char)object

Character constants:

    a single character between '' is permitted, eg, 'a', '4', '?'
    a newline can be generated by '\n'
    a tab can be generated by '\t' (it is a real tab char, not four spaces)
    backslash followed by any other character is that character, eg, '\'' and 
        '\\' are valid
    an integer can be cast to a char for any others that are difficult to 
        enter in the script editor, eg, (char)0xB1

Built-in functions:

    string xmrChars2String(object chararray, integer start, integer count)
        creates a string from an array of characters
            chararray = char[] array containing characters on input
            start     = offset in chararray to start at (zero based0
            count     = number of characters to extract
            returns the created string of length count

    xmrString2Chars(string srcstring, integer srcstart, object dstarray, integer dststart, integer count)
        extracts characters from a string and puts them in a character array
            srcstring = string containing characters on input
            srcstart  = where in srcstring to start reading at (zero based)
            dstarray  = char[] array to put characters in
            dststart  = where in dstarray to start writing at (zero based)
            count     = number of characters to extract



Read script source from a web server.

Triggered by:

    XMROption FetchSource url ;

...where url is a string giving the location of the script (including 
the "'s), such as:

    xmroption fetchsource "http://mywebserver.com/somescriptfile.lsl";

You put your script source file on a web server so it can be fetched via http.  
Then, instead of a normal script source inworld, you would put the fetchsource 
statement.  It must be the only source statement in the inworld script (you can 
put comments in there if you like).  When the region servers need the script 
source file, they will read it from the webserver.

This lets you maintain script source files on a webserver instead of using the 
inworld script editor window.  You can use git and splice files togther with 
cpp or whatever you want.

One thing to note however is that once a webserver fetches a source for a 
script and compiles it, it does not require access to the source again as it 
keeps a compiled object-code version cached.  So it will not re-fetch the 
source from the server and so if you make changes, you will need to retrigger 
a download.  This can be done by adding or removing whitespace from the inworld 
script file containing the XMROption FetchSource statement.



Script-defined types provide a mechanism to make programming scripts easier 
instead of having to resort to tricks like manipulating lists.

XMROption objects;  // to enable

Keywords:

    abstract    - declares a script-defined class's method as being abstract
    base        - used to access fields and methods of rootward class
    class       - declares a script-defined class's contents
    constructor - declares a script-defined class's constructor method
    delegate    - defines a type that can hold a function/method entrypoint
    final       - declares that a script-defined class's method may not be overidden by leafward classes
    interface   - defines a script-defined interface's method prototypes
    new         - allocates a new instance of a script-defined class and calls a constructor
                - also used on member declaration to ignore any rootward definition override
    override    - declares a script-defined class's method as overriding a rootward method
    private     - declares a member can be accessed only from within class
    protected   - declares a member can be accessed only from within class or a leafward class
    public      - declares a member can be accessed anywhere
    static      - declares a script-defined class's method as being static
    this        - used to access the current script-defined class's object instance
    virtual     - declares a script-defined class's method may be overridden by leafward classes

    Note:  Use 'undef' instead of 'null' to mean no object being referenced.

CLASSES

    class <classname> : <extends>, <interface> ... {

        <accessquals> class ... { ... }

        <accessquals> constant <fieldname> = <constinitvalue> ;

        <accessquals> constructor ( <arglist> ) [ : [ base ] ( <callargs> ) ] { <methodbody> }

        <accessquals> delegate ... ( ... ) ;

        <accessquals> interface ... { ... }

        <fieldquals>  <type> <fieldname> [ = <initvalue> ] ;

        <methodquals> [ <rettype> ] <methodname> [ : <intftype> [ . <intfmeth> ] ]
                ( <arglist> ) [ ; | { <methodbody> } ]
    }

    Instance methods and instance field initializers have 'base' and 'this' available.
    'this.' is implied when accessing instance fields or methods from within an instance 
    method or field initializer as is common with similar oo languages.

DELEGATES

    delegate [ <rettype> ] <delegatename> ( <arglist> ) ;

FIXED-DIMENSION ARRAYS

    <basetype>[]      - one dimension
    <basetype>[,]     - two dimensions
    <basetype>[,,]    - three dimensions
        ... etc

    declare variable or field example and allocating:

        integer rows = number of rows wanted;
        integer cols = number of columns wanted;
        float[,] mat = new float[,] (rows,cols);  // note: NOT new float[rows,cols]

    declaring and allocating with initial values example:

        integer[,] mat = new int[,] { { 1,2,3 }, { 4,5 },, { 10,11,12, } };

            creates a 4 row, 3 column matrix:

                [  1  2  3 ]
                [  4  5  0 ]
                [  0  0  0 ]
                [ 10 11 12 ]

            The ( 4,5 } got padded with zeroes to fill the row.
            The ,, after the { 4,5 } said to skip a row.
            The , after the 12 is ignored.

            If a comma is not preceded by a value or a sublist,
            it says to skip initializing that element of the array,
            whatever dimension it is in.  So the second comma of 
            ,, after the { 4,5 } said to skip initializing the 
            whole third row of the matrix.  The comma after the 
            12 did not skip anything because it was preceded by 
            a value (ie 12), as is the case with all the other
            commas.

            The initialization values can be arbitrary expressions of the 
            array element's type.

    access element example:

        mat[row,col]

    methods:

        .Length() = total number of elements in array (all dimensions multiplied)
        .Length(n) = number of elements in dimension n, n=0 for leftmost dimension

            float[,] mat = new float[,](2,3);
                mat.Length    -> 6
                mat.Length(0) -> 2
                mat.Length(1) -> 3

    Jagged arrays are also possible, they are simlar to C#:

        in XMRE:
            string[,][] jagged = new string[,][](3,4);

        equivalent C#:
            string[,][] jagged = new string[3,4][];

        Both yield a 3x4 matrix 'jagged' where each of the 12 elements can hold 
        an one-dimensional array of strings.

        The elements are referenced with indices in the same order as the 
        declaration:

            jagged[i,j]      yields a value of type string[]
            jagged[i,j][k]   yields a value of type string

INTERFACES

    interface <intfname> {

        class ... { ... }

        delegate ... ( ... ) ;

        interface ... { ... }

        [ <rettype> ] <methodname> ( <arglist> ) ;

    }

Generics

    Class, Delegate, Interfaces definitions can have generic prototypes in their names 
    and the prototypes can be referenced in the body of the definition as is common with 
    similar oo languages.

    Example:

        public class ArrayMapper<K,V> {
            public K[] keyArray;
            public V[] valArray;

            public constructor (integer len)
            {
                keyArray = new K[] (len);
                valArray = new V[] (len);
            }
            public SetEntry (integer index, K kee, V val)
            {
                keyArray[index] = kee;
                valArray[index] = val;
            }
            ...
        }

        and to access it...

            ArrayMapper<string,integer> am = new ArrayMapper<string,integer> (10);
            am.SetEntry (6, "tree-fife-niner", 359);

Other Definitions

    <accessquals> := { public | protected | private }
    <fieldquals>  := <accessquals> [ static ]
    <methodquals> := <accessquals> [ <methodalloc> ]
    <methodalloc> := abstract | new | new abstract | override | override abstract | 
                     override final | static | static new | virtual | virtual new

      - qualifier keywords can appear in any order, eg, public new abstract and abstract public new are equally valid
      - exactly one of public, protected, private must be specified for each member of a class

      - methodalloc can be any one of these combinations:
                  (omitted) : error if any overshadowed method, cannot be overridden
                   abstract : error if any overshadowed method, must be overridden
                        new : ignore any overshadowed method, cannot be overridden
               new abstract : ignore any overshadowed method, must be overridden
                   override : must have overshadowed abstract/virtual, may be overidden
          override abstract : must have overshadowed abstract, must be overridden
             override final : must have overshadowed abstract/virtual, cannot be overridden
                     static : error if any overshadowed method, cannot be overridden
                 static new : ignore any overshadowed method, cannot be overridden
                    virtual : error if any overshadowed method, may be overidden
                virtual new : ignore any overshadowed method, may be overidden

          'new' says to ignore any rootward overshadowed method.

          'final' says to prohibit any non-new overiding by leafward methods that would 
              otherwise allow it.  'override' is the only such case.

      - fieldalloc can be any one of these combinations:
           (omitted) : one per instance of allocated object
              static : one shared by all instances of the object

    <methodbody> : must use 'this' to refer to instance fields and methods
                   can use 'base' to refer to extended class's fields and methods

Built-in functions:

    string xmrTypeName(object)   returns typename of the given object
                                 should be as specified in script source file

    integer xmrHashCode(object)  gets hash code of the given argument

    xmrArrayCopy(object srcarray, integer srcstart, object dstarray, integer dststart, int count)
                                 copies elements from one array to another
                                 srcarray and dstarray must point to same-typed arrays, ie, 
                                    the element types must match.  If the arrays are multi-dimensional, 
                                    use srcarray.Index(idx0,idx1,...) and dstarray.Index(idx0,idx1,...) 
                                    for the srcstart and dststart parameters.

    list xmrArray2List(object srcarray, integer srcstart, int count)
            creates a list from the given subrange of the source array
            the array elements used can be any mixture of type float,integer,rotation,string,vector

    xmrList2Array(list srclist, integer srcstart, object dstarray, int dststart, int count)
            copies elements from the source list to the destination array
            dstarray must be an array of a type that can hold the types of the list elements
                object[] is always valid




Provide a mechanism for catching exceptions.

Enabled by 'XMROption' 'tryCatch' ';'

Keywords:

    catch
    finally
    throw
    try

    'try' '{' statements ... '}'
    [ 'catch' '(' 'string' name ')' '{' statements ... '}' ]
    [ 'finally' '{' statements ... '}' ]

    'throw' stringexpr ';'

    'throw' ';'     // rethrow from within a 'catch' statement block

