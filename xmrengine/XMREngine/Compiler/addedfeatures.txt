
XMRE supports several extensions to the LSL to make it easier to write scripts.

    advflowctl - provide traditional break/continue/switch/case statements
    arrays - provide an associative mutable datatype
    chars - provide the character datatype
    include - read source from another location
    inline events - handle event processing inline instead of using event 
                    handlers
    objects - provide mechanism to create script-definable class types
              ...including generics and fixed-dimension arrays
    trycatch - provide mechanism to catch exceptions

Note:  The keywords that are part of the extensions will not be recognized 
       until the corresponding xmroption statement has been given, so the 
       new keywords don't interfere with existing scripts.

       The parts of the xmroption statement are case-insensitive.



Provide advanced flow-control statements similar to other programming 
languages.

Enabled by:  xmroption advflowctl;

Keywords:

    break
    case
    constant
    continue
    switch
    ...
    :

'break'    : valid in 'do', 'for', 'foreach', 'switch', 'while'
'continue' : valid in 'do', 'for', 'foreach', 'while'

'constant' usage as follows:

    'constant' name '=' constantexpr ';'

    constantexpr := floatconstant | integerconstant | stringconstant | constantexpr constbinop constantexpr | constunop constantexpr
    constbinop   := '+' | '-' | '*' | '/' | '%' | '&' | '|' | '^'
    constunop    := '-' | '~'

    name is defined to be the same type as constantexpr

    Note: & | ^ ~ require all integer operands
          - * / % require either integer or float operands
          only + is valid for strings

'switch' usage as follows :

    'switch' '(' integerexpression ')' '{'
        [ 'case' integerconstantexpression [ '...' integerconstantexpression ']' ':' singlestatement ]*
        [ 'default' ':' singlestatement ]
    '}'


ASSOCIATIVE ARRAYS

Arrays are associative in that the index can be any immutable type, and any 
given array can have a mix of index types and a mix of value types.  In 
particular, the index of an array can be a list to provide multiple-dimension 
array functionality.

Unlike other LSL script types, arrays are mutable.  So, unlike lists, arrays 
can be passed to a function, the function can modify the array, and the caller 
will see the changes made by the function, all without any array copying.

Enabled by:  xmroption arrays;

Keywords:

    array       declare variable to be an array, and make it initially empty
    foreach     iterate through all elements in an array
    in          keyword part of foreach statement
    is          test array element to be a particular type
    object      declare variable that can hold any type
    undef       test object or array element to hold undefined element

Declare an array:

    'array' name ';'

    Example:

        array ar;

Insert element:

    name '[' index ']' '=' value ';'

        name  : was declared with 'array' statement
        index : lsl value of any type other than array
        value : lsl value of any type

    Examples:

        ar[3] = "abcdef";
        ar["five"] = [ "one", "two", "three" ];
        ar[5.0,"six"] = 7;

Delete element:

    name '[' index ']' '=' undef ';'

        it is not an error to delete an element that does not exist

    Example:

        ar["five"] = undef;

Retrieve element:

    name '[' index ']'

        if element not defined, return value is 'undef'

    Example:

        llOwnerSay((string)ar[3]);

Test type of object:

    <object> is <type>  =>  integer 0 or 1
    <object> is undef   =>  integer 0 or 1

    object o;
    if (o is integer) ...
    if (o is string) ... etc

Misc functions:

    ar.clear    // empty array, returns type void
    ar.count    // get number of elements in array, returns type integer
    ar.index(i) // get index of i'th (zero based) element, returns type object
    ar.value(i) // get value of i'th (zero based) element, returns type object

Iterate through all elements:

    array ar;
    object k, v;
    foreach (k,v in ar) {
        k holds the index
        v holds the value
        llOwnerSay("ar[" + (string)k + "]=" + (string)v);
    }

    // alternatively:

    object k, v;
    integer n = ar.count;
    for (integer i = 0; i < n; i ++) {
        k = ar.index(i);
        v = ar.value(i);
        llOwnerSay((string)i + ": ar[" + (string)k + "]=" + (string)v);
    }


CHARACTER DATATYPE

Enabled by:  xmroption chars;

Keyword:

    char - primitive datatype

Permitted operators -> result type (bool is an integer with value of 0 or 1):

    char == char    -> bool
    char != char    -> bool
    char <  char    -> bool
    char <= char    -> bool
    char >  char    -> bool
    char >= char    -> bool
    char + integer  -> char
    char - integer  -> char
    char + string   -> string
    string + char   -> string
    string[integer] -> char
    char ++         -> char
    char --         -> char
    -- char         -> char
    ++ char         -> char

Permitted casts:

    (integer)char
    (object)char
    (string)char
    (char)integer
    (char)object

Character constants:

    a single character between '' is permitted, eg, 'a', '4', '?'
    a newline can be generated by '\n'
    a tab can be generated by '\t' (it is a real tab char, not four spaces)
    backslash followed by any other character is that character, eg, '\'' and 
        '\\' are valid
    an integer can be cast to a char for any others that are difficult to 
        enter in the script editor, eg, (char)0xB1

Built-in functions:

    string xmrChars2String(object chararray, integer start, integer count)
        creates a string from an array of characters
            chararray = char[] array containing characters on input
            start     = offset in chararray to start at (zero based0
            count     = number of characters to extract
            returns the created string of length count

    xmrString2Chars(string srcstring, integer srcstart, object dstarray, integer dststart, integer count)
        extracts characters from a string and puts them in a character array
            srcstring = string containing characters on input
            srcstart  = where in srcstring to start reading at (zero based)
            dstarray  = char[] array to put characters in
            dststart  = where in dstarray to start writing at (zero based)
            count     = number of characters to extract

Note:  The 'xmroption objects;' option must be enabled to access datatype 
       char[].

xmroption advflowctl;  // 'switch'
xmroption chars;
xmroption objects;     // fixed-dimension arrays
default {
    state_entry ()
    {
        char[] icat = new char[] { 'I', 'c', 'a', 't' };
        string line = "";
        for (integer i = 0; i < icat.Length (); i ++) {
            char ch = icat[i];
            if (line != "") line += " ";
            switch (ch) {
                case 'a' + 2: {
                    line += "see";
                    break;
                }
                case 't': {
                    line += "cat";
                    break;
                }
                default: {
                    line += ch;
                    break;
                }
            }
        }
        llOwnerSay (line + '!');
    }
}


INCLUDE SOURCE FROM WEB SERVER

Read script source from a web server.

Enabled by:  xmroption include <url>;

...where <url> is a string giving the location of the script (including 
the "'s), such as:

    xmroption include "http://mywebserver.com/somescriptfile.lsl";

You put your script source file on a web server so it can be fetched via http.  
Then, instead of a normal script source inworld, you would put the xmroption 
include statement in the inworld script.  When the region servers need the 
script source file, they will read it from the webserver.

This lets you maintain script source files on a webserver instead of using the 
inworld script editor window.  You can use git and splice files togther with 
cpp or whatever you want.

The file is read from the webserver and spliced in the script file replacing 
the xmroption include statement.  A script may contain more than one xmroption 
include statement, and included source files may contain xmroption include 
statements.  A URL within an included source file may be relative, eg, if the 
current source file is from "http://mywebserver.com/myxmrlibrary/tanks.lsl", an 
xmroption include "wheels.lsl"; would open URL 
"http://mywebserver.com/myxmrlibrary/wheels.lsl".

Each included source file is considered to have a signature that uniquely 
identifies it.  This signature is the first line of text of the included source 
file.  If an attempt is made to include a source file with the same signature 
more than once in the same script, only the first include with that signature 
is processed, the others are ignored.  This allows for libraries that may do 
includes of other libraries and so it is not feasible to determine if an 
include has already been done by another library or not.  The signature line 
should be a comment beginning with '//' such as:

    // Scrypt Kyddy's web access library, v1.0.0

One thing to note however is that once a webserver fetches a source for a 
script and compiles it, it does not require access to the source again as it 
keeps a compiled object-code version cached.  So it will not re-fetch the 
source from the server and so if you make changes, you will need to retrigger 
a download.  This can be done by adding or removing whitespace from the inworld 
script file containing the xmroption include statement.


INLINE EVENT HANDLING

Sometimes using the event handler model can be inconvenient and lead to 
distored code.  These built-in functions can lead to simpler code when dealing 
with such situations.

Call an arbitrary event handler in the current state

    xmrEventCallHandler (list ev)
        ev = event to be processed
            ev[0] = (integer) event code (XMREVENTCODE_<eventname>, eg, 
                    XMREVENTCODE_touch_start)
            ev[1..n] = call parameters to the event, if any

 Note:
   1) The event handler is called immediately and when that event handler 
      completes, xmrEventCallHandler() returns to its caller.  Contrast with 
      xmrEventEnqueue() which places the event in the event queue for 
      processing after the current event handler completes.

Block script execution until and event is queued or a timeout is reached

    list xmrEventDequeue (float timeout, integer rm1, integer rm2, 
                                         integer bm1, integer bm2)

        timeout = maximum number of seconds to wait
        rm1,rm2 = if an event is queued that matches these mask bits, the 
                  script is woken, that event is dequeued and returned to the 
                  caller.  the normal event handler defined in the current 
                  state for the event is not executed.
        bm1,bm2 = if an event is queued that matches these mask bits, the 
                  script is woken, that event is dequeued and its normal event 
                  handler for the current statis is executed.  then the script 
                  resumes waiting for what's left of the timeout or for another 
                  event to be queued.

        returns empty list: no event was queued that matched rm1,rm2 and the 
                            timeout was reached
                      else: list giving parameters of the event, same format as 
                            is passed to xmrEventCallHandler()

 Notes:
   1) Scrips should use XMREVENTMASKn_<eventname> symbols for the mask 
      arguments, where n is 1 or 2 for mask1 or mask2 arguments.  The list[0] 
      return argument can be decoded by using XMREVENTCODE_<eventname> symbols.
   2) If all masks are zero, the call ends up acting like llSleep.
   3) If an event is enabled in both rm1,rm2 and bm1,bm2, the rm1,rm2 bit 
      action takes precedence, ie, the event is returned.  This allows a simple 
      specification -1 for both bm1,bm2 arguments to indicate that all events 
      not enabled to be returned by the rm1,rm2 argumetns should be handled in 
      the background.
   4) Any events not listed in either rm1,rm2 or bm1,bm2 arguments will be 
      queued for later processing (subject to normal queue limits).
   5) Background event handlers execute as calls from within XMREventDequeue, 
      they do not execute as separate threads.  Thus any background event 
      handlers must return before the call to xmrEventDequeue will return.
   6) If a background event handler changes state (eg, via 'state' statement), 
      the state is immediately changed and the script-level xmrEventDequeue 
      call does not return.
   7) For returned events, the detect parameters are overwritten by the 
      returned event.  For background events, the detect parameters are saved 
      and restored.
   8) Scripts must contain dummy event handler definitions for any event types 
      that may be returned by XMREventDequeue(), to let the runtime know that 
      the script is capable of processing that event type.  Otherwise, the 
      event may not be queued to the script.

    Event codes:

        XMREVENTCODE_attach
        XMREVENTCODE_state_exit
        XMREVENTCODE_timer
        XMREVENTCODE_touch
        XMREVENTCODE_collision
        XMREVENTCODE_collision_end
        XMREVENTCODE_collision_start
        XMREVENTCODE_control
        XMREVENTCODE_dataserver
        XMREVENTCODE_email
        XMREVENTCODE_http_response
        XMREVENTCODE_land_collision
        XMREVENTCODE_land_collision_end
        XMREVENTCODE_land_collision_start
        XMREVENTCODE_at_target
        XMREVENTCODE_listen
        XMREVENTCODE_money
        XMREVENTCODE_moving_end
        XMREVENTCODE_moving_start
        XMREVENTCODE_not_at_rot_target
        XMREVENTCODE_not_at_target
        XMREVENTCODE_touch_start
        XMREVENTCODE_object_rez
        XMREVENTCODE_remote_data
        XMREVENTCODE_at_rot_target
        XMREVENTCODE_run_time_permissions
        XMREVENTCODE_touch_end
        XMREVENTCODE_state_entry
        XMREVENTCODE_changed
        XMREVENTCODE_link_message
        XMREVENTCODE_no_sensor
        XMREVENTCODE_on_rez
        XMREVENTCODE_sensor
        XMREVENTCODE_http_request

    Event masks:

        XMREVENTMASK1_attach
        XMREVENTMASK1_state_exit
        XMREVENTMASK1_timer
        XMREVENTMASK1_touch
        XMREVENTMASK1_collision
        XMREVENTMASK1_collision_end
        XMREVENTMASK1_collision_start
        XMREVENTMASK1_control
        XMREVENTMASK1_dataserver
        XMREVENTMASK1_email
        XMREVENTMASK1_http_response
        XMREVENTMASK1_land_collision
        XMREVENTMASK1_land_collision_end
        XMREVENTMASK1_land_collision_start
        XMREVENTMASK1_at_target
        XMREVENTMASK1_listen
        XMREVENTMASK1_money
        XMREVENTMASK1_moving_end
        XMREVENTMASK1_moving_start
        XMREVENTMASK1_not_at_rot_target
        XMREVENTMASK1_not_at_target
        XMREVENTMASK1_touch_start
        XMREVENTMASK1_object_rez
        XMREVENTMASK1_remote_data
        XMREVENTMASK1_at_rot_target
        XMREVENTMASK1_run_time_permissions
        XMREVENTMASK1_touch_end
        XMREVENTMASK1_state_entry
        XMREVENTMASK2_changed
        XMREVENTMASK2_link_message
        XMREVENTMASK2_no_sensor
        XMREVENTMASK2_on_rez
        XMREVENTMASK2_sensor
        XMREVENTMASK2_http_request

    Example 1

xmroption advflowctl;
xmroption trycatch;
default {
    state_entry ()
    {
        /*
         * Send request to a webserver.
         */
        key reqid = llHTTPRequest ("http://www.outerworldapps.com/index.html", 
                                   [], "");

        /*
         * Wait here up to 30 seconds for the reply.
         * If any other events come in meanwhile, process them as background 
         * calls.
         */
        while (1) {
            list reply = xmrEventDequeue (30.0, XMREVENTMASK1_http_response, 
                                          0, -1, -1);

            if (llGetListLength (reply) == 0) {
                llOwnerSay ("timed out waiting for reply");
                break;
            }

            integer eventcode = (integer)reply[0];
            if (eventcode != XMREVENTCODE_http_response) {
                // fatal error - should never happen
                throw "bad event code " + eventcode;
            }
            key request_id = (key)reply[1];
            if (request_id != reqid) {
                // got reply for somthing else, ignore and look again
                continue;
            }
            integer status   = (integer)reply[2];
            list    metadata = (list)reply[3];
            string  body     = (string)reply[4];
            llOwnerSay ("reply body: " + body);
            break;
        }
    }
    
    /*
     * This dummy event handler must be present so the runtime knows this script 
     * can handle http_response events.
     */
    http_response (key request_id, integer status, list metadata, string body)
    {
        throw "should never get here";
    }

    /*
     * These event handlers will get called by xmrEventDequeue if the event is 
     * received while waiting for the reply from the webserver.
     *
     * They also get called normally once the start_entry() event handler 
     * completes.
     */
    touch_start (integer num_detected)
    {
        llOwnerSay ("touched!");
    }
    changed (integer change)
    {
        llOwnerSay ("changed!");
    }
}

    Example 2

xmroption advflowctl;
xmroption trycatch;
default {
    state_entry ()
    {
        /*
         * Tell runtime to queue all messages on channel 0 to us.
         */
        llListen (0, "", NULL_KEY, "");

        while (1) {

            /*
             * Tell xmrEventDequeue() to wait up to 5 seconds per call for one 
             * of the events listed in the rm1,rm2 arguments.  Meanwhile, if 
             * any events listed in the bm1,bm2 arguments are received, process 
             * them via the normal event handlers.
             */
            list ev = xmrEventDequeue (5.0, 
                    XMREVENTMASK1_touch_start | XMREVENTMASK1_listen, 
                    XMREVENTMASK2_changed, 
                    -1, -1);  // -1,-1 means everything else
            if (llGetListLength (ev) == 0) {
                llOwnerSay ("nothing happened in the past five seconds");
                continue;
            }
            integer eventcode = (integer)ev[0];
            switch (eventcode) {
                case XMREVENTCODE_touch_start: {
                    integer num_detected = (integer)ev[1];
                    llOwnerSay ("touched " + num_detected + " time(s)");
                    break;
                }
                case XMREVENTCODE_listen: {
                    integer channel = (integer)ev[1];
                    string  name    = (string)ev[2];
                    key     id      = (key)ev[3];
                    string  message = (string)ev[4];
                    llOwnerSay ("Heard from " + name + "(" + id + ") on " + 
                            channel + ": " + message);
                    break;
                }
                case XMREVENTCODE_changed: {
                    integer change = (integer)ev[1];
                    llOwnerSay ("something changed: " + change);
                    break;
                }
                default: {
                    // fatal error - should never happen
                    throw "don't know why I got event " + eventcode;
                }
            }
        }
    }

    /*
     * These dummy handlers must be present so the runtime knows the script 
     * wants these events to be queued to the script.  But they never get 
     * called because the xmrEventDequeue() has them listed in its rm1,rm2 
     * mask arguments.
     */
    touch_start (integer num_detected)
    {
        throw "should never get to the regular touch_start() handler";
    }
    listen (integer channel, string name, key id, string message)
    {
        throw "should never get to the regular listen() handler";
    }
    changed (integer change)
    {
        throw "should never get to the regular changed() handler";
    }

    /*
     * Since this event is not listed in the rm1,rm2 arguments but is listed in 
     * the bm1,bm2 arguments, it will be called normally in the background by 
     * xmrEventDequeue() whenever this event is received.
     */
    collision_start (integer num_detected)
    {
        llOwnerSay ("collided with " + num_detected + " thing(s)");
    }
}

Queue an event to the calling script

    xmrEventEnqueue (list ev)
        ev = event to be enqueued, see xmrEventCallHandler()

 Note:
   1) The event is queued to execute along with any other events that might be 
      pending, subject to event queuing limits, and executes after the current 
      event handler completes.  Contrast with xmrEventCallHandler(), which 
      directly calls the event handler immediately.

Load current detect params from a list

    xmrEventLoadDets (list dp)
        dp = as returned by xmrEventSaveDets()

Save current detect params into a list

    list xmrEventSaveDets ()
        returns list giving detect params for current event


OBJECTS

Script-defined types provide a mechanism to make programming scripts easier 
instead of having to resort to tricks like manipulating lists.

Enabled by:  xmroption objects;

Keywords:

    abstract    - declares a script-defined class's method as being abstract
    base        - used to access fields and methods of rootward class
    class       - declares a script-defined class's contents
    constructor - declares a script-defined class's constructor method
    delegate    - defines a type that can hold a function/method entrypoint
    final       - declares that a script-defined class's method may not be overidden by leafward classes
    interface   - defines a script-defined interface's method prototypes
    new         - allocates a new instance of a script-defined class and calls a constructor
                - also used on member declaration to ignore any rootward definition override
    override    - declares a script-defined class's method as overriding a rootward method
    private     - declares a member can be accessed only from within class
    protected   - declares a member can be accessed only from within class or a leafward class
    public      - declares a member can be accessed anywhere
    static      - declares a script-defined class's method as being static
    this        - used to access the current script-defined class's object instance
    typedef     - used to define convenience names for types
    virtual     - declares a script-defined class's method may be overridden by leafward classes

    Note:  Use 'undef' instead of 'null' to mean no object being referenced.
           Requires the 'xmroption arrays;' statement to enable.

CLASSES

    class <classname> : <extends>, <interface> ... {

        <accessquals> class ... { ... }

        <accessquals> constant <fieldname> = <constinitvalue> ;

        <accessquals> constructor ( <arglist> ) [ : [ base ] ( <callargs> ) ] { <methodbody> }

        <accessquals> delegate ... ( ... ) ;

        <accessquals> interface ... { ... }

        <fieldquals>  <type> <fieldname> [ = <initvalue> ] ;

        <methodquals> [ <rettype> ] <methodname> [ : <intftype> [ . <intfmeth> ] ]
                ( <arglist> ) [ ; | { <methodbody> } ]

        <methodquals> <type> <propname> { [ get [ ; | { <getbody> } ] ] [ set [ ; | { <setbody> } ] ] }
    }

    Instance methods and instance field initializers have 'base' and 'this' 
    available.  'this.' is implied when accessing instance fields or methods 
    from within an instance method or field initializer as is common with 
    similar oo languages.

DELEGATES

    delegate [ <rettype> ] <delegatename> ( <arglist> ) ;

FIXED-DIMENSION ARRAYS

    <basetype>[]      - one dimension
    <basetype>[,]     - two dimensions
    <basetype>[,,]    - three dimensions
        ... etc

    declare variable or field example and allocating:

        integer rows = number of rows wanted;
        integer cols = number of columns wanted;
        float[,] mat = new float[,] (rows,cols);  // note: NOT new float[rows,cols]

    declaring and allocating with initial values example:

        integer[,] mat = new int[,] { { 1,2,3 }, { 4,5 },, { 10,11,12, } };

            creates a 4 row, 3 column matrix:

                [  1  2  3 ]
                [  4  5  0 ]
                [  0  0  0 ]
                [ 10 11 12 ]

            The ( 4,5 } got padded with zeroes to fill the row.
            The ,, after the { 4,5 } said to skip a row.
            The , after the 12 is ignored.

            If a comma is not preceded by a value or a sublist,
            it says to skip initializing that element of the array,
            whatever dimension it is in.  So the second comma of 
            ,, after the { 4,5 } said to skip initializing the 
            whole third row of the matrix.  The comma after the 
            12 did not skip anything because it was preceded by 
            a value (ie 12), as is the case with all the other
            commas.

            The initialization values can be arbitrary expressions of the 
            array element's type.

    access element example:

        mat[row,col]

    methods:

        .Length() = total number of elements in array (all dimensions multiplied)
        .Length(n) = number of elements in dimension n, n=0 for leftmost dimension

            float[,] mat = new float[,](2,3);
                mat.Length    -> 6
                mat.Length(0) -> 2
                mat.Length(1) -> 3

    Jagged arrays are also possible, they are simlar to C#:

        in XMRE:
            string[,][] jagged = new string[,][](3,4);

        equivalent C#:
            string[,][] jagged = new string[3,4][];

        Both yield a 3x4 matrix 'jagged' where each of the 12 elements can hold 
        an one-dimensional array of strings.

        The elements are referenced with indices in the same order as the 
        declaration:

            jagged[i,j]      yields a value of type string[]
            jagged[i,j][k]   yields a value of type string

INTERFACES

    interface <intfname> {

        class ... { ... }

        delegate ... ( ... ) ;

        interface ... { ... }

        [ <rettype> ] <methodname> ( <arglist> ) ;

        <type> <propname> { [ get ; ] [ set ; ] }
    }

TYPEDEFS

    typedef <typedefname> <definition> ;

        Wherever <typedefname> is found in the source, substitute in 
        <definition>.  <definition> can contain any tokens except:

             { } ; class delegate interface typedef

        and cannot, either directly or indirectly, contain <typedefname>.
        { } ; can be specified within <definition> by using {{ }} ;; 
        respectively.

        Note that the order of the elements of the typedef statement are 
        reversed compared to C or C++.  The type name being declared comes 
        first followed by the definition.

        typedef can be used to avoid repeating long types:

            Dictionary<string,integer> CreateNameDict ()
            {
                Dictionary<string,integer> names = 
                        new Dictionary<string,integer> ();
                return names;
            }

        becomes:

            typedef Str2IntDict Dictionary<string,integer>;

            Str2IntDict CreateNameDict ()
            {
                Str2IntDict names = new Str2IntDict ();
                return names;
            }

        Note that Str2IntDict and Dictionary<string,integer> can be used 
        interchangably throughout the source code in the example as they are 
        considered to be exactly the same type.  Str2IntDict is simply a 
        shorthand for Dictionary<string,integer>.

Generics

    Class, Delegate, Interfaces, Typedef definitions can have generic 
    prototypes in their names and the prototypes can be referenced in the body 
    of the definition as is common with similar oo languages.

    For class, delegate and interface, the arguments passed must be valid 
    types.

    For typedef, the arguments passed can be arbitrary tokens, except cannot 
    normally include > or ,.  If it is desired to pass > or ,, enclose the 
    argument in ( ) which are stripped from the argument when substituted in 
    the body of the definition      

    Example:

        public class ArrayMapper<K,V> {
            public K[] keyArray;
            public V[] valArray;

            public constructor (integer len)
            {
                keyArray = new K[] (len);
                valArray = new V[] (len);
            }
            public SetEntry (integer index, K kee, V val)
            {
                keyArray[index] = kee;
                valArray[index] = val;
            }
            ...
        }

        and to access it...

            ArrayMapper<string,integer> am = new ArrayMapper<string,integer> (10);
            am.SetEntry (6, "tree-fife-niner", 359);

Other Definitions

    <accessquals> := { public | protected | private }
    <fieldquals>  := <accessquals> [ static ]
    <methodquals> := <accessquals> [ <methodalloc> ]
    <methodalloc> := abstract | new | new abstract | override | override abstract | 
                     override final | static | static new | virtual | virtual new

      - qualifier keywords can appear in any order, eg, public new abstract and abstract public new are equally valid
      - exactly one of public, protected, private must be specified for each member of a class

      - methodalloc can be any one of these combinations:
                  (omitted) : error if any overshadowed method, cannot be overridden
                   abstract : error if any overshadowed method, must be overridden
                        new : ignore any overshadowed method, cannot be overridden
               new abstract : ignore any overshadowed method, must be overridden
                   override : must have overshadowed abstract/virtual, may be overidden
          override abstract : must have overshadowed abstract, must be overridden
             override final : must have overshadowed abstract/virtual, cannot be overridden
                     static : error if any overshadowed method, cannot be overridden
                 static new : ignore any overshadowed method, cannot be overridden
                    virtual : error if any overshadowed method, may be overidden
                virtual new : ignore any overshadowed method, may be overidden

          'new' says to ignore any rootward overshadowed method.

          'final' says to prohibit any non-new overiding by leafward methods that would 
              otherwise allow it.  'override' is the only such case.

      - fieldalloc can be any one of these combinations:
           (omitted) : one per instance of allocated object
              static : one shared by all instances of the object

    <methodbody> : statements composing the method
                   can use 'this' to refer to the instance's members
                   can use 'base' to refer to extended class's members

    <getbody> : like a <methodbody> that returns the value of the property
    <setbody> : like a <methodbody> that has a single parameter named 'value' 
                that contains the value being written to the property

Built-in functions:

    string xmrTypeName(object)   returns typename of the given object
                                 should be as specified in script source file

    integer xmrHashCode(object)  gets hash code of the given argument

    xmrArrayCopy(object srcarray, integer srcstart, object dstarray, integer dststart, int count)
                                 copies elements from one array to another
                                 srcarray and dstarray must point to same-typed arrays, ie, 
                                    the element types must match.  If the arrays are multi-dimensional, 
                                    use srcarray.Index(idx0,idx1,...) and dstarray.Index(idx0,idx1,...) 
                                    for the srcstart and dststart parameters.

    list xmrArray2List(object srcarray, integer srcstart, int count)
            creates a list from the given subrange of the source array
            the array elements used can be any mixture of type float,integer,rotation,string,vector

    xmrList2Array(list srclist, integer srcstart, object dstarray, int dststart, int count)
            copies elements from the source list to the destination array
            dstarray must be an array of a type that can hold the types of the list elements
                object[] is always valid


EXCEPTION HANDLING

Provide a mechanism for catching exceptions.

Enabled by:  xmroption trycatch;

Keywords:

    catch
    finally
    throw
    try

    'try' '{' statements ... '}'
    [ 'catch' '(' type name ')' '{' statements ... '}' ]
    [ 'finally' '{' statements ... '}' ]

    'throw' expression ';'

    'throw' ';'     // rethrow from within a 'catch' clause

    A single try can include any number (greater than zero) of catch and/or 
    finally clauses, in any order.  They are stepped through one-by-one and 
    executed as needed.  try/catch/finally can be nested in any combination.

    The expression of a throw statement within a try clause can be of any type, 
    eg, integer, string, script-defined object type.  It will match a the first 
    catch clause whose parameter type is assignable from the value of thrown 
    expression.  Any finally clauses between the throw and the corresponding 
    catch are executed before the catch.  Then the single catch is executed.  
    If the catch rethrows the execption, then the search for a compatible catch 
    clause resumes, executing finally clauses until a match is found.  If a 
    catch does not rethrow the execption, all finally clauses outside the catch 
    are executed and all catch clauses outside the catch are ignored.

    If an exception is thrown and no compatible catch clause is found, all 
    finally clauses are executed in order and the script is terminated and an 
    error message is printed.  This also applies to an exception thrown outside 
    any try clause trivially as there can't be any catch clauses for it to 
    match and there won't be any finally clauses to execute either, the script 
    is simply terminated and an error message is printed.

xmroption arrays;    // for type 'object'
xmroption trycatch;
default {
    state_entry ()
    {
        llOwnerSay ("catch filtering...");
        list values = [ 1, "two", 3.0, <4,4,4>, <5,5,5,5> ];
        for (integer i = 0; i < 5; i ++) {
            try {
                throw values[i];
            } catch (integer i) {
                llOwnerSay ("caught integer " + i);
            } catch (string s) {
                llOwnerSay ("caught string " + s);
            } catch (float f) {
                llOwnerSay ("caught float " + f);
            } catch (vector v) {
                llOwnerSay ("caught vector " + (string)v);
            } catch (object o) {
                llOwnerSay ("caught other " + xmrTypeName (o) + " " + (string)o);
            }
        }
    }
}
