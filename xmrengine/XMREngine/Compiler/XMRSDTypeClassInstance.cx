/***************************************************\
 *  COPYRIGHT 2012, Mike Rieker, Beverly, MA, USA  *
 *  All rights reserved.                           *
\***************************************************/

#include "lsltypes.h"

using System;
using System.Reflection.Emit;

namespace OpenSim.Region.ScriptEngine.XMREngine
{
    public class XMRSDTypeClassInstance
    {
        /*
         * Which script instance we are part of so we can access
         * the script's global variables and functions.
         */
        public XMRInstAbstract xmrInst;

        /*
         * What class we actually are in the hierarchy
         * used for casting.
         */
        public TokenDeclSDTypeClass sdtcClass;

        /*
         * Our VTable array, used for calling virtual functions.
         * And ITable array, used for calling our implementation of interface functions.
         */
        public Delegate[]     sdtcVTable;
        public Delegate[][]   sdtcITable;

        /*
         * These arrays hold the insance variable values.
         * The array lengths are determined by the script compilation,
         * and are found in TokenDeclSDTypeClass.
         */
        public XMR_Array[]    sdtcArrays;
        public SCRIPTFLOAT[]  sdtcFloats;
        public int[]          sdtcIntegers;
        public LSL_List[]     sdtcLists;
        public object[]       sdtcObjects;
        public LSL_Rotation[] sdtcRotations;
        public string[]       sdtcStrings;
        public LSL_Vector[]   sdtcVectors;
        public XMRSDTypeClassInstance[] sdtcSDTClObjs;
        public Delegate[][]   sdtcSDTIntfObjs;

        private static readonly XMR_Array[]    noArrays      = new XMR_Array[0];
        private static readonly SCRIPTFLOAT[]  noFloats      = new SCRIPTFLOAT[0];
        private static readonly int[]          noIntegers    = new int[0];
        private static readonly LSL_List[]     noLists       = new LSL_List[0];
        private static readonly object[]       noObjects     = new object[0];
        private static readonly LSL_Rotation[] noRotations   = new LSL_Rotation[0];
        private static readonly string[]       noStrings     = new string[0];
        private static readonly LSL_Vector[]   noVectors     = new LSL_Vector[0];
        private static readonly XMRSDTypeClassInstance[] noSDTClObjs = new XMRSDTypeClassInstance[0];
        private static readonly Delegate[][]   noSDTIntfObjs = new Delegate[0][];

        public XMRSDTypeClassInstance (XMRInstAbstract inst, int classindex)
        {
            Delegate[] thisMid = null;
            TokenDeclSDTypeClass clas = (TokenDeclSDTypeClass)inst.m_ObjCode.sdObjTypesIndx[classindex];

            xmrInst   = inst;
            sdtcClass = clas;

            /*
             * VTable consists of delegates built from DynamicMethods and the 'this' pointer.
             * Yes, yes, lots of shitty little mallocs.
             */
            DynamicMethod[] vDynMeths = clas.vDynMeths;
            if (vDynMeths != null) {
                int n = vDynMeths.Length;
                Type[] vMethTypes = clas.vMethTypes;
                sdtcVTable = new Delegate[n];
                for (int i = 0; i < n; i ++) {
                    sdtcVTable[i] = vDynMeths[i].CreateDelegate (vMethTypes[i], this);
                }
            }

            /*
             * Fill in interface vtables.
             * There is one array of delegates for each implemented interface.
             * The array of delegates IS the interface's object, ie, the 'this' value of the interface.
             * To cast from the class type to the interface type, just get the correct array from the table.
             * To cast from the interface type to the class type, just get Target of entry 0.
             *
             * So we end up with this:
             *    sdtcITable[interfacenumber][methodofintfnumber] = delegate of this.ourimplementationofinterfacesmethod
             */
            if (clas.iDynMeths != null) {
                int nIFaces = clas.iDynMeths.Length;
                sdtcITable = new Delegate[nIFaces][];
                for (int i = 0; i < nIFaces; i ++) {

                    // get vector of entrypoints of our instance methods that implement that interface
                    DynamicMethod[] iDynMeths = clas.iDynMeths[i];
                    Type[]         iMethTypes = clas.iMethTypes[i];

                    // allocate an array with a slot for each method the interface defines
                    int nMeths = iDynMeths.Length;
                    Delegate[] ivec;
                    if (nMeths > 0) {
                        // fill in the array with delegates that reference back to this class instance
                        ivec = new Delegate[nMeths];
                        for (int j = 0; j < nMeths; j ++) {
                            ivec[j] = iDynMeths[j].CreateDelegate (iMethTypes[j], this);
                        }
                    } else {
                        // just a marker interface with no methods,
                        // allocate a one-element array and fill
                        // with a dummy entry.  this will allow casting
                        // back to the original class instance (this)
                        // by reading Target of entry 0.
                        if (thisMid == null) {
                            thisMid = new Delegate[1];
                            thisMid[0] = markerInterfaceDummy.CreateDelegate (typeof (MarkerInterfaceDummy), this);
                        }
                        ivec = thisMid;
                    }

                    // save whatever we ended up allocating
                    sdtcITable[i] = ivec;
                }
            }

            /*
             * These arrays hold the script non-static instance variables.
             * Lots more shitty little mallocs...
             */
            sdtcArrays      = (clas.numInstArrays      > 0) ? new XMR_Array   [clas.numInstArrays]        : noArrays;
            sdtcFloats      = (clas.numInstFloats      > 0) ? new SCRIPTFLOAT [clas.numInstFloats]        : noFloats;
            sdtcIntegers    = (clas.numInstIntegers    > 0) ? new int         [clas.numInstIntegers]      : noIntegers;
            sdtcLists       = (clas.numInstLists       > 0) ? new LSL_List    [clas.numInstLists]         : noLists;
            sdtcObjects     = (clas.numInstObjects     > 0) ? new object      [clas.numInstObjects]       : noObjects;
            sdtcRotations   = (clas.numInstRotations   > 0) ? new LSL_Rotation[clas.numInstRotations]     : noRotations;
            sdtcStrings     = (clas.numInstStrings     > 0) ? new string      [clas.numInstStrings]       : noStrings;
            sdtcVectors     = (clas.numInstVectors     > 0) ? new LSL_Vector  [clas.numInstVectors]       : noVectors;
            sdtcSDTClObjs   = (clas.numInstSDTClObjs   > 0) ? new XMRSDTypeClassInstance[clas.numInstSDTClObjs] : noSDTClObjs;
            sdtcSDTIntfObjs = (clas.numInstSDTIntfObjs > 0) ? new Delegate    [clas.numInstSDTIntfObjs][] : noSDTIntfObjs;
        }

        private delegate void MarkerInterfaceDummy ();
        private static DynamicMethod markerInterfaceDummy = MakeMarkerInterfaceDummy ();
        private static DynamicMethod MakeMarkerInterfaceDummy ()
        {
            DynamicMethod dm = new DynamicMethod ("XMRSDTypeClassInstance.MarkerInterfaceDummy", null, null);
            ILGenerator ilGen = dm.GetILGenerator ();
            ilGen.Emit (OpCodes.Ret);
            return dm;
        }

        /**
         * @brief Perform runtime casting of script-defined interface object to
         *        its corresponding script-defined class object.
         * @param da = interface object (array of delegates pointing to class's implementations of interface's methods)
         * @param classindex = what class those implementations are supposedly part of
         * @returns original script-defined class object
         */
        public static XMRSDTypeClassInstance CastIFace2Class (Delegate[] da, int classindex)
        {
            return CastClass2Class (da[0].Target, classindex);
        }

        /**
         * @brief Perform runtime casting of XMRSDTypeClassInstance's.
         * @param ob = XMRSDTypeClassInstance of unknown script-defined class to cast
         * @param classindex = script-defined class to cast it to
         * @returns ob is a valid instance of classindex; else exception thrown
         */
        public static XMRSDTypeClassInstance CastClass2Class (object ob, int classindex)
        {
            /*
             * Let mono check to see if we at least have an XMRSDTypeClassInstance.
             */
            XMRSDTypeClassInstance ci = (XMRSDTypeClassInstance)ob;
            if (ci != null) {

                /*
                 * This is the target class, ie, what we are hoping the object can cast to.
                 */
                TokenDeclSDTypeClass tc = (TokenDeclSDTypeClass)ci.xmrInst.m_ObjCode.sdObjTypesIndx[classindex];

                /*
                 * Step from the object's actual class rootward.
                 * If we find the target class along the way, the cast is valid.
                 * If we run off the end of the root, the cast is not valid.
                 */
                for (TokenDeclSDTypeClass ac = ci.sdtcClass; ac != tc; ac = ac.extends) {
                    if (ac == null) throw new InvalidCastException ("invalid cast from " + ci.sdtcClass.longName.val + 
                                                                                  " to " + tc.longName.val);
                }

                /*
                 * The target class is at or rootward of the actual class,
                 * so the cast is valid.
                 */
            }
            return ci;
        }

        /**
         * @brief Cast an arbitrary object to the given interface.
         * @param ob = object to be cast of unknown type
         * @returns ob cast to the interface type
         */
        public static Delegate[] CastObj2IFace (object ob, string ifacename)
        {
            if (ob == null) return null;

            /*
             * If it is already one of our delegates, extract the script-defined class object from it.
             */
            if (ob is Delegate[]) {
                Delegate[] da = (Delegate[])ob;
                ob = da[0].Target;
            }

            /*
             * Now that we have a presumed script-defined class object, cast that to the requested interface
             * by picking the array of delegates that corresponds to the requested interface.
             */
            XMRSDTypeClassInstance ci = (XMRSDTypeClassInstance)ob;
            int iFaceIndex = ci.sdtcClass.intfIndices[ifacename];
            return ci.sdtcITable[iFaceIndex];
        }

        public static void XMRArrayCopy (object srcobj, int srcstart, object dstobj, int dststart, int count)
        {
            XMRSDTypeClassInstance srcsdt = (XMRSDTypeClassInstance)srcobj;
            XMRSDTypeClassInstance dstsdt = (XMRSDTypeClassInstance)dstobj;

            string srctypename = srcsdt.sdtcClass.longName.val;
            string dsttypename = dstsdt.sdtcClass.longName.val;

            int i = srctypename.IndexOf ('[');
            int j = dsttypename.IndexOf ('[');

            if ((i < 0) || (j < 0)) throw new InvalidCastException ("non-array passed: " + srctypename + " and/or " + dsttypename);

            if ((i != j) || !srctypename.StartsWith (dsttypename.Substring (0, j))) {
                throw new ArrayTypeMismatchException (srctypename + " vs " + dsttypename);
            }

            int srclen  = srctypename.Length;
            int dstlen  = dsttypename.Length;
            int srcjags = 0;
            int dstjags = 0;
            while (++ i < srclen) if (srctypename[i] == ']') srcjags ++;
            while (++ j < dstlen) if (dsttypename[j] == ']') dstjags ++;
            if (dstjags != srcjags) {
                throw new ArrayTypeMismatchException (srctypename + " vs " + dsttypename);
            }

            Array srcarray = (Array)srcsdt.sdtcObjects[0];
            Array dstarray = (Array)dstsdt.sdtcObjects[0];

            Console.WriteLine ("XMRArrayCopy: srcsrray.len=" + srcarray.Length);
            Console.WriteLine ("XMRArrayCopy: dstarray.len=" + dstarray.Length);

            Array.Copy (srcarray, srcstart, dstarray, dststart, count);
        }
    }
}
