/***************************************************\
 *  COPYRIGHT 2012, Mike Rieker, Beverly, MA, USA  *
 *  All rights reserved.                           *
\***************************************************/

using System;
using System.Collections.Generic;
using System.Reflection;
using System.Reflection.Emit;
using System.Text;

using OpenSim.Region.ScriptEngine.Shared.Api.Interfaces;
using OpenSim.Region.ScriptEngine.Shared.ScriptBase;

#include "lsltypes.h"


/**
 * @brief Generate code for the backend API calls.
 */
namespace OpenSim.Region.ScriptEngine.XMREngine
{
	public delegate void CodeGenCall (ScriptCodeGen scg, Token errorAt, CompValuTemp result, CompValu[] args);

	public class TokenDeclInline : TokenDeclVar {

		public CodeGenCall codeGen;   // method that generates code
		public MethodInfo methInfo;   // function called by the inline
		public bool doCheckRun;       // valid for CodeGenBEApi only
		public int keepNulls;         // valid for CodeGenLLParseString2List only

		private static Type[] oneDoub  = new Type[] { typeof (double) };
		private static Type[] twoDoubs = new Type[] { typeof (double), typeof (double) };

		private static TokenTypeFloat tokenTypeFloat  = new TokenTypeFloat (null);

		private static MethodInfo roundMethInfo = ScriptCodeGen.GetStaticMethod (typeof (System.Math), "Round", 
				new Type[] { typeof (double), typeof (MidpointRounding) });

		private static readonly MethodInfo fixLLParcelMediaQuery = ScriptCodeGen.GetStaticMethod 
				(typeof (XMRInstAbstract), "FixLLParcelMediaQuery", new Type[] { typeof (LSL_List) });

		private static readonly MethodInfo fixLLParcelMediaCommandList = ScriptCodeGen.GetStaticMethod 
				(typeof (XMRInstAbstract), "FixLLParcelMediaCommandList", new Type[] { typeof (LSL_List) });

		/*
		 * For those listed in noCheckRun, we just generate the call (simple computations).
		 * For all others, we generate the call then a call to CheckRun().
		 */
		private static string[] noCheckRuns = new string[] {
			"llBase64ToString",
			"llCSV2List",
			"llDeleteSubList",
			"llDeleteSubString",
			"llDumpList2String",
			"llEscapeURL",
			"llEuler2Rot",
			"llGetListEntryType",
			"llGetListLength",
			"llGetSubString",
			"llGetUnixTime",
			"llInsertString",
			"llList2CSV",
			"llList2Float",
			"llList2Integer",
			"llList2Key",
			"llList2List",
			"llList2ListStrided",
			"llList2Rot",
			"llList2String",
			"llList2Vector",
			"llListFindList",
			"llListInsertList",
			"llListRandomize",
			"llListReplaceList",
			"llListSort",
			"llListStatistics",
			"llMD5String",
			"llParseString2List",
			"llParseStringKeepNulls",
			"llStringLength",
			"llStringToBase64",
			"llStringTrim",
			"llSubStringIndex",
			"llUnescapeURL"
		};

		/**
		 * @brief Create a dictionary of inline backend API functions.
		 */
		public static VarDict CreateDictionary ()
		{
			VarDict ifd = new VarDict ();
			TokenDeclInline inf;

			/*
			 * Mono generates an FPU instruction for many math calls.
			 */
			inf = new TokenDeclInline (ifd, false, "llAbs(integer)",       typeof (int),         null);                                                                      inf.codeGen = inf.CodeGenLLAbs;
			inf = new TokenDeclInline (ifd, false, "llAcos(float)",        typeof (SCRIPTFLOAT), ScriptCodeGen.GetStaticMethod (typeof (System.Math), "Acos",    oneDoub));  inf.codeGen = inf.CodeGenStatic;
			inf = new TokenDeclInline (ifd, false, "llAsin(float)",        typeof (SCRIPTFLOAT), ScriptCodeGen.GetStaticMethod (typeof (System.Math), "Asin",    oneDoub));  inf.codeGen = inf.CodeGenStatic;
			inf = new TokenDeclInline (ifd, false, "llAtan2(float,float)", typeof (SCRIPTFLOAT), ScriptCodeGen.GetStaticMethod (typeof (System.Math), "Atan2",   twoDoubs)); inf.codeGen = inf.CodeGenStatic;
			inf = new TokenDeclInline (ifd, false, "llCos(float)",         typeof (SCRIPTFLOAT), ScriptCodeGen.GetStaticMethod (typeof (System.Math), "Cos",     oneDoub));  inf.codeGen = inf.CodeGenStatic;
			inf = new TokenDeclInline (ifd, false, "llFabs(float)",        typeof (SCRIPTFLOAT), ScriptCodeGen.GetStaticMethod (typeof (System.Math), "Abs",     oneDoub));  inf.codeGen = inf.CodeGenStatic;
			inf = new TokenDeclInline (ifd, false, "llLog(float)",         typeof (SCRIPTFLOAT), ScriptCodeGen.GetStaticMethod (typeof (System.Math), "Log",     oneDoub));  inf.codeGen = inf.CodeGenStatic;
			inf = new TokenDeclInline (ifd, false, "llLog10(float)",       typeof (SCRIPTFLOAT), ScriptCodeGen.GetStaticMethod (typeof (System.Math), "Log10",   oneDoub));  inf.codeGen = inf.CodeGenStatic;
			inf = new TokenDeclInline (ifd, false, "llPow(float,float)",   typeof (SCRIPTFLOAT), ScriptCodeGen.GetStaticMethod (typeof (System.Math), "Pow",     twoDoubs)); inf.codeGen = inf.CodeGenStatic;
			inf = new TokenDeclInline (ifd, false, "llRound(float)",       typeof (int),         null);                                                                      inf.codeGen = inf.CodeGenLLRound;
			inf = new TokenDeclInline (ifd, false, "llSin(float)",         typeof (SCRIPTFLOAT), ScriptCodeGen.GetStaticMethod (typeof (System.Math), "Sin",     oneDoub));  inf.codeGen = inf.CodeGenStatic;
			inf = new TokenDeclInline (ifd, false, "llSqrt(float)",        typeof (SCRIPTFLOAT), ScriptCodeGen.GetStaticMethod (typeof (System.Math), "Sqrt",    oneDoub));  inf.codeGen = inf.CodeGenStatic;
			inf = new TokenDeclInline (ifd, false, "llTan(float)",         typeof (SCRIPTFLOAT), ScriptCodeGen.GetStaticMethod (typeof (System.Math), "Tan",     oneDoub));  inf.codeGen = inf.CodeGenStatic;

			/*
			 * Finally for any API functions defined by SCRIPTBASECLASS that are not overridden 
			 * by anything already defined above, create an inline definition to call it.
			 */
			AddInterfaceMethods (ifd, typeof (XMRInstAbstract));
			AddInterfaceMethods (ifd, typeof (SCRIPTBASECLASS));
			AddInterfaceMethods (ifd, typeof (IOSSL_Api));

			return ifd;
		}

		/**
		 * @brief Add API functions from the given interface to list of built-in functions.
		 *        Only functions beginning with a lower-case letter are entered, all others ignored.
		 * @param ifd = internal function dictionary to add them to
		 * @param ifaceType = interface to scan for functions
		 */
		private static void AddInterfaceMethods (VarDict ifd, Type ifaceType)
		{
			MethodInfo[] ifaceMethods = ifaceType.GetMethods ();
			foreach (MethodInfo ifaceMethod in ifaceMethods) {
				string key = ifaceMethod.Name;

				/*
				 * Only do ones that begin with lower-case letters...
				 * as any others can't be referenced by scripts.
				 */
				if ((key[0] < 'a') || (key[0] > 'z')) continue;

				try {
					/*
					 * See if we will generate a call to CheckRun() right 
					 * after we generate a call to the function.
					 * If function begins with xmr, assume we will not call CheckRun()
					 * Otherwise, assume we will call CheckRun()
					 */
					bool dcr = !key.StartsWith ("xmr");
					for (int i = noCheckRuns.Length; -- i >= 0;) {
						if (noCheckRuns[i] == key) {
							dcr = false;
							break;
						}
					}

					/*
					 * Create a corresponding signature.
					 */
					ParameterInfo[] parameters = ifaceMethod.GetParameters ();
					TokenArgDecl argDecl = new TokenArgDecl (null);
					for (int i = 0; i < parameters.Length; i ++) {
						TokenType type = TokenType.FromSysType (null, parameters[i].ParameterType);
						TokenName name = new TokenName (null, parameters[i].Name);
						argDecl.AddArg (type, name);
					}

					/*
					 * Add function to dictionary.
					 */
					TokenType retType      = TokenType.FromSysType (null, ifaceMethod.ReturnType);
					TokenDeclInline inlfun = new TokenDeclInline (ifd, dcr, key, retType, argDecl, ifaceMethod);
					inlfun.codeGen         = inlfun.CodeGenBEApi;
				} catch {

					///??? string msg = except.ToString ();
					///??? int i = msg.IndexOf ("\n");
					///??? if (i > 0) msg = msg.Substring (0, i);
					///??? Console.WriteLine ("TokenDeclInline*: {0}:     {1}", key, msg);

					///??? IGNORE ANY THAT FAIL - LIKE UNRECOGNIZED TYPE ???///
					///???                          and OVERLOADED NAMES ???///
				}
			}
		}

		/**
		 * @brief Add an inline function definition to the dictionary.
		 * @param ifd        = dictionary to add inline definition to
		 * @param doCheckRun = true iff the generated code or the function itself can possibly call CheckRun()
		 * @param nameArgSig = inline function signature string, in form <name>(<arglsltypes>,...)
		 * @param retType    = system return type, use typeof(void) if no return value
		 * @param methInfo   = used by codeGen to know what backend method to call
		 */
		private TokenDeclInline (VarDict ifd, 
		                         bool doCheckRun, 
		                         string nameArgSig, 
		                         Type retType, 
		                         MethodInfo methInfo)
			: base (null, null, null)
		{
			this.retType     = TokenType.FromSysType (null, retType);
			this.methInfo    = methInfo;
			this.doCheckRun  = doCheckRun;
			this.triviality  = (doCheckRun || IsTaggedComplex (methInfo)) ? Triviality.complex : Triviality.trivial;

			int j = nameArgSig.IndexOf ('(');
			this.name = new TokenName (null, nameArgSig.Substring (0, j ++));

			this.argDecl = new TokenArgDecl (null);
			if (nameArgSig[j] != ')') {
				int i;
				TokenName name;
				TokenType type;

				for (i = j; nameArgSig[i] != ')'; i ++) {
					if (nameArgSig[i] == ',') {
						type = TokenType.FromLSLType (null, nameArgSig.Substring (j, i - j));
						name = new TokenName (null, "arg" + this.argDecl.varDict.Count);
						this.argDecl.AddArg (type, name);
						j = i + 1;
					}
				}

				type = TokenType.FromLSLType (null, nameArgSig.Substring (j, i - j));
				name = new TokenName (null, "arg" + this.argDecl.varDict.Count);
				this.argDecl.AddArg (type, name);
			}

			this.location = new CompValuInline (this);
			ifd.AddEntry (this);
		}

		private TokenDeclInline (VarDict ifd, 
		                         bool doCheckRun, 
		                         string name, 
		                         TokenType retType, 
		                         TokenArgDecl argDecl, 
		                         MethodInfo methInfo)
			: base (null, null, null)
		{
			this.name        = new TokenName (null, name);
			this.retType     = retType;
			this.methInfo    = methInfo;
			this.argDecl     = argDecl;
			this.doCheckRun  = doCheckRun;
			this.triviality  = (doCheckRun || IsTaggedComplex (methInfo)) ? Triviality.complex : Triviality.trivial;
			this.location    = new CompValuInline (this);
			ifd.AddEntry (this);
		}

		/**
		 * @brief The above code assumes all methods beginning with 'xmr' are trivial, ie, 
		 *        they do not call CheckRun() and also we do not generate a CheckRun() 
		 *        call after they return.  So if an 'xmr' method does call CheckRun(), it 
		 *        must be tagged with attribute 'xmrMethodIsComplexAttribute' so we know 
		 *        the method is not trivial.  But in neither case do we emit our own call 
		 *        to CheckRun(), the 'xmr' method must do its own.
		 */
		private static bool IsTaggedComplex (MethodInfo methInfo)
		{
			if (methInfo != null) {
				foreach (Attribute attr in Attribute.GetCustomAttributes (methInfo)) {
					if (attr is xmrMethodIsComplexAttribute) return true;
				}
			}
			return false;
		}

		/**
		 * @brief Code generators...
		 * @param scg = script we are generating code for
		 * @param result = type/location for result (type matches function definition)
		 * @param args = type/location of arguments (types match function definition)
		 */

		private void CodeGenLLAbs (ScriptCodeGen scg, Token errorAt, CompValuTemp result, CompValu[] args)
		{
			ScriptMyLabel itsPosLabel = scg.ilGen.DefineLabel ("llAbstemp");

			args[0].PushVal (scg, errorAt);
			scg.ilGen.Emit (errorAt, OpCodes.Dup);
			scg.ilGen.Emit (errorAt, OpCodes.Ldc_I4_0);
			scg.ilGen.Emit (errorAt, OpCodes.Bge_S, itsPosLabel);
			scg.ilGen.Emit (errorAt, OpCodes.Neg);
			scg.ilGen.MarkLabel (itsPosLabel);
			result.Pop (scg, errorAt, retType);
		}

		private void CodeGenStatic (ScriptCodeGen scg, Token errorAt, CompValuTemp result, CompValu[] args)
		{
			ParameterInfo[] paramsInfo = methInfo.GetParameters ();

			for (int i = 0; i < args.Length; i ++) {
				args[i].PushVal (scg, errorAt, TokenType.FromSysType (errorAt, paramsInfo[i].ParameterType));
			}
			scg.ilGen.Emit (errorAt, OpCodes.Call, methInfo);
			result.Pop (scg, errorAt, retType);
		}

		private void CodeGenLLRound (ScriptCodeGen scg, Token errorAt, CompValuTemp result, CompValu[] args)
		{
			args[0].PushVal (scg, errorAt, tokenTypeFloat);
			scg.ilGen.Emit (errorAt, OpCodes.Ldc_I4, (int)System.MidpointRounding.AwayFromZero);
			scg.ilGen.Emit (errorAt, OpCodes.Call, roundMethInfo);
			result.Pop (scg, errorAt, tokenTypeFloat);
		}

		/**
		 * @brief Generate call to backend API function (eg llSay()) maybe followed by a call to CheckRun().
		 * @param scg    = script being compiled
		 * @param result = where to place result (might be void)
		 * @param args   = script-visible arguments to pass to API function
		 */
		private void CodeGenBEApi (ScriptCodeGen scg, Token errorAt, CompValuTemp result, CompValu[] args)
		{
			if (!methInfo.IsStatic) {
				scg.PushXMRInst ();                       // xmrinstance = 'this' for the API function
			}
			for (int i = 0; i < args.Length; i ++) {          // push arguments, boxing/unboxing as needed
				args[i].PushVal (scg, errorAt, argDecl.types[i]);
			}
			if (methInfo.Name == "llParcelMediaQuery") {
				scg.ilGen.Emit (errorAt, OpCodes.Call, fixLLParcelMediaQuery);
			}
			if (methInfo.Name == "llParcelMediaCommandList") {
				scg.ilGen.Emit (errorAt, OpCodes.Call, fixLLParcelMediaCommandList);
			}
			if (methInfo.IsVirtual) {                         // call API function
				scg.ilGen.Emit (errorAt, OpCodes.Callvirt, methInfo);
			} else {
				scg.ilGen.Emit (errorAt, OpCodes.Call, methInfo);
			}
			result.Pop (scg, errorAt, retType);               // pop result, boxing/unboxing as needed
			if (doCheckRun) {
				scg.EmitCallCheckRun (errorAt);           // maybe call CheckRun()
			}
		}
	}
}
