/***************************************************\
 *  COPYRIGHT 2012, Mike Rieker, Beverly, MA, USA  *
 *  All rights reserved.                           *
\***************************************************/

using System;
using System.Collections.Generic;
using System.Reflection;
using System.Reflection.Emit;
using System.Text;

#include "lsltypes.h"


/**
 * @brief Generate code for the backend API calls.
 */
namespace OpenSim.Region.ScriptEngine.XMREngine
{
	public abstract class TokenDeclInline : TokenDeclVar {
		public static VarDict inlineFunctions = CreateDictionary ();

		public abstract void CodeGen (ScriptCodeGen scg, Token errorAt, CompValuTemp result, CompValu[] args);

		private static string[] noCheckRuns;
		private static string[] keyReturns;

		/**
		 * @brief Create a dictionary of inline backend API functions.
		 */
		private static VarDict CreateDictionary ()
		{
			/*
			 * For those listed in noCheckRun, we just generate the call (simple computations).
			 * For all others, we generate the call then a call to CheckRun().
			 */
			noCheckRuns = new string[] {
				"llBase64ToString",
				"llCSV2List",
				"llDeleteSubList",
				"llDeleteSubString",
				"llDumpList2String",
				"llEscapeURL",
				"llEuler2Rot",
				"llGetListEntryType",
				"llGetListLength",
				"llGetSubString",
				"llGetUnixTime",
				"llInsertString",
				"llList2CSV",
				"llList2Float",
				"llList2Integer",
				"llList2Key",
				"llList2List",
				"llList2ListStrided",
				"llList2Rot",
				"llList2String",
				"llList2Vector",
				"llListFindList",
				"llListInsertList",
				"llListRandomize",
				"llListReplaceList",
				"llListSort",
				"llListStatistics",
				"llMD5String",
				"llParseString2List",
				"llParseStringKeepNulls",
				"llStringLength",
				"llStringToBase64",
				"llStringTrim",
				"llSubStringIndex",
				"llUnescapeURL"
			};

			/*
			 * These functions really return a 'key' even though we see them as
			 * returning 'string' because OpenSim has key and string as same type.
			 */
			keyReturns = new string[] {
				"llAvatarOnLinkSitTarget",
				"llAvatarOnSitTarget",
				"llDetectedKey",
				"llDetectedOwner",
				"llGenerateKey",
				"llGetCreator",
				"llGetInventoryCreator",
				"llGetInventoryKey",
				"llGetKey",
				"llGetLandOwnerAt",
				"llGetLinkKey",
				"llGetNotecardLine",
				"llGetNumberOfNotecardLines",
				"llGetOwner",
				"llGetOwnerKey",
				"llGetPermissionsKey",
				"llHTTPRequest",
				"llList2Key",
				"llRequestAgentData",
				"llRequestDisplayName",
				"llRequestInventoryData",
				"llRequestSecureURL",
				"llRequestSimulatorData",
				"llRequestURL",
				"llRequestUsername",
				"llSendRemoteData",
				"llTransferLindenDollars"
			};

			VarDict ifd = new VarDict ();

			Type[] oneDoub  = new Type[] { typeof (double) };
			Type[] twoDoubs = new Type[] { typeof (double), typeof (double) };

			/*
			 * Mono generates an FPU instruction for many math calls.
			 */
			new TokenDeclInline_LLAbs   (ifd);
			new TokenDeclInline_Math    (ifd, "llAcos(float)",        "Acos",  oneDoub);
			new TokenDeclInline_Math    (ifd, "llAsin(float)",        "Asin",  oneDoub);
			new TokenDeclInline_Math    (ifd, "llAtan2(float,float)", "Atan2", twoDoubs);
			new TokenDeclInline_Math    (ifd, "llCos(float)",         "Cos",   oneDoub);
			new TokenDeclInline_Math    (ifd, "llFabs(float)",        "Abs",   oneDoub);
			new TokenDeclInline_Math    (ifd, "llLog(float)",         "Log",   oneDoub);
			new TokenDeclInline_Math    (ifd, "llLog10(float)",       "Log10", oneDoub);
			new TokenDeclInline_Math    (ifd, "llPow(float,float)",   "Pow",   twoDoubs);
			new TokenDeclInline_LLRound (ifd);
			new TokenDeclInline_Math    (ifd, "llSin(float)",         "Sin",   oneDoub);
			new TokenDeclInline_Math    (ifd, "llSqrt(float)",        "Sqrt",  oneDoub);
			new TokenDeclInline_Math    (ifd, "llTan(float)",         "Tan",   oneDoub);

			/*
			 * Something weird about the code generation for these calls, so they all have their own handwritten code generators.
			 */
			new TokenDeclInline_GetFreeMemory (ifd);
			new TokenDeclInline_GetUsedMemory (ifd);

			/*
			 * These are all the xmr...() calls directly in XMRInstAbstract.
			 */
			List<MethodInfo> lcms = new List<MethodInfo> ();
			foreach (MethodInfo meth in typeof (XMRInstAbstract).GetMethods ()) {
				string name = meth.Name;
				if ((name[0] >= 'a') && (name[0] <= 'z')) {
					lcms.Add (meth);
				}
			}
			AddInterfaceMethods (ifd, lcms.GetEnumerator (), null);

			return ifd;
		}

		/**
		 * @brief Add API functions from the given interface to list of built-in functions.
		 *        Only functions beginning with a lower-case letter are entered, all others ignored.
		 * @param ifd = internal function dictionary to add them to
		 * @param ifaceMethods = list of API functions
		 * @param acf = which field in XMRInstanceSuperType holds method's 'this' pointer
		 */
		// this one accepts only names beginning with a lower-case letter
		public static void AddInterfaceMethods (VarDict ifd, MethodInfo[] ifaceMethods, FieldInfo acf)
		{
			List<MethodInfo> lcms = new List<MethodInfo> (ifaceMethods.Length);
			foreach (MethodInfo meth in ifaceMethods)
			{
				string name = meth.Name;
				if ((name[0] >= 'a') && (name[0] <= 'z')) {
					lcms.Add (meth);
				}
			}
			AddInterfaceMethods (ifd, lcms.GetEnumerator (), acf);
		}

		// this one accepts all methods given to it
		public static void AddInterfaceMethods (VarDict ifd, IEnumerator<MethodInfo> ifaceMethods, FieldInfo acf)
		{
			if (ifd == null) ifd = inlineFunctions;

			for (ifaceMethods.Reset (); ifaceMethods.MoveNext ();) {
				MethodInfo ifaceMethod = ifaceMethods.Current;
				string key = ifaceMethod.Name;

				try {
					/*
					 * See if we will generate a call to CheckRun() right 
					 * after we generate a call to the function.
					 * If function begins with xmr, assume we will not call CheckRun()
					 * Otherwise, assume we will call CheckRun()
					 */
					bool dcr = !key.StartsWith ("xmr");
					foreach (string ncr in noCheckRuns) {
						if (ncr == key) {
							dcr = false;
							break;
						}
					}

					/*
					 * Add function to dictionary.
					 */
					new TokenDeclInline_BEApi (ifd, dcr, ifaceMethod, acf);
				} catch {
					///??? IGNORE ANY THAT FAIL - LIKE UNRECOGNIZED TYPE ???///
					///???                          and OVERLOADED NAMES ???///
				}
			}
		}

		/**
		 * @brief Add an inline function definition to the dictionary.
		 * @param ifd        = dictionary to add inline definition to
		 * @param doCheckRun = true iff the generated code or the function itself can possibly call CheckRun()
		 * @param nameArgSig = inline function signature string, in form <name>(<arglsltypes>,...)
		 * @param retType    = return type, use TokenTypeVoid if no return value
		 */
		protected TokenDeclInline (VarDict ifd, 
		                           bool doCheckRun, 
		                           string nameArgSig, 
		                           TokenType retType)
				: base (null, null, null)
		{
			this.retType    = retType;
			this.triviality = doCheckRun ? Triviality.complex : Triviality.trivial;

			int j = nameArgSig.IndexOf ('(');
			this.name = new TokenName (null, nameArgSig.Substring (0, j ++));

			this.argDecl = new TokenArgDecl (null);
			if (nameArgSig[j] != ')') {
				int i;
				TokenName name;
				TokenType type;

				for (i = j; nameArgSig[i] != ')'; i ++) {
					if (nameArgSig[i] == ',') {
						type = TokenType.FromLSLType (null, nameArgSig.Substring (j, i - j));
						name = new TokenName (null, "arg" + this.argDecl.varDict.Count);
						this.argDecl.AddArg (type, name);
						j = i + 1;
					}
				}

				type = TokenType.FromLSLType (null, nameArgSig.Substring (j, i - j));
				name = new TokenName (null, "arg" + this.argDecl.varDict.Count);
				this.argDecl.AddArg (type, name);
			}

			this.location = new CompValuInline (this);
			if (ifd == null) ifd = inlineFunctions;
			ifd.AddEntry (this);
		}

		protected TokenDeclInline (VarDict ifd, 
		                           bool doCheckRun, 
		                           MethodInfo methInfo)
				: base (null, null, null)
		{
			TokenType retType = TokenType.FromSysType (null, methInfo.ReturnType);

			this.name       = new TokenName (null, methInfo.Name);
			this.retType    = GetRetType (methInfo, retType);
			this.argDecl    = GetArgDecl (methInfo.GetParameters ());
			this.triviality = (doCheckRun || IsTaggedComplex (methInfo)) ? Triviality.complex : Triviality.trivial;
			this.location   = new CompValuInline (this);

			if (ifd == null) ifd = inlineFunctions;
			ifd.AddEntry (this);
		}

		private static TokenArgDecl GetArgDecl (ParameterInfo[] parameters)
		{
			TokenArgDecl argDecl = new TokenArgDecl (null);
			foreach (ParameterInfo pi in parameters) {
				TokenType type = TokenType.FromSysType (null, pi.ParameterType);
				TokenName name = new TokenName (null, pi.Name);
				argDecl.AddArg (type, name);
			}
			return argDecl;
		}

		/**
		 * @brief The above code assumes all methods beginning with 'xmr' are trivial, ie, 
		 *        they do not call CheckRun() and also we do not generate a CheckRun() 
		 *        call after they return.  So if an 'xmr' method does call CheckRun(), it 
		 *        must be tagged with attribute 'xmrMethodIsComplexAttribute' so we know 
		 *        the method is not trivial.  But in neither case do we emit our own call 
		 *        to CheckRun(), the 'xmr' method must do its own.
		 */
		private static bool IsTaggedComplex (MethodInfo methInfo)
		{
			if (methInfo != null) {
				foreach (Attribute attr in Attribute.GetCustomAttributes (methInfo)) {
					if (attr is xmrMethodIsComplexAttribute) return true;
				}
			}
			return false;
		}

		/**
		 * @brief The dumbass OpenSim has key and string as the same type so non-ll
		 *        methods must be tagged with xmrMethodReturnsKeyAttribute if we
		 *        are to think they return a key type, otherwise we will think they
		 *        return string.
		 */
		private static TokenType GetRetType (MethodInfo methInfo, TokenType retType)
		{
			if ((methInfo != null) && (retType != null) && (retType is TokenTypeStr)) {
				foreach (Attribute attr in Attribute.GetCustomAttributes (methInfo)) {
					if (attr is xmrMethodReturnsKeyAttribute) {
						return ChangeToKeyType (retType);
					}
				}

				string mn = methInfo.Name;
				foreach (string kr in keyReturns) {
					if (kr == mn) {
						return ChangeToKeyType (retType);
					}
				}

			}
			return retType;
		}
		private static TokenType ChangeToKeyType (TokenType retType)
		{
			if (retType is TokenTypeLSLString) {
				retType = new TokenTypeLSLKey (null);
			} else {
				retType = new TokenTypeKey (null);
			}
			return retType;
		}

		public virtual MethodInfo GetMethodInfo ()
		{
			return null;
		}
	}

	/**
	 * @brief Code generators...
	 * @param scg = script we are generating code for
	 * @param result = type/location for result (type matches function definition)
	 * @param args = type/location of arguments (types match function definition)
	 */

	public class TokenDeclInline_LLAbs : TokenDeclInline {
		public TokenDeclInline_LLAbs (VarDict ifd)
				: base (ifd, false, "llAbs(integer)", new TokenTypeInt (null)) { }

		public override void CodeGen (ScriptCodeGen scg, Token errorAt, CompValuTemp result, CompValu[] args)
		{
			ScriptMyLabel itsPosLabel = scg.ilGen.DefineLabel ("llAbstemp");

			args[0].PushVal (scg, errorAt);
			scg.ilGen.Emit (errorAt, OpCodes.Dup);
			scg.ilGen.Emit (errorAt, OpCodes.Ldc_I4_0);
			scg.ilGen.Emit (errorAt, OpCodes.Bge_S, itsPosLabel);
			scg.ilGen.Emit (errorAt, OpCodes.Neg);
			scg.ilGen.MarkLabel (itsPosLabel);
			result.Pop (scg, errorAt, retType);
		}
	}

	public class TokenDeclInline_Math : TokenDeclInline {
		private MethodInfo methInfo;

		public TokenDeclInline_Math (VarDict ifd, string sig, string name, Type[] args)
				: base (ifd, false, sig, new TokenTypeFloat (null))
		{
			methInfo = ScriptCodeGen.GetStaticMethod (typeof (System.Math), name, args);
		}

		public override void CodeGen (ScriptCodeGen scg, Token errorAt, CompValuTemp result, CompValu[] args)
		{
			for (int i = 0; i < args.Length; i ++) {
				args[i].PushVal (scg, errorAt, argDecl.types[i]);
			}
			scg.ilGen.Emit (errorAt, OpCodes.Call, methInfo);
			result.Pop (scg, errorAt, retType);
		}
	}

	public class TokenDeclInline_LLRound : TokenDeclInline {

		private static MethodInfo roundMethInfo = ScriptCodeGen.GetStaticMethod (typeof (System.Math), "Round", 
				new Type[] { typeof (double), typeof (MidpointRounding) });

		public TokenDeclInline_LLRound (VarDict ifd)
				: base (ifd, false, "llRound(float)", new TokenTypeInt (null)) { }

		public override void CodeGen (ScriptCodeGen scg, Token errorAt, CompValuTemp result, CompValu[] args)
		{
			args[0].PushVal (scg, errorAt, new TokenTypeFloat (null));
			scg.ilGen.Emit (errorAt, OpCodes.Ldc_I4, (int)System.MidpointRounding.AwayFromZero);
			scg.ilGen.Emit (errorAt, OpCodes.Call, roundMethInfo);
			result.Pop (scg, errorAt, new TokenTypeFloat (null));
		}
	}

	public class TokenDeclInline_GetFreeMemory : TokenDeclInline {
		private static readonly MethodInfo getFreeMemMethInfo = typeof (XMRInstAbstract).GetMethod ("xmrHeapLeft", new Type[] { });

		public TokenDeclInline_GetFreeMemory (VarDict ifd)
				: base (ifd, false, "llGetFreeMemory()", new TokenTypeInt (null)) { }

		// appears as llGetFreeMemory() in script source code
		// but actually calls xmrHeapLeft()
		public override void CodeGen (ScriptCodeGen scg, Token errorAt, CompValuTemp result, CompValu[] args)
		{
			scg.PushXMRInst ();
			scg.ilGen.Emit (errorAt, OpCodes.Call, getFreeMemMethInfo);
			result.Pop (scg, errorAt, new TokenTypeInt (null));
		}
	}

	public class TokenDeclInline_GetUsedMemory : TokenDeclInline {
		private static readonly MethodInfo getUsedMemMethInfo = typeof (XMRInstAbstract).GetMethod ("xmrHeapUsed", new Type[] { });

		public TokenDeclInline_GetUsedMemory (VarDict ifd)
				: base (ifd, false, "llGetUsedMemory()", new TokenTypeInt (null)) { }

		// appears as llGetUsedMemory() in script source code
		// but actually calls xmrHeapUsed()
		public override void CodeGen (ScriptCodeGen scg, Token errorAt, CompValuTemp result, CompValu[] args)
		{
			scg.PushXMRInst ();
			scg.ilGen.Emit (errorAt, OpCodes.Call, getUsedMemMethInfo);
			result.Pop (scg, errorAt, new TokenTypeInt (null));
		}
	}

	/**
	 * @brief Generate code for the usual ll...() functions.
	 */
	public class TokenDeclInline_BEApi : TokenDeclInline {
		private static readonly MethodInfo fixLLParcelMediaQuery = ScriptCodeGen.GetStaticMethod 
				(typeof (XMRInstAbstract), "FixLLParcelMediaQuery", new Type[] { typeof (LSL_List) });

		private static readonly MethodInfo fixLLParcelMediaCommandList = ScriptCodeGen.GetStaticMethod 
				(typeof (XMRInstAbstract), "FixLLParcelMediaCommandList", new Type[] { typeof (LSL_List) });

		public bool doCheckRun;
		private FieldInfo apiContextField;
		private MethodInfo methInfo;

		/**
		 * @brief Constructor
		 * @param ifd = dictionary to add the function to
		 * @param dcr = append a call to CheckRun()
		 * @param methInfo = ll...() method to be called
		 */
		public TokenDeclInline_BEApi (VarDict ifd, bool dcr, MethodInfo methInfo, FieldInfo acf)
				: base (ifd, dcr, methInfo)
		{
			this.methInfo = methInfo;
			doCheckRun = dcr;
			apiContextField = acf;
		}

		public override MethodInfo GetMethodInfo ()
		{
			return methInfo;
		}

		/**
		 * @brief Generate call to backend API function (eg llSay()) maybe followed by a call to CheckRun().
		 * @param scg    = script being compiled
		 * @param result = where to place result (might be void)
		 * @param args   = script-visible arguments to pass to API function
		 */
		public override void CodeGen (ScriptCodeGen scg, Token errorAt, CompValuTemp result, CompValu[] args)
		{
			if (!methInfo.IsStatic) {
				scg.PushXMRInst ();                       // XMRInstanceSuperType pointer
				if (apiContextField != null) {
					scg.ilGen.Emit (errorAt, OpCodes.Ldfld, apiContextField);
				                                          // 'this' pointer for API function
				}
			}
			for (int i = 0; i < args.Length; i ++) {          // push arguments, boxing/unboxing as needed
				args[i].PushVal (scg, errorAt, argDecl.types[i]);
			}
			if (methInfo.Name == "llParcelMediaQuery") {
				scg.ilGen.Emit (errorAt, OpCodes.Call, fixLLParcelMediaQuery);
			}
			if (methInfo.Name == "llParcelMediaCommandList") {
				scg.ilGen.Emit (errorAt, OpCodes.Call, fixLLParcelMediaCommandList);
			}
			if (methInfo.IsVirtual) {                         // call API function
				scg.ilGen.Emit (errorAt, OpCodes.Callvirt, methInfo);
			} else {
				scg.ilGen.Emit (errorAt, OpCodes.Call, methInfo);
			}
			result.Pop (scg, errorAt, retType);               // pop result, boxing/unboxing as needed
			if (doCheckRun) {
				scg.EmitCallCheckRun (errorAt);           // maybe call CheckRun()
			}
		}
	}
}
