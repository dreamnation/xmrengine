/***************************************************\
 *  COPYRIGHT 2009, Mike Rieker, Beverly, MA, USA  *
 *  All rights reserved.                           *
\***************************************************/

using System;
using System.Collections.Generic;
using System.Reflection;
using System.Reflection.Emit;
using System.Text;

using OpenSim.Region.ScriptEngine.Shared.Api.Interfaces;
using OpenSim.Region.ScriptEngine.Shared.ScriptBase;

#include "lsltypes.h"


/**
 * @brief Generate code for the backend API calls.
 */
namespace OpenSim.Region.ScriptEngine.XMREngine
{
	public delegate void CodeGenCall (ScriptCodeGen scg, Token errorAt, CompValuTemp result, CompValu[] args);

	public class TokenDeclInline : TokenDeclVar {

		public CodeGenCall codeGen;   // method that generates code
		public MethodInfo methInfo;   // function called by the inline
		public bool doCheckRun;       // valid for CodeGenBEApi only
		public int keepNulls;         // valid for CodeGenLLParseString2List only

		private static Type[] oneDoub  = new Type[] { typeof (double) };
		private static Type[] twoDoubs = new Type[] { typeof (double), typeof (double) };

		private static TokenTypeFloat tokenTypeFloat  = new TokenTypeFloat (null);
		private static TokenTypeInt   tokenTypeInt    = new TokenTypeInt (null);
		private static TokenTypeStr   tokenTypeString = new TokenTypeStr (null);

///		private static MethodInfo consoleWrite = ScriptCodeGen.GetStaticMethod (typeof (XMRInstAbstract), "ConsoleWrite",
///				new Type[] { typeof (XMRInstAbstract), typeof (string) });
		private static MethodInfo roundMethInfo = ScriptCodeGen.GetStaticMethod (typeof (System.Math), "Round", 
				new Type[] { typeof (double), typeof (MidpointRounding) });

		private static MethodInfo xmrEventCallHandler = typeof (XMRInstAbstract).GetMethod ("XMREventCallHandler",
				new Type[] { typeof (LSL_List) });
		private static MethodInfo xmrEventDequeue  = typeof (XMRInstAbstract).GetMethod ("XMREventDequeue",
				new Type[] { typeof (SCRIPTFLOAT), typeof (int), typeof (int), typeof (int), typeof (int), typeof (int) });
		private static MethodInfo xmrEventEnqueue = typeof (XMRInstAbstract).GetMethod ("XMREventEnqueue",
				new Type[] { typeof (LSL_List) });
		private static MethodInfo xmrEventLoadDets = typeof (XMRInstAbstract).GetMethod ("XMREventLoadDets",
				new Type[] { typeof (LSL_List) });
		private static MethodInfo xmrEventSaveDets = typeof (XMRInstAbstract).GetMethod ("XMREventSaveDets",
				new Type[] { });
		private static MethodInfo xmrOSParseJSON = typeof (XMRInstAbstract).GetMethod ("XMRosParseJSON", 
				new Type[] { typeof (string) });

		/*
		 * For those listed in noCheckRun, we just generate the call (simple computations).
		 * For all others, we generate the call then a call to wrapper.continuation.CheckRun().
		 */
		private static string[] noCheckRun = new string[] {
			"llBase64ToString",
			"llCSV2List",
			"llDeleteSubList",
			"llDeleteSubString",
			"llDumpList2String",
			"llEscapeURL",
			"llEuler2Rot",
			"llGetListEntryType",
			"llGetListLength",
			"llGetSubString",
			"llGetUnixTime",
			"llInsertString",
			"llList2CSV",
			"llList2Float",
			"llList2Integer",
			"llList2Key",
			"llList2List",
			"llList2ListStrided",
			"llList2Rot",
			"llList2String",
			"llList2Vector",
			"llListFindList",
			"llListInsertList",
			"llListRandomize",
			"llListReplaceList",
			"llListSort",
			"llListStatistics",
			"llMD5String",
			"llParseString2List",
			"llParseStringKeepNulls",
			"llStringLength",
			"llStringToBase64",
			"llStringTrim",
			"llSubStringIndex",
			"llUnescapeURL"
		};

		/**
		 * @brief Create a dictionary of inline backend API functions.
		 */
		public static VarDict CreateDictionary ()
		{
			VarDict ifd = new VarDict ();
			TokenDeclInline inf;

			/*
			 * Mono generates an FPU instruction for many math calls.
			 */
			inf = new TokenDeclInline (ifd, false, "llAbs(integer)",       typeof (int),         null);                                                                      inf.codeGen = inf.CodeGenLLAbs;
			inf = new TokenDeclInline (ifd, false, "llAcos(float)",        typeof (SCRIPTFLOAT), ScriptCodeGen.GetStaticMethod (typeof (System.Math), "Acos",    oneDoub));  inf.codeGen = inf.CodeGenStatic;
			inf = new TokenDeclInline (ifd, false, "llAsin(float)",        typeof (SCRIPTFLOAT), ScriptCodeGen.GetStaticMethod (typeof (System.Math), "Asin",    oneDoub));  inf.codeGen = inf.CodeGenStatic;
			inf = new TokenDeclInline (ifd, false, "llAtan2(float,float)", typeof (SCRIPTFLOAT), ScriptCodeGen.GetStaticMethod (typeof (System.Math), "Atan2",   twoDoubs)); inf.codeGen = inf.CodeGenStatic;
		///	inf = new TokenDeclInline (ifd, false, "llCeil(float)",        typeof (SCRIPTFLOAT), ScriptCodeGen.GetStaticMethod (typeof (System.Math), "Ceiling", oneDoub));  inf.codeGen = inf.CodeGenStatic;
			inf = new TokenDeclInline (ifd, false, "llCos(float)",         typeof (SCRIPTFLOAT), ScriptCodeGen.GetStaticMethod (typeof (System.Math), "Cos",     oneDoub));  inf.codeGen = inf.CodeGenStatic;
			inf = new TokenDeclInline (ifd, false, "llFabs(float)",        typeof (SCRIPTFLOAT), ScriptCodeGen.GetStaticMethod (typeof (System.Math), "Abs",     oneDoub));  inf.codeGen = inf.CodeGenStatic;
		///	inf = new TokenDeclInline (ifd, false, "llFloor(float)",       typeof (SCRIPTFLOAT), ScriptCodeGen.GetStaticMethod (typeof (System.Math), "Floor",   oneDoub));  inf.codeGen = inf.CodeGenStatic;
			inf = new TokenDeclInline (ifd, false, "llLog(float)",         typeof (SCRIPTFLOAT), ScriptCodeGen.GetStaticMethod (typeof (System.Math), "Log",     oneDoub));  inf.codeGen = inf.CodeGenStatic;
			inf = new TokenDeclInline (ifd, false, "llLog10(float)",       typeof (SCRIPTFLOAT), ScriptCodeGen.GetStaticMethod (typeof (System.Math), "Log10",   oneDoub));  inf.codeGen = inf.CodeGenStatic;
			inf = new TokenDeclInline (ifd, false, "llPow(float,float)",   typeof (SCRIPTFLOAT), ScriptCodeGen.GetStaticMethod (typeof (System.Math), "Pow",     twoDoubs)); inf.codeGen = inf.CodeGenStatic;
			inf = new TokenDeclInline (ifd, false, "llRound(float)",       typeof (int),         null);                                                                      inf.codeGen = inf.CodeGenLLRound;
			inf = new TokenDeclInline (ifd, false, "llSin(float)",         typeof (SCRIPTFLOAT), ScriptCodeGen.GetStaticMethod (typeof (System.Math), "Sin",     oneDoub));  inf.codeGen = inf.CodeGenStatic;
			inf = new TokenDeclInline (ifd, false, "llSqrt(float)",        typeof (SCRIPTFLOAT), ScriptCodeGen.GetStaticMethod (typeof (System.Math), "Sqrt",    oneDoub));  inf.codeGen = inf.CodeGenStatic;
			inf = new TokenDeclInline (ifd, false, "llTan(float)",         typeof (SCRIPTFLOAT), ScriptCodeGen.GetStaticMethod (typeof (System.Math), "Tan",     oneDoub));  inf.codeGen = inf.CodeGenStatic;

			/*
			 * Our internally defined functions.
			 */
		///	inf = new TokenDeclInline (ifd, false, "consoleWrite(string)",                                    typeof (void),        null); inf.codeGen = inf.CodeGenConsoleWrite;
			inf = new TokenDeclInline (ifd, false, "xmrEventCallHandler(list)",                               typeof (void),        null); inf.codeGen = inf.CodeGenXMREventCallHandler;
			inf = new TokenDeclInline (ifd, true,  "xmrEventDequeue(float,integer,integer,integer,integer)",  typeof (LSL_List),    null); inf.codeGen = inf.CodeGenXMREventDequeue;
			inf = new TokenDeclInline (ifd, false, "xmrEventEnqueue(list)",                                   typeof (void),        null); inf.codeGen = inf.CodeGenXMREventEnqueue;
			inf = new TokenDeclInline (ifd, false, "xmrEventLoadDets(list)",                                  typeof (void),        null); inf.codeGen = inf.CodeGenXMREventLoadDets;
			inf = new TokenDeclInline (ifd, false, "xmrEventSaveDets()",                                      typeof (LSL_List),    null); inf.codeGen = inf.CodeGenXMREventSaveDets;
			inf = new TokenDeclInline (ifd, false, "xmrHeapLeft()",                                           typeof (int),         null); inf.codeGen = inf.CodeGenXMRHeapLeft;
			inf = new TokenDeclInline (ifd, false, "xmrStackLeft()",                                          typeof (int),         null); inf.codeGen = inf.CodeGenXMRStackLeft;
			inf = new TokenDeclInline (ifd, false, "xmrTypeName(object)",                                     typeof (string),      null); inf.codeGen = inf.CodeGenXMRTypeName;
			inf = new TokenDeclInline (ifd, false, "xmrHashCode(float)",                                      typeof (int),         null); inf.codeGen = inf.CodeGenXMRHashCodeFloat;
			inf = new TokenDeclInline (ifd, false, "xmrHashCode(integer)",                                    typeof (int),         null); inf.codeGen = inf.CodeGenXMRHashCodeInteger;
			inf = new TokenDeclInline (ifd, false, "xmrHashCode(object)",                                     typeof (int),         null); inf.codeGen = inf.CodeGenXMRHashCodeObject;
			inf = new TokenDeclInline (ifd, false, "xmrArrayCopy(object,integer,object,integer,integer)",     typeof (int),         null); inf.codeGen = inf.CodeGenXMRArrayCopy;
			inf = new TokenDeclInline (ifd, false, "xmrArray2List(object,integer,integer)",                   typeof (LSL_List),    null); inf.codeGen = inf.CodeGenXMRArray2List;
			inf = new TokenDeclInline (ifd, false, "xmrList2Array(list,integer,object,integer,integer)",      typeof (void),        null); inf.codeGen = inf.CodeGenXMRList2Array;
			inf = new TokenDeclInline (ifd, false, "xmrChars2String(object,integer,integer)",                 typeof (string),      null); inf.codeGen = inf.CodeGenXMRChars2String;
			inf = new TokenDeclInline (ifd, false, "xmrString2Chars(string,integer,object,integer,integer)",  typeof (void),        null); inf.codeGen = inf.CodeGenXMRString2Chars;

			inf = new TokenDeclInline (ifd, false, "xmrFixedArrayAllocC(integer)",                            typeof (object),      null); inf.codeGen = inf.CodeGenXMRFixedArrayAllocC;
			inf = new TokenDeclInline (ifd, false, "xmrFixedArrayGetC(object,integer)",                       typeof (char),        null); inf.codeGen = inf.CodeGenXMRFixedArrayGetC;
			inf = new TokenDeclInline (ifd, false, "xmrFixedArraySetC(object,integer,char)",                  typeof (void),        null); inf.codeGen = inf.CodeGenXMRFixedArraySetC;
			inf = new TokenDeclInline (ifd, false, "xmrFixedArrayAllocF(integer)",                            typeof (object),      null); inf.codeGen = inf.CodeGenXMRFixedArrayAllocF;
			inf = new TokenDeclInline (ifd, false, "xmrFixedArrayGetF(object,integer)",                       typeof (SCRIPTFLOAT), null); inf.codeGen = inf.CodeGenXMRFixedArrayGetF;
			inf = new TokenDeclInline (ifd, false, "xmrFixedArraySetF(object,integer,float)",                 typeof (void),        null); inf.codeGen = inf.CodeGenXMRFixedArraySetF;
			inf = new TokenDeclInline (ifd, false, "xmrFixedArrayAllocI(integer)",                            typeof (object),      null); inf.codeGen = inf.CodeGenXMRFixedArrayAllocI;
			inf = new TokenDeclInline (ifd, false, "xmrFixedArrayGetI(object,integer)",                       typeof (int),         null); inf.codeGen = inf.CodeGenXMRFixedArrayGetI;
			inf = new TokenDeclInline (ifd, false, "xmrFixedArraySetI(object,integer,integer)",               typeof (void),        null); inf.codeGen = inf.CodeGenXMRFixedArraySetI;
			inf = new TokenDeclInline (ifd, false, "xmrFixedArrayAllocO(integer)",                            typeof (object),      null); inf.codeGen = inf.CodeGenXMRFixedArrayAllocO;
			inf = new TokenDeclInline (ifd, false, "xmrFixedArrayGetO(object,integer)",                       typeof (object),      null); inf.codeGen = inf.CodeGenXMRFixedArrayGetO;
			inf = new TokenDeclInline (ifd, false, "xmrFixedArraySetO(object,integer,object)",                typeof (void),        null); inf.codeGen = inf.CodeGenXMRFixedArraySetO;

			/*
			 * Jack-assed os...() functions that use screwy types.
			 */
			inf = new TokenDeclInline (ifd, false, "osParseJSON(string)",                                    typeof (XMR_Array), null); inf.codeGen = inf.CodeGenOSParseJSON;

			/*
			 * Finally for any API functions defined by SCRIPTBASECLASS that are not overridden 
			 * by anything already defined above, create an inline definition to call it.
			 */
			AddInterfaceMethods (ifd, typeof (SCRIPTBASECLASS));
			AddInterfaceMethods (ifd, typeof (IOSSL_Api));

			return ifd;
		}

		private static void AddInterfaceMethods (VarDict ifd, Type ifaceType)
		{
			MethodInfo[] ifaceMethods = ifaceType.GetMethods ();
			foreach (MethodInfo ifaceMethod in ifaceMethods) {
				string key = ifaceMethod.Name;

				/*
				 * Only do ones that begin with lower-case letters...
				 * as any others can't be referenced by scripts.
				 */
				if ((key[0] < 'a') || (key[0] > 'z')) continue;

				try {
					/*
					 * See if we will generate a call to CheckRun() right 
					 * after we generate a call to the function.
					 */
					bool doCheckRun = true;
					for (int i = noCheckRun.Length; -- i >= 0;) {
						if (noCheckRun[i] == ifaceMethod.Name) {
							doCheckRun = false;
							break;
						}
					}

					/*
					 * Create a corresponding signature.
					 */
					ParameterInfo[] parameters = ifaceMethod.GetParameters ();
					TokenArgDecl argDecl = new TokenArgDecl (null);
					for (int i = 0; i < parameters.Length; i ++) {
						TokenType type = TokenType.FromSysType (null, parameters[i].ParameterType);
						TokenName name = new TokenName (null, parameters[i].Name);
						argDecl.AddArg (type, name);
					}

					/*
					 * Add function to dictionary.
					 */
					TokenType retType      = TokenType.FromSysType (null, ifaceMethod.ReturnType);
					TokenDeclInline inlfun = new TokenDeclInline (ifd, doCheckRun, key, retType, argDecl, ifaceMethod);
					inlfun.codeGen         = inlfun.CodeGenBEApi;
				} catch {

					///??? string msg = except.ToString ();
					///??? int i = msg.IndexOf ("\n");
					///??? if (i > 0) msg = msg.Substring (0, i);
					///??? Console.WriteLine ("TokenDeclInline*: {0}:     {1}", key, msg);

					///??? IGNORE ANY THAT FAIL - LIKE UNRECOGNIZED TYPE ???///
					///???                          and OVERLOADED NAMES ???///
				}
			}
		}

		/**
		 * @brief Add an inline function definition to the dictionary.
		 * @param ifd        = dictionary to add inline definition to
		 * @param doCheckRun = true iff the generated code or the function itself can possibly call CheckRun()
		 * @param nameArgSig = inline function signature string, in form <name>(<arglsltypes>,...)
		 * @param retType    = system return type, use typeof(void) if no return value
		 * @param methInfo   = used by codeGen to know what backend method to call
		 */
		private TokenDeclInline (VarDict ifd, 
		                         bool doCheckRun, 
		                         string nameArgSig, 
		                         Type retType, 
		                         MethodInfo methInfo)
			: base (null, null, null)
		{
			this.retType     = TokenType.FromSysType (null, retType);
			this.methInfo    = methInfo;
			this.doCheckRun  = doCheckRun;
			this.triviality  = doCheckRun ? Triviality.complex : Triviality.trivial;

			int j = nameArgSig.IndexOf ('(');
			this.name = new TokenName (null, nameArgSig.Substring (0, j ++));

			this.argDecl = new TokenArgDecl (null);
			if (nameArgSig[j] != ')') {
				int i;
				TokenName name;
				TokenType type;

				for (i = j; nameArgSig[i] != ')'; i ++) {
					if (nameArgSig[i] == ',') {
						type = TokenType.FromLSLType (null, nameArgSig.Substring (j, i - j));
						name = new TokenName (null, "arg" + this.argDecl.varDict.Count);
						this.argDecl.AddArg (type, name);
						j = i + 1;
					}
				}

				type = TokenType.FromLSLType (null, nameArgSig.Substring (j, i - j));
				name = new TokenName (null, "arg" + this.argDecl.varDict.Count);
				this.argDecl.AddArg (type, name);
			}

			this.location = new CompValuInline (this);
			ifd.AddEntry (this);
		}

		private TokenDeclInline (VarDict ifd, 
		                         bool doCheckRun, 
		                         string name, 
		                         TokenType retType, 
		                         TokenArgDecl argDecl, 
		                         MethodInfo methInfo)
			: base (null, null, null)
		{
			this.name        = new TokenName (null, name);
			this.retType     = retType;
			this.methInfo    = methInfo;
			this.argDecl     = argDecl;
			this.doCheckRun  = doCheckRun;
			this.triviality  = doCheckRun ? Triviality.complex : Triviality.trivial;
			this.location    = new CompValuInline (this);
			ifd.AddEntry (this);
		}

		/**
		 * @brief Code generators...
		 * @param scg = script we are generating code for
		 * @param result = type/location for result (type matches function definition)
		 * @param args = type/location of arguments (types match function definition)
		 */

		private void CodeGenLLAbs (ScriptCodeGen scg, Token errorAt, CompValuTemp result, CompValu[] args)
		{
			ScriptMyLabel itsPosLabel = scg.ilGen.DefineLabel ("llAbstemp");

			args[0].PushVal (scg, errorAt);
			scg.ilGen.Emit (OpCodes.Dup);
			scg.ilGen.Emit (OpCodes.Ldc_I4_0);
			scg.ilGen.Emit (OpCodes.Bge_S, itsPosLabel);
			scg.ilGen.Emit (OpCodes.Neg);
			scg.ilGen.MarkLabel (itsPosLabel);
			result.Pop (scg, errorAt, retType);
		}

		private void CodeGenStatic (ScriptCodeGen scg, Token errorAt, CompValuTemp result, CompValu[] args)
		{
			ParameterInfo[] paramsInfo = methInfo.GetParameters ();

			for (int i = 0; i < args.Length; i ++) {
				args[i].PushVal (scg, errorAt, TokenType.FromSysType (errorAt, paramsInfo[i].ParameterType));
			}
			scg.ilGen.Emit (OpCodes.Call, methInfo);
			result.Pop (scg, errorAt, retType);
		}

		private void CodeGenLLRound (ScriptCodeGen scg, Token errorAt, CompValuTemp result, CompValu[] args)
		{
			args[0].PushVal (scg, errorAt, tokenTypeFloat);
			scg.ilGen.Emit (OpCodes.Ldc_I4, (int)System.MidpointRounding.AwayFromZero);
			scg.ilGen.Emit (OpCodes.Call, roundMethInfo);
			result.Pop (scg, errorAt, tokenTypeFloat);
		}

		/**
		 * @brief Generate code to print a debug string on stdout.
		 *        Script-level prototype:  void consoleWrite(string)
		 */
///		private void CodeGenConsoleWrite (ScriptCodeGen scg, Token errorAt, CompValuTemp result, CompValu[] args)
///		{
///			scg.PushXMRInst ();
///			args[0].PushVal (scg, errorAt, tokenTypeString);
///			scg.ilGen.Emit (OpCodes.Call, consoleWrite);
///		}

		/**
		 * @brief Generate code to call an event handler
		 *        Script-level prototype:  xmrEventCallHandler(list)
		 */
		private void CodeGenXMREventCallHandler (ScriptCodeGen scg, Token errorAt, CompValuTemp result, CompValu[] args)
		{
			scg.PushXMRInst ();
			args[0].PushVal (scg, errorAt);
			scg.ilGen.Emit (OpCodes.Call, xmrEventCallHandler);
		}

		/**
		 * @brief Generate code to dequeue an event
		 *        Script-level prototype:  list xmrEventDequeue(float,integer,integer,integer,integer)
		 */
		private void CodeGenXMREventDequeue (ScriptCodeGen scg, Token errorAt, CompValuTemp result, CompValu[] args)
		{
			scg.PushXMRInst ();
			args[0].PushVal (scg, errorAt, tokenTypeFloat);
			args[1].PushVal (scg, errorAt, tokenTypeInt);
			args[2].PushVal (scg, errorAt, tokenTypeInt);
			args[3].PushVal (scg, errorAt, tokenTypeInt);
			args[4].PushVal (scg, errorAt, tokenTypeInt);
			scg.ilGen.PushInt (errorAt.line);
			scg.ilGen.Emit (OpCodes.Call, xmrEventDequeue);
			result.Pop (scg, errorAt, retType);
		}

		/**
		 * @brief Generate code to enqueue an event
		 *        Script-level prototype:  xmrEventEnqueue(list)
		 */
		private void CodeGenXMREventEnqueue (ScriptCodeGen scg, Token errorAt, CompValuTemp result, CompValu[] args)
		{
			scg.PushXMRInst ();
			args[0].PushVal (scg, errorAt);
			scg.ilGen.Emit (OpCodes.Call, xmrEventEnqueue);
		}

		/**
		 * @brief Generate code to load event detect parameters
		 *        Script-level prototype:  xmrEventLoadDets(list)
		 */
		private void CodeGenXMREventLoadDets (ScriptCodeGen scg, Token errorAt, CompValuTemp result, CompValu[] args)
		{
			scg.PushXMRInst ();
			args[0].PushVal (scg, errorAt);
			scg.ilGen.Emit (OpCodes.Call, xmrEventLoadDets);
		}

		/**
		 * @brief Generate code to save event detect parameters
		 *        Script-level prototype:  list xmrEventSaveDets()
		 */
		private void CodeGenXMREventSaveDets (ScriptCodeGen scg, Token errorAt, CompValuTemp result, CompValu[] args)
		{
			scg.PushXMRInst ();
			scg.ilGen.Emit (OpCodes.Call, xmrEventSaveDets);
			result.Pop (scg, errorAt, retType);
		}

		/**
		 * @brief Generate code to return number of bytes of heap they have left.
		 *        Script-level prototype:  integer xmrHeapLeft()
		 */
		private void CodeGenXMRHeapLeft (ScriptCodeGen scg, Token errorAt, CompValuTemp result, CompValu[] args)
		{
			scg.PushXMRInst ();
			scg.ilGen.Emit (OpCodes.Ldfld, ScriptCodeGen.heapLeftFieldInfo);
			result.Pop (scg, errorAt, retType);
		}

		/**
		 * @brief Generate code to return number of bytes of stack they have left.
		 *        Script-level prototype:  integer xmrStackLeft()
		 */
		private static MethodInfo stackLeftMethodInfo = typeof (XMRInstAbstract).GetMethod ("StackLeft", new Type[0]);
		private void CodeGenXMRStackLeft (ScriptCodeGen scg, Token errorAt, CompValuTemp result, CompValu[] args)
		{
			scg.PushXMRInst ();
			scg.ilGen.Emit (OpCodes.Call, stackLeftMethodInfo);
			result.Pop (scg, errorAt, retType);
		}

		/**
		 * @brief Generate code to return type name of the argument
		 *        Script-level prototype:  string xmrTypeName(object)
		 */
		private static MethodInfo typeNameMethodInfo = typeof (XMRInstAbstract).GetMethod ("XMRTypeName", new Type[] { typeof (object) });
		private void CodeGenXMRTypeName (ScriptCodeGen scg, Token errorAt, CompValuTemp result, CompValu[] args)
		{
			scg.PushXMRInst ();
			args[0].PushVal (scg, errorAt);
			scg.ilGen.Emit (OpCodes.Call, typeNameMethodInfo);
			result.Pop (scg, errorAt, retType);
		}

		/**
		 * @brief Generate code to return hash code of the argument
		 *        Script-level prototypes:  int xmrHashCode(float)
		 *                                  int xmrHashCode(integer)
		 *                                  int xmrHashCode(object)
		 */
		private static MethodInfo hashCodeFloatMethodInfo  = typeof (SCRIPTFLOAT).GetMethod ("GetHashCode", new Type[] { });
		private static MethodInfo hashCodeObjectMethodInfo = typeof (object).GetMethod ("GetHashCode", new Type[] { });
		private void CodeGenXMRHashCodeFloat (ScriptCodeGen scg, Token errorAt, CompValuTemp result, CompValu[] args)
		{
			if (args[0] is CompValuFloat) {
				scg.ilGen.PushInt (((CompValuFloat)args[0]).x.GetHashCode ());
			} else {
				try {
					args[0].PushRef (scg, errorAt);
				} catch {
					ScriptMyLocal temp = scg.ilGen.DeclareLocal (typeof (SCRIPTFLOAT), "hashcodefloat");
					args[0].PushVal (scg, errorAt);
					scg.ilGen.Emit (OpCodes.Stloc, temp);
					scg.ilGen.Emit (OpCodes.Ldloca, temp);
				}
				scg.ilGen.Emit (OpCodes.Call, hashCodeFloatMethodInfo);
			}
			result.Pop (scg, errorAt, retType);
		}
		private void CodeGenXMRHashCodeInteger (ScriptCodeGen scg, Token errorAt, CompValuTemp result, CompValu[] args)
		{
			args[0].PushVal (scg, errorAt);
			result.Pop (scg, errorAt, retType);
		}
		private void CodeGenXMRHashCodeObject (ScriptCodeGen scg, Token errorAt, CompValuTemp result, CompValu[] args)
		{
			args[0].PushVal (scg, errorAt);
			scg.ilGen.Emit (OpCodes.Callvirt, hashCodeObjectMethodInfo);
			result.Pop (scg, errorAt, retType);
		}

		/**
		 * @brief Generate code to access fixed-dimension arrays
		 */
		// object xmrFixedAllocC(integer)
		private void CodeGenXMRFixedArrayAllocC (ScriptCodeGen scg, Token errorAt, CompValuTemp result, CompValu[] args)
		{
			args[0].PushVal (scg, errorAt);
			scg.ilGen.Emit (OpCodes.Newarr, typeof (char));
			result.Pop (scg, errorAt);
		}

		// integer xmrFixedGetC(object,integer)
		private void CodeGenXMRFixedArrayGetC (ScriptCodeGen scg, Token errorAt, CompValuTemp result, CompValu[] args)
		{
			args[0].PushVal (scg, errorAt);
			scg.ilGen.Emit (OpCodes.Castclass, typeof (char[]));
			args[1].PushVal (scg, errorAt);
			scg.ilGen.Emit (OpCodes.Ldelem_I2);
			result.Pop (scg, errorAt);
		}

		// xmrFixedSetC(object,integer,integer)
		private void CodeGenXMRFixedArraySetC (ScriptCodeGen scg, Token errorAt, CompValuTemp result, CompValu[] args)
		{
			args[0].PushVal (scg, errorAt);
			scg.ilGen.Emit (OpCodes.Castclass, typeof (char[]));
			args[1].PushVal (scg, errorAt);
			args[2].PushVal (scg, errorAt);
			scg.ilGen.Emit (OpCodes.Stelem_I2);
		}

		// object xmrFixedAllocF(integer)
		private void CodeGenXMRFixedArrayAllocF (ScriptCodeGen scg, Token errorAt, CompValuTemp result, CompValu[] args)
		{
			args[0].PushVal (scg, errorAt);
			scg.ilGen.Emit (OpCodes.Newarr, typeof (SCRIPTFLOAT));
			result.Pop (scg, errorAt);
		}

		// float xmrFixedGetF(object,integer)
		private void CodeGenXMRFixedArrayGetF (ScriptCodeGen scg, Token errorAt, CompValuTemp result, CompValu[] args)
		{
			args[0].PushVal (scg, errorAt);
			scg.ilGen.Emit (OpCodes.Castclass, typeof (SCRIPTFLOAT[]));
			args[1].PushVal (scg, errorAt);
#define float Ldelem_R4
#define double Ldelem_R8
			scg.ilGen.Emit (OpCodes.SCRIPTFLOAT);
#undef float
#undef double
			result.Pop (scg, errorAt);
		}

		// xmrFixedSetF(object,integer,float)
		private void CodeGenXMRFixedArraySetF (ScriptCodeGen scg, Token errorAt, CompValuTemp result, CompValu[] args)
		{
			args[0].PushVal (scg, errorAt);
			scg.ilGen.Emit (OpCodes.Castclass, typeof (SCRIPTFLOAT[]));
			args[1].PushVal (scg, errorAt);
			args[2].PushVal (scg, errorAt);
#define float Stelem_R4
#define double Stelem_R8
			scg.ilGen.Emit (OpCodes.SCRIPTFLOAT);
#undef float
#undef double
		}

		// object xmrFixedAllocI(integer)
		private void CodeGenXMRFixedArrayAllocI (ScriptCodeGen scg, Token errorAt, CompValuTemp result, CompValu[] args)
		{
			args[0].PushVal (scg, errorAt);
			scg.ilGen.Emit (OpCodes.Newarr, typeof (int));
			result.Pop (scg, errorAt);
		}

		// integer xmrFixedGetI(object,integer)
		private void CodeGenXMRFixedArrayGetI (ScriptCodeGen scg, Token errorAt, CompValuTemp result, CompValu[] args)
		{
			args[0].PushVal (scg, errorAt);
			scg.ilGen.Emit (OpCodes.Castclass, typeof (int[]));
			args[1].PushVal (scg, errorAt);
			scg.ilGen.Emit (OpCodes.Ldelem_I4);
			result.Pop (scg, errorAt);
		}

		// xmrFixedSetI(object,integer,integer)
		private void CodeGenXMRFixedArraySetI (ScriptCodeGen scg, Token errorAt, CompValuTemp result, CompValu[] args)
		{
			args[0].PushVal (scg, errorAt);
			scg.ilGen.Emit (OpCodes.Castclass, typeof (int[]));
			args[1].PushVal (scg, errorAt);
			args[2].PushVal (scg, errorAt);
			scg.ilGen.Emit (OpCodes.Stelem_I4);
		}

		// object xmrFixedAllocO(integer)
		private void CodeGenXMRFixedArrayAllocO (ScriptCodeGen scg, Token errorAt, CompValuTemp result, CompValu[] args)
		{
			args[0].PushVal (scg, errorAt);
			scg.ilGen.Emit (OpCodes.Newarr, typeof (object));
			result.Pop (scg, errorAt);
		}

		// object xmrFixedGetO(object,integer)
		private void CodeGenXMRFixedArrayGetO (ScriptCodeGen scg, Token errorAt, CompValuTemp result, CompValu[] args)
		{
			args[0].PushVal (scg, errorAt);
			scg.ilGen.Emit (OpCodes.Castclass, typeof (object[]));
			args[1].PushVal (scg, errorAt);
			scg.ilGen.Emit (OpCodes.Ldelem, typeof (object));
			result.Pop (scg, errorAt);
		}

		// xmrFixedSetO(object,integer,object)
		private void CodeGenXMRFixedArraySetO (ScriptCodeGen scg, Token errorAt, CompValuTemp result, CompValu[] args)
		{
			args[0].PushVal (scg, errorAt);
			scg.ilGen.Emit (OpCodes.Castclass, typeof (object[]));
			args[1].PushVal (scg, errorAt);
			args[2].PushVal (scg, errorAt);
			scg.ilGen.Emit (OpCodes.Stelem, typeof (object));
		}

		/**
		 * @brief Generate code to return type name of the argument
		 *        Script-level prototype:  xmrArrayCppy(object,integer,object,integer,integer)
		 */
		private static MethodInfo arrayCopyMethodInfo = typeof (XMRSDTypeClObj).GetMethod ("XMRArrayCopy", new Type[] { typeof (object), typeof (int), typeof (object), typeof (int), typeof (int) });
		private void CodeGenXMRArrayCopy (ScriptCodeGen scg, Token errorAt, CompValuTemp result, CompValu[] args)
		{
			args[0].PushVal (scg, errorAt);
			args[1].PushVal (scg, errorAt);
			args[2].PushVal (scg, errorAt);
			args[3].PushVal (scg, errorAt);
			args[4].PushVal (scg, errorAt);
			scg.ilGen.Emit (OpCodes.Call, arrayCopyMethodInfo);
		}

		/**
		 * @brief List <-> Array conversion
		 */
		private static MethodInfo array2ListMethodInfo = typeof (XMRSDTypeClObj).GetMethod ("XMRArray2List", new Type[] { typeof (object), typeof (int), typeof (int) });
		private void CodeGenXMRArray2List (ScriptCodeGen scg, Token errorAt, CompValuTemp result, CompValu[] args)
		{
			args[0].PushVal (scg, errorAt);
			args[1].PushVal (scg, errorAt);
			args[2].PushVal (scg, errorAt);
			scg.ilGen.Emit (OpCodes.Call, array2ListMethodInfo);
			result.Pop (scg, errorAt);
		}

		private static MethodInfo list2ArrayMethodInfo = typeof (XMRSDTypeClObj).GetMethod ("XMRList2Array", new Type[] { typeof (LSL_List), typeof (int), typeof (object), typeof (int), typeof (int) });
		private void CodeGenXMRList2Array (ScriptCodeGen scg, Token errorAt, CompValuTemp result, CompValu[] args)
		{
			args[0].PushVal (scg, errorAt);
			args[1].PushVal (scg, errorAt);
			args[2].PushVal (scg, errorAt);
			args[3].PushVal (scg, errorAt);
			args[4].PushVal (scg, errorAt);
			scg.ilGen.Emit (OpCodes.Call, list2ArrayMethodInfo);
		}

		/**
		 * @brief String <-> Char Array conversion
		 */
		private static MethodInfo chars2StringMethodInfo = typeof (XMRSDTypeClObj).GetMethod ("XMRChars2String", new Type[] { typeof (object), typeof (int), typeof (int) });
		private void CodeGenXMRChars2String (ScriptCodeGen scg, Token errorAt, CompValuTemp result, CompValu[] args)
		{
			args[0].PushVal (scg, errorAt);
			args[1].PushVal (scg, errorAt);
			args[2].PushVal (scg, errorAt);
			scg.ilGen.Emit (OpCodes.Call, chars2StringMethodInfo);
			result.Pop (scg, errorAt);
		}

		private static MethodInfo string2CharsMethodInfo = typeof (XMRSDTypeClObj).GetMethod ("XMRString2Chars", new Type[] { typeof (string), typeof (int), typeof (object), typeof (int), typeof (int) });
		private void CodeGenXMRString2Chars (ScriptCodeGen scg, Token errorAt, CompValuTemp result, CompValu[] args)
		{
			args[0].PushVal (scg, errorAt);
			args[1].PushVal (scg, errorAt);
			args[2].PushVal (scg, errorAt);
			args[3].PushVal (scg, errorAt);
			args[4].PushVal (scg, errorAt);
			scg.ilGen.Emit (OpCodes.Call, string2CharsMethodInfo);
		}

		/**
		 * @brief Generate code to parse a JSON string
		 *        Script-level prototype:  array osParseJSON(string)
		 */
		private void CodeGenOSParseJSON (ScriptCodeGen scg, Token errorAt, CompValuTemp result, CompValu[] args)
		{
			scg.PushXMRInst ();
			args[0].PushVal (scg, errorAt, tokenTypeString);
			scg.ilGen.Emit (OpCodes.Call, xmrOSParseJSON);
			result.Pop (scg, errorAt, retType);
		}

		/**
		 * @brief Generate call to backend API function (eg llSay()) followed by a call to CheckRun().
		 * @param scg = script being compiled
		 * @param result = where to place result (might be void)
		 * @param args = arguments to pass to API function
		 */
		private void CodeGenBEApi (ScriptCodeGen scg, Token errorAt, CompValuTemp result, CompValu[] args)
		{
			scg.PushXMRInst ();                               // xmrinstance = 'this' for the API function
			for (int i = 0; i < args.Length; i ++) {          // push arguments
				args[i].PushVal (scg, errorAt, argDecl.types[i]);  // .. boxing/unboxing as needed
			}
			scg.ilGen.Emit (OpCodes.Call, methInfo);          // call API function
			result.Pop (scg, errorAt, retType);               // pop result, boxing/unboxing as needed
			if (doCheckRun) {
				scg.EmitCallCheckRun (errorAt.line);      // maybe call CheckRun()
			}
		}
	}
}
