/***************************************************\
 *  COPYRIGHT 2012, Mike Rieker, Beverly, MA, USA  *
 *  All rights reserved.                           *
\***************************************************/

using System;
using System.Collections.Generic;
using System.Reflection;
using System.Reflection.Emit;
using System.Text;

using OpenSim.Region.ScriptEngine.Shared.Api.Interfaces;
using OpenSim.Region.ScriptEngine.Shared.ScriptBase;

#include "lsltypes.h"


/**
 * @brief Generate code for the backend API calls.
 */
namespace OpenSim.Region.ScriptEngine.XMREngine
{
	public delegate void CodeGenCall (ScriptCodeGen scg, Token errorAt, CompValuTemp result, CompValu[] args);

	public class TokenDeclInline : TokenDeclVar {
		public static VarDict inlineFunctions = TokenDeclInline.CreateDictionary ();

		public CodeGenCall codeGen;   // method that generates code
		public MethodInfo methInfo;   // function called by the inline
		public bool doCheckRun;       // valid for CodeGenBEApi only
		public int keepNulls;         // valid for CodeGenLLParseString2List only

		private static TokenTypeFloat tokenTypeFloat = new TokenTypeFloat (null);
		private static TokenTypeInt   tokenTypeInt   = new TokenTypeInt   (null);

		private static MethodInfo roundMethInfo = ScriptCodeGen.GetStaticMethod (typeof (System.Math), "Round", 
				new Type[] { typeof (double), typeof (MidpointRounding) });

		private static readonly MethodInfo fixLLParcelMediaQuery = ScriptCodeGen.GetStaticMethod 
				(typeof (XMRInstAbstract), "FixLLParcelMediaQuery", new Type[] { typeof (LSL_List) });

		private static readonly MethodInfo fixLLParcelMediaCommandList = ScriptCodeGen.GetStaticMethod 
				(typeof (XMRInstAbstract), "FixLLParcelMediaCommandList", new Type[] { typeof (LSL_List) });

		private static readonly MethodInfo getFreeMemMethInfo = typeof (XMRInstAbstract).GetMethod ("xmrHeapLeft", new Type[] { });
		private static readonly MethodInfo getUsedMemMethInfo = typeof (XMRInstAbstract).GetMethod ("xmrHeapUsed", new Type[] { });

		private static string[] noCheckRuns;
		private static string[] keyReturns;

		/**
		 * @brief Create a dictionary of inline backend API functions.
		 */
		private static VarDict CreateDictionary ()
		{
			/*
			 * For those listed in noCheckRun, we just generate the call (simple computations).
			 * For all others, we generate the call then a call to CheckRun().
			 */
			noCheckRuns = new string[] {
				"llBase64ToString",
				"llCSV2List",
				"llDeleteSubList",
				"llDeleteSubString",
				"llDumpList2String",
				"llEscapeURL",
				"llEuler2Rot",
				"llGetListEntryType",
				"llGetListLength",
				"llGetSubString",
				"llGetUnixTime",
				"llInsertString",
				"llList2CSV",
				"llList2Float",
				"llList2Integer",
				"llList2Key",
				"llList2List",
				"llList2ListStrided",
				"llList2Rot",
				"llList2String",
				"llList2Vector",
				"llListFindList",
				"llListInsertList",
				"llListRandomize",
				"llListReplaceList",
				"llListSort",
				"llListStatistics",
				"llMD5String",
				"llParseString2List",
				"llParseStringKeepNulls",
				"llStringLength",
				"llStringToBase64",
				"llStringTrim",
				"llSubStringIndex",
				"llUnescapeURL"
			};

			/*
			 * These functions really return a 'key' even though we see them as
			 * returning 'string' because OpenSim has key and string as same type.
			 */
			keyReturns = new string[] {
				"llAvatarOnLinkSitTarget",
				"llAvatarOnSitTarget",
				"llDetectedKey",
				"llDetectedOwner",
				"llGenerateKey",
				"llGetCreator",
				"llGetInventoryCreator",
				"llGetInventoryKey",
				"llGetKey",
				"llGetLandOwnerAt",
				"llGetLinkKey",
				"llGetNotecardLine",
				"llGetNumberOfNotecardLines",
				"llGetOwner",
				"llGetOwnerKey",
				"llGetPermissionsKey",
				"llHTTPRequest",
				"llList2Key",
				"llRequestAgentData",
				"llRequestDisplayName",
				"llRequestInventoryData",
				"llRequestSecureURL",
				"llRequestSimulatorData",
				"llRequestURL",
				"llRequestUsername",
				"llSendRemoteData",
				"llTransferLindenDollars"
			};

			VarDict ifd = new VarDict ();
			TokenDeclInline inf;

			Type[] oneDoub  = new Type[] { typeof (double) };
			Type[] twoDoubs = new Type[] { typeof (double), typeof (double) };

			/*
			 * Mono generates an FPU instruction for many math calls.
			 */
			inf = new TokenDeclInline (ifd, false, "llAbs(integer)",       typeof (int),         null);                                                                      inf.codeGen = inf.CodeGenLLAbs;
			inf = new TokenDeclInline (ifd, false, "llAcos(float)",        typeof (SCRIPTFLOAT), ScriptCodeGen.GetStaticMethod (typeof (System.Math), "Acos",    oneDoub));  inf.codeGen = inf.CodeGenStatic;
			inf = new TokenDeclInline (ifd, false, "llAsin(float)",        typeof (SCRIPTFLOAT), ScriptCodeGen.GetStaticMethod (typeof (System.Math), "Asin",    oneDoub));  inf.codeGen = inf.CodeGenStatic;
			inf = new TokenDeclInline (ifd, false, "llAtan2(float,float)", typeof (SCRIPTFLOAT), ScriptCodeGen.GetStaticMethod (typeof (System.Math), "Atan2",   twoDoubs)); inf.codeGen = inf.CodeGenStatic;
			inf = new TokenDeclInline (ifd, false, "llCos(float)",         typeof (SCRIPTFLOAT), ScriptCodeGen.GetStaticMethod (typeof (System.Math), "Cos",     oneDoub));  inf.codeGen = inf.CodeGenStatic;
			inf = new TokenDeclInline (ifd, false, "llFabs(float)",        typeof (SCRIPTFLOAT), ScriptCodeGen.GetStaticMethod (typeof (System.Math), "Abs",     oneDoub));  inf.codeGen = inf.CodeGenStatic;
			inf = new TokenDeclInline (ifd, false, "llLog(float)",         typeof (SCRIPTFLOAT), ScriptCodeGen.GetStaticMethod (typeof (System.Math), "Log",     oneDoub));  inf.codeGen = inf.CodeGenStatic;
			inf = new TokenDeclInline (ifd, false, "llLog10(float)",       typeof (SCRIPTFLOAT), ScriptCodeGen.GetStaticMethod (typeof (System.Math), "Log10",   oneDoub));  inf.codeGen = inf.CodeGenStatic;
			inf = new TokenDeclInline (ifd, false, "llPow(float,float)",   typeof (SCRIPTFLOAT), ScriptCodeGen.GetStaticMethod (typeof (System.Math), "Pow",     twoDoubs)); inf.codeGen = inf.CodeGenStatic;
			inf = new TokenDeclInline (ifd, false, "llRound(float)",       typeof (int),         null);                                                                      inf.codeGen = inf.CodeGenLLRound;
			inf = new TokenDeclInline (ifd, false, "llSin(float)",         typeof (SCRIPTFLOAT), ScriptCodeGen.GetStaticMethod (typeof (System.Math), "Sin",     oneDoub));  inf.codeGen = inf.CodeGenStatic;
			inf = new TokenDeclInline (ifd, false, "llSqrt(float)",        typeof (SCRIPTFLOAT), ScriptCodeGen.GetStaticMethod (typeof (System.Math), "Sqrt",    oneDoub));  inf.codeGen = inf.CodeGenStatic;
			inf = new TokenDeclInline (ifd, false, "llTan(float)",         typeof (SCRIPTFLOAT), ScriptCodeGen.GetStaticMethod (typeof (System.Math), "Tan",     oneDoub));  inf.codeGen = inf.CodeGenStatic;

			/*
			 * Something weird about the code generation for these calls, so they all have their own handwritten code generators.
			 */
			inf = new TokenDeclInline (ifd, false, "llGetFreeMemory()", typeof (int), null); inf.codeGen = inf.CodeGenGetFreeMemory;
			inf = new TokenDeclInline (ifd, false, "llGetUsedMemory()", typeof (int), null); inf.codeGen = inf.CodeGenGetUsedMemory;

			/*
			 * Finally for any API functions defined by SCRIPTBASECLASS that are not overridden 
			 * by anything already defined above, create an inline definition to call it.
			 */
			AddInterfaceMethods (ifd, typeof (XMRInstAbstract));
			AddInterfaceMethods (ifd, typeof (SCRIPTBASECLASS));
			AddInterfaceMethods (ifd, typeof (IOSSL_Api));

			return ifd;
		}

		/**
		 * @brief Add API functions from the given interface to list of built-in functions.
		 *        Only functions beginning with a lower-case letter are entered, all others ignored.
		 * @param ifd = internal function dictionary to add them to
		 * @param ifaceType = interface to scan for functions
		 */
		public static void AddInterfaceMethods (VarDict ifd, Type ifaceType)
		{
			MethodInfo[] ifaceMethods = ifaceType.GetMethods ();
			foreach (MethodInfo ifaceMethod in ifaceMethods) {
				string key = ifaceMethod.Name;

				/*
				 * Only do ones that begin with lower-case letters...
				 * as any others can't be referenced by scripts.
				 */
				if ((key[0] < 'a') || (key[0] > 'z')) continue;

				try {
					/*
					 * See if we will generate a call to CheckRun() right 
					 * after we generate a call to the function.
					 * If function begins with xmr, assume we will not call CheckRun()
					 * Otherwise, assume we will call CheckRun()
					 */
					bool dcr = !key.StartsWith ("xmr");
					foreach (string ncr in noCheckRuns) {
						if (ncr == key) {
							dcr = false;
							break;
						}
					}

					/*
					 * Create a corresponding signature.
					 */
					ParameterInfo[] parameters = ifaceMethod.GetParameters ();
					TokenArgDecl argDecl = new TokenArgDecl (null);
					foreach (ParameterInfo pi in parameters) {
						TokenType type = TokenType.FromSysType (null, pi.ParameterType);
						TokenName name = new TokenName (null, pi.Name);
						argDecl.AddArg (type, name);
					}

					/*
					 * Add function to dictionary.
					 */
					TokenType retType      = TokenType.FromSysType (null, ifaceMethod.ReturnType);
					TokenDeclInline inlfun = new TokenDeclInline (ifd, dcr, key, retType, argDecl, ifaceMethod);
					inlfun.codeGen         = inlfun.CodeGenBEApi;
				} catch {
					///??? IGNORE ANY THAT FAIL - LIKE UNRECOGNIZED TYPE ???///
					///???                          and OVERLOADED NAMES ???///
				}
			}
		}

		/**
		 * @brief Add an inline function definition to the dictionary.
		 * @param ifd        = dictionary to add inline definition to
		 * @param doCheckRun = true iff the generated code or the function itself can possibly call CheckRun()
		 * @param nameArgSig = inline function signature string, in form <name>(<arglsltypes>,...)
		 * @param retType    = system return type, use typeof(void) if no return value
		 * @param methInfo   = used by codeGen to know what backend method to call
		 */
		private TokenDeclInline (VarDict ifd, 
		                         bool doCheckRun, 
		                         string nameArgSig, 
		                         Type retType, 
		                         MethodInfo methInfo)
			: base (null, null, null)
		{
			this.retType     = GetRetType (methInfo, TokenType.FromSysType (null, retType));
			this.methInfo    = methInfo;
			this.doCheckRun  = doCheckRun;
			this.triviality  = (doCheckRun || IsTaggedComplex (methInfo)) ? Triviality.complex : Triviality.trivial;

			int j = nameArgSig.IndexOf ('(');
			this.name = new TokenName (null, nameArgSig.Substring (0, j ++));

			this.argDecl = new TokenArgDecl (null);
			if (nameArgSig[j] != ')') {
				int i;
				TokenName name;
				TokenType type;

				for (i = j; nameArgSig[i] != ')'; i ++) {
					if (nameArgSig[i] == ',') {
						type = TokenType.FromLSLType (null, nameArgSig.Substring (j, i - j));
						name = new TokenName (null, "arg" + this.argDecl.varDict.Count);
						this.argDecl.AddArg (type, name);
						j = i + 1;
					}
				}

				type = TokenType.FromLSLType (null, nameArgSig.Substring (j, i - j));
				name = new TokenName (null, "arg" + this.argDecl.varDict.Count);
				this.argDecl.AddArg (type, name);
			}

			this.location = new CompValuInline (this);
			ifd.AddEntry (this);
		}

		private TokenDeclInline (VarDict ifd, 
		                         bool doCheckRun, 
		                         string name, 
		                         TokenType retType, 
		                         TokenArgDecl argDecl, 
		                         MethodInfo methInfo)
			: base (null, null, null)
		{
			this.name        = new TokenName (null, name);
			this.retType     = GetRetType (methInfo, retType);
			this.methInfo    = methInfo;
			this.argDecl     = argDecl;
			this.doCheckRun  = doCheckRun;
			this.triviality  = (doCheckRun || IsTaggedComplex (methInfo)) ? Triviality.complex : Triviality.trivial;
			this.location    = new CompValuInline (this);
			ifd.AddEntry (this);
		}

		/**
		 * @brief The above code assumes all methods beginning with 'xmr' are trivial, ie, 
		 *        they do not call CheckRun() and also we do not generate a CheckRun() 
		 *        call after they return.  So if an 'xmr' method does call CheckRun(), it 
		 *        must be tagged with attribute 'xmrMethodIsComplexAttribute' so we know 
		 *        the method is not trivial.  But in neither case do we emit our own call 
		 *        to CheckRun(), the 'xmr' method must do its own.
		 */
		private static bool IsTaggedComplex (MethodInfo methInfo)
		{
			if (methInfo != null) {
				foreach (Attribute attr in Attribute.GetCustomAttributes (methInfo)) {
					if (attr is xmrMethodIsComplexAttribute) return true;
				}
			}
			return false;
		}

		/**
		 * @brief The dumbass OpenSim has key and string as the same type so non-ll
		 *        methods must be tagged with xmrMethodReturnsKeyAttribute if we
		 *        are to think they return a key type, otherwise we will think they
		 *        return string.
		 */
		private static TokenType GetRetType (MethodInfo methInfo, TokenType retType)
		{
			if ((methInfo != null) && (retType != null) && (retType is TokenTypeStr)) {
				foreach (Attribute attr in Attribute.GetCustomAttributes (methInfo)) {
					if (attr is xmrMethodReturnsKeyAttribute) {
						return ChangeToKeyType (retType);
					}
				}

				string mn = methInfo.Name;
				foreach (string kr in keyReturns) {
					if (kr == mn) {
						return ChangeToKeyType (retType);
					}
				}

			}
			return retType;
		}
		private static TokenType ChangeToKeyType (TokenType retType)
		{
			if (retType is TokenTypeLSLString) {
				retType = new TokenTypeLSLKey (null);
			} else {
				retType = new TokenTypeKey (null);
			}
			return retType;
		}

		/**
		 * @brief Code generators...
		 * @param scg = script we are generating code for
		 * @param result = type/location for result (type matches function definition)
		 * @param args = type/location of arguments (types match function definition)
		 */

		private void CodeGenLLAbs (ScriptCodeGen scg, Token errorAt, CompValuTemp result, CompValu[] args)
		{
			ScriptMyLabel itsPosLabel = scg.ilGen.DefineLabel ("llAbstemp");

			args[0].PushVal (scg, errorAt);
			scg.ilGen.Emit (errorAt, OpCodes.Dup);
			scg.ilGen.Emit (errorAt, OpCodes.Ldc_I4_0);
			scg.ilGen.Emit (errorAt, OpCodes.Bge_S, itsPosLabel);
			scg.ilGen.Emit (errorAt, OpCodes.Neg);
			scg.ilGen.MarkLabel (itsPosLabel);
			result.Pop (scg, errorAt, retType);
		}

		private void CodeGenStatic (ScriptCodeGen scg, Token errorAt, CompValuTemp result, CompValu[] args)
		{
			ParameterInfo[] paramsInfo = methInfo.GetParameters ();

			for (int i = 0; i < args.Length; i ++) {
				args[i].PushVal (scg, errorAt, TokenType.FromSysType (errorAt, paramsInfo[i].ParameterType));
			}
			scg.ilGen.Emit (errorAt, OpCodes.Call, methInfo);
			result.Pop (scg, errorAt, retType);
		}

		private void CodeGenLLRound (ScriptCodeGen scg, Token errorAt, CompValuTemp result, CompValu[] args)
		{
			args[0].PushVal (scg, errorAt, tokenTypeFloat);
			scg.ilGen.Emit (errorAt, OpCodes.Ldc_I4, (int)System.MidpointRounding.AwayFromZero);
			scg.ilGen.Emit (errorAt, OpCodes.Call, roundMethInfo);
			result.Pop (scg, errorAt, tokenTypeFloat);
		}

		// appears as llGetFreeMemory() in script source code
		// but actually calls xmrHeapLeft()
		private void CodeGenGetFreeMemory (ScriptCodeGen scg, Token errorAt, CompValuTemp result, CompValu[] args)
		{
			scg.PushXMRInst ();
			scg.ilGen.Emit (errorAt, OpCodes.Call, getFreeMemMethInfo);
			result.Pop (scg, errorAt, tokenTypeInt);
		}

		// appears as llGetUsedMemory() in script source code
		// but actually calls xmrHeapUsed()
		private void CodeGenGetUsedMemory (ScriptCodeGen scg, Token errorAt, CompValuTemp result, CompValu[] args)
		{
			scg.PushXMRInst ();
			scg.ilGen.Emit (errorAt, OpCodes.Call, getUsedMemMethInfo);
			result.Pop (scg, errorAt, tokenTypeInt);
		}

		/**
		 * @brief Generate call to backend API function (eg llSay()) maybe followed by a call to CheckRun().
		 * @param scg    = script being compiled
		 * @param result = where to place result (might be void)
		 * @param args   = script-visible arguments to pass to API function
		 */
		private void CodeGenBEApi (ScriptCodeGen scg, Token errorAt, CompValuTemp result, CompValu[] args)
		{
			if (!methInfo.IsStatic) {
				scg.PushXMRInst ();                       // xmrinstance = 'this' for the API function
			}
			for (int i = 0; i < args.Length; i ++) {          // push arguments, boxing/unboxing as needed
				args[i].PushVal (scg, errorAt, argDecl.types[i]);
			}
			if (methInfo.Name == "llParcelMediaQuery") {
				scg.ilGen.Emit (errorAt, OpCodes.Call, fixLLParcelMediaQuery);
			}
			if (methInfo.Name == "llParcelMediaCommandList") {
				scg.ilGen.Emit (errorAt, OpCodes.Call, fixLLParcelMediaCommandList);
			}
			if (methInfo.IsVirtual) {                         // call API function
				scg.ilGen.Emit (errorAt, OpCodes.Callvirt, methInfo);
			} else {
				scg.ilGen.Emit (errorAt, OpCodes.Call, methInfo);
			}
			result.Pop (scg, errorAt, retType);               // pop result, boxing/unboxing as needed
			if (doCheckRun) {
				scg.EmitCallCheckRun (errorAt);           // maybe call CheckRun()
			}
		}
	}
}
