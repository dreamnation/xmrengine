/********************************************************\
 *  COPYRIGHT 2009,2010, Mike Rieker, Beverly, MA, USA  *
 *  All rights reserved.                                *
\********************************************************/

using OpenSim.Region.ScriptEngine.Shared.ScriptBase;
using OpenSim.Region.ScriptEngine.XMREngine;
using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Reflection.Emit;
using System.Text;
using System.Threading;

#include "lsltypes.h"

/**
 * @brief translate a reduced script token into corresponding CIL code.
 * The single script token contains a tokenized and textured version of the whole script file.
 */

namespace OpenSim.Region.ScriptEngine.XMREngine
{

	public class ScriptCodeGen
	{
		public static readonly string OBJECT_CODE_MAGIC = "XMRObjectCode";
		public static int COMPILED_VERSION_VALUE = 16;  // incremented when compiler changes for compatibility testing

		public static readonly int CALL_FRAME_MEMUSE = 64;
		public static readonly int STRING_LEN_TO_MEMUSE = 2;

		public static Exception outOfStackException = new OutOfStackException ();

		/*
		 * Static tables that there only needs to be one copy of for all.
		 */
		private static Dictionary<string, BinOpStr> binOpStrings = BinOpStr.DefineBinOps ();
		private static VarDict inlineFunctions = TokenDeclInline.CreateDictionary ();
		private static VarDict legalEventHandlers = CreateLegalEventHandlers ();
		private static TokenType[]     zeroArgs      = new TokenType[0];
		private static TokenTypeBool   tokenTypeBool = new TokenTypeBool   (null);
		private static TokenTypeFloat  tokenTypeFlt  = new TokenTypeFloat  (null);
		private static TokenTypeInt    tokenTypeInt  = new TokenTypeInt    (null);
		private static TokenTypeObject tokenTypeObj  = new TokenTypeObject (null);
		private static TokenTypeRot    tokenTypeRot  = new TokenTypeRot    (null);
		private static TokenTypeStr    tokenTypeStr  = new TokenTypeStr    (null);
		private static TokenTypeVec    tokenTypeVec  = new TokenTypeVec    (null);
		private static Type[] instanceTypeArg = new Type[] { typeof (XMRInstAbstract) };

		private static ConstructorInfo lslFloatConstructorInfo = typeof (LSL_Float).GetConstructor (new Type[] { typeof (SCRIPTFLOAT) });
		private static ConstructorInfo lslIntegerConstructorInfo = typeof (LSL_Integer).GetConstructor (new Type[] { typeof (int) });
		private static ConstructorInfo lslListConstructorInfo = typeof (LSL_List).GetConstructor (new Type[] { typeof (object[]) });
		public  static ConstructorInfo lslRotationConstructorInfo = typeof (LSL_Rotation).GetConstructor (new Type[] { typeof (double), typeof (double), typeof (double), typeof (double) });
		private static ConstructorInfo lslStringConstructorInfo = typeof (LSL_String).GetConstructor (new Type[] { typeof (string) });
		public  static ConstructorInfo lslVectorConstructorInfo = typeof (LSL_Vector).GetConstructor (new Type[] { typeof (double), typeof (double), typeof (double) });
		private static ConstructorInfo scriptBadCallNoExceptionConstructorInfo = typeof (ScriptBadCallNoException).GetConstructor (new Type[] { typeof (int) });
		private static ConstructorInfo scriptChangeStateExceptionConstructorInfo = typeof (ScriptChangeStateException).GetConstructor (new Type[] { typeof (int) });
		private static ConstructorInfo scriptUndefinedStateExceptionConstructorInfo = typeof (ScriptUndefinedStateException).GetConstructor (new Type[] { typeof (string) });
		private static ConstructorInfo sdtClassConstructorInfo = typeof (XMRSDTypeClassInstance).GetConstructor (new Type[] { typeof (XMRInstAbstract), typeof (string) });
		private static ConstructorInfo xmrArrayConstructorInfo = typeof (XMR_Array).GetConstructor (new Type[] { typeof (XMRInstAbstract), typeof (int), typeof (int) });
		private static FieldInfo callModeFieldInfo     = typeof (XMRInstAbstract).GetField ("callMode");
		private static FieldInfo doGblInitFieldInfo    = typeof (XMRInstAbstract).GetField ("doGblInit");
		private static FieldInfo ehArgsFieldInfo       = typeof (XMRInstAbstract).GetField ("ehArgs");
		public  static FieldInfo heapLeftFieldInfo     = typeof (XMRInstAbstract).GetField ("heapLeft");
		private static FieldInfo heapLimitFieldInfo    = typeof (XMRInstAbstract).GetField ("heapLimit");
		private static FieldInfo rotationXFieldInfo    = typeof (LSL_Rotation).GetField ("x");
		private static FieldInfo rotationYFieldInfo    = typeof (LSL_Rotation).GetField ("y");
		private static FieldInfo rotationZFieldInfo    = typeof (LSL_Rotation).GetField ("z");
		private static FieldInfo rotationSFieldInfo    = typeof (LSL_Rotation).GetField ("s");
		private static FieldInfo sdtXMRInstFieldInfo   = typeof (XMRSDTypeClassInstance).GetField ("xmrInst");
		private static FieldInfo vectorXFieldInfo      = typeof (LSL_Vector).GetField ("x");
		private static FieldInfo vectorYFieldInfo      = typeof (LSL_Vector).GetField ("y");
		private static FieldInfo vectorZFieldInfo      = typeof (LSL_Vector).GetField ("z");

		private static MethodInfo arrayClearMethodInfo = typeof (XMR_Array).GetMethod ("__pub_clear", new Type[] { });
		private static MethodInfo arrayCountMethodInfo = typeof (XMR_Array).GetMethod ("__pub_count", new Type[] { });
		private static MethodInfo arrayIndexMethodInfo = typeof (XMR_Array).GetMethod ("__pub_index", new Type[] { typeof (int) });
		private static MethodInfo arrayValueMethodInfo = typeof (XMR_Array).GetMethod ("__pub_value", new Type[] { typeof (int) });
		private static MethodInfo checkRunMethodInfo   = typeof (XMRInstAbstract).GetMethod ("CheckRun", new Type[] { typeof (int) });
		private static MethodInfo ehArgUnwrapFloat     = GetStaticMethod (typeof (TypeCast), "EHArgUnwrapFloat",    new Type[] { typeof (object) });
		private static MethodInfo ehArgUnwrapInteger   = GetStaticMethod (typeof (TypeCast), "EHArgUnwrapInteger",  new Type[] { typeof (object) });
		private static MethodInfo ehArgUnwrapRotation  = GetStaticMethod (typeof (TypeCast), "EHArgUnwrapRotation", new Type[] { typeof (object) });
		private static MethodInfo ehArgUnwrapString    = GetStaticMethod (typeof (TypeCast), "EHArgUnwrapString",   new Type[] { typeof (object) });
		private static MethodInfo ehArgUnwrapVector    = GetStaticMethod (typeof (TypeCast), "EHArgUnwrapVector",   new Type[] { typeof (object) });
		private static MethodInfo forEachMethodInfo    = typeof (XMR_Array).GetMethod ("ForEach", 
		                                                                               new Type[] { typeof (int),
		                                                                                            typeof (object).MakeByRefType (),
		                                                                                            typeof (object).MakeByRefType () });
		private static MethodInfo captureStackFrameMethodInfo = typeof (XMRInstAbstract).GetMethod ("CaptureStackFrame", new Type[] { typeof (string), typeof (int), typeof (int) });
		private static MethodInfo restoreStackFrameMethodInfo = typeof (XMRInstAbstract).GetMethod ("RestoreStackFrame", new Type[] { typeof (string), typeof (int).MakeByRefType () });
		private static MethodInfo interlockedAddMethodInfo    = GetStaticMethod (typeof (Interlocked), "Add", new Type[] { typeof (int).MakeByRefType (), typeof (int) });
		private static MethodInfo updateHeapLeftMethodInfo = GetStaticMethod (typeof (ScriptCodeGen), 
		                                                                      "UpdateHeapLeft", 
		                                                                      new Type[] { typeof (XMRInstAbstract),
		                                                                                   typeof (object),
		                                                                                   typeof (int),
		                                                                                   typeof (int),
		                                                                                   typeof (int) });
		private static MethodInfo lslVectorNegateMethodInfo = GetStaticMethod (typeof (ScriptCodeGen), 
		                                                                       "LSLVectorNegate", 
		                                                                       new Type[] { typeof (LSL_Vector) });
		private static MethodInfo throwStrToExcMethodInfo = GetStaticMethod (typeof (ScriptCodeGen),
		                                                                     "ThrowStrToExc",
		                                                                     new Type[] { typeof (string) });
		private static MethodInfo catchExcToStrMethodInfo = GetStaticMethod (typeof (ScriptCodeGen),
		                                                                     "CatchExcToStr",
		                                                                     new Type[] { typeof (Exception) });

		public static bool CodeGen (TokenScript tokenScript, BinaryWriter objFileWriter)
		{
			TypeCast.CreateLegalTypeCasts ();

			/*
			 * Run compiler such that it has a 'this' context for convenience.
			 */
			ScriptCodeGen scg = new ScriptCodeGen (tokenScript, objFileWriter);

			/*
			 * Return pointer to resultant script object code.
			 */
			return !scg.youveAnError;
		}

		/*
		 * There is one set of these variables for each script being compiled.
		 */
		private bool mightGetHere = false;
		private bool youveAnError = false;
		private BreakContTarg curBreakTarg = null;
		private BreakContTarg curContTarg  = null;
		private int nStates = 0;
		private Token errorMessageToken = null;
		private TokenDeclVar curDeclFunc = null;
		private TokenStmtBlock curStmtBlock = null;
		private BinaryWriter objFileWriter = null;
		private TokenScript tokenScript = null;
		public  int tempCompValuNum = 0;
		private TokenDeclSDTypeClass currentSDTClass = null;

		private Dictionary<string, int> stateIndices = null;
		private Stack<VarDict> scriptVariablesStack = null;

		// code generation output
		public ScriptObjCode scriptObjCode = null;

		// These get cleared at beginning of every function definition
		public  ScriptMyILGen ilGen    = null;  // the output instruction stream
		private ScriptMyLabel retLabel = null;  // where to jump to exit function
		private ScriptMyLocal retValue = null;
		private ScriptMyLocal callNo   = null;
		private LinkedList<CallLabel> allCallLabels = new LinkedList<CallLabel> ();
		public  LinkedList<CompValuTemp> activeTemps = new LinkedList<CompValuTemp> ();

		private ScriptCodeGen (TokenScript tokenScript, BinaryWriter objFileWriter)
		{
			this.tokenScript   = tokenScript;
			this.objFileWriter = objFileWriter;

			try {
				PerformCompilation ();
			} catch {
				// if we've an error, just punt on any exception
				// it's probably just a null reference from something
				// not being filled in etc.
				if (!youveAnError) throw;
			} finally {
				objFileWriter = null;
				scriptObjCode = null;
			}
		}

		/**
		 * @brief Convert 'tokenScript' to 'objFileWriter' format.
		 *   'tokenScript' is a parsed/reduced abstract syntax tree of the script source file
		 *   'objFileWriter' is a serialized form of the CIL code that we generate
		 * Note:  The scriptObjCode herein is only temporary and is discarded on return.
		 *        Use PerformGeneration() to create the 'real' one.
		 */
		private void PerformCompilation ()
		{

			/*
			 * errorMessageToken is used only when the given token doesn't have a
			 * output delegate associated with it such as for backend API functions
			 * that only have one copy for the whole system.  It is kept up-to-date
			 * approximately but is rarely needed so going to assume it doesn't have 
			 * to be exact.
			 */
			errorMessageToken = tokenScript;

			/*
			 * Set up dictionary to translate state names to their index number.
			 */
			stateIndices = new Dictionary<string, int> ();

			/*
			 * Assign each state its own unique index.
			 * The default state gets 0.
			 */
			nStates = 0;
			tokenScript.defaultState.body.index = nStates ++;
			stateIndices.Add ("default", 0);
			foreach (KeyValuePair<string, TokenDeclState> kvp in tokenScript.states) {
				TokenDeclState declState = kvp.Value;
				declState.body.index = nStates ++;
				stateIndices.Add (declState.name.val, declState.body.index);
			}

			/*
			 * Make up an array that translates state indices to state name strings.
			 */
			scriptObjCode = new ScriptObjCode ();
			scriptObjCode.stateNames = new string[nStates];
			scriptObjCode.stateNames[0] = "default";
			foreach (KeyValuePair<string, TokenDeclState> kvp in tokenScript.states) {
				TokenDeclState declState = kvp.Value;
				scriptObjCode.stateNames[declState.body.index] = declState.name.val;
			}

			/*
			 * Set up stack of dictionaries to translate function and variable names to their declaration.
			 * This stack is used for function/variable names that stand alone, ie, no '.' involved in the
			 * reference.
			 * Then push the first element on the stack that will get any script-defined global variables.
			 */
			scriptVariablesStack = new Stack<VarDict> ();
			PushVarDefnBlock ();

			/*
			 * Assign all global variables a slot in its corresponding XMRInstance.gbl<Type>s[] array.
			 * Global variables are simply elements of those arrays at runtime, thus we don't need to create
			 * an unique class for each script, we can just use XMRInstance as is for all.
			 */
			foreach (TokenDeclVar declVar in tokenScript.vars) {

				/*
				 * Omit 'constant' variables as they are coded inline so don't need a slot.
				 */
				if (declVar.constant) continue;

				/*
				 * Create entry in the value array for the variable.
				 */
				declVar.location = new CompValuGlobalVar (declVar, scriptObjCode);

				/*
				 * Add its name to top-level variable definition stack frame so code can see it.
				 */
				AddVarDefinition (declVar);

				/*
				 * If it references heap, add it to list of global vars that reference heap.  We use 
				 * this list to maintain instance.heapLeft to keep track of how much heap script is 
				 * allowed to use.  Do not include arrays as they do their own heap tracking.
				 */
				if ((declVar.type is TokenTypeList) ||
				    (declVar.type is TokenTypeStr)) {
					TokenDeclVar htDeclVar = new TokenDeclVar (declVar, null, tokenScript);
					htDeclVar.type = new TokenTypeInt (declVar);
					htDeclVar.name = new TokenName (declVar, "__htg_" + declVar.name.val);
					htDeclVar.location = new CompValuGlobalVar (htDeclVar, scriptObjCode);
					declVar.heapTracker = htDeclVar;
				}
			}

			/*
			 * Likewise for any static fields in script-defined classes.
			 * They do not get added to the VarDefn stack though because they cannot be referenced by their
			 * simple name in general.  They can be referenced anywhere by <typename>.<fieldname>, see 
			 * GenerateFromLValSField().
			 */
			foreach (KeyValuePair<string, TokenDeclSDType> kvpc in tokenScript.sdSrcTypes) {
				TokenDeclSDType sdType = kvpc.Value;
				if (!(sdType is TokenDeclSDTypeClass)) continue;
				TokenDeclSDTypeClass sdtClass = (TokenDeclSDTypeClass)sdType;

				foreach (TokenDeclVar declVar in sdtClass.members) {
					if (declVar.retType != null) continue;  // ignore methods

					/*
					 * Omit 'constant' variables as they are coded inline so don't need a slot.
					 */
					if (declVar.constant) continue;

					/*
					 * Ignore non-static fields for now.
					 * They get assigned below.
					 */
					if ((declVar.sdtFlags & ScriptReduce.SDT_STATIC) == 0) continue;

					/*
					 * Create entry in the value array for the field.
					 */
					declVar.location = new CompValuGlobalVar (declVar, scriptObjCode);

					/*
					 * If it references heap, add it to list of global vars that reference heap.  We use 
					 * this list to maintain instance.heapLeft to keep track of how much heap script is 
					 * allowed to use.  Do not include arrays as they do their own heap tracking.
					 */
					if ((declVar.type is TokenTypeList) ||
					    (declVar.type is TokenTypeStr)) {
						TokenDeclVar htDeclVar = new TokenDeclVar (declVar, null, tokenScript);
						htDeclVar.type = new TokenTypeInt (declVar);
						htDeclVar.name = new TokenName (declVar, "__hts_" + declVar.name.val);
						htDeclVar.location = new CompValuGlobalVar (htDeclVar, scriptObjCode);
						declVar.heapTracker = htDeclVar;
					}
				}
			}

			/*
			 * For all classes that define instance fields with initializers, 
			 * create a ".instancefieldinit.()" instance method that fills them all in.
			 * This method will then be called at the beginning of all constructors
			 * defined for the class.
			 */
			foreach (KeyValuePair<string, TokenDeclSDType> kvpc in tokenScript.sdSrcTypes) {
				TokenDeclSDType sdType = kvpc.Value;
				if (!(sdType is TokenDeclSDTypeClass)) continue;
				TokenDeclSDTypeClass sdtClass = (TokenDeclSDTypeClass)sdType;

				/*
				 * Define an instance function .instancefieldinit.() with no args and a void return value.
				 */
				TokenDeclVar fiFunc = new TokenDeclVar (sdtClass.name, null, tokenScript);
				fiFunc.retType = new TokenTypeVoid (fiFunc);
				fiFunc.funcNameSig = new TokenName (fiFunc, ".instancefieldinit.()");
				fiFunc.sdtClass = sdtClass;

				TokenArgDecl fiArgs = new TokenArgDecl (sdtClass.name);
				fiArgs.types = new TokenType[0];
				fiArgs.names = new TokenName[0];
				fiArgs.locns = new CompValu[0];
				fiFunc.argDecl = fiArgs;

				/*
				 * Start it with an empty statment block { }.
				 */
				TokenStmtBlock fiBody = new TokenStmtBlock (sdtClass.name);
				fiBody.function = fiFunc;
				fiFunc.body = fiBody;

				/*
				 * Scan the class definition for non-constant instance fields with initializers.
				 */
				foreach (TokenDeclVar field in sdtClass.members) {
					if (!field.constant && ((field.sdtFlags & ScriptReduce.SDT_STATIC) == 0) && (field.init != null)) {

						/*
						 * Make up an assignment statement and add it to the statement block.
						 */
						TokenLValIField left = new TokenLValIField (field.init);  // this.field
						left.baseRVal = new TokenRValThis (field.init);
						left.field = field.name;
						TokenKw op = new TokenKwAssign (field.init);              // = initvalue
						TokenRValOpBin rVal = new TokenRValOpBin (left, op, field.init);
						TokenStmtRVal stmt = new TokenStmtRVal (field.init);      // wrap in a statement
						stmt.rVal = rVal;
						stmt.nextToken = fiBody.statements;                       // add to body
						fiBody.statements = stmt;
					}
				}

				/*
				 * If any initializers found, add function definition to class's list of methods.
				 * Otherwise, let function get garbage collected.
				 */
				if (fiBody.statements != null) {
					sdtClass.members.AddEntry (fiFunc);
				}
			}

			/*
			 * Assign slots for all interface method prototypes.
			 * These indices are used to index the array of delegates that holds a class' implementation of an 
			 * interface.
			 */
			foreach (KeyValuePair<string, TokenDeclSDType> kvpc in tokenScript.sdSrcTypes) {
				TokenDeclSDType sdType = kvpc.Value;
				if (!(sdType is TokenDeclSDTypeInterface)) continue;
				TokenDeclSDTypeInterface sdtIFace = (TokenDeclSDTypeInterface)sdType;
				int vti = 0;
				foreach (TokenDeclVar im in sdtIFace.methods) {
					im.vTableIndex = vti ++;
				}
			}

			/*
			 * Assign slots for all instance fields and virtual methods of script-defined types.
			 */
			int maxExtends = tokenScript.sdSrcTypes.Count;
			bool didOne;
			do {
				didOne = false;
				foreach (KeyValuePair<string, TokenDeclSDType> kvpc in tokenScript.sdSrcTypes) {
					TokenDeclSDType sdType = kvpc.Value;
					if (!(sdType is TokenDeclSDTypeClass)) continue;
					TokenDeclSDTypeClass sdtClass = (TokenDeclSDTypeClass)sdType;
					if (sdtClass.slotsAssigned) continue;

					/*
					 * If this class extends another, the extended class has to already 
					 * be set up, because our slots add on to the end of the extended class.
					 */
					TokenDeclSDTypeClass extends = sdtClass.extends;
					if (extends != null) {
						if (!extends.slotsAssigned) continue;
						sdtClass.numInstArrays    = extends.numInstArrays;
						sdtClass.numInstFloats    = extends.numInstFloats;
						sdtClass.numInstIntegers  = extends.numInstIntegers;
						sdtClass.numInstLists     = extends.numInstLists;
						sdtClass.numInstObjects   = extends.numInstObjects;
						sdtClass.numInstRotations = extends.numInstRotations;
						sdtClass.numInstStrings   = extends.numInstStrings;
						sdtClass.numInstVectors   = extends.numInstVectors;
						sdtClass.numInstSDTClObjs = extends.numInstSDTClObjs;
						sdtClass.numVirtFuncs     = extends.numVirtFuncs;
						sdtClass.numInterfaces    = extends.numInterfaces;

						int n = maxExtends;
						for (TokenDeclSDTypeClass ex = extends; ex != null; ex = ex.extends) {
							if (-- n < 0) break;
						}
						if (n < 0) {
							ErrorMsg (sdtClass, "loop in extended classes");
							sdtClass.slotsAssigned = true;
							continue;
						}
					}

					/*
					 * Extended class's slots all assigned, assign our instance fields 
					 * slots in the XMRSDTypeClassInstance arrays.
					 */
					foreach (TokenDeclVar declVar in sdtClass.members) {
						if (declVar.retType != null) continue;
						if (declVar.constant) continue;
						if ((declVar.sdtFlags & ScriptReduce.SDT_STATIC) != 0) continue;
						if ((declVar.getProp == null) && (declVar.setProp == null)) {
							declVar.type.AssignSDTClassFieldSlot (declVar, sdtClass);
						}
						if ((declVar.type is TokenTypeList) ||
						    (declVar.type is TokenTypeStr)) {
							TokenDeclVar htDeclVar = new TokenDeclVar (declVar, null, tokenScript);
							htDeclVar.type = new TokenTypeInt (declVar);
							htDeclVar.name = new TokenName (declVar, "__hti_" + declVar.name.val);
							htDeclVar.type.AssignSDTClassFieldSlot (htDeclVar, sdtClass);
							declVar.heapTracker = htDeclVar;
						}
					}

					/*
					 * ... and assign virtual method vtable slots.
					 *
					 *                   - : error if any overidden method, doesn't need a slot
					 *            abstract : error if any overidden method, alloc new slot but leave it empty
					 *                 new : ignore any overidden method, doesn't need a slot
					 *        new abstract : ignore any overidden method, alloc new slot but leave it empty
					 *            override : must have overidden abstract/virtual, use old slot
					 *   override abstract : must have overidden abstract, use old slot but it is still empty
					 *              static : error if any overidden method, doesn't need a slot
					 *          static new : ignore any overidden method, doesn't need a slot
					 *             virtual : error if any overidden method, alloc new slot and fill it in
					 *         virtual new : ignore any overidden method, alloc new slot and fill it in
					 *    virtual override : must have overidden abstract/virtual, use old slot (same as plain override)
					 */
					foreach (TokenDeclVar declFunc in sdtClass.members) {
						if (declFunc.retType == null) continue;

						/*
						 * See if there is a method in an extended class that this method overshadows.
						 * If so, check for various conflicts.
						 * In any case, SDT_NEW on our method means to ignore any overshadowed method.
						 */
						string name = sdtClass.name.val + "." + declFunc.funcNameSig.val;
						uint declFlags = declFunc.sdtFlags;
						TokenDeclVar overridden = null;
						if ((declFlags & ScriptReduce.SDT_NEW) == 0) {
							for (TokenDeclSDTypeClass sdtd = extends; sdtd != null; sdtd = sdtd.extends) {
								overridden = FindExactWithRet (sdtd.members, declFunc.name, declFunc.retType, declFunc.argDecl.types);
								if (overridden != null) break;
							}
						}
						if (overridden != null) do {
							uint overFlags = overridden.sdtFlags;

							/*
							 * See if overridden method allows itself to be overidden.
							 */
							if ((overFlags & ScriptReduce.SDT_ABSTRACT) != 0) {
								if ((declFlags & (ScriptReduce.SDT_ABSTRACT | ScriptReduce.SDT_OVERRIDE)) == 0) {
									ErrorMsg (declFunc, name + " overshadows abstract " + overridden.sdtClass.name.val + " but is not marked abstract, new or override");
									break;
								}
							} else if ((overFlags & (ScriptReduce.SDT_OVERRIDE | ScriptReduce.SDT_VIRTUAL)) != 0) {
								if ((declFlags & (ScriptReduce.SDT_NEW | ScriptReduce.SDT_OVERRIDE)) == 0) {
									ErrorMsg (declFunc, name + " overshadows virtual " + overridden.sdtClass.name.val + " but is not marked new or override");
									break;
								}
							} else {
								ErrorMsg (declFunc, name + " overshadows non-virtual " + overridden.sdtClass.name.val + " but is not marked new");
								break;
							}

							/*
							 * See if our method is capable of overriding the other method.
							 */
							if ((declFlags & ScriptReduce.SDT_ABSTRACT) != 0) {
								if ((overFlags & ScriptReduce.SDT_ABSTRACT) == 0) {
									ErrorMsg (declFunc, name + " abstract overshadows non-abstract " + overridden.sdtClass.name.val + " but is not marked new");
									break;
								}
							} else if ((declFlags & ScriptReduce.SDT_OVERRIDE) != 0) {
								if ((overFlags & (ScriptReduce.SDT_ABSTRACT | ScriptReduce.SDT_OVERRIDE | ScriptReduce.SDT_VIRTUAL)) == 0) {
									ErrorMsg (declFunc, name + " override overshadows non-abstract/non-virtual " + overridden.sdtClass.name.val);
									break;
								}
							} else {
								ErrorMsg (declFunc, name + " overshadows " + overridden.sdtClass.name.val + " but is not marked new");
								break;
							}
						} while (false);

						/*
						 * Now we can assign it a vtable slot if it needs one (ie, it is virtual).
						 */
						declFunc.vTableIndex = -1;
						if (overridden != null) {
							declFunc.vTableIndex = overridden.vTableIndex;
						} else if ((declFlags & ScriptReduce.SDT_OVERRIDE) != 0) {
							ErrorMsg (declFunc, name + " marked override but nothing matching found that it overrides");
						}
						if ((declFlags & (ScriptReduce.SDT_ABSTRACT | ScriptReduce.SDT_VIRTUAL)) != 0) {
							declFunc.vTableIndex = sdtClass.numVirtFuncs ++;
						}
					}

					/*
					 * ... and assign implemented interface slots.
					 * Note that our implementations of a given interface is completely independent of any 
					 * rootward class's implementation of that same interface.
					 */
					int nIFaces        = sdtClass.numInterfaces + sdtClass.implements.Count;
					sdtClass.iFaces    = new TokenDeclSDTypeInterface[nIFaces];
					sdtClass.iImplFunc = new TokenDeclVar[nIFaces][];
					for (int i = 0; i < sdtClass.numInterfaces; i ++) {
						sdtClass.iFaces[i]    = extends.iFaces[i];
						sdtClass.iImplFunc[i] = extends.iImplFunc[i];
					}

					foreach (TokenDeclSDTypeInterface intf in sdtClass.implements) {
						int i = sdtClass.numInterfaces ++;
						sdtClass.iFaces[i] = intf;
						sdtClass.intfIndices.Add (intf.name.val, i);
						sdtClass.iImplFunc[i] = new TokenDeclVar[intf.methods.Count];
					}

					foreach (TokenDeclVar classMeth in sdtClass.members) {
						for (TokenIntfImpl intfImpl = classMeth.implements; intfImpl != null; intfImpl = (TokenIntfImpl)intfImpl.nextToken) {

							/*
							 * One of the class methods implements an interface method.
							 */
							TokenDeclSDTypeInterface intfType = intfImpl.intfType.decl;
							TokenDeclVar intfMeth = FindExactWithRet (intfType.methods, intfImpl.methName, classMeth.retType, classMeth.argDecl.types);
							if (intfMeth == null) {
								ErrorMsg (intfImpl, "interface does not define method " + intfImpl.methName.val + classMeth.argDecl.GetArgSig ());
								continue;
							}

							/*
							 * See if this class was declared to implement that interface.
							 */
							bool found = false;
							foreach (TokenDeclSDTypeInterface intf in sdtClass.implements) {
								if (intf == intfType) {
									found = true;
									break;
								}
							}
							if (!found) {
								ErrorMsg (intfImpl, "class does not implement " + intfType.name.val);
								continue;
							}

							/*
							 * Get index in iFaces[] and iImplFunc[] arrays.
							 * Start scanning from the end in case one of our rootward classes also implements the interface.
							 * We should always be successful because we know by now that this class implements the interface.
							 */
							int i;
							for (i = sdtClass.numInterfaces; -- i >= 0;) {
								if (sdtClass.iFaces[i] == intfType) break;
							}

							/*
							 * Now remember which of the class methods implements that interface method.
							 */
							int j = intfMeth.vTableIndex;
							if (sdtClass.iImplFunc[i][j] != null) {
								ErrorMsg (intfImpl, "also implemented by " + sdtClass.iImplFunc[i][j].funcNameSig.val);
								continue;
							}
							sdtClass.iImplFunc[i][j] = classMeth;
						}
					}

					/*
					 * Now make sure this class implements all methods for all declared interfaces.
					 */
					for (int i = sdtClass.numInterfaces - sdtClass.implements.Count; i < sdtClass.numInterfaces; i ++) {
						TokenDeclVar[] implementations = sdtClass.iImplFunc[i];
						for (int j = implementations.Length; -- j >= 0;) {
							if (implementations[j] == null) {
								TokenDeclSDTypeInterface intf = sdtClass.iFaces[i];
								TokenDeclVar meth = null;
								foreach (TokenDeclVar im in intf.methods) {
									if (im.vTableIndex == j) {
										meth = im;
										break;
									}
								}
								ErrorMsg (sdtClass, "does not implement " + intf.name.val + "." + meth.funcNameSig.val);
							}
						}
					}

					/*
					 * All slots for this class have been assigned.
					 */
					sdtClass.slotsAssigned = true;
					didOne = true;
				}
			} while (didOne);

			/*
			 * Compute final values for all variables/fields declared as 'constant'.
			 * Note that there may be forward references.
			 */
			do {
				didOne = false;
				foreach (TokenDeclVar tdv in tokenScript.vars) {
					if (tdv.constant && !(tdv.init is TokenRValConst)) {
						tdv.init = tdv.init.TryComputeConstant (LookupInitConstants, ref didOne);
					}
				}
				foreach (KeyValuePair<string, TokenDeclSDType> kvpc in tokenScript.sdSrcTypes) {
					TokenDeclSDType sdType = kvpc.Value;
					if (!(sdType is TokenDeclSDTypeClass)) continue;
					currentSDTClass = (TokenDeclSDTypeClass)sdType;
					foreach (TokenDeclVar tdv in currentSDTClass.members) {
						if (tdv.constant && !(tdv.init is TokenRValConst)) {
							tdv.init = tdv.init.TryComputeConstant (LookupInitConstants, ref didOne);
						}
					}
				}
				currentSDTClass = null;
			} while (didOne);

			/*
			 * Now we should be able to assign all those constants their type and location.
			 */
			foreach (TokenDeclVar tdv in tokenScript.vars) {
				if (tdv.constant) {
					if (tdv.init is TokenRValConst) {
						TokenRValConst rvc = (TokenRValConst)tdv.init;
						tdv.type = rvc.tokType;
						tdv.location = rvc.GetCompValu ();
						AddVarDefinition (tdv);
					} else {
						ErrorMsg (tdv, "value is not constant");
					}
				}
			}
			foreach (KeyValuePair<string, TokenDeclSDType> kvpc in tokenScript.sdSrcTypes) {
				TokenDeclSDType sdType = kvpc.Value;
				if (!(sdType is TokenDeclSDTypeClass)) continue;
				currentSDTClass = (TokenDeclSDTypeClass)sdType;
				foreach (TokenDeclVar tdv in currentSDTClass.members) {
					if (tdv.constant) {
						if (tdv.init is TokenRValConst) {
							TokenRValConst rvc = (TokenRValConst)tdv.init;
							tdv.type = rvc.tokType;
							tdv.location = rvc.GetCompValu ();
						} else {
							ErrorMsg (tdv, "value is not constant");
						}
					}
				}
			}
			currentSDTClass = null;

			/*
			 * For all classes that define all the methods needed for the class, ie, they aren't abstract,
			 * define a static class.new() method with same args as the constructor(s).  This will allow the
			 * class to be instantiated via the new operator.
			 */
			foreach (KeyValuePair<string, TokenDeclSDType> kvpc in tokenScript.sdSrcTypes) {
				TokenDeclSDType sdType = kvpc.Value;
				if (!(sdType is TokenDeclSDTypeClass)) continue;
				TokenDeclSDTypeClass sdtClass = (TokenDeclSDTypeClass)sdType;

				/*
				 * See if the class as it stands would be able to fill every slot of its vtable.
				 */
				bool[] filled = new bool[sdtClass.numVirtFuncs];
				int numFilled = 0;
				for (TokenDeclSDTypeClass sdtc = sdtClass; sdtc != null; sdtc = sdtc.extends) {
					foreach (TokenDeclVar tdf in sdtc.members) {
						if ((tdf.retType != null) && (tdf.vTableIndex >= 0) && ((tdf.sdtFlags & ScriptReduce.SDT_ABSTRACT) == 0)) {
							if (!filled[tdf.vTableIndex]) {
								filled[tdf.vTableIndex] = true;
								numFilled ++;
							}
						}
					}
				}
				sdtClass.isAbstract = (numFilled < sdtClass.numVirtFuncs);

				/*
				 * If so, define a static class.new() method for every constructor defined for the class.
				 * Give it the same access (private/protected/public) as the script declared for the constructor.
				 * Note that the reducer made sure there is at least a default constructor for every class.
				 * We don't give tne function a body here, fortunately GenerateNewobjBody() just knows how 
			 	 * to generate teh code.
				 */
				if (!sdtClass.isAbstract) {
					List<TokenDeclVar> newobjDeclFuncs = new List<TokenDeclVar> ();
					foreach (TokenDeclVar ctorDeclFunc in sdtClass.members) {
						if ((ctorDeclFunc.funcNameSig != null) && ctorDeclFunc.funcNameSig.val.StartsWith ("constructor(")) {
							TokenDeclVar newobjDeclFunc = new TokenDeclVar (ctorDeclFunc, null, tokenScript);
							newobjDeclFunc.retType       = sdtClass.MakeRefToken (newobjDeclFunc);
							newobjDeclFunc.argDecl       = ctorDeclFunc.argDecl;
							string nameSig               = "new" + ctorDeclFunc.argDecl.GetArgSig ();
							newobjDeclFunc.funcNameSig   = new TokenName (newobjDeclFunc, nameSig);
							newobjDeclFunc.sdtClass      = sdtClass;
							newobjDeclFunc.sdtFlags      = ScriptReduce.SDT_STATIC | ctorDeclFunc.sdtFlags;
							newobjDeclFuncs.Add (newobjDeclFunc);
						}
					}
					foreach (TokenDeclVar newobjDeclFunc in newobjDeclFuncs) {
						sdtClass.members.AddEntry (newobjDeclFunc);
					}
				}
			}

			/*
			 * Write fixed portion of object file.
			 */
			objFileWriter.Write (OBJECT_CODE_MAGIC.ToCharArray ());
			objFileWriter.Write (COMPILED_VERSION_VALUE);

			objFileWriter.Write (tokenScript.expiryDays);
			objFileWriter.Write (scriptObjCode.numGblArrays);
			objFileWriter.Write (scriptObjCode.numGblFloats);
			objFileWriter.Write (scriptObjCode.numGblIntegers);
			objFileWriter.Write (scriptObjCode.numGblLists);
			objFileWriter.Write (scriptObjCode.numGblObjects);
			objFileWriter.Write (scriptObjCode.numGblRotations);
			objFileWriter.Write (scriptObjCode.numGblStrings);
			objFileWriter.Write (scriptObjCode.numGblVectors);
			objFileWriter.Write (scriptObjCode.numGblSDTClObjs);

			objFileWriter.Write (nStates);
			for (int i = 0; i < nStates; i ++) {
				objFileWriter.Write (scriptObjCode.stateNames[i]);
			}

			/*
			 * For debugging, we also write out global variable array slot assignments.
			 */
			foreach (TokenDeclVar declVar in tokenScript.vars) {
				WriteOutGblAssignment ("", declVar);
			}
			foreach (KeyValuePair<string, TokenDeclSDType> kvpc in tokenScript.sdSrcTypes) {
				TokenDeclSDType sdType = kvpc.Value;
				if (!(sdType is TokenDeclSDTypeClass)) continue;
				TokenDeclSDTypeClass sdtClass = (TokenDeclSDTypeClass)sdType;
				foreach (TokenDeclVar declVar in sdtClass.members) {
					if ((declVar.sdtFlags & ScriptReduce.SDT_STATIC) != 0) {
						WriteOutGblAssignment (sdtClass.name.val + ".", declVar);
					}
				}
			}
			objFileWriter.Write ("");

			/*
			 * Write out script-defined types.
			 */
			foreach (KeyValuePair<string, TokenDeclSDType> kvp in tokenScript.sdSrcTypes) {
				objFileWriter.Write (kvp.Key);
				kvp.Value.WriteToFile (objFileWriter);
			}
			objFileWriter.Write ("");

			/*
			 * Output function headers then bodies.
			 * Do all headers first in case bodies do forward references.
			 * Do both global functions, script-defined class static methods and 
			 * script-defined instance methods, as we handle the differences
			 * during compilation of the functions/methods themselves.
			 */
			for (int pass = 0; pass < 2; pass ++) {
				foreach (TokenDeclVar declFunc in tokenScript.funcs) {
					if (pass == 0) GenerateMethodHeader (declFunc);
					          else GenerateMethodBody   (declFunc);
				}
				foreach (TokenDeclSDType sdType in tokenScript.sdSrcTypes.Values) {
					if (sdType is TokenDeclSDTypeClass) {
						TokenDeclSDTypeClass sdtClass = (TokenDeclSDTypeClass)sdType;
						if (pass > 0) PushSDTClassFieldsAndMethods (sdtClass);
						foreach (TokenDeclVar declFunc in sdtClass.members) {
							if ((declFunc.retType != null) && ((declFunc.sdtFlags & ScriptReduce.SDT_ABSTRACT) == 0)) {
								if (pass == 0) GenerateMethodHeader (declFunc);
								          else GenerateMethodBody   (declFunc);
							}
						}
						if (pass > 0) PopVarDefnBlock ();
					}
				}
			}

			/*
			 * Output default state event handler functions.
			 * Each event handler is a private static method named __seh_default_<eventname>.
			 * Splice in a default state_entry() handler if none defined so we can init global vars.
			 */
			TokenDeclVar defaultStateEntry = null;
			for (defaultStateEntry = tokenScript.defaultState.body.eventFuncs;
			     defaultStateEntry != null;
			     defaultStateEntry = (TokenDeclVar)defaultStateEntry.nextToken) {
				if (defaultStateEntry.funcNameSig.val == "state_entry()") break;
			}
			if (defaultStateEntry == null) {
				defaultStateEntry               = new TokenDeclVar (tokenScript.defaultState.body, null, tokenScript);
				defaultStateEntry.retType       = new TokenTypeVoid (tokenScript.defaultState.body);
				defaultStateEntry.funcNameSig   = new TokenName     (tokenScript.defaultState.body, "state_entry()");
				defaultStateEntry.argDecl       = new TokenArgDecl  (tokenScript.defaultState.body);
				defaultStateEntry.argDecl.types = new TokenType[0];
				defaultStateEntry.argDecl.names = new TokenName[0];
				defaultStateEntry.argDecl.locns = new CompValu[0];
				defaultStateEntry.body          = new TokenStmtBlock (tokenScript.defaultState.body);
				defaultStateEntry.body.function = defaultStateEntry;

				defaultStateEntry.nextToken = tokenScript.defaultState.body.eventFuncs;
				tokenScript.defaultState.body.eventFuncs = defaultStateEntry;
			}
			GenerateStateEventHandlers ("default", tokenScript.defaultState.body);

			/*
			 * Output script-defined state event handler methods.
			 * Each event handler is a private static method named __seh_<statename>_<eventname>
			 */
			foreach (KeyValuePair<string, TokenDeclState> kvp in tokenScript.states) {
				TokenDeclState declState = kvp.Value;
				GenerateStateEventHandlers (declState.name.val, declState.body);
			}

			ScriptMyILGen.TheEnd (objFileWriter);

			scriptObjCode = null;
		}

		/**
		 * @brief Write out what slot was assigned for a global or sdtclass static variable.
		 *        Constants, functions, instance fields, methods, properties do not have slots in the global variables arrays.
		 */
		private void WriteOutGblAssignment (string pfx, TokenDeclVar declVar)
		{
			if (!declVar.constant && (declVar.retType == null) && (declVar.getProp == null) && (declVar.setProp == null)) {
				CompValuGlobalVar gblVar = (CompValuGlobalVar)declVar.location;
				objFileWriter.Write (pfx + declVar.name.val);    // string
				objFileWriter.Write (declVar.vTableArray.Name);  // string
				objFileWriter.Write (declVar.vTableIndex);       // int
				TokenDeclVar htDeclVar = declVar.heapTracker;
				if (htDeclVar != null) {
					CompValu htGblVar = (CompValuGlobalVar)htDeclVar.location;
					objFileWriter.Write (pfx + htDeclVar.name.val);
					objFileWriter.Write (htDeclVar.vTableArray.Name);
					objFileWriter.Write (htDeclVar.vTableIndex);
				}
			}
		}

		/**
		 * @brief Create a variable definition frame consisting of all the static
		 *        fields and methods of a script-defined class.  This will allow
		 *        those fields and methods to be accessed by their name without
		 *        needing the class name prefix, ie, <name> will work just as well
		 *        as <class>.<name>.  This is used when generating code for the
		 *        methods in the class and any field initializers.
		 *
		 *        Note that we don't enter instance fields and methods, they
		 *        require an explicit 'this.' to reference them.
		 */
		private void PushSDTClassFieldsAndMethods (TokenDeclSDTypeClass sdtClass)
		{
			PushVarDefnBlock ();

			foreach (TokenDeclVar tdv in sdtClass.members) {
				if ((tdv.sdtFlags & ScriptReduce.SDT_STATIC) != 0) {
					AddVarDefinition (tdv);
				}
			}
		}

		/**
		 * @brief generate event handler code
		 * Writes out a function definition for each state handler
		 * named __seh_<statename>_<eventname>
		 *
		 * However, each has just 'XMRInstance __sw' as its single argument
		 * and each of its user-visible argments is extracted from __sw.ehArgs[].
		 *
		 * So we end up generating something like this:
		 *
		 *   private static void __seh_<statecode>_<eventcode>_<statename>_<eventname>(XMRInstance __sw)
		 *   {
		 *      <typeArg0> <nameArg0> = (<typeArg0>)__sw.ehArgs[0];
		 *      <typeArg1> <nameArg1> = (<typeArg1>)__sw.ehArgs[1];
		 *
		 *      ... script code ...
		 *   }
		 *
		 * The continuations code assumes there will be no references to ehArgs[]
		 * after the first call to CheckRun() as CheckRun() makes no attempt to
		 * serialize the ehArgs[] array, as doing so would be redundant.  Any values
		 * from ehArgs[] that are being used will be in local stack variables and
		 * thus preserved that way.
		 */
		private void GenerateStateEventHandlers (string statename, TokenStateBody body)
		{
			for (Token t = body.eventFuncs; t != null; t = t.nextToken) {
				GenerateEventHandler (statename, (TokenDeclVar)t);
			}
		}

		private void GenerateEventHandler (string statename, TokenDeclVar declFunc)
		{
			string eventname = declFunc.GetSimpleName ();
			TokenArgDecl argDecl = declFunc.argDecl;
			int nargs = argDecl.types.Length;

			/*
			 * Make sure event handler name is valid and that number and type of arguments is correct.
			 * Apparently some scripts exist with fewer than correct number of args in their declaration 
			 * so allow for that.  It is ok because the handlers are called with the arguments in an
			 * object[] array, and we just won't access the missing argments in the vector.  But the 
			 * specified types must match one of the prototypes in legalEventHandlers.
			 */
			TokenDeclVar protoDeclFunc = legalEventHandlers.FindExact (eventname, argDecl.types);
			if (protoDeclFunc == null) {
				ErrorMsg (declFunc, "unknown event handler " + eventname + argDecl.GetArgSig ());
				return;
			}

			/*
			 * Output function header.
			 * They just have the XMRInstance pointer as the one argument.
			 */
			int statecode = stateIndices[statename];
			int eventcode = (int)Enum.Parse (typeof (ScriptEventCode), eventname);
			string functionName = "__seh_" + statecode.ToString() + "_" + eventcode.ToString () + "_" + 
			                                 statename + "_" + eventname;
			ilGen = new ScriptMyILGen (tokenScript.sdSrcTypes, 
			                           functionName,
			                           typeof (void),
			                           instanceTypeArg,
			                           objFileWriter);
			StartFunctionBody (declFunc);

			/*
			 * Output args as variable definitions and initialize each from __sw.ehArgs[].
			 * If the script writer goofed, the typecast will complain.
			 */
			if (nargs > 0) {
				ScriptMyLocal swehArgs = ilGen.DeclareLocal (typeof (object[]), "ehArgs");

				PushXMRInst ();                 // instance
				ilGen.Emit (OpCodes.Ldfld, ehArgsFieldInfo);  // instance.ehArgs
				ilGen.Emit (OpCodes.Stloc, swehArgs);

				for (int i = 0; i < nargs; i ++) {

					// <argtype> __lcl_<argname> = (<argtype>)__sw.ehArgs[i];
					TokenType argTokType = argDecl.types[i];
					Type argSysType = argTokType.ToSysType ();
					CompValu local = new CompValuTemp (argTokType, argDecl.names[i].val, this);
					argDecl.locns[i] = local;
					local.PopPre (this);
					ilGen.Emit (OpCodes.Ldloc, swehArgs);          // __sw.ehArgs
					PushConstantI4 (i);                            // array index = i
					ilGen.Emit (OpCodes.Ldelem, typeof (object));  // it is an array of objects
					TokenType stkTokType = tokenTypeObj;           // stack has a type 'object' on it now
					if (argSysType == typeof (SCRIPTFLOAT)) {      // LSL_Float/SCRIPTFLOAT -> SCRIPTFLOAT
						ilGen.Emit (OpCodes.Call, ehArgUnwrapFloat);
						stkTokType = tokenTypeFlt;             // stack has a type 'SCRIPTFLOAT' on it now
					}
					if (argSysType == typeof (int)) {              // LSL_Integer/int -> int
						ilGen.Emit (OpCodes.Call, ehArgUnwrapInteger);
						stkTokType = tokenTypeInt;             // stack has a type 'int' on it now
					}
					if (argSysType == typeof (LSL_Rotation)) {     // OpenMetaverse.Quaternion/LSL_Rotation -> LSL_Rotation
						ilGen.Emit (OpCodes.Call, ehArgUnwrapRotation);
						stkTokType = tokenTypeRot;             // stack has a type 'LSL_Rotation' on it now
					}
					if (argSysType == typeof (string)) {           // LSL_Key/LSL_String/string -> string
						ilGen.Emit (OpCodes.Call, ehArgUnwrapString);
						stkTokType = tokenTypeStr;             // stack has a type 'string' on it now
					}
					if (argSysType == typeof (LSL_Vector)) {       // OpenMetaverse.Vector3/LSL_Vector -> LSL_Vector
						ilGen.Emit (OpCodes.Call, ehArgUnwrapVector);
						stkTokType = tokenTypeVec;             // stack has a type 'LSL_Vector' on it now
					}
					local.PopPost (this, stkTokType);              // pop stack type into argtype

					/*
					 * Make it look like a local variable.
					 */
					TokenDeclVar argVar = new TokenDeclVar (argDecl.names[i], null, tokenScript);
					argVar.type = argDecl.types[i];
					argVar.name = argDecl.names[i];
					argVar.location = local;

					/*
					 * Account for any heap usage by this local variable from now on to end of function.
					 */
					NewLocalVariable (argVar);

					/*
					 * The argument is now defined as a local variable accessible to the function body.
					 */
					AddVarDefinition (argVar);
				}
			}

			/*
			 * Output code for the statements and clean up.
			 */
			GenerateFuncBody ();
		}

		/**
		 * @brief generate header for an arbitrary script-defined global function.
		 * @param declFunc = function being defined
		 */
		private void GenerateMethodHeader (TokenDeclVar declFunc)
		{
			curDeclFunc = declFunc;

			/*
			 * Make up array of all argument types as seen by the code generator.
			 * We splice in XMRInstance or XMRSDTypeClassInstance for the first 
			 * arg as the function itself is static, followed by script-visible
			 * arg types.
			 */
			TokenArgDecl argDecl = declFunc.argDecl;
			Type[] argTypes = new Type[argDecl.types.Length+1];
			if (IsSDTInstMethod ()) {
				argTypes[0] = typeof (XMRSDTypeClassInstance);
			} else {
				argTypes[0] = typeof (XMRInstAbstract);
			}
			for (int i = 0; i < argDecl.types.Length; i ++) {
				argTypes[i+1] = argDecl.types[i].ToSysType ();
			}

			/*
			 * Set up entrypoint.
			 * Prefix the names with __fun_ to keep them separate from any XMRInstance functions.
			 */
			string objCodeName = declFunc.GetObjCodeName ();
			declFunc.ilGen = new ScriptMyILGen (tokenScript.sdSrcTypes, 
			                                    objCodeName,
			                                    declFunc.retType.ToSysType (),
			                                    argTypes,
			                                    objFileWriter);

			/*
			 * This says how to generate a call to the function and to get a delegate.
			 */
			declFunc.location = new CompValuGlobalMeth (declFunc);

			/*
			 * For script-global functions, make it a global variable so GenerateFromLValName() will see it,
			 * using the name <functionname>(<argsig>).
			 */
			if (declFunc.sdtClass == null) {
				AddVarDefinition (declFunc);
			}

			curDeclFunc = null;
		}

		/**
		 * @brief generate code for an arbitrary script-defined function.
		 * @param name = name of the function
		 * @param argDecl = argument declarations
		 * @param body = function's code body
		 */
		private void GenerateMethodBody (TokenDeclVar declFunc)
		{
			/*
			 * Now for some craziness...
			 * Script-defined types create static methods called 'new' that are supposed to create a new instance 
			 * of the type.  But it generates special code, so we just pump it out here.
			 */
			if (declFunc.funcNameSig.val.StartsWith ("new(") && (declFunc.sdtClass != null)) {
				GenerateNewobjBody (declFunc);
				return;
			}

			/*
			 * Set up code generator for the function's contents.
			 */
			ilGen = declFunc.ilGen;
			StartFunctionBody (declFunc);

			/*
			 * Define all arguments as named variables so script body can reference them.
			 * The argument indices need to have +1 added to them because XMRInstance or XMRSDTypeClassInstance 
			 * is spliced in at arg 0.  Account for their heap usage just like they were local variables.
			 */
			TokenArgDecl argDecl = declFunc.argDecl;
			int nargs = argDecl.types.Length;
			for (int i = 0; i < nargs; i ++) {
				CompValu arg = new CompValuArg (argDecl.types[i], i + 1);
				argDecl.locns[i] = arg;
				TokenDeclVar argVar = new TokenDeclVar (argDecl.names[i], null, tokenScript);
				argVar.type = argDecl.types[i];
				argVar.name = argDecl.names[i];
				argVar.location = arg;
				NewLocalVariable (argVar);
				AddVarDefinition (argVar);
			}

			/*
			 * Output code for the statements and clean up.
			 */
			GenerateFuncBody ();
		}

		private void StartFunctionBody (TokenDeclVar declFunc)
		{
			/*
			 * Start current function being processed.
			 * Set 'mightGetHere' as the code at the top is always executed.
			 */
			mightGetHere = true;
			curBreakTarg = null;
			curContTarg  = null;
			curDeclFunc  = declFunc;

			/*
			 * Any vars defined by function, including its args, go in their own var block.
			 */
			PushVarDefnBlock ();

			/*
			 * Start generating code.
			 */
			ilGen.BegMethod ();
		}

		/**
		 * @brief Generate code for a script-define type's <typename>.new(<argsig>) method.
		 *        It is used to malloc the object and initialize it.
		 *        It is defined as a script-defined type static method, so the object level
		 *        method gets the XMRInstance pointer passed as arg 0, and the method is 
		 *        supposed to return the allocated and constructed XMRSDTypeClassInstance
		 *        object pointer.
		 */
		private void GenerateNewobjBody (TokenDeclVar newobjFunc)
		{
			ScriptMyILGen ilGen = newobjFunc.ilGen;
			ilGen.BegMethod ();

			/*
			 * First off, malloc a new empty XMRSDTypeClassInstance object
			 * then call the XMRSDTypeClassInstance()-level constructor.
			 */
			ilGen.Emit (OpCodes.Ldarg_0);
			ilGen.Emit (OpCodes.Ldstr, newobjFunc.sdtClass.name.val);
			ilGen.Emit (OpCodes.Newobj, sdtClassConstructorInfo);

			/*
			 * Now call the script-level constructor.
			 * It is compiled as an instance method so its arg 0 = pointer to the XMRSDTypeClassInstance object.
			 * The rest of the args are the script-visible args and are just copied from new newobj call.
			 */
			ilGen.Emit (OpCodes.Dup);
			int nArgs = newobjFunc.argDecl.names.Length;
			for (int i = 0; i < nArgs; i ++) {
				ilGen.Emit (OpCodes.Ldarg, i + 1);
			}
			TokenDeclVar ctorFunc = newobjFunc.sdtClass.members.FindExact ("constructor", newobjFunc.argDecl.types);
			ilGen.Emit (OpCodes.Call, ctorFunc.ilGen);

			/*
			 * The return value should be on the stack still (pointer to the XMRSDTypeClassInstance object).
			 */
			ilGen.Emit (OpCodes.Ret);
			ilGen.EndMethod ();
		}

		/**
		 * @brief Output function body (either event handler or script-defined method).
		 */
		private void GenerateFuncBody ()
		{
			/*
			 * Clear list of all call labels.
			 * A call label is inserted just before every call that can possibly
			 * call CheckRun(), including any direct calls to CheckRun().
			 * Then, when restoring stack, we can just switch to this label to
			 * resume at the correct spot.
			 */
			allCallLabels.Clear ();

			/*
			 * Clear list of active CompValuTemps.
			 */
			activeTemps.Clear ();

			/*
			 * Any return statements inside function body jump to this label
			 * after putting return value in __retval.
			 */
			retLabel = ilGen.DefineLabel ("__retlbl");
			retValue = null;
			if (!(curDeclFunc.retType is TokenTypeVoid)) {
				retValue = ilGen.DeclareLocal (curDeclFunc.retType.ToSysType (), "__retval");
			}

			/*
			 * Output:
			 *    int callNo;
			 *    if (instance.callMode != CALLMODE_NORMAL) goto __cmRestore;
			 */
			callNo = ilGen.DeclareLocal (typeof (int), "__callNo");
			ScriptMyLabel cmRestore = ilGen.DefineLabel ("__cmRestore");
			PushXMRInst ();
			if (XMRInstAbstract.CALLMODE_NORMAL != 0) throw new Exception ();
			ilGen.Emit (OpCodes.Ldfld, ScriptCodeGen.callModeFieldInfo);
			ilGen.Emit (OpCodes.Brtrue, cmRestore);

			/*
			 * Catch exceptions thrown by script body and any initialization code.
			 */
			ilGen.BeginExceptionBlock ();

			/*
			 * If this is the default state_entry() handler, output code to set all global
			 * variables to their initial values.  Note that every script must have a
			 * default state_entry() handler, we provide one if the script doesn't explicitly
			 * define one.
			 */
			string methname = ilGen.methName;
			if (methname.StartsWith ("__seh_") && methname.EndsWith ("_default_state_entry")) {

				// if (!doGblInit) goto skipGblInit;
				ScriptMyLabel skipGblInitLabel = ilGen.DefineLabel ("__skipGblInit");
				PushXMRInst ();                                  // instance
				ilGen.Emit (OpCodes.Ldfld, doGblInitFieldInfo);  // instance.doGblInit
				ilGen.Emit (OpCodes.Brfalse, skipGblInitLabel);

				// heapLeft = heapLimit
				PushXMRInst ();                                  // instance
				ilGen.Emit (OpCodes.Dup);
				ilGen.Emit (OpCodes.Ldfld, heapLimitFieldInfo);  // instance.heapLimit
				ilGen.Emit (OpCodes.Stfld, heapLeftFieldInfo);   // instance.heapLeft

				// init real global variables
				foreach (TokenDeclVar v in tokenScript.vars) {
					InitStaticVar (v);
				}

				// init script-defined class static fields
				foreach (KeyValuePair<string, TokenDeclSDType> kvpc in tokenScript.sdSrcTypes) {
					TokenDeclSDType sdType = kvpc.Value;
					if (!(sdType is TokenDeclSDTypeClass)) continue;
					TokenDeclSDTypeClass sdtClass = (TokenDeclSDTypeClass)sdType;
					foreach (TokenDeclVar declVar in sdtClass.members) {
						if ((declVar.retType == null) && ((declVar.sdtFlags & ScriptReduce.SDT_STATIC) != 0)) {
							InitStaticVar (declVar);
						}
					}
				}

				// doGblInit = 0;
				PushXMRInst ();                                  // instance
				PushConstantI4 (0);
				ilGen.Emit (OpCodes.Stfld, doGblInitFieldInfo);  // instance.doGblInit

				//skipGblInit:
				ilGen.MarkLabel (skipGblInitLabel);
			}

			/*
			 * If this is a script-defined type constructor, call the base constructor and call
			 * this class's .instancefieldinit.() method.
			 */
			if ((curDeclFunc.sdtClass != null) && curDeclFunc.funcNameSig.val.StartsWith ("constructor(")) {
				if (curDeclFunc.baseCtorCall != null) {
					GenerateFromRValCall (curDeclFunc.baseCtorCall);
				}
				TokenDeclVar ifim = curDeclFunc.sdtClass.members.FindExact (".instancefieldinit.", zeroArgs);
				if (ifim != null) {
					new CallLabel (this);
					ilGen.Emit (OpCodes.Ldarg_0);
					ilGen.Emit (OpCodes.Call, ifim.ilGen);
				}
			}

			/*
			 * Alloc stack space for local vars.
			 * Also allocates corresponding heap-tracker vars.
			 */
			AllocLocalVarStackSpace ();

			/*
			 * See if time to suspend in case they are doing a loop with recursion.
			 */
			EmitCallCheckRun (curDeclFunc.line);

			/*
			 * Output code body.
			 */
			GenerateStmtBlock (curDeclFunc.body);

			/*
			 * If code falls through to this point, means they are missing 
			 * a return statement.  And that is legal only if the function 
			 * returns 'void'.
			 */
			if (mightGetHere) {
				if (!(curDeclFunc.retType is TokenTypeVoid)) {
					ErrorMsg (curDeclFunc.body, "missing final return statement");
				}
				ilGen.Emit (OpCodes.Leave, retLabel);
			}

			/*
			 * Output epilog that subtracts heap usage by local vars.
			 *
			 *   finally {
			 *      if (instance.callMode ! 0) goto __cmSave;
			 *      CreditAllLocalsHeapLeft();
			 *      goto __endFin;
			 *   __cmSave:
			 *      GenerateFrameCaptureCode();
			 *   __endFin:
			 *   }
			 */
			ilGen.BeginFinallyBlock ();
			ScriptMyLabel cmSave = ilGen.DefineLabel ("__cmSave");
			ScriptMyLabel endFin = ilGen.DefineLabel ("__endFin");
			PushXMRInst ();
			ilGen.Emit (OpCodes.Ldfld, callModeFieldInfo);
			if (XMRInstAbstract.CALLMODE_NORMAL != 0) throw new Exception ();
			ilGen.Emit (OpCodes.Brtrue, cmSave);
			CreditAllLocalsHeapLeft ();
			ilGen.Emit (OpCodes.Br, endFin);
			ilGen.MarkLabel (cmSave);
			GenerateFrameCaptureCode ();
			ilGen.MarkLabel (endFin);
			ilGen.Emit (OpCodes.Endfinally);
			ilGen.EndExceptionBlock ();

			/*
			 * Output the 'real' return opcode.
			 */
			ilGen.MarkLabel (retLabel);
			if (!(curDeclFunc.retType is TokenTypeVoid)) {
				ilGen.Emit (OpCodes.Ldloc, retValue);
			}
			ilGen.Emit (OpCodes.Ret);
			retLabel = null;
			retValue = null;

			/*
			 * Output code to restore stack frame from stream.
			 */
			ilGen.MarkLabel (cmRestore);
			GenerateFrameRestoreCode ();

			/*
			 * No more instructions for this method.
			 */
			ilGen.EndMethod ();
			ilGen = null;

			/*
			 * Pop off the top-level local definition block.
			 */
			PopVarDefnBlock ();

			/*
			 * Not generating function code any more.
			 */
			curBreakTarg = null;
			curContTarg  = null;
			curDeclFunc  = null;
		}

		/**
		 * @brief Output code to initialize a global variable or script-defined class static field.
		 */
		private void InitStaticVar (TokenDeclVar declVar)
		{
			if (!declVar.constant) {
				CompValu loc = declVar.location;
				loc.PopPre (this);
				if (declVar.init != null) {
					CompValu rVal = GenerateFromRVal (declVar.init, loc.GetArgTypes ());
					rVal.PushVal (this, declVar.type);
				} else {
					PushVarDefaultValue (declVar);
				}
				loc.PopPost (this);
				DebitHeapLeft (declVar, false, declVar);
			}
		}

		/**
		 * @brief Allocate stack space and heap tracker for all local variables, regardless of
		 *        which { } statement block they are actually defined in.  This will allow the
		 *        heap trackers to keep track of any heap use within deeply nested blocks.
		 *
		 * We don't add it to the var definition stack as we don't want it to be visible
		 * until the script says the variable is declared.
		 */
		private void AllocLocalVarStackSpace ()
		{
			foreach (TokenDeclVar localVar in curDeclFunc.localVars) {

				/*
				 * Skip all 'constant' vars as they were handled by the reducer.
				 */
				if (localVar.constant) continue;

				/*
				 * Get a stack location for it and fill in with default value.
				 */
				CompValu localLoc = new CompValuTemp (localVar.type, localVar.name.val, this);
				localVar.location = localLoc;
				localLoc.PopPre (this);
				PushVarDefaultValue (localVar);
				localLoc.PopPost (this);

				/*
				 * Set up heap-tracker variable and fill in with corresponding value for 
				 * the variable's default value.
				 */
				NewLocalVariable (localVar);
			}
		}

		/**
		 * @brief Generate code to write all arguments and locals to the capture stack frame.
		 *        This includes heap-tracker and temp variables.
		 */
		private void GenerateFrameCaptureCode ()
		{
			int nSaves = curDeclFunc.argDecl.locns.Length + curDeclFunc.localVars.Count + activeTemps.Count;

			/*
			 * Output code to allocate a stack frame object with an object array.
			 * This also pushes the stack frame object on the instance.stackFrames list.
			 * It returns a pointer to the object array it allocated.
			 */
			PushXMRInst ();
			ilGen.Emit (OpCodes.Ldstr, ilGen.methName);
			ilGen.Emit (OpCodes.Ldloc, callNo);
			PushConstantI4 (nSaves);
			ilGen.Emit (OpCodes.Call, captureStackFrameMethodInfo);

			/*
			 * Copy arg values to object array, boxing as needed.
			 */
			int i = 0;
			foreach (CompValu argLoc in curDeclFunc.argDecl.locns) {
				ilGen.Emit (OpCodes.Dup);
				PushConstantI4 (i ++);
				argLoc.PushVal (this, tokenTypeObj);
				ilGen.Emit (OpCodes.Stelem_Ref);
			}

			/*
			 * Copy local values to object array, boxing as needed.
			 */
			foreach (TokenDeclVar localVar in curDeclFunc.localVars) {
				ilGen.Emit (OpCodes.Dup);
				PushConstantI4 (i ++);
				CompValu localLoc = localVar.location;
				localLoc.PushVal (this, tokenTypeObj);
				ilGen.Emit (OpCodes.Stelem_Ref);
			}

			/*
			 * Copy temp values to object array, boxing as needed.
			 */
			foreach (CompValu temp in activeTemps) {
				ilGen.Emit (OpCodes.Dup);
				PushConstantI4 (i ++);
				temp.PushVal (this, tokenTypeObj);
				ilGen.Emit (OpCodes.Stelem_Ref);
			}

			ilGen.Emit (OpCodes.Pop);
		}

		/**
		 * @brief Generate code to restore all arguments and locals from the restore stack frame.
		 *        This includes heap-tracker and temp variables.
		 */
		private void GenerateFrameRestoreCode ()
		{
			ScriptMyLocal objArray = ilGen.DeclareLocal (typeof (object[]), "__restObjArray");

			/*
			 * Output code to pop stack frame from instance.stackFrames.
			 * It returns a pointer to the object array that contains values to be restored.
			 */
			PushXMRInst ();
			ilGen.Emit (OpCodes.Ldstr, ilGen.methName);
			ilGen.Emit (OpCodes.Ldloca, callNo);
			ilGen.Emit (OpCodes.Call, restoreStackFrameMethodInfo);
			ilGen.Emit (OpCodes.Stloc, objArray);

			/*
			 * Restore argument values from object array, unboxing as needed.
			 * Although the caller has restored them to what it called us with, it's possible that this 
			 * function has modified them since, so we need to do our own restore.
			 */
			int i = 0;
			foreach (CompValu argLoc in curDeclFunc.argDecl.locns) {
				argLoc.PopPre (this);
				ilGen.Emit (OpCodes.Ldloc, objArray);
				PushConstantI4 (i ++);
				ilGen.Emit (OpCodes.Ldelem_Ref);
				TypeCast.CastTopOfStack (this, tokenTypeObj, argLoc.type, true);
				argLoc.PopPost (this);
			}

			/*
			 * Restore local values from object array, unboxing as needed.
			 */
			foreach (TokenDeclVar localVar in curDeclFunc.localVars) {
				CompValu localLoc = localVar.location;
				localLoc.PopPre (this);
				ilGen.Emit (OpCodes.Ldloc, objArray);
				PushConstantI4 (i ++);
				ilGen.Emit (OpCodes.Ldelem_Ref);
				TypeCast.CastTopOfStack (this, tokenTypeObj, localVar.type, true);
				localLoc.PopPost (this);
			}

			/*
			 * Restore temp values from object array, unboxing as needed.
			 */
			foreach (CompValu temp in activeTemps) {
				temp.PopPre (this);
				ilGen.Emit (OpCodes.Ldloc, objArray);
				PushConstantI4 (i ++);
				ilGen.Emit (OpCodes.Ldelem_Ref);
				TypeCast.CastTopOfStack (this, tokenTypeObj, temp.type, true);
				temp.PopPost (this);
			}

			/*
			 * Output a switch statement with a case for each possible value of callNo.
			 *
			 *   switch (callNo) {
			 *      case 0: goto __call_0;
			 *      case 1: goto __call_1;
			 *      ...
			 *   }
			 *   throw new ScriptBadCallNoException (callNo);
			 */
			ScriptMyLabel[] callLabels = new ScriptMyLabel[allCallLabels.Count];
			foreach (CallLabel cl in allCallLabels) {
				callLabels[cl.index] = cl.callLabel;
			}
			ilGen.Emit (OpCodes.Ldloc, callNo);
			ilGen.Emit (OpCodes.Switch, callLabels);

			ilGen.Emit (OpCodes.Ldloc, callNo);
			ilGen.Emit (OpCodes.Newobj, scriptBadCallNoExceptionConstructorInfo);
			ilGen.Emit (OpCodes.Throw);
		}

		/**
		 * @brief There is one of these per call that can possibly call CheckRun(),
		 *        including direct calls to CheckRun().
		 */
		private class CallLabel {
			public int           index;       // sequential integer, starting at 0
			public ScriptMyLabel callLabel;   // the actual label token

			public CallLabel (ScriptCodeGen scg)
			{
				this.index = scg.allCallLabels.Count;
				scg.allCallLabels.AddLast (this);
				this.callLabel = scg.ilGen.DefineLabel ("__call_" + index);
				scg.PushConstantI4(this.index);
				scg.ilGen.Emit (OpCodes.Stloc, scg.callNo);
				scg.ilGen.MarkLabel (this.callLabel);
			}
		};

		/**
		 * @brief generate code for an arbitrary statement.
		 */
		private void GenerateStmt (TokenStmt stmt)
		{
			errorMessageToken = stmt;
			if (stmt is TokenStmtBlock)   { GenerateStmtBlock   ((TokenStmtBlock)stmt);   return; }
			if (stmt is TokenStmtBreak)   { GenerateStmtBreak   ((TokenStmtBreak)stmt);   return; }
			if (stmt is TokenStmtCont)    { GenerateStmtCont    ((TokenStmtCont)stmt);    return; }
			if (stmt is TokenStmtDo)      { GenerateStmtDo      ((TokenStmtDo)stmt);      return; }
			if (stmt is TokenStmtFor)     { GenerateStmtFor     ((TokenStmtFor)stmt);     return; }
			if (stmt is TokenStmtForEach) { GenerateStmtForEach ((TokenStmtForEach)stmt); return; }
			if (stmt is TokenStmtIf)      { GenerateStmtIf      ((TokenStmtIf)stmt);      return; }
			if (stmt is TokenStmtJump)    { GenerateStmtJump    ((TokenStmtJump)stmt);    return; }
			if (stmt is TokenStmtLabel)   { GenerateStmtLabel   ((TokenStmtLabel)stmt);   return; }
			if (stmt is TokenStmtNull)    {                                               return; }
			if (stmt is TokenStmtRet)     { GenerateStmtRet     ((TokenStmtRet)stmt);     return; }
			if (stmt is TokenStmtRVal)    { GenerateStmtRVal    ((TokenStmtRVal)stmt);    return; }
			if (stmt is TokenStmtState)   { GenerateStmtState   ((TokenStmtState)stmt);   return; }
			if (stmt is TokenStmtSwitch)  { GenerateStmtSwitch  ((TokenStmtSwitch)stmt);  return; }
			if (stmt is TokenStmtThrow)   { GenerateStmtThrow   ((TokenStmtThrow)stmt);   return; }
			if (stmt is TokenStmtTry)     { GenerateStmtTry     ((TokenStmtTry)stmt);     return; }
			if (stmt is TokenStmtWhile)   { GenerateStmtWhile   ((TokenStmtWhile)stmt);   return; }
			throw new Exception ("unknown TokenStmt type " + stmt.GetType ().ToString ());
		}

		/**
		 * @brief generate statement block (ie, with braces)
		 */
		private void GenerateStmtBlock (TokenStmtBlock stmtBlock)
		{
			if (!mightGetHere) return;

			/*
			 * Start a new variable defintion block.
			 */
			PushVarDefnBlock ();

			/*
			 * Push new current statement block pointer for anyone who cares.
			 */
			TokenStmtBlock oldStmtBlock = curStmtBlock;
			curStmtBlock = stmtBlock;

			/*
			 * Output the statements that make up the block.
			 */
			for (Token t = stmtBlock.statements; t != null; t = t.nextToken) {
				if (t is TokenStmt) {
					GenerateStmt ((TokenStmt)t);
				} else {
					GenerateDeclVar ((TokenDeclVar)t);
				}
			}

			/*
			 * Pop the current statement block.
			 */
			curStmtBlock = oldStmtBlock;

			/*
			 * Pop the local var definition stack.
			 */
			PopVarDefnBlock ();
		}

		/**
		 * @brief output code for a 'break' statement
		 */
		private void GenerateStmtBreak (TokenStmtBreak breakStmt)
		{
			if (!mightGetHere) return;

			/*
			 * Make sure we are in a breakable situation.
			 */
			if (curBreakTarg == null) {
				ErrorMsg (breakStmt, "not in a breakable situation");
				return;
			}

			/*
			 * Output the goto instruction.
			 */
			ilGen.Emit (OpCodes.Br, curBreakTarg.label);

			/*
			 * Tell anyone who cares that the break target was actually used.
			 */
			curBreakTarg.used = true;

			/*
			 * 'break' statements never fall through.
			 */
			mightGetHere = false;
		}

		/**
		 * @brief output code for a 'continue' statement
		 */
		private void GenerateStmtCont (TokenStmtCont contStmt)
		{
			if (!mightGetHere) return;

			/*
			 * Make sure we are in a contable situation.
			 */
			if (curContTarg == null) {
				ErrorMsg (contStmt, "not in a continueable situation");
				return;
			}

			/*
			 * Output the goto instruction.
			 */
			ilGen.Emit (OpCodes.Br, curContTarg.label);

			/*
			 * Tell anyone who cares that the continue target was actually used.
			 */
			curContTarg.used = true;

			/*
			 * 'continue' statements never fall through.
			 */
			mightGetHere = false;
		}

		/**
		 * @brief output code for a 'do' statement
		 */
		private void GenerateStmtDo (TokenStmtDo doStmt)
		{
			if (!mightGetHere) return;

			BreakContTarg oldBreakTarg = curBreakTarg;
			BreakContTarg oldContTarg  = curContTarg;
			ScriptMyLabel loopLabel    = ilGen.DefineLabel ("doloop_" + doStmt.Unique);

			curBreakTarg = new BreakContTarg (ilGen, "dobreak_" + doStmt.Unique);
			curContTarg  = new BreakContTarg (ilGen, "docont_"  + doStmt.Unique);

			ilGen.MarkLabel (loopLabel);
			GenerateStmt (doStmt.bodyStmt);
			if (curContTarg.used) {
				ilGen.MarkLabel (curContTarg.label);
				mightGetHere = true;
			}

			if (mightGetHere) {
				EmitCallCheckRun (doStmt.line);
				if (IsConstBoolExprTrue (doStmt.testRVal)) {

					/*
					 * Unconditional looping, don't bother with the test
					 * and say we never fall through to next statement.
					 */
					ilGen.Emit (OpCodes.Br, loopLabel);
					mightGetHere = false;
				} else {

					/*
					 * Conditional looping, output test and brach back to top of loop.
					 */
					CompValu testRVal = GenerateFromRVal (doStmt.testRVal);
					testRVal.PushVal (this, tokenTypeBool);
					ilGen.Emit (OpCodes.Brtrue, loopLabel);
				}
			}

			/*
			 * If 'break' statement was used, output target label.
			 * And assume that since a 'break' statement was used, it's possible for the code to get here.
			 */
			if (curBreakTarg.used) {
				ilGen.MarkLabel (curBreakTarg.label);
				mightGetHere = true;
			}

			curBreakTarg = oldBreakTarg;
			curContTarg  = oldContTarg;
		}

		/**
		 * @brief output code for a 'for' statement
		 * Must use labels and if/goto's instead of braces as the test expression may generate temp 
		 * assignment statements and then we can't cram all the temp assignment statments in a real
		 * for statement.
		 */
		private void GenerateStmtFor (TokenStmtFor forStmt)
		{
			if (!mightGetHere) return;

			BreakContTarg oldBreakTarg = curBreakTarg;
			BreakContTarg oldContTarg  = curContTarg;
			ScriptMyLabel loopLabel    = ilGen.DefineLabel ("forloop_" + forStmt.Unique);

			curBreakTarg = new BreakContTarg (ilGen, "forbreak_" + forStmt.Unique);
			curContTarg  = new BreakContTarg (ilGen, "forcont_"  + forStmt.Unique);

			if (forStmt.initStmt != null) {
				GenerateStmt (forStmt.initStmt);
			}
			ilGen.MarkLabel (loopLabel);

			/*
			 * See if we have a test expression that is other than a constant TRUE.
			 */
			if ((forStmt.testRVal != null) && !IsConstBoolExprTrue (forStmt.testRVal)) {
				CompValu testRVal = GenerateFromRVal (forStmt.testRVal);
				testRVal.PushVal (this, tokenTypeBool);
				ilGen.Emit (OpCodes.Brfalse, curBreakTarg.label);
				curBreakTarg.used = true;
			}

			/*
			 * Output loop body.
			 */
			GenerateStmt (forStmt.bodyStmt);

			/*
			 * Here's where a 'continue' statement jumps to.
			 */
			if (curContTarg.used) {
				ilGen.MarkLabel (curContTarg.label);
				mightGetHere = true;
			}

			if (mightGetHere) {

				/*
				 * After checking for excessive CPU time, output increment statement, if any.
				 */
				EmitCallCheckRun (forStmt.line);
				if (forStmt.incrRVal != null) {
					GenerateFromRVal (forStmt.incrRVal);
				}

				/*
				 * Unconditional branch back to beginning of loop.
				 */
				ilGen.Emit (OpCodes.Br, loopLabel);
			}

			/*
			 * If test needs label, output label for it to jump to.
			 * Otherwise, clear mightGetHere as we know loop never
			 * falls out the bottom.
			 */
			mightGetHere = curBreakTarg.used;
			if (mightGetHere) {
				ilGen.MarkLabel (curBreakTarg.label);
			}

			curBreakTarg = oldBreakTarg;
			curContTarg  = oldContTarg;
		}

		private void GenerateStmtForEach (TokenStmtForEach forEachStmt)
		{
			if (!mightGetHere) return;

			BreakContTarg oldBreakTarg = curBreakTarg;
			BreakContTarg oldContTarg  = curContTarg;
			CompValu      keyLVal      = null;
			CompValu      valLVal      = null;
			CompValu      arrayRVal    = GenerateFromRVal (forEachStmt.arrayRVal);

			if (forEachStmt.keyLVal != null) {
				keyLVal = GenerateFromLVal (forEachStmt.keyLVal);
				if (!(keyLVal.type is TokenTypeObject)) {
					ErrorMsg (forEachStmt.arrayRVal, "must be object");
				}
			}
			if (forEachStmt.valLVal != null) {
				valLVal = GenerateFromLVal (forEachStmt.valLVal);
				if (!(valLVal.type is TokenTypeObject)) {
					ErrorMsg (forEachStmt.arrayRVal, "must be object");
				}
			}
			if (!(arrayRVal.type is TokenTypeArray)) {
				ErrorMsg (forEachStmt.arrayRVal, "must be an array");
			}

			curBreakTarg = new BreakContTarg (ilGen, "foreachbreak_" + forEachStmt.Unique);
			curContTarg  = new BreakContTarg (ilGen, "foreachcont_"  + forEachStmt.Unique);

			ScriptMyLabel loopLabel = ilGen.DefineLabel ("foreachloop_" + forEachStmt.Unique);
			ScriptMyLocal indexVar  = ilGen.DeclareLocal (typeof (int), "foreachidx_" + forEachStmt.Unique);
			ScriptMyLocal objectVar = ((keyLVal == null) || (valLVal == null)) ? ilGen.DeclareLocal (typeof (object), "foreachobj_" + forEachStmt.Unique) : null;

			ilGen.MarkLabel (loopLabel);

			// ForEach arg 0: arrayRVal
			arrayRVal.PushVal (this);

			// ForEach arg 1: indexVar ++
			ilGen.Emit (OpCodes.Ldloc, indexVar);
			ilGen.Emit (OpCodes.Dup);
			PushConstantI4 (1);
			ilGen.Emit (OpCodes.Add);
			ilGen.Emit (OpCodes.Stloc, indexVar);

			// ForEach arg 2: ref keyLVal
			if (keyLVal == null) {
				ilGen.Emit (OpCodes.Ldloca, objectVar);
			} else {
				keyLVal.PushRef (this);
			}

			// ForEach arg 3: ref valLVal
			if (valLVal == null) {
				ilGen.Emit (OpCodes.Ldloca, objectVar);
			} else {
				valLVal.PushRef (this);
			}

			// Call XMR_Array.ForEach (arrayRVal, index, ref keyLVal, ref valLVal)
			ilGen.Emit (OpCodes.Callvirt, forEachMethodInfo);
			ilGen.Emit (OpCodes.Brfalse, curBreakTarg.label);
			curBreakTarg.used = true;

			GenerateStmt (forEachStmt.bodyStmt);
			if (curContTarg.used) {
				ilGen.MarkLabel (curContTarg.label);
				mightGetHere = true;
			}
			if (mightGetHere) {
				EmitCallCheckRun (forEachStmt.line);
				ilGen.Emit (OpCodes.Br, loopLabel);
			}
			ilGen.MarkLabel (curBreakTarg.label);
			mightGetHere = true;

			curBreakTarg = oldBreakTarg;
			curContTarg  = oldContTarg;
		}

		/**
		 * @brief output code for an 'if' statement
		 * Braces are necessary because what may be one statement for trueStmt or elseStmt in
		 * the script may translate to more than one statement in the resultant C# code.
		 */
		private void GenerateStmtIf (TokenStmtIf ifStmt)
		{
			if (!mightGetHere) return;

			bool constVal;

			/*
			 * See if constant test expression.
			 */
			if (IsConstBoolExpr (ifStmt.testRVal, out constVal)) {

				/*
				 * Constant, output just either the true or else part.
				 */
				if (constVal) {
					GenerateStmt (ifStmt.trueStmt);
				} else if (ifStmt.elseStmt != null) {
					GenerateStmt (ifStmt.elseStmt);
				}
			} else if (ifStmt.elseStmt == null) {

				/*
				 * This is an 'if' statement without an 'else' clause.
				 */
				CompValu testRVal = GenerateFromRVal (ifStmt.testRVal);
				testRVal.PushVal (this, tokenTypeBool);      // generate test code
				ScriptMyLabel doneLabel = ilGen.DefineLabel ("ifdone_" + ifStmt.Unique);
				ilGen.Emit (OpCodes.Brfalse, doneLabel);     // brfalse doneLabel
				GenerateStmt (ifStmt.trueStmt);              // generate true body code
				ilGen.MarkLabel (doneLabel);
				mightGetHere = true;                         // there's always a possibility of getting here
			} else {

				/*
				 * This is an 'if' statement with an 'else' clause.
				 */
				CompValu testRVal = GenerateFromRVal (ifStmt.testRVal);
				testRVal.PushVal (this, tokenTypeBool);      // generate test code
				ScriptMyLabel elseLabel = ilGen.DefineLabel ("ifelse_" + ifStmt.Unique);
				ilGen.Emit (OpCodes.Brfalse, elseLabel);     // brfalse elseLabel
				GenerateStmt (ifStmt.trueStmt);              // generate true body code
				bool trueMightGetHere = mightGetHere;        // save whether or not true falls through
				ScriptMyLabel doneLabel = ilGen.DefineLabel ("ifdone_" + ifStmt.Unique);
				ilGen.Emit (OpCodes.Br, doneLabel);          // branch to done
				ilGen.MarkLabel (elseLabel);                 // beginning of else code
				mightGetHere = true;                         // the top of the else might be executed
				GenerateStmt (ifStmt.elseStmt);              // output else code
				ilGen.MarkLabel (doneLabel);                 // where end of true clause code branches to
				mightGetHere |= trueMightGetHere;            // gets this far if either true or else falls through
			}
		}

		/**
		 * @brief output code for a 'jump' statement
		 */
		private void GenerateStmtJump (TokenStmtJump jumpStmt)
		{
			if (!mightGetHere) return;

			/*
			 * Make sure the target label is defined somewhere in the function.
			 */
			TokenStmtLabel stmtLabel;
			if (!curDeclFunc.labels.TryGetValue (jumpStmt.label.val, out stmtLabel)) {
				ErrorMsg (jumpStmt, "undefined label " + jumpStmt.label.val);
				return;
			}
			if (!stmtLabel.labelTagged) {
				stmtLabel.labelStruct = ilGen.DefineLabel ("jump_" + stmtLabel.name.val);
				stmtLabel.labelTagged = true;
			}

			/*
			 * Find which block the target label is in.  Must be in this or an outer block,
			 * no laterals allowed.  And if we exit a try/catch block, use Leave instead of Br.
			 */
			TokenStmtBlock stmtBlock;
			OpCode brop = OpCodes.Br;
			for (stmtBlock = curStmtBlock; stmtBlock != null; stmtBlock = stmtBlock.outerStmtBlock) {
				if (stmtBlock == stmtLabel.block) break;
				if (stmtBlock.isTry || stmtBlock.isCatch) brop = OpCodes.Leave;
				if (stmtBlock.isFinally) {
					ErrorMsg (jumpStmt, "cannot jump out of finally");
					return;
				}
			}
			if (stmtBlock == null) {
				ErrorMsg (jumpStmt, "no lateral jumps allowed");
				return;
			}

			/*
			 * Finally output the branch/leave opcode.
			 */
			ilGen.Emit (brop, stmtLabel.labelStruct);

			/*
			 * 'goto' statements never fall through.
			 */
			mightGetHere = false;
		}

		/**
		 * @brief output code for a jump target label statement.
		 * If there are any backward jumps to the label, do a CheckRun() also.
		 */
		private void GenerateStmtLabel (TokenStmtLabel labelStmt)
		{
			if (!labelStmt.labelTagged) {
				labelStmt.labelStruct = ilGen.DefineLabel ("jump_" + labelStmt.name.val);
				labelStmt.labelTagged = true;
			}
			ilGen.MarkLabel (labelStmt.labelStruct);
			if (labelStmt.hasBkwdRefs) {
				EmitCallCheckRun (labelStmt.line);
			}

			/*
			 * We are going to say that the label falls through.
			 * It would be nice if we could analyze all referencing
			 * goto's to see if all of them are not used but we are
			 * going to assume that if the script writer put a goto
			 * somewhere, it is probably going to be used.
			 */
			mightGetHere = true;
		}

		/**
		 * @brief output code for a return statement.
		 * @param retStmt = return statement token, including return value if any
		 */
		private void GenerateStmtRet (TokenStmtRet retStmt)
		{
			if (!mightGetHere) return;

			for (TokenStmtBlock stmtBlock = curStmtBlock; stmtBlock != null; stmtBlock = stmtBlock.outerStmtBlock) {
				if (stmtBlock.isFinally) {
					ErrorMsg (retStmt, "cannot return out of finally");
					return;
				}
			}

			if (curDeclFunc.retType is TokenTypeVoid) {
				if (retStmt.rVal != null) {
					ErrorMsg (retStmt, "function returns void, no value allowed");
					return;
				}
			} else {
				if (retStmt.rVal == null) {
					ErrorMsg (retStmt, "function requires return value type " + curDeclFunc.retType.ToString ());
					return;
				}
				CompValu rVal = GenerateFromRVal (retStmt.rVal);
				rVal.PushVal (this, curDeclFunc.retType);
				ilGen.Emit (OpCodes.Stloc, retValue);
			}
			ilGen.Emit (OpCodes.Leave, retLabel);

			/*
			 * 'return' statements never fall through.
			 */
			mightGetHere = false;
		}

		/**
		 * @brief the statement is just an expression, most likely an assignment or a ++ or -- thing.
		 */
		private void GenerateStmtRVal (TokenStmtRVal rValStmt)
		{
			if (!mightGetHere) return;

			GenerateFromRVal (rValStmt.rVal);
		}

		/**
		 * @brief generate code for a 'state' statement that transitions state.
		 * It sets the new state by throwing a ScriptChangeStateException.
		 */
		private void GenerateStmtState (TokenStmtState stateStmt)
		{
			if (!mightGetHere) return;

			int index = 0;  // 'default' state

			/*
			 * Set new state value by throwing an exception.
			 * These exceptions aren't catchable by script-level try { } catch { }.
			 */
			if ((stateStmt.state != null) && !stateIndices.TryGetValue (stateStmt.state.val, out index)) {
				// The moron XEngine compiles scripts that reference undefined states.
				// So rather than produce a compile-time error, we'll throw an exception at runtime.
				// ErrorMsg (stateStmt, "undefined state " + stateStmt.state.val);

				// throw new UndefinedStateException (stateStmt.state.val);
				ilGen.Emit (OpCodes.Ldstr, stateStmt.state.val);
				ilGen.Emit (OpCodes.Newobj, scriptUndefinedStateExceptionConstructorInfo);
			} else {
				PushConstantI4 (index);				// new state's index
				ilGen.Emit (OpCodes.Newobj, scriptChangeStateExceptionConstructorInfo);
			}
			ilGen.Emit (OpCodes.Throw);

			/*
			 * 'state' statements never fall through.
			 */
			mightGetHere = false;
		}

		/**
		 * @brief output code for a 'switch' statement
		 */
		private void GenerateStmtSwitch (TokenStmtSwitch switchStmt)
		{
			if (!mightGetHere) return;

			BreakContTarg   oldBreakTarg = curBreakTarg;
			ScriptMyLabel   defaultLabel = null;
			TokenSwitchCase sortedCases  = null;
			TokenSwitchCase defaultCase  = null;

			curBreakTarg = new BreakContTarg (ilGen, "switchbreak_" + switchStmt.Unique);

			/*
			 * Build list of cases sorted by ascending values.
			 * There should not be any overlapping of values.
			 */
			for (TokenSwitchCase thisCase = switchStmt.cases; thisCase != null; thisCase = thisCase.nextCase) {
				thisCase.label = ilGen.DefineLabel ("case_" + thisCase.Unique);

				/*
				 * The default case if any, goes in its own separate slot.
				 */
				if (thisCase.rVal1 == null) {
					if (defaultCase != null) {
						ErrorMsg (thisCase, "only one default case allowed");
						ErrorMsg (defaultCase, "...prior default case");
						return;
					}
					defaultCase  = thisCase;
					defaultLabel = thisCase.label;
					continue;
				}

				/*
				 * Evaluate case operands, they must be compile-time integer constants.
				 */
				if (!IsConstIntExpr (thisCase.rVal1, out thisCase.val1)) {
					ErrorMsg (thisCase.rVal1, "must be compile-time constant");
					return;
				}
				thisCase.val2 = thisCase.val1;
				if ((thisCase.rVal2 != null) && !IsConstIntExpr (thisCase.rVal2, out thisCase.val2)) {
					ErrorMsg (thisCase.rVal2, "must be compile-time constant");
					return;
				}
				if (thisCase.val2 < thisCase.val1) {
					ErrorMsg (thisCase.rVal2, "must be .ge. first value for the case");
					return;
				}

				/*
				 * Insert into list, sorted by value.
				 * Note that both limits are inclusive.
				 */
				TokenSwitchCase lastCase = null;
				TokenSwitchCase nextCase;
				for (nextCase = sortedCases; nextCase != null; nextCase = nextCase.nextSortedCase) {
					if (nextCase.val1 >  thisCase.val2) break;
					if (nextCase.val2 >= thisCase.val1) {
						ErrorMsg (thisCase, "value used by previous case");
						ErrorMsg (nextCase, "...previous case");
						return;
					}
					lastCase = nextCase;
				}
				thisCase.nextSortedCase = nextCase;
				if (lastCase == null) {
					sortedCases = thisCase;
				} else {
					lastCase.nextSortedCase = thisCase;
				}
			}

			if (defaultLabel == null) {
				defaultLabel = ilGen.DefineLabel ("default_" + switchStmt.Unique);
			}

			/*
			 * Output code to calculate index, push result on stack as an integer.
			 */
			CompValu testRVal = GenerateFromRVal (switchStmt.testRVal);
			testRVal.PushVal (this, tokenTypeInt);

			/*
			 * Output code to jump to the case statement's labels based on integer index on stack.
			 * Note that each case still has the integer index on stack when jumped to.
			 */
			int offset = 0;
			for (TokenSwitchCase thisCase = sortedCases; thisCase != null;) {

				/*
				 * Scan through list of cases to find the maximum number of cases who's numvalues-to-case ratio
				 * is from 0.5 to 2.0.  If such a group is found, use a CIL switch for them.  If not, just use a
				 * compare-and-branch for the current case.
				 */
				int numCases  = 0;
				int numFound  = 0;
				int lowValue  = thisCase.val1;
				int numValues = 0;
				for (TokenSwitchCase scanCase = thisCase; scanCase != null; scanCase = scanCase.nextSortedCase) {
					int nVals = scanCase.val2 - thisCase.val1 + 1;
					double ratio = (double)nVals / (double)(++ numCases);
					if ((ratio >= 0.5) && (ratio <= 2.0)) {
						numFound  = numCases;
						numValues = nVals;
					}
				}
				if (numFound > 1) {

					/*
					 * There is a group of case's, starting with thisCase, that fall within our criteria, ie, 
					 * that have a nice density of meaningful jumps.
					 *
					 * So first generate an array of jumps to the default label (explicit or implicit).
					 */
					ScriptMyLabel[] labels = new ScriptMyLabel[numValues];
					for (int i = 0; i < numValues; i ++) {
						labels[i] = defaultLabel;
					}

					/*
					 * Next, for each case in that group, fill in the corresponding array entries to jump to
					 * that case's label.
					 */
					do {
						for (int i = thisCase.val1; i <= thisCase.val2; i ++) {
							labels[i-lowValue] = thisCase.label;
						}
						thisCase = thisCase.nextSortedCase;
					} while (-- numFound > 0);

					/*
					 * Subtract the low value and do the computed jump.
					 * The OpCodes.Switch falls through if out of range (unsigned compare).
					 */
					if (offset != lowValue) {
						PushConstantI4 (lowValue - offset);
						ilGen.Emit (OpCodes.Sub);
						offset = lowValue;
					}
					ilGen.Emit (OpCodes.Dup);
					ilGen.Emit (OpCodes.Switch, labels);
				} else {

					/*
					 * It's not economical to do with a computed jump, so output a subtract/compare/branch
					 * for thisCase.
					 */
					if (lowValue == thisCase.val2) {
						ilGen.Emit (OpCodes.Dup);
						PushConstantI4 (lowValue - offset);
						ilGen.Emit (OpCodes.Beq, thisCase.label);
					} else {
						if (offset != lowValue) {
							PushConstantI4 (lowValue - offset);
							ilGen.Emit (OpCodes.Sub);
							offset = lowValue;
						}
						ilGen.Emit (OpCodes.Dup);
						PushConstantI4 (thisCase.val2 - offset);
						ilGen.Emit (OpCodes.Ble_Un, thisCase.label);
					}
					thisCase = thisCase.nextSortedCase;
				}
			}
			ilGen.Emit (OpCodes.Br, defaultLabel);

			/*
			 * Output code for the cases themselves, in the order given by the programmer, 
			 * so they fall through as programmer wants.  This includes the default case, if any.
			 *
			 * Each label is jumped to with the index still on the stack.  So pop it off in case
			 * the case body does a goto outside the switch or a return.  If the case body might
			 * fall through to the next case or the bottom of the switch, push a zero so the stack
			 * matches in all cases.
			 */
			for (TokenSwitchCase thisCase = switchStmt.cases; thisCase != null; thisCase = thisCase.nextCase) {
				ilGen.MarkLabel (thisCase.label);	// the branch comes here
				ilGen.Emit (OpCodes.Pop);		// pop the integer index off stack
				mightGetHere = true;			// it's possible to get here
				for (TokenStmt stmt = thisCase.stmts; stmt != null; stmt = (TokenStmt)(stmt.nextToken)) {
					GenerateStmt (stmt);		// output the case/explicit default body
				}
				if (mightGetHere) {
					PushConstantI4 (0);		// in case we fall through, push a dummy integer index
				}
			}

			/*
			 * If no explicit default case, output the default label here.
			 */
			if (defaultCase == null) {
				ilGen.MarkLabel (defaultLabel);
				mightGetHere = true;
			}

			/*
			 * If the last case of the switch falls through out the bottom,
			 * we have to pop the index still on the stack.
			 */
			if (mightGetHere) {
				ilGen.Emit (OpCodes.Pop);
			}

			/*
			 * Output the 'break' statement target label.
			 * Note that the integer index is not on the stack at this point.
			 */
			if (curBreakTarg.used) {
				ilGen.MarkLabel (curBreakTarg.label);
				mightGetHere = true;
			}

			curBreakTarg = oldBreakTarg;
		}

		/**
		 * @brief output code for a throw statement.
		 * @param throwStmt = throw statement token, including value to be thrown
		 */
		private void GenerateStmtThrow (TokenStmtThrow throwStmt)
		{
			if (!mightGetHere) return;

			if (throwStmt.rVal == null) {
				if (!curStmtBlock.isCatch) {
					ErrorMsg (throwStmt, "rethrow allowed only in catch clause");
				}
				ilGen.Emit (OpCodes.Rethrow);
			} else {
				CompValu rVal = GenerateFromRVal (throwStmt.rVal);
				rVal.PushVal (this, tokenTypeStr);
				ilGen.Emit (OpCodes.Call, throwStrToExcMethodInfo);
				ilGen.Emit (OpCodes.Throw);
			}

			/*
			 * 'throw' statements never fall through.
			 */
			mightGetHere = false;
		}

		/**
		 * @brief output code for an 'try' statement
		 */
		private void GenerateStmtTry (TokenStmtTry tryStmt)
		{
			if (!mightGetHere) return;

			BreakContTarg oldBreakTarg = curBreakTarg;		// cannot continue out of try/catch/finally
			BreakContTarg oldContTarg  = curContTarg;		// (break jumps to end of try/catch/finally)
			curBreakTarg = null;
			curContTarg  = null;

			ScriptMyLabel tryEndLabel = ilGen.DefineLabel ("tryend_" + tryStmt.Unique);


			tryStmt.tryStmt.isTry = true;				// jumps out of try require Leave opcode
										// rethrow not allowed
										// return statements not allowed
			curBreakTarg = new BreakContTarg (ilGen, "trybreak_" + tryStmt.Unique);
			ilGen.BeginExceptionBlock ();
			GenerateStmtBlock (tryStmt.tryStmt);			// output the try block statement block
			if (curBreakTarg.used) {
				ilGen.MarkLabel (curBreakTarg.label);
				mightGetHere = true;
			}
			bool mightGetOut = mightGetHere;
			ilGen.Emit (OpCodes.Leave, tryEndLabel);
			if (tryStmt.catchStmt != null) {
				tryStmt.catchStmt.isCatch = true;		// jumps out of catch require Leave opcode
										// rethrow allowed
										// return statements not allowed
				CompValu catchVarLoc = new CompValuTemp (tokenTypeStr, tryStmt.catchVar.name.val, this);
				tryStmt.catchVar.location = catchVarLoc;
				VarDict frame = PushVarDefnBlock ();
				frame.AddEntry (tryStmt.catchVar);
				ScriptMyLabel catchLabel = ilGen.DefineLabel ("catchlbl_" + tryStmt.Unique);
				ScriptMyLocal excLocal = ilGen.DeclareLocal (typeof (Exception), "catchexc_" + tryStmt.Unique);

				curBreakTarg = new BreakContTarg (ilGen, "catchbreak_" + tryStmt.Unique);
				ilGen.BeginCatchBlock (typeof (Exception));	// start of the catch block
				ilGen.Emit (OpCodes.Stloc, excLocal);		// save pointer to exception object
				catchVarLoc.PopPre (this);
				ilGen.Emit (OpCodes.Ldloc, excLocal);		// convert exception object to string
				ilGen.Emit (OpCodes.Call, catchExcToStrMethodInfo);
				catchVarLoc.PopPost (this);			// ... and store in catch clause var
				catchVarLoc.PushVal (this);			// see if null
				ilGen.Emit (OpCodes.Brtrue_S, catchLabel);
				ilGen.Emit (OpCodes.Rethrow);			// if so, rethrow exception
				ilGen.MarkLabel (catchLabel);			// if not, process script code

				mightGetHere = true;				// if we can get to the 'try' assume we can get to the 'catch'
				GenerateStmtBlock (tryStmt.catchStmt);		// output catch clause statement block
				if (curBreakTarg.used) {
					ilGen.MarkLabel (curBreakTarg.label);
					mightGetHere = true;
				}
				mightGetOut |= mightGetHere;			// remember whether or not we can get to end of try or catch at all
				ilGen.Emit (OpCodes.Leave, tryEndLabel);

				PopVarDefnBlock ();				// forget about catch clause var
			}
			if (tryStmt.finallyStmt != null) {
				curBreakTarg = new BreakContTarg (ilGen, "finbreak_" + tryStmt.Unique);
				tryStmt.finallyStmt.isFinally = true;		// cannot exit finally with jump or return statement
				ilGen.BeginFinallyBlock ();			// start of the finally block
				mightGetHere = true;
				GenerateStmtBlock (tryStmt.finallyStmt);
				if (curBreakTarg.used) {
					ilGen.MarkLabel (curBreakTarg.label);
				}
				ilGen.Emit (OpCodes.Endfinally);
			}
			ilGen.EndExceptionBlock ();
			ilGen.MarkLabel (tryEndLabel);
			mightGetHere = mightGetOut;

			curBreakTarg = oldBreakTarg;
			curContTarg  = oldContTarg;
		}

		/**
		 * @brief generate code for a 'while' statement including the loop body.
		 */
		private void GenerateStmtWhile (TokenStmtWhile whileStmt)
		{
			if (!mightGetHere) return;

			BreakContTarg oldBreakTarg = curBreakTarg;
			BreakContTarg oldContTarg  = curContTarg;
			ScriptMyLabel loopLabel    = ilGen.DefineLabel ("whileloop_" + whileStmt.Unique);

			curBreakTarg = new BreakContTarg (ilGen, "whilebreak_" + whileStmt.Unique);
			curContTarg  = new BreakContTarg (ilGen, "whilecont_"  + whileStmt.Unique);

			ilGen.MarkLabel (loopLabel);                                        // loop:
			if (!IsConstBoolExprTrue (whileStmt.testRVal)) {
				CompValu testRVal = GenerateFromRVal (whileStmt.testRVal);  //   testRVal = while test expression
				testRVal.PushVal (this, tokenTypeBool);                     //   if (!testRVal)
				ilGen.Emit (OpCodes.Brfalse, curBreakTarg.label);           //      goto break
				curBreakTarg.used = true;
			}
			GenerateStmt (whileStmt.bodyStmt);                                  //   while body statement
			if (curContTarg.used) {
				ilGen.MarkLabel (curContTarg.label);                        // cont:
				mightGetHere = true;
			}
			if (mightGetHere) {
				EmitCallCheckRun (whileStmt.line);                          //   __sw.CheckRun()
				ilGen.Emit (OpCodes.Br, loopLabel);                         //   goto loop
			}
			mightGetHere = curBreakTarg.used;
			if (mightGetHere) {
				ilGen.MarkLabel (curBreakTarg.label);                       // done:
			}

			curBreakTarg = oldBreakTarg;
			curContTarg  = oldContTarg;
		}

		/**
		 * @brief process a local variable declaration statement, possibly with initialization expression.
		 *        Note that the function header processing allocated stack space (CompValuTemp) for the
		 *        variable and now all we do is make it visible to the script at this point and compute
		 *        its initialization value.
		 */
		private void GenerateDeclVar (TokenDeclVar declVar)
		{
			CompValu local = declVar.location;

			/*
			 * Script gave us an initialization value, so just store init value in var like an assignment statement.
			 * Also debit any heap used by the initialization value, just like an assignment statement.
			 * If no init given, the var was set to its default value when stack space was allocated at the beginning
			 * of the function.
			 */
			if (declVar.init != null) {
				local.PopPre (this);
				CompValu rVal = GenerateFromRVal (declVar.init, local.GetArgTypes ());
				rVal.PushVal (this, declVar.type);
				local.PopPost (this);
				DebitHeapLeft (declVar, true, declVar.init);
			}

			/*
			 * Now it's ok for subsequent expressions in the block to reference the local variable.
			 */
			AddVarDefinition (declVar);
		}

		/**
		 * @brief Get the type and location of an L-value (eg, variable)
		 */
		private CompValu GenerateFromLVal (TokenLVal lVal)
		{
			return GenerateFromLVal (lVal, null);
		}
		private CompValu GenerateFromLVal (TokenLVal lVal, TokenType[] argsig)
		{
			if (lVal is TokenLValArEle)  return GenerateFromLValArEle  ((TokenLValArEle)lVal);
			if (lVal is TokenLValIField) return GenerateFromLValIField ((TokenLValIField)lVal, argsig);
			if (lVal is TokenLValName)   return GenerateFromLValName   ((TokenLValName)lVal, argsig);
			if (lVal is TokenLValSField) return GenerateFromLValSField ((TokenLValSField)lVal, argsig);
			throw new Exception ("bad lval class");
		}

		/**
		 * @brief we have an L-value token that is an element within an array.
		 * @returns a CompValu giving the type and location of the element of the array.
		 */
		private CompValu GenerateFromLValArEle (TokenLValArEle lVal)
		{
			/*
			 * Compute subscript before rest of lVal in case of multiple subscripts.
			 */
			CompValu subRVal = GenerateFromRVal (lVal.subRVal);

			/*
			 * Compute location of array itself.
			 */
			CompValu baseRVal = GenerateFromRVal (lVal.baseRVal);

			/*
			 * It better be an array!
			 */
			if (!(baseRVal.type is TokenTypeArray)) {
				ErrorMsg (lVal, "taking subscript of non-array");
				return baseRVal;
			}

			/*
			 * Ok, generate reference.
			 */
			return new CompValuArEle (new TokenTypeObject (lVal), baseRVal, subRVal);
		}

		/**
		 * @brief we have an L-value token that is an instance field/method within a struct.
		 * @returns a CompValu giving the type and location of the field/method in the struct.
		 */
		private CompValu GenerateFromLValIField (TokenLValIField lVal, TokenType[] argsig)
		{
			CompValu baseRVal = GenerateFromRVal (lVal.baseRVal);
			string fieldName = lVal.field.val + ArgSigString (argsig);

			/*
			 * Maybe they are accessing an instance field or method of a script-defined class.
			 */
			if (baseRVal.type is TokenTypeSDTypeClass) {
				TokenTypeSDTypeClass sdtType = (TokenTypeSDTypeClass)baseRVal.type;
				TokenDeclSDTypeClass sdtDecl = sdtType.decl;
				for (TokenDeclSDTypeClass sdtd = sdtDecl; sdtd != null; sdtd = sdtd.extends) {
					TokenDeclVar declVar = FindSingleMember (sdtd.members, lVal.field, argsig);
					if (declVar != null) {
						if ((declVar.sdtFlags & ScriptReduce.SDT_STATIC) != 0) {
							ErrorMsg (lVal.field, "non-static reference to static member " + fieldName);
							return new CompValuVoid (lVal.field);
						}
						return (declVar.retType == null) ? (CompValu)new CompValuInstField (declVar, baseRVal, false) 
						                                 : (CompValu)new CompValuInstMeth (declVar, baseRVal, false);
					}
				}
				ErrorMsg (lVal.field, "no member " + fieldName + " in " + sdtDecl.name.val);
				return new CompValuVoid (lVal.field);
			}

			/*
			 * Maybe they are accessing a method of a script-defined interface.
			 */
			if (baseRVal.type is TokenTypeSDTypeInterface) {
				TokenTypeSDTypeInterface sdtType = (TokenTypeSDTypeInterface)baseRVal.type;
				TokenDeclSDTypeInterface sdtDecl = sdtType.decl;
				if (argsig != null) {
					TokenDeclVar declFunc = FindSingleMember (sdtDecl.methods, lVal.field, argsig);
					if (declFunc != null) {
						return new CompValuIntfMeth (declFunc, baseRVal);
					}
				}
				ErrorMsg (lVal.field, "no member " + fieldName + " in " + sdtDecl.name.val);
				return new CompValuVoid (lVal.field);
			}

			/*
			 * Since we only have a few built-in types with fields, just pound them out.
			 */
			if (baseRVal.type is TokenTypeArray) {

				// no arguments, no parentheses, just the field name, returning integer
				// but internally, it is a call to a method()
				if (fieldName == "count") {
					TokenType retType = new TokenTypeInt (lVal);
					return new CompValuIntInstROProp (retType, baseRVal, arrayCountMethodInfo);
				}

				// no arguments but with the parentheses, returning void
				if (fieldName == "clear()") {
					TokenType retType = new TokenTypeVoid (lVal);
					TokenType[] argTypes = new TokenType[0];
					TokenTypeSDTypeDelegate ttd = new TokenTypeSDTypeDelegate (lVal, retType, argTypes, tokenScript);
					return new CompValuIntInstMeth (ttd, baseRVal, arrayClearMethodInfo);
				}

				// single integer argument, returning an object
				MethodInfo mi = null;
				if (fieldName == "index(integer)") mi = arrayIndexMethodInfo;
				if (fieldName == "value(integer)") mi = arrayValueMethodInfo;
				if (mi != null) {
					TokenType retType = new TokenTypeObject (lVal);
					TokenType[] argTypes = new TokenType[] { new TokenTypeInt (lVal) };
					TokenTypeSDTypeDelegate ttd = new TokenTypeSDTypeDelegate (lVal, retType, argTypes, tokenScript);
					return new CompValuIntInstMeth (ttd, baseRVal, mi);
				}
			}
			if (baseRVal.type is TokenTypeRot) {
				FieldInfo fi = null;
				if (fieldName == "x") fi = rotationXFieldInfo;
				if (fieldName == "y") fi = rotationYFieldInfo;
				if (fieldName == "z") fi = rotationZFieldInfo;
				if (fieldName == "s") fi = rotationSFieldInfo;
				if (fi != null) {
					return new CompValuField (new TokenTypeFloat (lVal), baseRVal, fi);
				}
			}
			if (baseRVal.type is TokenTypeVec) {
				FieldInfo fi = null;
				if (fieldName == "x") fi = vectorXFieldInfo;
				if (fieldName == "y") fi = vectorYFieldInfo;
				if (fieldName == "z") fi = vectorZFieldInfo;
				if (fi != null) {
					return new CompValuField (new TokenTypeFloat (lVal), baseRVal, fi);
				}
			}

			ErrorMsg (lVal, "type " + baseRVal.type.ToString () + " does not define member " + fieldName);
			return baseRVal;
		}

		/**
		 * @brief We have an L-value token that is a function, method or variable name.
		 * @param lVal = name we are looking for
		 * @param argsig = null: just look for name as a variable
		 *                 else: look for name as a function/method being called with the given argument types
		 *                       eg, "(string,integer,list)"
		 * @returns a CompValu giving the type and location of the function, method or variable.
		 */
		private CompValu GenerateFromLValName (TokenLValName lVal, TokenType[] argsig)
		{
			string name = lVal.name.val;

			/*
			 * Look in variable stack for the given name.
			 */
			foreach (VarDict vars in scriptVariablesStack) {

				// first look for it possibly with an argument signature
				// so we pick the correct overloaded method
				TokenDeclVar var = FindSingleMember (vars, lVal.name, argsig);
				if (var != null) return var.location;

				// if that fails, try it without the argument signature.
				// delegates get entered like any other variable, ie, 
				// no signature on their name.
				if (argsig != null) {
					var = FindSingleMember (vars, lVal.name, null);
					if (var != null) return var.location;
				}
			}

			/*
			 * If not found, try one of the built-in constants or functions.
			 */
			if (argsig == null) {
				ScriptConst scriptConst = ScriptConst.Lookup (name);
				if (scriptConst != null) return scriptConst.rVal;
			} else {
				TokenDeclVar inline = FindSingleMember (inlineFunctions, lVal.name, argsig);
				if (inline != null) return inline.location;
			}

			/*
			 * Who knows what the name is referring to.
			 */
			ErrorMsg (lVal, "undefined constant/function/method/variable " + name + ArgSigString (argsig));
			return new CompValuVoid (lVal);
		}

		/**
		 * @brief we have an L-value token that is a static field/method within a struct.
		 * @returns a CompValu giving the type and location of the field/method in the struct.
		 */
		private CompValu GenerateFromLValSField (TokenLValSField lVal, TokenType[] argsig)
		{
			TokenType stType = lVal.baseType;
			string fieldName = lVal.fieldName.val + ArgSigString (argsig);

			/*
			 * Maybe they are accessing a static field or method of a script-defined class.
			 */
			if (stType is TokenTypeSDTypeClass) {
				TokenTypeSDTypeClass sdtType = (TokenTypeSDTypeClass)stType;
				TokenDeclSDTypeClass sdtDecl = sdtType.decl;
				for (TokenDeclSDTypeClass sdtd = sdtDecl; sdtd != null; sdtd = sdtd.extends) {
					TokenDeclVar declFunc = FindSingleMember (sdtd.members, lVal.fieldName, argsig);
					if (declFunc != null) {
						if ((declFunc.sdtFlags & ScriptReduce.SDT_STATIC) == 0) {
							ErrorMsg (lVal.fieldName, "static reference to non-static member " + fieldName);
							return new CompValuVoid (lVal.fieldName);
						}
						return declFunc.location;
					}
				}
			}

			ErrorMsg (lVal.fieldName, "no member " + fieldName + " in " + stType.ToString ());
			return new CompValuVoid (lVal.fieldName);
		}

		/**
		 * @brief generate code from an RVal expression and return its type and where the result is stored.
		 * For anything that has side-effects, statements are generated that perform the computation then
		 * the result it put in a temp var and the temp var name is returned.
		 * For anything without side-effects, they are returned as an equivalent sequence of Emits.
		 * @param rVal = rVal token to be evaluated
		 * @param argsig = null: not being used in an function/method context
		 *                 else: string giving argument types, eg, "(string,integer,list,vector)"
		 *                       that can be used to select among overloaded methods
		 * @returns resultant type and location
		 */
		private CompValu GenerateFromRVal (TokenRVal rVal)
		{
			return GenerateFromRVal (rVal, null);
		}
		private CompValu GenerateFromRVal (TokenRVal rVal, TokenType[] argsig)
		{
			errorMessageToken = rVal;

			/*
			 * Maybe the expression can be converted to a constant.
			 */
			bool didOne;
			do {
				didOne = false;
				rVal = rVal.TryComputeConstant (LookupBodyConstants, ref didOne);
			} while (didOne);

			/*
			 * Generate code for the computation and return resulting type and location.
			 */
			if (rVal is TokenRValAsnPost)   return GenerateFromRValAsnPost   ((TokenRValAsnPost)rVal);
			if (rVal is TokenRValAsnPre)    return GenerateFromRValAsnPre    ((TokenRValAsnPre)rVal);
			if (rVal is TokenRValBaseField) return GenerateFromRValBaseField ((TokenRValBaseField)rVal, argsig);
			if (rVal is TokenRValCall)      return GenerateFromRValCall      ((TokenRValCall)rVal);
			if (rVal is TokenRValCast)      return GenerateFromRValCast      ((TokenRValCast)rVal);
			if (rVal is TokenRValConst)     return GenerateFromRValConst     ((TokenRValConst)rVal);
			if (rVal is TokenRValIsType)    return GenerateFromRValIsType    ((TokenRValIsType)rVal);
			if (rVal is TokenRValList)      return GenerateFromRValList      ((TokenRValList)rVal);
			if (rVal is TokenRValOpBin)     return GenerateFromRValOpBin     ((TokenRValOpBin)rVal);
			if (rVal is TokenRValOpUn)      return GenerateFromRValOpUn      ((TokenRValOpUn)rVal);
			if (rVal is TokenRValParen)     return GenerateFromRValParen     ((TokenRValParen)rVal);
			if (rVal is TokenRValRot)       return GenerateFromRValRot       ((TokenRValRot)rVal);
			if (rVal is TokenRValThis)      return GenerateFromRValThis      ((TokenRValThis)rVal, argsig);
			if (rVal is TokenRValUndef)     return GenerateFromRValUndef     ((TokenRValUndef)rVal);
			if (rVal is TokenRValVec)       return GenerateFromRValVec       ((TokenRValVec)rVal);
			if (rVal is TokenLVal)          return GenerateFromLVal          ((TokenLVal)rVal, argsig);

			throw new Exception ("bad rval class " + rVal.GetType ().ToString ());
		}

		/**
		 * @brief compute the result of a binary operator (eg, add, subtract, multiply, lessthan)
		 * @param token = binary operator token, includes the left and right operands
		 * @returns where the resultant R-value is as something that doesn't have side effects
		 */
		private CompValu GenerateFromRValOpBin (TokenRValOpBin token)
		{
			CompValu leftLVal = null;
			CompValu left = null;
			CompValu right;

			/*
			 * If left operand is an L-value, create an leftLVal location marker for it.
			 * In either case, create a R-value location marker for it.
			 */
			if (token.rValLeft is TokenLVal) {
				left = leftLVal = GenerateFromLVal ((TokenLVal)token.rValLeft);
			}

			/*
			 * Simple overwriting assignments are their own special case,
			 * as we want to cast the R-value to the type of the L-value.
			 * And in the case of delegates, we want to use the arg signature
			 * of the delegate to select which overloaded method to use.
			 * And we might also be able to optimize out a temp by having
			 * the result put directly in the L-value variable.
			 */
			string opcodeIndex = token.opcode.ToString ();
			if (opcodeIndex == "=") {
				if (left == null) {
					ErrorMsg (token, "invalid L-value for =");
					left = GenerateFromRVal (token.rValLeft);
				} else {
					right = GenerateFromRVal (token.rValRight, left.GetArgTypes ());
					leftLVal.PopPre (this);
					right.PushVal (this, leftLVal.type);  // push (leftLVal.type)right
					leftLVal.PopPost (this);              // pop to leftLVal
					////????DebitHeapLeft (left, true, token.rValLeft);
				}
				return left;
			}

			/*
			 * Comma operators are also special, as they say to compute the left-hand value
			 * and discard it, then compute the right-hand argument and that is the result.
			 */
			if (opcodeIndex == ",") {

				/*
				 * Compute left-hand operand but throw away result (because we say to store in a 'void').
				 */
				if (left == null) {
					GenerateFromRVal (token.rValLeft);
				}

				/*
				 * Compute right-hand operand and that is the value of the expression.
				 */
				return GenerateFromRVal (token.rValRight);
			}

			/*
			 * Computation of some sort, compute right-hand operand value then left-hand value
			 * because LSL is supposed to be right-to-left evaluation.
			 *
			 * If left-hand operand has side effects, force right-hand operand into a temp so
			 * it will get computed first, and not just stacked for later evaluation.
			 */
			right = GenerateFromRVal (token.rValRight);
			if (token.rValLeft.sideEffects && !right.isFinal) {
				CompValu rightTemp = new CompValuTemp (right.type, null, this);
				rightTemp.PopPre (this);
				right.PushVal (this, right.type);
				rightTemp.PopPost (this);
				right = rightTemp;
			}
			left = GenerateFromRVal (token.rValLeft);

			/*
			 * Formulate key string for binOpStrings = (lefttype)(operator)(righttype)
			 */
			string leftIndex = left.type.ToString ();
			string rightIndex = right.type.ToString ();
			string key = leftIndex + opcodeIndex + rightIndex;

			/*
			 * If that key exists in table, then the operation is defined between those types
			 * ... and it produces an R-value of type as given in the table.
			 */
			BinOpStr binOpStr;
			if (binOpStrings.TryGetValue (key, out binOpStr)) {

				/*
				 * If table contained an explicit assignment type like +=, output the statement without
				 * casting the L-value, then return the L-value as the resultant value.
				 *
				 * Make sure we don't include comparisons (such as ==, >=, etc).
				 * Nothing like +=, -=, %=, etc, generate a boolean, only the comparisons.
				 */
				if ((binOpStr.outtype != typeof (bool)) && opcodeIndex.EndsWith ("=")) {
					binOpStr.emitBO (this, left, right, left);
					////????DebitHeapLeft (left, true, token.rValLeft);
					return left;
				}

				/*
				 * It's of the form left binop right.
				 * If either the original left or right had side effects, they should have been evaluated
				 * and put in temps already, so what we have for left and right don't have side effects.
				 * So we can simply return (outtype)(left binop right) as the location of the result.
				 *
				 * ??? optimise by creating a CompValu that can have left.PushVal(),right.PushVal(),EmitBinOpCode() as its PushVal() ???
				 */
				CompValu retRVal = new CompValuTemp (TokenType.FromSysType (token.opcode, binOpStr.outtype), null, this);
				retRVal.isFinal = left.isFinal && right.isFinal;
				binOpStr.emitBO (this, left, right, retRVal);
				return retRVal;
			}

			/*
			 * If the opcode ends with "=", it may be something like "+=".
			 * So look up the key as if we didn't have the "=" to tell us if the operation is legal.
			 * Also, the binary operation's output type must be the same as the L-value type.
			 * Likewise, integer += float not allowed because result is float, but float += integer is ok.
			 */
			if (opcodeIndex.EndsWith ("=")) {
				key = leftIndex + opcodeIndex.Substring (0, opcodeIndex.Length - 1) + rightIndex;
				if (binOpStrings.TryGetValue (key, out binOpStr)) {

					/*
					 * Now we know for something like %= that left%right is legal for the types given.
					 * We can only actually process it if the resultant type is of the left type.
					 * So for example, we can't do float += list, as float + list gives a list.
					 */
					if (binOpStr.outtype == left.type.ToSysType ()) {

						/*
						 * Types are ok, see if the '=' (read/modify/write) form is allowed...
						 */
						if (binOpStr.rmwOK) {
							if (leftLVal == null) {
								ErrorMsg (token, "invalid L-value for <op>=");
							} else {
								binOpStr.emitBO (this, leftLVal, right, leftLVal);
								////????DebitHeapLeft (left, true, token.rValLeft);
							}
							return left;
						}
					}
				}
			}

			/*
			 * Can't find it, oh well.
			 */
			ErrorMsg (token, "op not defined: " + leftIndex + " " + opcodeIndex + " " + rightIndex);
			return new CompValuVoid (token);
		}

		/**
		 * @brief compute the result of an unary operator
		 * @param token = unary operator token, includes the operand
		 * @returns where the resultant R-value is
		 */
		private CompValu GenerateFromRValOpUn (TokenRValOpUn token)
		{
			CompValu inRVal = GenerateFromRVal (token.rVal);
			return UnOpGenerate (inRVal, token.opcode);
		}

		/**
		 * @brief postfix operator -- this returns the type and location of the resultant value
		 */
		private CompValu GenerateFromRValAsnPost (TokenRValAsnPost asnPost)
		{
			CompValu lVal = GenerateFromLVal (asnPost.lVal);

			/*
			 * Make up a temp to save original value in.
			 */
			CompValu result = new CompValuTemp (lVal.type, null, this);

			/*
			 * Prepare to pop incremented value back into variable being incremented.
			 */
			lVal.PopPre (this);

			/*
			 * Copy original value to temp and leave value on stack.
			 */
			lVal.PushVal (this);
			result.PopPre (this);  // this should push nothing on stack because it is a CIL local var
			ilGen.Emit (OpCodes.Dup);
			result.PopPost (this);

			/*
			 * Perform the ++/--.
			 */
			if (lVal.type is TokenTypeInt) {
				PushConstantI4 (1);
			} else if (lVal.type is TokenTypeFloat) {
				ilGen.Emit (OpCodes.Ldc_R4, 1.0f);
			} else {
				lVal.PopPost (this);
				ErrorMsg (asnPost, "invalid type for " + asnPost.postfix.ToString ());
				return lVal;
			}
			switch (asnPost.postfix.ToString ()) {
				case "++": {
					ilGen.Emit (OpCodes.Add);
					break;
				}
				case "--": {
					ilGen.Emit (OpCodes.Sub);
					break;
				}
				default: throw new Exception ("unknown asnPost op");
			}

			/*
			 * Store new value in original variable.
			 */
			lVal.PopPost (this);

			return result;
		}

		/**
		 * @brief prefix operator -- this returns the type and location of the resultant value
		 */
		private CompValu GenerateFromRValAsnPre (TokenRValAsnPre asnPre)
		{
			CompValu lVal = GenerateFromLVal (asnPre.lVal);

			/*
			 * Make up a temp to put result in.
			 */
			CompValu result = new CompValuTemp (lVal.type, null, this);

			/*
			 * Prepare to pop incremented value back into variable being incremented.
			 */
			lVal.PopPre (this);

			/*
			 * Push original value.
			 */
			lVal.PushVal (this);

			/*
			 * Perform the ++/--.
			 */
			if (lVal.type is TokenTypeInt) {
				PushConstantI4 (1);
			} else if (lVal.type is TokenTypeFloat) {
				ilGen.Emit (OpCodes.Ldc_R4, 1.0f);
			} else {
				lVal.PopPost (this);
				ErrorMsg (asnPre, "invalid type for " + asnPre.prefix.ToString ());
				return lVal;
			}
			switch (asnPre.prefix.ToString ()) {
				case "++": {
					ilGen.Emit (OpCodes.Add);
					break;
				}
				case "--": {
					ilGen.Emit (OpCodes.Sub);
					break;
				}
				default: throw new Exception ("unknown asnPre op");
			}

			/*
			 * Store new value in temp variable, keeping new value on stack.
			 */
			result.PopPre (this);  // this should push nothing on stack because it is a CIL local var
			ilGen.Emit (OpCodes.Dup);
			result.PopPost (this);

			/*
			 * Store new value in original variable.
			 */
			lVal.PopPost (this);

			return result;
		}

		/**
		 * @brief using 'base' within a script-defined instance method to refer to an instance field/method 
		 *        of the class being extended.
		 */
		private CompValu GenerateFromRValBaseField (TokenRValBaseField baseField, TokenType[] argsig)
		{
			string fieldName = baseField.field.val;

			TokenDeclSDTypeClass sdtDecl = curDeclFunc.sdtClass;
			if ((sdtDecl == null) || ((curDeclFunc.sdtFlags & ScriptReduce.SDT_STATIC) != 0)) {
				ErrorMsg (baseField, "cannot use 'base' outside instance method body");
				return new CompValuVoid (baseField);
			}

			for (TokenDeclSDTypeClass sdtd = sdtDecl; sdtd != null; sdtd = sdtd.extends) {
				TokenDeclVar declVar = FindSingleMember (sdtd.members, baseField.field, argsig);
				if (declVar != null) {
					if ((declVar.sdtFlags & ScriptReduce.SDT_STATIC) != 0) {
						ErrorMsg (baseField, "non-static reference to static member " + fieldName + ArgSigString (argsig));
						return new CompValuVoid (baseField);
					}
					TokenType baseType = sdtd.MakeRefToken (baseField);
					CompValu  basePtr  = new CompValuArg (baseType, 0);
					return (declVar.retType == null) ? (CompValu)new CompValuInstField (declVar, basePtr, true) : 
					                                   (CompValu)new CompValuInstMeth (declVar, basePtr, true);
				}
			}

			ErrorMsg (baseField, "no member " + fieldName + ArgSigString (argsig) + " rootward of " + sdtDecl.name.val);
			return new CompValuVoid (baseField);
		}

		/**
		 * @brief Generate code that calls a function or object's method.
		 * @returns where the call's return value is stored (a TokenTypeVoid if void)
		 */
		private CompValu GenerateFromRValCall (TokenRValCall call)
		{
			CompValu method, result;
			CompValu[] argRVals;
			int i, nargs;
			TokenType retType;
			TokenType[] argTypes;

			/*
			 * Compute the values of all the function's call arguments.
			 * Save where the computation results are in the argRVals[] array.
			 * Might as well build the argument signature from the argument types, too.
			 */
			nargs = call.nArgs;
			argRVals = new CompValu[nargs];
			argTypes = new TokenType[nargs];
			if (nargs > 0) {
				i = 0;
				for (TokenRVal arg = call.args; arg != null; arg = (TokenRVal)arg.nextToken) {
					argRVals[i] = GenerateFromRVal (arg);
					argTypes[i] = argRVals[i].type;
					i ++;
				}
			}

			/*
			 * Get function/method's entrypoint that matches the call argument types.
			 */
			method = GenerateFromRVal (call.meth, argTypes);
			if (method == null) return null;

			/*
			 * Inline functions know how to generate their own call.
			 */
			if (method is CompValuInline) {
				CompValuInline inline = (CompValuInline)method;
				result = SetupReturnLocation (inline.declInline.retType);
				inline.declInline.codeGen (this, call, result, argRVals);
				return result;
			}

			/*
			 * Otherwise must some other kind of callable.
			 */
			retType = method.GetRetType ();  // TokenTypeVoid if void; null means a variable
			if (retType == null) {
				ErrorMsg (call.meth, "must be a function or method");
				return new CompValuVoid (call.meth);
			}

			/*
			 * Stick in a label here that stack frame restore code can jump to.
			 */
			new CallLabel (this);

			/*
			 * Make sure we have a place to put return value and prepare to pop return value into it.
			 * The PopPre() call must be done before pushing anything else so PopPost() will work.
			 */
			result = SetupReturnLocation (retType);

			/*
			 * Push whatever the function/method needs as a this argument, if anything.
			 */
			method.CallPre (this);

			/*
			 * Push the script-visible args, left-to-right.
			 */
			argTypes = method.GetArgTypes ();
			for (i = 0; i < nargs; i ++) {
				if (argTypes == null) {
					argRVals[i].PushVal (this);
				} else {
					argRVals[i].PushVal (this, argTypes[i]);
				}
			}

			/*
			 * Now output call instruction.
			 */
			method.CallPost (this);

			/*
			 * Deal with the return value (if any), by putting it in 'result'.
			 */
			result.PopPost (this, retType);
			return result;
		}

		private CompValu SetupReturnLocation (TokenType retType)
		{
			CompValu result;
			if (retType is TokenTypeVoid) {
				result = new CompValuVoid (retType);
			} else {
				result = new CompValuTemp (retType, null, this);
			}
			result.PopPre (this);
			return result;
		}

		/**
		 * @brief Generate code that casts a value to a particular type.
		 * @returns where the result of the conversion is stored.
		 */
		private CompValu GenerateFromRValCast (TokenRValCast cast)
		{
			/*
			 * If casting to a delegate type, use the argment signature 
			 * of the delegate to help select the function/method, eg, 
			 *    '(delegate string(integer))ToString'
			 * will select 'string ToString(integer x)'
			 * instaead of 'string ToString(float x)' or anything else
			 */
			TokenType[] argsig = null;
			TokenType outType = cast.castTo;
			if (outType is TokenTypeSDTypeDelegate) {
				argsig = ((TokenTypeSDTypeDelegate)outType).decl.GetArgTypes ();
			}

			/*
			 * Generate the value that is being cast.
			 * If the value is already the requested type, just use it as is.
			 */
			CompValu inRVal = GenerateFromRVal (cast.rVal, argsig);
			if (inRVal.type == outType) return inRVal;

			/*
			 * Different type, generate casting code, putting the result in a temp of the output type.
			 */
			//??? optimize by having CompValu.PushVal() emit code for the conversion instead of needing a temp ???//
			CompValu outRVal = new CompValuTemp (outType, null, this);
			outRVal.isFinal = inRVal.isFinal;
			outRVal.PopPre (this);
			inRVal.PushVal (this, outType, true);
			outRVal.PopPost (this);
			return outRVal;
		}

		/**
		 * @brief Constant in the script somewhere
		 * @returns where the constants value is stored
		 */
		private CompValu GenerateFromRValConst (TokenRValConst rValConst)
		{
			if (rValConst.val is SCRIPTFLOAT) {
				return new CompValuFloat (new TokenTypeFloat (rValConst), (SCRIPTFLOAT)(rValConst.val));
			}
			if (rValConst.val is int) {
				return new CompValuInteger (new TokenTypeInt (rValConst), (int)(rValConst.val));
			}
			if (rValConst.val is string) {
				return new CompValuString (new TokenTypeStr (rValConst), (string)(rValConst.val));
			}
			throw new Exception ("unknown constant type " + rValConst.val.GetType ());
		}

		/**
		 * @brief generate a new list object
		 * @param rValList = an rVal to create it from
		 */
		private CompValu GenerateFromRValList (TokenRValList rValList)
		{
			CompValu newList = new CompValuTemp (new TokenTypeList (rValList.rVal), null, this);
			newList.PopPre (this);

			/*
			 * Create a temp array to hold all the initial values.
			 */
			PushConstantI4 (rValList.nItems);
			ilGen.Emit (OpCodes.Newarr, typeof (object));

			/*
			 * Populate the array.
			 */
			int i = 0;
			for (TokenRVal val = rValList.rVal; val != null; val = (TokenRVal)val.nextToken) {

				/*
				 * Get pointer to temp array object.
				 */
				ilGen.Emit (OpCodes.Dup);

				/*
				 * Get index in that array.
				 */
				PushConstantI4 (i);

				/*
				 * Emit code to compute initial value for the element.
				 */
				CompValu eRVal = GenerateFromRVal (val);

				/*
				 * Store initialization value in array location.
				 * However, floats and ints need to be converted to LSL_Float and LSL_Integer,
				 * or things like llSetPayPrice() will puque when they try to cast the elements
				 * to LSL_Float or LSL_Integer.  Likewise with string/LSL_String.
				 *
				 * Maybe it's already LSL-boxed so we don't do anything with it except make sure
				 * it is an object, not a struct.
				 */
				eRVal.PushVal (this);
				if (eRVal.type.ToLSLWrapType () == null) {
					if (eRVal.type is TokenTypeFloat) {
						ilGen.Emit (OpCodes.Newobj, lslFloatConstructorInfo);
						ilGen.Emit (OpCodes.Box, typeof (LSL_Float));
					} else if (eRVal.type is TokenTypeInt) {
						ilGen.Emit (OpCodes.Newobj, lslIntegerConstructorInfo);
						ilGen.Emit (OpCodes.Box, typeof (LSL_Integer));
					} else if (eRVal.type is TokenTypeStr) {
						ilGen.Emit (OpCodes.Newobj, lslStringConstructorInfo);
						ilGen.Emit (OpCodes.Box, typeof (LSL_String));
					} else if (eRVal.type.ToSysType ().IsValueType) {
						ilGen.Emit (OpCodes.Box, eRVal.type.ToSysType ());
					}
				} else if (eRVal.type.ToLSLWrapType ().IsValueType) {

					// Convert the LSL value structs to an object of the LSL-boxed type
					ilGen.Emit (OpCodes.Box, eRVal.type.ToLSLWrapType ());
				}
				ilGen.Emit (OpCodes.Stelem, typeof (object));
				i ++;
			}

			/*
			 * Create new list object from temp initial value array (whose ref is still on the stack).
			 */
			ilGen.Emit (OpCodes.Newobj, lslListConstructorInfo);
			newList.PopPost (this);
			return newList;
		}

		/**
		 * @brief parenthesized expression
		 * @returns type and location of the result of the computation.
		 */
		private CompValu GenerateFromRValParen (TokenRValParen rValParen)
		{
			return GenerateFromRVal (rValParen.rVal);
		}

		/**
		 * @brief create a rotation object from the x,y,z,w value expressions.
		 */
		private CompValu GenerateFromRValRot (TokenRValRot rValRot)
		{
			CompValu xRVal, yRVal, zRVal, wRVal;

			xRVal = GenerateFromRVal (rValRot.xRVal);
			yRVal = GenerateFromRVal (rValRot.yRVal);
			zRVal = GenerateFromRVal (rValRot.zRVal);
			wRVal = GenerateFromRVal (rValRot.wRVal);
			return new CompValuRot (new TokenTypeRot (rValRot), xRVal, yRVal, zRVal, wRVal);
		}

		/**
		 * @brief Using 'this' as a pointer to the current script-defined instance object.
		 *        The value is located in arg #0 of the current instance method.
		 */
		private CompValu GenerateFromRValThis (TokenRValThis zhis, TokenType[] argsig)
		{
			if ((curDeclFunc.sdtClass == null) || ((curDeclFunc.sdtFlags & ScriptReduce.SDT_STATIC) != 0)) {
				ErrorMsg (zhis, "cannot use 'this' outside instance method body");
				return new CompValuVoid (zhis);
			}
			return new CompValuArg (curDeclFunc.sdtClass.MakeRefToken (zhis), 0);
		}

		/**
		 * @brief 'undefined' constant.
		 *        If this constant gets written to an array element, it will delete that element from the array.
		 *        If the script retrieves an element by key that is not defined, it will get this value.
		 *        This value can be stored in and retrieved from variables of type 'object'.
		 *        It is a runtime error to cast this value to any type, eg, we don't allow string variables to be null pointers.
		 */
		private CompValu GenerateFromRValUndef (TokenRValUndef rValUndef)
		{
			return new CompValuNull (new TokenTypeObject (rValUndef));
		}

		/**
		 * @brief create a vector object from the x,y,z value expressions.
		 */
		private CompValu GenerateFromRValVec (TokenRValVec rValVec)
		{
			CompValu xRVal, yRVal, zRVal;

			xRVal = GenerateFromRVal (rValVec.xRVal);
			yRVal = GenerateFromRVal (rValVec.yRVal);
			zRVal = GenerateFromRVal (rValVec.zRVal);
			return new CompValuVec (new TokenTypeVec (rValVec), xRVal, yRVal, zRVal);
		}

		/**
		 * @brief Generate code to process an <rVal> is <type> expression, and produce a boolean value.
		 */
		private CompValu GenerateFromRValIsType (TokenRValIsType rValIsType)
		{
			/*
			 * Expression we want to know the type of.
			 */
			CompValu val = GenerateFromRVal (rValIsType.rValExp);

			/*
			 * Pass it in to top-level type expression decoder.
			 */
			return GenerateFromTypeExp (val, rValIsType.typeExp);
		}

		/**
		 * @brief See if the type of the given value matches the type expression.
		 * @param val = where the value to be evaluated is stored
		 * @param typeExp = script tokens representing type expression
		 * @returns location where the boolean result is stored
		 */
		private CompValu GenerateFromTypeExp (CompValu val, TokenTypeExp typeExp)
		{
			if (typeExp is TokenTypeExpBinOp) {
				CompValu left   = GenerateFromTypeExp (val, ((TokenTypeExpBinOp)typeExp).leftOp);
				CompValu right  = GenerateFromTypeExp (val, ((TokenTypeExpBinOp)typeExp).rightOp);
				CompValu result = new CompValuTemp (tokenTypeBool, null, this);
				Token op = ((TokenTypeExpBinOp)typeExp).binOp;
				result.PopPre (this);
				left.PushVal (this);
				right.PushVal (this);
				if (op is TokenKwAnd) {
					ilGen.Emit (OpCodes.And);
				} else if (op is TokenKwOr) {
					ilGen.Emit (OpCodes.Or);
				} else {
					throw new Exception ("unknown TokenTypeExpBinOp " + op.GetType ());
				}
				result.PopPost (this);
				return result;
			}
			if (typeExp is TokenTypeExpNot) {
				CompValu interm = GenerateFromTypeExp (val, ((TokenTypeExpNot)typeExp).typeExp);
				CompValu result = new CompValuTemp (tokenTypeBool, null, this);
				result.PopPre (this);
				interm.PushVal (this, tokenTypeBool);
				PushConstantI4 (1);
				ilGen.Emit (OpCodes.Xor);
				result.PopPost (this);
				return result;
			}
			if (typeExp is TokenTypeExpPar) {
				return GenerateFromTypeExp (val, ((TokenTypeExpPar)typeExp).typeExp);
			}
			if (typeExp is TokenTypeExpType) {
				CompValu result = new CompValuTemp (tokenTypeBool, null, this);
				result.PopPre (this);
				val.PushVal (this);
				ilGen.Emit (OpCodes.Isinst, ((TokenTypeExpType)typeExp).typeToken.ToSysType ());
				ilGen.Emit (OpCodes.Ldnull);
				ilGen.Emit (OpCodes.Ceq);
				PushConstantI4 (1);
				ilGen.Emit (OpCodes.Xor);
				result.PopPost (this);
				return result;
			}
			if (typeExp is TokenTypeExpUndef) {
				CompValu result = new CompValuTemp (tokenTypeBool, null, this);
				result.PopPre (this);
				val.PushVal (this);
				ilGen.Emit (OpCodes.Ldnull);
				ilGen.Emit (OpCodes.Ceq);
				result.PopPost (this);
				return result;
			}
			throw new Exception ("unknown TokenTypeExp type " + typeExp.GetType ());
		}

		/**
		 * @brief Push the default (null) value for a particular variable
		 * @param var = variable to get the default value for
		 * @returns with value pushed on stack
		 */
		public void PushVarDefaultValue (TokenDeclVar var)
		{
			TokenType type = var.type;
			if (type is TokenTypeArray) {
				PushXMRInst ();                // instance
				PushConstantI4 (var.line);     // source line in file
				PushConstantI4 (var.posn);     // source posn in line
				ilGen.Emit (OpCodes.Newobj, xmrArrayConstructorInfo);
				return;
			}
			if (type is TokenTypeList) {
				PushConstantI4 (0);
				ilGen.Emit (OpCodes.Newarr, typeof (object));
				ilGen.Emit (OpCodes.Newobj, lslListConstructorInfo);
				return;
			}
			if (type is TokenTypeRot) {
				// Mono is tOO stOOpid to allow: ilGen.Emit (OpCodes.Ldsfld, zeroRotationFieldInfo);
				ilGen.Emit (OpCodes.Ldc_R8, ScriptBaseClass.ZERO_ROTATION.x);
				ilGen.Emit (OpCodes.Ldc_R8, ScriptBaseClass.ZERO_ROTATION.y);
				ilGen.Emit (OpCodes.Ldc_R8, ScriptBaseClass.ZERO_ROTATION.z);
				ilGen.Emit (OpCodes.Ldc_R8, ScriptBaseClass.ZERO_ROTATION.s);
				ilGen.Emit (OpCodes.Newobj, lslRotationConstructorInfo);
				return;
			}
			if (type is TokenTypeStr) {
				ilGen.Emit (OpCodes.Ldstr, "");
				return;
			}
			if (type is TokenTypeVec) {
				// Mono is tOO stOOpid to allow: ilGen.Emit (OpCodes.Ldsfld, zeroVectorFieldInfo);
				ilGen.Emit (OpCodes.Ldc_R8, ScriptBaseClass.ZERO_VECTOR.x);
				ilGen.Emit (OpCodes.Ldc_R8, ScriptBaseClass.ZERO_VECTOR.y);
				ilGen.Emit (OpCodes.Ldc_R8, ScriptBaseClass.ZERO_VECTOR.z);
				ilGen.Emit (OpCodes.Newobj, lslVectorConstructorInfo);
				return;
			}
			if (type is TokenTypeInt) {
				PushConstantI4 (0);
				return;
			}
			if (type is TokenTypeFloat) {
				ilGen.Emit (OpCodes.Ldc_R4, 0.0f);
				return;
			}

			/*
			 * Default for 'object' type is 'undef'.
			 * Likewise for script-defined classes and interfaces.
			 */
			if ((type is TokenTypeObject) || (type is TokenTypeSDTypeClass) || (type is TokenTypeSDTypeInterface)) {
				ilGen.Emit (OpCodes.Ldnull);
				return;
			}

			/*
			 * Void is pushed as the default return value of a void function.
			 * So just push nothing as expected of void functions.
			 */
			if (type is TokenTypeVoid) {
				return;
			}

			/*
			 * Default for 'delegate' type is 'undef'.
			 */
			if (type is TokenTypeSDTypeDelegate) {
				ilGen.Emit (OpCodes.Ldnull);
				return;
			}

			throw new Exception ("unknown type " + type.ToString ());
		}

		/**
		 * @brief Determine if the expression has a constant boolean value
		 *        and if so, if the value is true or false.
		 * @param expr = expression to evaluate
		 * @returns true: expression is contant and has boolean value true
		 *         false: otherwise
		 */
		private bool IsConstBoolExprTrue (TokenRVal expr)
		{
			bool constVal;
			return IsConstBoolExpr (expr, out constVal) && constVal;
		}

		private bool IsConstBoolExpr (TokenRVal expr, out bool constVal)
		{
			if (expr is TokenRValConst) {
				object val = ((TokenRValConst)expr).val;
				if (val is SCRIPTFLOAT) {
					constVal = (SCRIPTFLOAT)val != 0.0;
					return true;
				}
				if (val is int) {
					constVal = (int)val != 0.0;
					return true;
				}
			}

			constVal = false;
			return false;
		}

		/**
		 * @brief Determine if the expression has a constant integer value
		 *        and if so, return the integer value.
		 * @param expr = expression to evaluate
		 * @returns true: expression is contant and has integer value
		 *         false: otherwise
		 */
		private bool IsConstIntExpr (TokenRVal expr, out int constVal)
		{
			if (expr is TokenRValConst) {
				object val = ((TokenRValConst)expr).val;
				if (val is SCRIPTFLOAT) {
					constVal = (int)(SCRIPTFLOAT)val;
					return true;
				}
				if (val is int) {
					constVal = (int)val;
					return true;
				}
			}

			constVal = 0;
			return false;
		}

		/**
		 * @brief create table of legal event handler prototypes.
		 *        This is used to make sure script's event handler declrations are valid.
		 */
		private static VarDict CreateLegalEventHandlers ()
		{
			/*
			 * Get handler prototypes with full argument lists.
			 */
			VarDict leh = new InternalFuncDict (typeof (IEventHandlers), false);

			/*
			 * We want the scripts to be able to declare their handlers with
			 * fewer arguments than the full argument lists.  So define additional 
			 * prototypes with fewer arguments.
			 */
			TokenDeclVar[] fullArgProtos = new TokenDeclVar[leh.Count];
			int i = 0;
			foreach (TokenDeclVar fap in leh) fullArgProtos[i++] = fap;

			foreach (TokenDeclVar fap in fullArgProtos) {
				TokenArgDecl fal = fap.argDecl;
				int fullArgCount = fal.types.Length;
				for (i = 0; i < fullArgCount; i ++) {
					TokenArgDecl shortArgList = new TokenArgDecl (null);
					shortArgList.names = new TokenName[i];
					shortArgList.types = new TokenType[i];
					for (int j = 0; j < i; j ++) {
						shortArgList.names[j] = fal.names[j];
						shortArgList.types[j] = fal.types[j];
					}
					TokenDeclVar shortArgProto = new TokenDeclVar (null, null, null);
					shortArgProto.retType      = fap.retType;
					shortArgProto.argDecl      = shortArgList;
					shortArgProto.funcNameSig  = new TokenName (null, fap.GetSimpleName () + shortArgList.GetArgSig ());
					leh.AddEntry (shortArgProto);
				}
			}

			return leh;
		}

		/**
		 * @brief Push an integer constant
		 */
		public void PushConstantI4 (int c)
		{
			switch (c) {
				case -1: {
					ilGen.Emit (OpCodes.Ldc_I4_M1);
					return;
				}
				case 0: {
					ilGen.Emit (OpCodes.Ldc_I4_0);
					return;
				}
				case 1: {
					ilGen.Emit (OpCodes.Ldc_I4_1);
					return;
				}
				case 2: {
					ilGen.Emit (OpCodes.Ldc_I4_2);
					return;
				}
				case 3: {
					ilGen.Emit (OpCodes.Ldc_I4_3);
					return;
				}
				case 4: {
					ilGen.Emit (OpCodes.Ldc_I4_4);
					return;
				}
				case 5: {
					ilGen.Emit (OpCodes.Ldc_I4_5);
					return;
				}
				case 6: {
					ilGen.Emit (OpCodes.Ldc_I4_6);
					return;
				}
				case 7: {
					ilGen.Emit (OpCodes.Ldc_I4_7);
					return;
				}
				case 8: {
					ilGen.Emit (OpCodes.Ldc_I4_8);
					return;
				}
				default: break;
			}
			if ((c >= 0) && (c <= 127)) {  // negatives dont seem to work
				ilGen.Emit (OpCodes.Ldc_I4_S, c);
				return;
			}
			ilGen.Emit (OpCodes.Ldc_I4, c);
		}

		/**
		 * @brief Emit a call to CheckRun(), (voluntary multitasking switch)
		 */
		public void EmitCallCheckRun (int line)
		{
			new CallLabel (this);                           // jump here when stack restored
			PushXMRInst ();                                 // instance
			PushConstantI4 (line);                          // source line number
			ilGen.Emit (OpCodes.Call, checkRunMethodInfo);  // instance.CheckRun()
		}

		/**
		 * @brief Maintain list of current function's local variables so we can keep track
		 *        of heap usage.  We don't have to keep track of stack usage as that is done
		 *        entirely within CheckRun().  Do not include arrays as they do their own heap tracking.
		 */
		private void NewLocalVariable (TokenDeclVar var)
		{
			if ((var.type is TokenTypeList) ||
			    (var.type is TokenTypeStr)) {
				TokenDeclVar htVar = new TokenDeclVar (var, null, tokenScript);
				htVar.type         = new TokenTypeInt (var);
				htVar.name         = new TokenName (var, "__htl_" + var.name.val);
				htVar.location     = new CompValuTemp (htVar.type, htVar.name.val, this);
				var.heapTracker    = htVar;
				DebitHeapLeft (var, false, var);
			}
		}

		/**
		 * @brief A variable was just assigned a value.  If the variable references heap,
		 *        debit the instance.heapLeft to make sure the script doesn't hog memory.
		 * @param var = instance, local or global variable
		 * @param stValid = false: heapTracker contains garbage, so don't bother adding it back first
		 *                   true: heapTracker contains previous debit quantity, so add it back first
		 * @param where = token giving location in source code of assignment for tracing/debug
		 */
		private void DebitHeapLeft (TokenDeclVar var, bool stValid, Token where)
		{
			/*
			 * See if the variable is heap tracked
			 * and if so, output call to check heap usage.
			 */
			TokenDeclVar htVar = var.heapTracker;
			if (htVar != null) {
				CompValu heapTracker = htVar.location;
				heapTracker.PopPre (this);
				
				PushXMRInst ();                                       // instance

				var.location.PushVal (this);                          // object we care about

				if (stValid) {
					heapTracker.PushVal (this);                   // previously debited amount or ...
				} else {
					PushConstantI4 (0);                           // 0 because nothing debited before
				}

				PushConstantI4 (where.line);
				PushConstantI4 (where.posn);

				ilGen.Emit (OpCodes.Call, updateHeapLeftMethodInfo);  // update instance.heapLeft
				                                                      // throws exception if not enuf left

				heapTracker.PopPost (this);                           // new debited amount
			}
		}

		/**
		 * @brief A function is about to return, so credit any debits on heapLeft by its local variables.
		 */
		private void CreditAllLocalsHeapLeft ()
		{
			bool first = true;

			foreach (TokenDeclVar localVar in curDeclFunc.localVars) {
				TokenDeclVar htLocalVar = localVar.heapTracker;
				if (htLocalVar == null) continue;

				CompValu heapTracker = htLocalVar.location;
				if (first) {
					PushXMRInst ();                                  // instance
					ilGen.Emit (OpCodes.Ldflda, heapLeftFieldInfo);  // &instance.heapLeft
					heapTracker.PushVal (this);                      // numberOfBytes subtracted from heapLeft
					first = false;
				} else {
					heapTracker.PushVal (this);                      // numberOfBytes subtracted from heapLeft
					ilGen.Emit (OpCodes.Add);                        // add them back to heapLeft
				}
			}
			if (!first) {
				ilGen.Emit (OpCodes.Call, interlockedAddMethodInfo);     // ...atomically
				ilGen.Emit (OpCodes.Pop);                                // we don't need return value
			}
		}

		/**
		 * @brief maintain variable definition stack.
		 * It translates a variable name string to its declaration.
		 */
		private VarDict PushVarDefnBlock ()
		{
			VarDict frame = new VarDict ();
			scriptVariablesStack.Push (frame);
			return frame;
		}
		private void PopVarDefnBlock ()
		{
			scriptVariablesStack.Pop ();
		}
		private void AddVarDefinition (TokenDeclVar var)
		{
			VarDict vars = scriptVariablesStack.Peek ();
			if (!vars.AddEntry (var)) {
				string name = var.name.val;
				if (var.funcNameSig != null) name = var.funcNameSig.val;
				ErrorMsg (var, "duplicate definition " + name);
			}
		}

		/**
		 * @brief handle a unary operator, such as -x.
		 */
		private CompValu UnOpGenerate (CompValu inRVal, Token opcode)
		{
			/*
			 * - Negate
			 */
			if (opcode is TokenKwSub) {
				if (inRVal.type is TokenTypeFloat) {
					CompValu outRVal = new CompValuTemp (new TokenTypeFloat (opcode), null, this);
					outRVal.PopPre (this);                // set up for a pop
					inRVal.PushVal (this, outRVal.type);  // push value to negate, make sure not LSL-boxed
					ilGen.Emit (OpCodes.Neg);             // compute the negative
					outRVal.PopPost (this);               // pop into result
					return outRVal;                       // tell caller where we put it
				}
				if (inRVal.type is TokenTypeInt) {
					CompValu outRVal = new CompValuTemp (new TokenTypeInt (opcode), null, this);
					outRVal.PopPre (this);                // set up for a pop
					inRVal.PushVal (this, outRVal.type);  // push value to negate, make sure not LSL-boxed
					ilGen.Emit (OpCodes.Neg);             // compute the negative
					outRVal.PopPost (this);               // pop into result
					return outRVal;                       // tell caller where we put it
				}
				if (inRVal.type is TokenTypeVec) {
					CompValu outRVal = new CompValuTemp (inRVal.type, null, this);
					outRVal.PopPre (this);                // set up for a pop
					inRVal.PushVal (this);                // push vector, then call negate routine
					ilGen.Emit (OpCodes.Call, lslVectorNegateMethodInfo);
					outRVal.PopPost (this);               // pop into result
					return outRVal;                       // tell caller where we put it
				}
				ErrorMsg (opcode, "can't negate a " + inRVal.type.ToString ());
				return inRVal;
			}

			/*
			 * ~ Complement (bitwise integer)
			 */
			if (opcode is TokenKwTilde) {
				if (inRVal.type is TokenTypeInt) {
					CompValu outRVal = new CompValuTemp (new TokenTypeInt (opcode), null, this);
					outRVal.PopPre (this);                // set up for a pop
					inRVal.PushVal (this, outRVal.type);  // push value to negate, make sure not LSL-boxed
					ilGen.Emit (OpCodes.Not);             // compute the complement
					outRVal.PopPost (this);               // pop into result
					return outRVal;                       // tell caller where we put it
				}
				ErrorMsg (opcode, "can't complement a " + inRVal.type.ToString ());
				return inRVal;
			}

			/*
			 * ! Not (boolean)
			 *
			 * We stuff the 0/1 result in an int because I've seen x+!y in scripts
			 * and we don't want to have to create tables to handle int+bool and
			 * everything like that.
			 */
			if (opcode is TokenKwExclam) {
				CompValu outRVal = new CompValuTemp (new TokenTypeInt (opcode), null, this);
				outRVal.PopPre (this);                 // set up for a pop
				inRVal.PushVal (this, tokenTypeBool);  // anything converts to boolean
				PushConstantI4 (1);                    // then XOR with 1 to flip it
				ilGen.Emit (OpCodes.Xor);
				outRVal.PopPost (this);                // pop into result
				return outRVal;                        // tell caller where we put it
			}

			throw new Exception ("unhandled opcode " + opcode.ToString ());
		}

		/**
		 * @brief This is called while trying to compute the value of constant initializers.
		 *        It is passed a name and that name is looked up in the constant tables.
		 */
		private TokenRVal LookupInitConstants (TokenRVal rVal, ref bool didOne)
		{
			/*
			 * If it is a static field of a script-defined type, look it up and hopefully we find a constant there.
			 */
			TokenDeclVar gblVar;
			if (rVal is TokenLValSField) {
				TokenLValSField lvsf = (TokenLValSField)rVal;
				if (lvsf.baseType is TokenTypeSDTypeClass) {
					TokenDeclSDTypeClass sdtClass = ((TokenTypeSDTypeClass)lvsf.baseType).decl;
					gblVar = sdtClass.members.FindExact (lvsf.fieldName.val, null);
					if (gblVar != null) {
						if (gblVar.constant && (gblVar.init is TokenRValConst)) {
							didOne = true;
							return gblVar.init;
						}
					}
				}
				return rVal;
			}

			/*
			 * Only other thing we handle is stand-alone names.
			 */
			if (!(rVal is TokenLValName)) return rVal;
			string name = ((TokenLValName)rVal).name.val;

			/*
			 * If we are doing the initializations for a script-defined type,
			 * look for the constant among the fields for that type.
			 */
			if (currentSDTClass != null) {
				gblVar = currentSDTClass.members.FindExact (name, null);
				if (gblVar != null) {
					if (gblVar.constant && (gblVar.init is TokenRValConst)) {
						didOne = true;
						return gblVar.init;
					}
					return rVal;
				}
			}

			/*
			 * Look it up as a script-defined global variable.
			 * Then if the variable is defined as a constant and has a constant value,
			 * we are successful.  If it is defined as something else, return failure.
			 */
			gblVar = tokenScript.vars.FindExact (name, null);
			if (gblVar != null) {
				if (gblVar.constant && (gblVar.init is TokenRValConst)) {
					didOne = true;
					return gblVar.init;
				}
				return rVal;
			}

			/*
			 * Maybe it is a built-in symbolic constant.
			 */
			ScriptConst scriptConst = ScriptConst.Lookup (name);
			if (scriptConst != null) {
				CompValu val = scriptConst.rVal;
				if (val is CompValuFloat)   rVal = new TokenRValConst (rVal, ((CompValuFloat)val).x);
				if (val is CompValuInteger) rVal = new TokenRValConst (rVal, ((CompValuInteger)val).x);
				if (val is CompValuString)  rVal = new TokenRValConst (rVal, ((CompValuString)val).x);
				if (rVal is TokenRValConst) {
					didOne = true;
					return rVal;
				}
			}

			/*
			 * Don't know what it is, return failure.
			 */
			return rVal;
		}

		/**
		 * @brief This is called while trying to compute the value of constant initializers.
		 *        It is passed a name and that name is looked up in the constant tables.
		 */
		private TokenRVal LookupBodyConstants (TokenRVal rVal, ref bool didOne)
		{
			/*
			 * If it is a static field of a script-defined type, look it up and hopefully we find a constant there.
			 */
			TokenDeclVar gblVar;
			if (rVal is TokenLValSField) {
				TokenLValSField lvsf = (TokenLValSField)rVal;
				if (lvsf.baseType is TokenTypeSDTypeClass) {
					TokenDeclSDTypeClass sdtClass = ((TokenTypeSDTypeClass)lvsf.baseType).decl;
					gblVar = sdtClass.members.FindExact (lvsf.fieldName.val, null);
					if ((gblVar != null) && gblVar.constant && (gblVar.init is TokenRValConst)) {
						didOne = true;
						return gblVar.init;
					}
				}
				return rVal;
			}

			/*
			 * Only other thing we handle is stand-alone names.
			 */
			if (!(rVal is TokenLValName)) return rVal;
			string name = ((TokenLValName)rVal).name.val;

			/*
			 * Scan through the variable stack and hopefully we find a constant there.
			 * But we stop as soon as we get a match because that's what the script is referring to.
			 */
			CompValu val;
			foreach (VarDict vars in scriptVariablesStack) {
				TokenDeclVar var = vars.FindExact (name, null);
				if (var != null) {
					val = var.location;
					goto foundit;
				}
			}

			/*
			 * Maybe it is a built-in symbolic constant.
			 */
			ScriptConst scriptConst = ScriptConst.Lookup (name);
			if (scriptConst != null) {
				val = scriptConst.rVal;
				goto foundit;
			}

			/*
			 * Don't know what it is, return failure.
			 */
			return rVal;

			/*
			 * Found a CompValu.  If it's a simple constant, then use it.
			 * Otherwise tell caller we failed to simplify.
			 */
		foundit:
			if (val is CompValuFloat)   rVal = new TokenRValConst (rVal, ((CompValuFloat)val).x);
			if (val is CompValuInteger) rVal = new TokenRValConst (rVal, ((CompValuInteger)val).x);
			if (val is CompValuString)  rVal = new TokenRValConst (rVal, ((CompValuString)val).x);
			if (rVal is TokenRValConst) {
				didOne = true;
			}
			return rVal;
		}

		/**
		 * @brief Generate code to push XMR_Instance pointer on stack.
		 */
		public void PushXMRInst ()
		{
			// for everything except script-defined class instance methods,
			// arg 0 holds the XMR_Instance pointer
			ilGen.Emit (OpCodes.Ldarg_0);

			if (IsSDTInstMethod ()) {

				// for script-defined class instance methods,
				// arg 0 holds the XMRSDTypeClassInstance pointer
				// and so we read the XMR_Instance pointer from
				// its XMRSDTypeClassInstance.xmrInst field
				ilGen.Emit (OpCodes.Ldfld, sdtXMRInstFieldInfo);
			}
		}

		/**
		 * @returns true: Ldarg_0 gives XMRSDTypeClassInstance pointer
		 *                - this is the case for instance methods
		 *         false: Ldarg_0 gives XMR_Instance pointer
		 *                - this is the case for both global functions and static methods
		 */
		public bool IsSDTInstMethod ()
		{
			return (curDeclFunc.sdtClass != null) && 
			       ((curDeclFunc.sdtFlags & ScriptReduce.SDT_STATIC) == 0);
		}

		/**
		 * @brief Look for a single member that matches the given name and argument signature
		 * @param where = which dictionary to look in
		 * @param name = basic name of the field or method, eg, "Printable"
		 * @param argsig = argument types the method is being called with, eg, "(string)"
		 *                 or null to find a field
		 * @returns null: no member found
		 *          else: the member found
		 */
		private TokenDeclVar FindSingleMember (VarDict where, TokenName name, TokenType[] argsig)
		{
			TokenDeclVar[] members = where.FindCallables (name.val, argsig);
			if (members == null) return null;
			if (members.Length > 1) {
				ErrorMsg (name, "more than one matching member");
				for (int i = 0; i < members.Length; i ++) {
					ErrorMsg (members[i], "  " + members[i].argDecl.GetArgSig ());
				}
			}
			CheckAccess (members[0]);
			return members[0];
		}

		/**
		 * @brief Find an exact function name and argument signature match.
		 *        Also verify that the return value type is an exact match.
		 * @param where = which method dictionary to look in
		 * @param name = basic name of the method, eg, "Printable"
		 * @param ret = expected return value type
		 * @param argsig = argument types the method is being called with, eg, "(string)"
		 * @returns null: no exact match found
		 *          else: the matching function
		 */
		private TokenDeclVar FindExactWithRet (VarDict where, TokenName name, TokenType ret, TokenType[] argsig)
		{
			TokenDeclVar func = where.FindExact (name.val, argsig);
			if ((func != null) && (func.retType.ToString () != ret.ToString ())) {
				ErrorMsg (name, "return type mismatch, have " + func.retType.ToString () + ", expect " + ret.ToString ());
			}
			if (func != null) CheckAccess (func);
			return func;
		}

		/**
		 * @brief Check the private/protected/public access flags of a member.
		 */
		private void CheckAccess (TokenDeclVar var)
		{
			if ((var.sdtFlags & ScriptReduce.SDT_PRIVATE) != 0) {
				if (curDeclFunc.sdtClass != var.sdtClass) {
					ErrorMsg (var, "member private to class " + var.sdtClass.name.val);
				}
			}
			if ((var.sdtFlags & ScriptReduce.SDT_PROTECTED) != 0) {
				for (TokenDeclSDTypeClass sdtc = curDeclFunc.sdtClass; sdtc != var.sdtClass; sdtc = sdtc.extends) {
					if (sdtc == null) {
						ErrorMsg (var, "member protected by class " + var.sdtClass.name.val);
						break;
					}
				}
			}
		}

		/**
		 * @brief Convert a list of argument types to printable string, eg, "(list,string,float,integer)"
		 *        If given a null, return "" indicating it is a field not a method
		 */
		private static string ArgSigString (TokenType[] argsig)
		{
			if (argsig == null) return "";
			StringBuilder sb = new StringBuilder ("(");
			for (int i = 0; i < argsig.Length; i ++) {
				if (i > 0) sb.Append (",");
				sb.Append (argsig[i].ToString ());
			}
			sb.Append (")");
			return sb.ToString ();
		}

		/**
		 * @brief output error message and remember that we did
		 */
		public void ErrorMsg (Token token, string message)
		{
			if ((token == null) || (token.emsg == null)) token = errorMessageToken;
			token.ErrorMsg (message);
			youveAnError = true;
		}

		/**
		 * @brief Find a private static method.
		 * @param owner = class the method is part of
		 * @param name = name of method to find
		 * @param args = array of argument types
		 * @returns pointer to method
		 */
		public static MethodInfo GetStaticMethod (Type owner, string name, Type[] args)
		{
			MethodInfo mi = owner.GetMethod (name, BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic, null, args, null);
			if (mi == null) {
				throw new Exception ("undefined method " + owner.ToString () + "." + name);
			}
			return mi;
		}

		public static LSL_Vector LSLVectorNegate (LSL_Vector v) { return -v; }

		/**
		 * @brief Called at runtime to convert the string given by the script in a throw statement to an exception.
		 */
		public static Exception ThrowStrToExc (string msg)
		{
			return new ScriptThrownException (msg);
		}

		/**
		 * @brief Called at runtime to convert a caught exception to the string given to the catch clause.
		 *        If we return null, the script's catch clause will do a rethrow before letting the script see it.
		 */
		public static string CatchExcToStr (Exception exc)
		{
			if (exc is IXMRUncatchable) return null;
			return exc.ToString ();
		}

		/**
		 * @brief An heap referencing variable was just set to a new object so we need to
		 *        update instance.heapLeft to reflect the new amount of heap available
		 *        to the script.
		 * @param instance = script instance who's heap usage is being updated
		 * @param value = object pointer value that was just written
		 * @param oldHeapUse = what was previously debited by the variable that was just written
		 * @returns amount being debited by the new assignment
		 *          instance.heapLeft = adjusted to reflect new heap avaialbe to script
		 * Throws exception if the new value exceeds available amount.
		 */
		public static int UpdateHeapLeft (XMRInstAbstract instance, object value, int oldHeapUse, int srcLine, int srcPosn)
		{
			int newHeapUse = 0;

			     if (value is XMR_Array)  newHeapUse = ((XMR_Array)value).Size;
			else if (value is LSL_List)   newHeapUse = ((LSL_List)value).Size;
			else if (value is LSL_String) newHeapUse = ((LSL_String)value).Length * 2 + 24;
			else if (value is string)     newHeapUse = ((string)value).Length * 2 + 24;

			int heapNeeded  = newHeapUse - oldHeapUse;
			int newHeapLeft = Interlocked.Add (ref instance.heapLeft, -heapNeeded);
			int oldHeapLeft = newHeapLeft + heapNeeded;
			if (newHeapLeft < 0) {
				GC.Collect ();
				GC.WaitForPendingFinalizers ();  // in case XMR_Array can give anything back
				if (instance.heapLeft < 0) {
					throw new OutOfHeapException (heapNeeded, oldHeapLeft, srcLine, srcPosn);
				}
			}

			if (instance.traceHeapUse != null) {
				Console.WriteLine("traceHeapUse: {0} {1}.{2}: old={3} new={4} left={5}", 
					instance.traceHeapUse, srcLine, srcPosn, oldHeapUse, newHeapUse, instance.heapLeft);
			}

			return newHeapUse;
		}

		/**
		 * @brief Defines an internal label that is used as a target for 'break' and 'continue' statements.
		 */
		private class BreakContTarg {
			public ScriptMyLabel label;
			public bool used;
			public BreakContTarg (ScriptMyILGen ilGen, string name) {
				label = ilGen.DefineLabel (name);  // label to be used
				used  = false;                     // assume it isn't referenced at all
			}
		}

		/**
		 * @brief Convert 'objFileReader' format to 'scriptObjCode' format.
		 *   'objFileReader' is a serialized form of the CIL code we generated
		 *   'asmFileWriter' is where we write the disassembly to (or null if not wanted)
		 *   'scriptObjCode' is an in-memory object with methods filled in from the CIL code
		 * Throws an exception if there is any error (theoretically).
		 */
		public static ScriptObjCode PerformGeneration (string descName,
		                                               BinaryReader objFileReader, 
		                                               TextWriter asmFileWriter)
		{
			/*
			 * Check version number to make sure we know how to process file contents.
			 */
			char[] ocm = objFileReader.ReadChars (OBJECT_CODE_MAGIC.Length);
			if (new String (ocm) != OBJECT_CODE_MAGIC) {
				throw new Exception ("not an XMR object file (bad magic)");
			}
			int cvv = objFileReader.ReadInt32 ();
			if (cvv != COMPILED_VERSION_VALUE) {
				throw new Exception ("object version is " + cvv.ToString () + 
				                     " but accept only " + COMPILED_VERSION_VALUE.ToString ());
			}

			/*
			 * Fill in simple parts of scriptObjCode object.
			 */
			ScriptObjCode scriptObjCode   = new ScriptObjCode ();
			scriptObjCode.expiryDays      = objFileReader.ReadInt32 ();
			scriptObjCode.numGblArrays    = objFileReader.ReadInt32 ();
			scriptObjCode.numGblFloats    = objFileReader.ReadInt32 ();
			scriptObjCode.numGblIntegers  = objFileReader.ReadInt32 ();
			scriptObjCode.numGblLists     = objFileReader.ReadInt32 ();
			scriptObjCode.numGblObjects   = objFileReader.ReadInt32 ();
			scriptObjCode.numGblRotations = objFileReader.ReadInt32 ();
			scriptObjCode.numGblStrings   = objFileReader.ReadInt32 ();
			scriptObjCode.numGblVectors   = objFileReader.ReadInt32 ();
			scriptObjCode.numGblSDTClObjs = objFileReader.ReadInt32 ();

			int nStates = objFileReader.ReadInt32 ();

			scriptObjCode.stateNames = new string[nStates];
			for (int i = 0; i < nStates; i ++) {
				scriptObjCode.stateNames[i] = objFileReader.ReadString ();
				if (asmFileWriter != null) {
					asmFileWriter.WriteLine ("  state[{0}] = {1}", i, scriptObjCode.stateNames[i]);
				}
			}

			if (asmFileWriter != null) {
				asmFileWriter.WriteLine ("  numGblArrays     {0}", scriptObjCode.numGblArrays);
				asmFileWriter.WriteLine ("  numGblFloats     {0}", scriptObjCode.numGblFloats);
				asmFileWriter.WriteLine ("  numGblIntegers   {0}", scriptObjCode.numGblIntegers);
				asmFileWriter.WriteLine ("  numGblLists      {0}", scriptObjCode.numGblLists);
				asmFileWriter.WriteLine ("  numGblObjects    {0}", scriptObjCode.numGblObjects);
				asmFileWriter.WriteLine ("  numGblRotations  {0}", scriptObjCode.numGblRotations);
				asmFileWriter.WriteLine ("  numGblStrings    {0}", scriptObjCode.numGblStrings);
				asmFileWriter.WriteLine ("  numGblVectors    {0}", scriptObjCode.numGblVectors);
				asmFileWriter.WriteLine ("  numGblSDTClObjs  {0}", scriptObjCode.numGblSDTClObjs);
			}

			string gblName;
			while ((gblName = objFileReader.ReadString ()) != "") {
				string gblType = objFileReader.ReadString ();
				int gblIndex = objFileReader.ReadInt32 ();
				if (asmFileWriter != null) {
					asmFileWriter.WriteLine ("  {0} = {1}[{2}]", gblName, gblType, gblIndex);
				}
			}

			/*
			 * Read in script-defined types.
			 */
			scriptObjCode.sdObjTypes = new Dictionary<string, TokenDeclSDType> ();
			while ((gblName = objFileReader.ReadString ()) != "") {
				TokenDeclSDType sdt = TokenDeclSDType.ReadFromFile (scriptObjCode.sdObjTypes, 
				                                      gblName, objFileReader, asmFileWriter);
				scriptObjCode.sdObjTypes.Add (gblName, sdt);
			}

			/*
			 * Now fill in the methods (the hard part).
			 */
			EndMethodWrapper endMethodWrapper     = new EndMethodWrapper ();
			endMethodWrapper.scriptObjCode        = scriptObjCode;
			endMethodWrapper.descName             = descName;
			scriptObjCode.scriptEventHandlerTable = new ScriptEventHandler[nStates,(int)ScriptEventCode.Size];
			scriptObjCode.dynamicMethods          = new Dictionary<string, DynamicMethod> ();
			ScriptMyILGen.CreateObjCode (scriptObjCode.sdObjTypes, objFileReader, endMethodWrapper.EndMethod, asmFileWriter);

			/*
			 * We enter all script event handler methods in the ScriptEventHandler table.
			 * They are named:  __seh_<statenumber>_<eventnumber>_<bunchofstuffwedontcareabout>
			 */
			foreach (KeyValuePair<string, DynamicMethod> kvp in scriptObjCode.dynamicMethods) {
				string methName = kvp.Key;
				if (methName.StartsWith ("__seh_")) {
					int j = methName.IndexOf ('_', 6);      // terminates <statenumber>
					int k = methName.IndexOf ('_', j + 1);  // terminates <eventnumber>
					int stateCode = Int32.Parse (methName.Substring (6, j - 6));
					int eventCode = Int32.Parse (methName.Substring (j + 1, k - j - 1));
					scriptObjCode.scriptEventHandlerTable[stateCode,eventCode] = 
							(ScriptEventHandler)kvp.Value.CreateDelegate (typeof (ScriptEventHandler));
				}
			}

			/*
			 * Fill in all script-defined class vtables.
			 */
			foreach (KeyValuePair<string, TokenDeclSDType> kvp in scriptObjCode.sdObjTypes) {
				TokenDeclSDType sdt = kvp.Value;
				if (sdt is TokenDeclSDTypeClass) {
					TokenDeclSDTypeClass sdtc = (TokenDeclSDTypeClass)sdt;
					sdtc.FillVTables (scriptObjCode);
				}
			}

			return scriptObjCode;
		}

		/**
		 * @brief Called once for every method found in objFileReader file.
		 *        It enters the method in the ScriptObjCode object table so it can be called.
		 */
		private class EndMethodWrapper {
			public ScriptObjCode scriptObjCode;
			public string descName;

			public void EndMethod (DynamicMethod method)
			{
				scriptObjCode.dynamicMethods.Add (method.Name, method);
			}
		}
	}

	/**
	 * @brief Marker interface indicates an exception that can't be caught by a script-level try/catch.
	 */
	public interface IXMRUncatchable { }

	/**
	 * @brief Thrown by a script when it attempts to change to an undefined state.
	 * These can be detected at compile time but the moron XEngine compiles
	 * such things, so we compile them as runtime errors.
	 */
	public class ScriptUndefinedStateException : Exception {
		public string stateName;
		public ScriptUndefinedStateException (string stateName) : base ("undefined state " + stateName) {
			this.stateName = stateName;
		}
	}

	/**
	 * @brief Thrown by a script when it attempts to change to a defined state.
	 */
	public class ScriptChangeStateException : Exception, IXMRUncatchable {
		public int newState;
		public ScriptChangeStateException (int newState) {
			this.newState = newState;
		}
	}

	/**
	 * @brief Thrown by a script from a 'throw' statement.
	 */
	public class ScriptThrownException : Exception {
		public ScriptThrownException (string msg) : base (msg) { }
	}

	public class OutOfHeapException : Exception {
		public OutOfHeapException(int heapNeeded, int heapLeft, int srcLine, int srcPosn)
			: base ("need " + heapNeeded + ", have only " + heapLeft + 
				" heap bytes left at " + srcLine + ":" + srcPosn)
		{ }
	}
	public class OutOfStackException : Exception { }

	public class ScriptBadCallNoException : Exception {
		public ScriptBadCallNoException (int callNo) : base ("bad callNo " + callNo) { }
	}
}
