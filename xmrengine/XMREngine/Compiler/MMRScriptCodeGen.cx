/********************************************************\
 *  COPYRIGHT 2009,2010, Mike Rieker, Beverly, MA, USA  *
 *  All rights reserved.                                *
\********************************************************/

using OpenSim.Region.ScriptEngine.Shared.ScriptBase;
using OpenSim.Region.ScriptEngine.XMREngine;
using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Reflection.Emit;
using System.Text;
using System.Threading;

#include "lsltypes.h"

/**
 * @brief translate a reduced script token into corresponding CIL code.
 * The single script token contains a tokenized and textured version of the whole script file.
 */

namespace OpenSim.Region.ScriptEngine.XMREngine
{

	public class ScriptCodeGen
	{
		public static readonly string OBJECT_CODE_MAGIC = "XMRObjectCode";
		public static int COMPILED_VERSION_VALUE = 16;  // incremented when compiler changes for compatibility testing

		public static readonly int CALL_FRAME_MEMUSE = 64;
		public static readonly int STRING_LEN_TO_MEMUSE = 2;

		public static Exception outOfStackException = new OutOfStackException ();

		/*
		 * Static tables that there only needs to be one copy of for all.
		 */
		private static VarDict inlineFunctions = TokenDeclInline.CreateDictionary ();
		private static VarDict legalEventHandlers = CreateLegalEventHandlers ();
		private static CompValu[]      zeroCompValus = new CompValu[0];
		private static TokenType[]     zeroArgs      = new TokenType[0];
		private static TokenTypeBool   tokenTypeBool = new TokenTypeBool   (null);
		private static TokenTypeFloat  tokenTypeFlt  = new TokenTypeFloat  (null);
		private static TokenTypeInt    tokenTypeInt  = new TokenTypeInt    (null);
		private static TokenTypeObject tokenTypeObj  = new TokenTypeObject (null);
		private static TokenTypeRot    tokenTypeRot  = new TokenTypeRot    (null);
		private static TokenTypeStr    tokenTypeStr  = new TokenTypeStr    (null);
		private static TokenTypeVec    tokenTypeVec  = new TokenTypeVec    (null);
		private static Type[] instanceTypeArg = new Type[] { typeof (XMRInstAbstract) };

		private static ConstructorInfo lslFloatConstructorInfo = typeof (LSL_Float).GetConstructor (new Type[] { typeof (SCRIPTFLOAT) });
		private static ConstructorInfo lslIntegerConstructorInfo = typeof (LSL_Integer).GetConstructor (new Type[] { typeof (int) });
		private static ConstructorInfo lslListConstructorInfo = typeof (LSL_List).GetConstructor (new Type[] { typeof (object[]) });
		public  static ConstructorInfo lslRotationConstructorInfo = typeof (LSL_Rotation).GetConstructor (new Type[] { typeof (double), typeof (double), typeof (double), typeof (double) });
		private static ConstructorInfo lslStringConstructorInfo = typeof (LSL_String).GetConstructor (new Type[] { typeof (string) });
		public  static ConstructorInfo lslVectorConstructorInfo = typeof (LSL_Vector).GetConstructor (new Type[] { typeof (double), typeof (double), typeof (double) });
		private static ConstructorInfo scriptBadCallNoExceptionConstructorInfo = typeof (ScriptBadCallNoException).GetConstructor (new Type[] { typeof (int) });
		private static ConstructorInfo scriptChangeStateExceptionConstructorInfo = typeof (ScriptChangeStateException).GetConstructor (new Type[] { typeof (int) });
		private static ConstructorInfo scriptUndefinedStateExceptionConstructorInfo = typeof (ScriptUndefinedStateException).GetConstructor (new Type[] { typeof (string) });
		private static ConstructorInfo sdtClassConstructorInfo = typeof (XMRSDTypeClObj).GetConstructor (new Type[] { typeof (XMRInstAbstract), typeof (int) });
		private static ConstructorInfo xmrArrayConstructorInfo = typeof (XMR_Array).GetConstructor (new Type[] { typeof (XMRInstAbstract), typeof (int), typeof (int) });
		private static FieldInfo callModeFieldInfo     = typeof (XMRInstAbstract).GetField ("callMode");
		private static FieldInfo doGblInitFieldInfo    = typeof (XMRInstAbstract).GetField ("doGblInit");
		private static FieldInfo ehArgsFieldInfo       = typeof (XMRInstAbstract).GetField ("ehArgs");
		public  static FieldInfo heapLeftFieldInfo     = typeof (XMRInstAbstract).GetField ("heapLeft");
		private static FieldInfo heapLimitFieldInfo    = typeof (XMRInstAbstract).GetField ("heapLimit");
		private static FieldInfo rotationXFieldInfo    = typeof (LSL_Rotation).GetField ("x");
		private static FieldInfo rotationYFieldInfo    = typeof (LSL_Rotation).GetField ("y");
		private static FieldInfo rotationZFieldInfo    = typeof (LSL_Rotation).GetField ("z");
		private static FieldInfo rotationSFieldInfo    = typeof (LSL_Rotation).GetField ("s");
		private static FieldInfo sdtXMRInstFieldInfo   = typeof (XMRSDTypeClObj).GetField ("xmrInst");
		private static FieldInfo vectorXFieldInfo      = typeof (LSL_Vector).GetField ("x");
		private static FieldInfo vectorYFieldInfo      = typeof (LSL_Vector).GetField ("y");
		private static FieldInfo vectorZFieldInfo      = typeof (LSL_Vector).GetField ("z");

		private static MethodInfo arrayClearMethodInfo = typeof (XMR_Array).GetMethod ("__pub_clear", new Type[] { });
		private static MethodInfo arrayCountMethodInfo = typeof (XMR_Array).GetMethod ("__pub_count", new Type[] { });
		private static MethodInfo arrayIndexMethodInfo = typeof (XMR_Array).GetMethod ("__pub_index", new Type[] { typeof (int) });
		private static MethodInfo arrayValueMethodInfo = typeof (XMR_Array).GetMethod ("__pub_value", new Type[] { typeof (int) });
		private static MethodInfo checkRunMethodInfo   = typeof (XMRInstAbstract).GetMethod ("CheckRun", new Type[] { typeof (int) });
		private static MethodInfo ehArgUnwrapFloat     = GetStaticMethod (typeof (TypeCast), "EHArgUnwrapFloat",    new Type[] { typeof (object) });
		private static MethodInfo ehArgUnwrapInteger   = GetStaticMethod (typeof (TypeCast), "EHArgUnwrapInteger",  new Type[] { typeof (object) });
		private static MethodInfo ehArgUnwrapRotation  = GetStaticMethod (typeof (TypeCast), "EHArgUnwrapRotation", new Type[] { typeof (object) });
		private static MethodInfo ehArgUnwrapString    = GetStaticMethod (typeof (TypeCast), "EHArgUnwrapString",   new Type[] { typeof (object) });
		private static MethodInfo ehArgUnwrapVector    = GetStaticMethod (typeof (TypeCast), "EHArgUnwrapVector",   new Type[] { typeof (object) });
		private static MethodInfo forEachMethodInfo    = typeof (XMR_Array).GetMethod ("ForEach", 
		                                                                               new Type[] { typeof (int),
		                                                                                            typeof (object).MakeByRefType (),
		                                                                                            typeof (object).MakeByRefType () });
		private static MethodInfo captureStackFrameMethodInfo = typeof (XMRInstAbstract).GetMethod ("CaptureStackFrame", new Type[] { typeof (string), typeof (int), typeof (int) });
		private static MethodInfo restoreStackFrameMethodInfo = typeof (XMRInstAbstract).GetMethod ("RestoreStackFrame", new Type[] { typeof (string), typeof (int).MakeByRefType () });
		private static MethodInfo interlockedAddMethodInfo    = GetStaticMethod (typeof (Interlocked), "Add", new Type[] { typeof (int).MakeByRefType (), typeof (int) });
		private static MethodInfo updateHeapLeftMethodInfo = GetStaticMethod (typeof (ScriptCodeGen), 
		                                                                      "UpdateHeapLeft", 
		                                                                      new Type[] { typeof (XMRInstAbstract),
		                                                                                   typeof (object),
		                                                                                   typeof (int),
		                                                                                   typeof (int),
		                                                                                   typeof (int) });
		private static MethodInfo lslVectorNegateMethodInfo = GetStaticMethod (typeof (ScriptCodeGen), 
		                                                                       "LSLVectorNegate", 
		                                                                       new Type[] { typeof (LSL_Vector) });
		private static MethodInfo throwStrToExcMethodInfo = GetStaticMethod (typeof (ScriptCodeGen),
		                                                                     "ThrowStrToExc",
		                                                                     new Type[] { typeof (string) });
		private static MethodInfo catchExcToStrMethodInfo = GetStaticMethod (typeof (ScriptCodeGen),
		                                                                     "CatchExcToStr",
		                                                                     new Type[] { typeof (Exception) });

		public static bool CodeGen (TokenScript tokenScript, BinaryWriter objFileWriter, string sourceHash)
		{
			/*
			 * Run compiler such that it has a 'this' context for convenience.
			 */
			ScriptCodeGen scg = new ScriptCodeGen (tokenScript, objFileWriter, sourceHash);

			/*
			 * Return pointer to resultant script object code.
			 */
			return !scg.youveAnError;
		}

		/*
		 * There is one set of these variables for each script being compiled.
		 */
		private bool mightGetHere = false;
		private bool youveAnError = false;
		private BreakContTarg curBreakTarg = null;
		private BreakContTarg curContTarg  = null;
		private int lastErrorLine = 0;
		private int nStates = 0;
		private string sourceHash;
		private string lastErrorFile = "";
		private Token errorMessageToken = null;
		private TokenDeclVar curDeclFunc = null;
		private TokenStmtBlock curStmtBlock = null;
		private BinaryWriter objFileWriter = null;
		private TokenScript tokenScript = null;
		public  int tempCompValuNum = 0;
		private TokenDeclSDTypeClass currentSDTClass = null;

		private Dictionary<string, int> stateIndices = null;

		// code generation output
		public ScriptObjCode scriptObjCode = null;

		// These get cleared at beginning of every function definition
		public  ScriptMyILGen ilGen    = null;  // the output instruction stream
		private ScriptMyLabel retLabel = null;  // where to jump to exit function
		private ScriptMyLocal retValue = null;
		private ScriptMyLocal callNo   = null;
		private LinkedList<CallLabel> allCallLabels = new LinkedList<CallLabel> ();
		private List<ScriptMyLocal> activeTemps = new List<ScriptMyLocal> ();

		private ScriptCodeGen (TokenScript tokenScript, BinaryWriter objFileWriter, string sourceHash)
		{
			this.tokenScript   = tokenScript;
			this.objFileWriter = objFileWriter;
			this.sourceHash    = sourceHash;

			try {
				PerformCompilation ();
			} catch {
				// if we've an error, just punt on any exception
				// it's probably just a null reference from something
				// not being filled in etc.
				if (!youveAnError) throw;
			} finally {
				objFileWriter = null;
				scriptObjCode = null;
			}
		}

		/**
		 * @brief Convert 'tokenScript' to 'objFileWriter' format.
		 *   'tokenScript' is a parsed/reduced abstract syntax tree of the script source file
		 *   'objFileWriter' is a serialized form of the CIL code that we generate
		 * Note:  The scriptObjCode herein is only temporary and is discarded on return.
		 *        Use PerformGeneration() to create the 'real' one.
		 */
		private void PerformCompilation ()
		{

			/*
			 * errorMessageToken is used only when the given token doesn't have a
			 * output delegate associated with it such as for backend API functions
			 * that only have one copy for the whole system.  It is kept up-to-date
			 * approximately but is rarely needed so going to assume it doesn't have 
			 * to be exact.
			 */
			errorMessageToken = tokenScript;

			/*
			 * Set up dictionary to translate state names to their index number.
			 */
			stateIndices = new Dictionary<string, int> ();

			/*
			 * Assign each state its own unique index.
			 * The default state gets 0.
			 */
			nStates = 0;
			tokenScript.defaultState.body.index = nStates ++;
			stateIndices.Add ("default", 0);
			foreach (KeyValuePair<string, TokenDeclState> kvp in tokenScript.states) {
				TokenDeclState declState = kvp.Value;
				declState.body.index = nStates ++;
				stateIndices.Add (declState.name.val, declState.body.index);
			}

			/*
			 * Make up an array that translates state indices to state name strings.
			 */
			scriptObjCode = new ScriptObjCode ();
			scriptObjCode.stateNames = new string[nStates];
			scriptObjCode.stateNames[0] = "default";
			foreach (KeyValuePair<string, TokenDeclState> kvp in tokenScript.states) {
				TokenDeclState declState = kvp.Value;
				scriptObjCode.stateNames[declState.body.index] = declState.name.val;
			}

			/*
			 * Make sure we have delegates for all script-defined functions and methods,
			 * creating anonymous ones if needed.
			 */
			foreach (TokenDeclVar declFunc in tokenScript.variablesStack) {
				if (declFunc.retType != null) {
					declFunc.GetDelType ();
				}
			}
			while (true) {
				bool itIsAGoodDayToDie = true;
				try {
					foreach (TokenDeclSDType sdType in tokenScript.sdSrcTypesValues) {
						itIsAGoodDayToDie = false;
						if (sdType is TokenDeclSDTypeClass) {
							TokenDeclSDTypeClass sdtClass = (TokenDeclSDTypeClass)sdType;
							foreach (TokenDeclVar declFunc in sdtClass.members) {
								if (declFunc.retType != null) {
									declFunc.GetDelType ();
									if (declFunc.funcNameSig.val.StartsWith ("$ctor(")) {
										// this is for the "$new()" static method that we create below.
										// See GenerateStmtNewobj() etc.
										new TokenTypeSDTypeDelegate (declFunc, sdtClass.MakeRefToken (declFunc), 
												declFunc.argDecl.types, tokenScript);
									}
								}
							}
						}
						if (sdType is TokenDeclSDTypeInterface) {
							TokenDeclSDTypeInterface sdtIFace = (TokenDeclSDTypeInterface)sdType;
							foreach (TokenDeclVar declFunc in sdtIFace.methProtos) {
								declFunc.GetDelType ();
							}
						}
						itIsAGoodDayToDie = true;
					}
					break;
				} catch (InvalidOperationException) {
					if (!itIsAGoodDayToDie) throw;
					// fetching the delegate created an anonymous entry in tokenScript.sdSrcTypesValues
					// which made the foreach statement puque, so start over...
				}
			}

			/*
			 * No more types can be defined or we won't be able to write them to the object file.
			 */
			tokenScript.sdSrcTypesSeal ();

			/*
			 * Assign all global variables a slot in its corresponding XMRInstance.gbl<Type>s[] array.
			 * Global variables are simply elements of those arrays at runtime, thus we don't need to create
			 * an unique class for each script, we can just use XMRInstance as is for all.
			 */
			foreach (TokenDeclVar declVar in tokenScript.variablesStack) {

				/*
				 * Omit 'constant' variables as they are coded inline so don't need a slot.
				 */
				if (declVar.constant) continue;

				/*
				 * Do functions later.
				 */
				if (declVar.retType != null) continue;

				/*
				 * Create entry in the value array for the variable.
				 */
				declVar.location = new CompValuGlobalVar (declVar, scriptObjCode);

				/*
				 * If it references heap, add it to list of global vars that reference heap.  We use 
				 * this list to maintain instance.heapLeft to keep track of how much heap script is 
				 * allowed to use.  Do not include arrays as they do their own heap tracking.
				 */
				if ((declVar.type is TokenTypeList) ||
				    (declVar.type is TokenTypeStr)) {
					TokenDeclVar htDeclVar = new TokenDeclVar (declVar, null, tokenScript);
					htDeclVar.type = new TokenTypeInt (declVar);
					htDeclVar.name = new TokenName (declVar, "__htg_" + declVar.name.val);
					htDeclVar.location = new CompValuGlobalVar (htDeclVar, scriptObjCode);
					declVar.heapTracker = htDeclVar;
				}
			}

			/*
			 * Likewise for any static fields in script-defined classes.
			 * They can be referenced anywhere by <typename>.<fieldname>, see 
			 * GenerateFromLValSField().
			 */
			foreach (TokenDeclSDType sdType in tokenScript.sdSrcTypesValues) {
				if (!(sdType is TokenDeclSDTypeClass)) continue;
				TokenDeclSDTypeClass sdtClass = (TokenDeclSDTypeClass)sdType;

				foreach (TokenDeclVar declVar in sdtClass.members) {

					/*
					 * Omit 'constant' variables as they are coded inline so don't need a slot.
					 */
					if (declVar.constant) continue;

					/*
					 * Do methods later.
					 */
					if (declVar.retType != null) continue;

					/*
					 * Ignore non-static fields for now.
					 * They get assigned below.
					 */
					if ((declVar.sdtFlags & ScriptReduce.SDT_STATIC) == 0) continue;

					/*
					 * Create entry in the value array for the field.
					 */
					declVar.location = new CompValuGlobalVar (declVar, scriptObjCode);

					/*
					 * If it references heap, add it to list of global vars that reference heap.  We use 
					 * this list to maintain instance.heapLeft to keep track of how much heap script is 
					 * allowed to use.  Do not include arrays as they do their own heap tracking.
					 */
					if ((declVar.type is TokenTypeList) ||
					    (declVar.type is TokenTypeStr)) {
						TokenDeclVar htDeclVar = new TokenDeclVar (declVar, null, tokenScript);
						htDeclVar.type = new TokenTypeInt (declVar);
						htDeclVar.name = new TokenName (declVar, "__hts_" + declVar.name.val);
						htDeclVar.location = new CompValuGlobalVar (htDeclVar, scriptObjCode);
						declVar.heapTracker = htDeclVar;
					}
				}
			}

			/*
			 * Assign slots for all interface method prototypes.
			 * These indices are used to index the array of delegates that holds a class' implementation of an 
			 * interface.
			 */
			foreach (TokenDeclSDType sdType in tokenScript.sdSrcTypesValues) {
				if (!(sdType is TokenDeclSDTypeInterface)) continue;
				TokenDeclSDTypeInterface sdtIFace = (TokenDeclSDTypeInterface)sdType;
				int vti = 0;
				foreach (TokenDeclVar im in sdtIFace.methProtos) {
					im.vTableIndex = vti ++;
				}
			}

			/*
			 * Assign slots for all instance fields and virtual methods of script-defined types.
			 */
			int maxExtends = tokenScript.sdSrcTypesCount;
			bool didOne;
			do {
				didOne = false;
				foreach (TokenDeclSDType sdType in tokenScript.sdSrcTypesValues) {
					if (!(sdType is TokenDeclSDTypeClass)) continue;
					TokenDeclSDTypeClass sdtClass = (TokenDeclSDTypeClass)sdType;
					if (sdtClass.slotsAssigned) continue;

					/*
					 * If this class extends another, the extended class has to already 
					 * be set up, because our slots add on to the end of the extended class.
					 */
					TokenDeclSDTypeClass extends = sdtClass.extends;
					if (extends != null) {
						if (!extends.slotsAssigned) continue;
						sdtClass.instSizes     = extends.instSizes;
						sdtClass.numVirtFuncs  = extends.numVirtFuncs;
						sdtClass.numInterfaces = extends.numInterfaces;

						int n = maxExtends;
						for (TokenDeclSDTypeClass ex = extends; ex != null; ex = ex.extends) {
							if (-- n < 0) break;
						}
						if (n < 0) {
							ErrorMsg (sdtClass, "loop in extended classes");
							sdtClass.slotsAssigned = true;
							continue;
						}
					}

					/*
					 * Extended class's slots all assigned, assign our instance fields 
					 * slots in the XMRSDTypeClObj arrays.
					 */
					foreach (TokenDeclVar declVar in sdtClass.members) {
						if (declVar.retType != null) continue;
						if (declVar.constant) continue;
						if ((declVar.sdtFlags & ScriptReduce.SDT_STATIC) != 0) continue;
						declVar.type.AssignVarSlot (declVar, ref sdtClass.instSizes);
						if ((declVar.type is TokenTypeList) ||
						    (declVar.type is TokenTypeStr)) {
							TokenDeclVar htDeclVar = new TokenDeclVar (declVar, null, tokenScript);
							htDeclVar.type = new TokenTypeInt (declVar);
							htDeclVar.name = new TokenName (declVar, "__hti_" + declVar.name.val);
							htDeclVar.type.AssignVarSlot (htDeclVar, ref sdtClass.instSizes);
							declVar.heapTracker = htDeclVar;
						}
					}

					/*
					 * ... and assign virtual method vtable slots.
					 *
					 *                   - : error if any overridden method, doesn't need a slot
					 *            abstract : error if any overridden method, alloc new slot but leave it empty
					 *                 new : ignore any overridden method, doesn't need a slot
					 *        new abstract : ignore any overridden method, alloc new slot but leave it empty
					 *            override : must have overridden abstract/virtual, use old slot
					 *   override abstract : must have overridden abstract, use old slot but it is still empty
					 *              static : error if any overridden method, doesn't need a slot
					 *          static new : ignore any overridden method, doesn't need a slot
					 *             virtual : error if any overridden method, alloc new slot and fill it in
					 *         virtual new : ignore any overridden method, alloc new slot and fill it in
					 */
					foreach (TokenDeclVar declFunc in sdtClass.members) {
						if (declFunc.retType == null) continue;
						curDeclFunc = declFunc;

						/*
						 * See if there is a method in an extended class that this method overshadows.
						 * If so, check for various conflicts.
						 * In any case, SDT_NEW on our method means to ignore any overshadowed method.
						 */
						string declLongName = sdtClass.longName.val + "." + declFunc.funcNameSig.val;
						uint declFlags = declFunc.sdtFlags;
						TokenDeclVar overridden = null;
						if ((declFlags & ScriptReduce.SDT_NEW) == 0) {
							for (TokenDeclSDTypeClass sdtd = extends; sdtd != null; sdtd = sdtd.extends) {
								overridden = FindExactWithRet (sdtd.members, declFunc.name, declFunc.retType, declFunc.argDecl.types);
								if (overridden != null) break;
							}
						}
						if (overridden != null) do {
							string overLongName = overridden.sdtClass.longName.val;
							uint overFlags = overridden.sdtFlags;

							/*
							 * See if overridden method allows itself to be overridden.
							 */
							if ((overFlags & ScriptReduce.SDT_ABSTRACT) != 0) {
								if ((declFlags & (ScriptReduce.SDT_ABSTRACT | ScriptReduce.SDT_OVERRIDE)) == 0) {
									ErrorMsg (declFunc, declLongName + " overshadows abstract " + overLongName + " but is not marked abstract, new or override");
									break;
								}
							} else if ((overFlags & ScriptReduce.SDT_FINAL) != 0) {
								ErrorMsg (declFunc, declLongName + " overshadows final " + overLongName + " but is not marked new");
							} else if ((overFlags & (ScriptReduce.SDT_OVERRIDE | ScriptReduce.SDT_VIRTUAL)) != 0) {
								if ((declFlags & (ScriptReduce.SDT_NEW | ScriptReduce.SDT_OVERRIDE)) == 0) {
									ErrorMsg (declFunc, declLongName + " overshadows virtual " + overLongName + " but is not marked new or override");
									break;
								}
							} else {
								ErrorMsg (declFunc, declLongName + " overshadows non-virtual " + overLongName + " but is not marked new");
								break;
							}

							/*
							 * See if our method is capable of overriding the other method.
							 */
							if ((declFlags & ScriptReduce.SDT_ABSTRACT) != 0) {
								if ((overFlags & ScriptReduce.SDT_ABSTRACT) == 0) {
									ErrorMsg (declFunc, declLongName + " abstract overshadows non-abstract " + overLongName + " but is not marked new");
									break;
								}
							} else if ((declFlags & ScriptReduce.SDT_OVERRIDE) != 0) {
								if ((overFlags & (ScriptReduce.SDT_ABSTRACT | ScriptReduce.SDT_OVERRIDE | ScriptReduce.SDT_VIRTUAL)) == 0) {
									ErrorMsg (declFunc, declLongName + " override overshadows non-abstract/non-virtual " + overLongName);
									break;
								}
							} else {
								ErrorMsg (declFunc, declLongName + " overshadows " + overLongName + " but is not marked new");
								break;
							}
						} while (false);

						/*
						 * Now we can assign it a vtable slot if it needs one (ie, it is virtual).
						 */
						declFunc.vTableIndex = -1;
						if (overridden != null) {
							declFunc.vTableIndex = overridden.vTableIndex;
						} else if ((declFlags & ScriptReduce.SDT_OVERRIDE) != 0) {
							ErrorMsg (declFunc, declLongName + " marked override but nothing matching found that it overrides");
						}
						if ((declFlags & (ScriptReduce.SDT_ABSTRACT | ScriptReduce.SDT_VIRTUAL)) != 0) {
							declFunc.vTableIndex = sdtClass.numVirtFuncs ++;
						}
					}
					curDeclFunc = null;

					/*
					 * ... and assign implemented interface slots.
					 * Note that our implementations of a given interface is completely independent of any 
					 * rootward class's implementation of that same interface.
					 */
					int nIFaces        = sdtClass.numInterfaces + sdtClass.implements.Count;
					sdtClass.iFaces    = new TokenDeclSDTypeInterface[nIFaces];
					sdtClass.iImplFunc = new TokenDeclVar[nIFaces][];
					for (int i = 0; i < sdtClass.numInterfaces; i ++) {
						sdtClass.iFaces[i]    = extends.iFaces[i];
						sdtClass.iImplFunc[i] = extends.iImplFunc[i];
					}

					foreach (TokenDeclSDTypeInterface intf in sdtClass.implements) {
						int i = sdtClass.numInterfaces ++;
						sdtClass.iFaces[i] = intf;
						sdtClass.intfIndices.Add (intf.longName.val, i);
						int nMeths = intf.methProtos.Count;
						sdtClass.iImplFunc[i] = new TokenDeclVar[nMeths];
					}

					foreach (TokenDeclVar classMeth in sdtClass.members) {
						if (classMeth.retType == null) continue;
						curDeclFunc = classMeth;
						for (TokenIntfImpl intfImpl = classMeth.implements; intfImpl != null; intfImpl = (TokenIntfImpl)intfImpl.nextToken) {

							/*
							 * One of the class methods implements an interface method.
							 * Try to find the interface method that is implemented and verify its signature.
							 */
							TokenDeclSDTypeInterface intfType = intfImpl.intfType.decl;
							TokenDeclVar intfMeth = FindExactWithRet (intfType.methProtos, intfImpl.methName, classMeth.retType, classMeth.argDecl.types);
							if (intfMeth == null) {
								ErrorMsg (intfImpl, "interface does not define method " + intfImpl.methName.val + classMeth.argDecl.GetArgSig ());
								continue;
							}

							/*
							 * See if this class was declared to implement that interface.
							 */
							bool found = false;
							foreach (TokenDeclSDTypeInterface intf in sdtClass.implements) {
								if (intf == intfType) {
									found = true;
									break;
								}
							}
							if (!found) {
								ErrorMsg (intfImpl, "class not declared to implement " + intfType.longName.val);
								continue;
							}

							/*
							 * Get index in iFaces[] and iImplFunc[] arrays.
							 * Start scanning from the end in case one of our rootward classes also implements the interface.
							 * We should always be successful because we know by now that this class implements the interface.
							 */
							int i;
							for (i = sdtClass.numInterfaces; -- i >= 0;) {
								if (sdtClass.iFaces[i] == intfType) break;
							}

							/*
							 * Now remember which of the class methods implements that interface method.
							 */
							int j = intfMeth.vTableIndex;
							if (sdtClass.iImplFunc[i][j] != null) {
								ErrorMsg (intfImpl, "also implemented by " + sdtClass.iImplFunc[i][j].funcNameSig.val);
								continue;
							}
							sdtClass.iImplFunc[i][j] = classMeth;
						}
					}
					curDeclFunc = null;

					/*
					 * Now make sure this class implements all methods for all declared interfaces.
					 */
					for (int i = sdtClass.numInterfaces - sdtClass.implements.Count; i < sdtClass.numInterfaces; i ++) {
						TokenDeclVar[] implementations = sdtClass.iImplFunc[i];
						for (int j = implementations.Length; -- j >= 0;) {
							if (implementations[j] == null) {
								TokenDeclSDTypeInterface intf = sdtClass.iFaces[i];
								TokenDeclVar meth = null;
								foreach (TokenDeclVar im in intf.methProtos) {
									if (im.vTableIndex == j) {
										meth = im;
										break;
									}
								}
								ErrorMsg (sdtClass, "does not implement " + intf.longName.val + "." + meth.funcNameSig.val);
							}
						}
					}

					/*
					 * All slots for this class have been assigned.
					 */
					sdtClass.slotsAssigned = true;
					didOne = true;
				}
			} while (didOne);

			/*
			 * Compute final values for all variables/fields declared as 'constant'.
			 * Note that there may be forward references.
			 */
			do {
				didOne = false;
				foreach (TokenDeclVar tdv in tokenScript.variablesStack) {
					if (tdv.constant && !(tdv.init is TokenRValConst)) {
						tdv.init = tdv.init.TryComputeConstant (LookupInitConstants, ref didOne);
					}
				}
				foreach (TokenDeclSDType sdType in tokenScript.sdSrcTypesValues) {
					if (!(sdType is TokenDeclSDTypeClass)) continue;
					currentSDTClass = (TokenDeclSDTypeClass)sdType;
					foreach (TokenDeclVar tdv in currentSDTClass.members) {
						if (tdv.constant && !(tdv.init is TokenRValConst)) {
							tdv.init = tdv.init.TryComputeConstant (LookupInitConstants, ref didOne);
						}
					}
				}
				currentSDTClass = null;
			} while (didOne);

			/*
			 * Now we should be able to assign all those constants their type and location.
			 */
			foreach (TokenDeclVar tdv in tokenScript.variablesStack) {
				if (tdv.constant) {
					if (tdv.init is TokenRValConst) {
						TokenRValConst rvc = (TokenRValConst)tdv.init;
						tdv.type = rvc.tokType;
						tdv.location = rvc.GetCompValu ();
					} else {
						ErrorMsg (tdv, "value is not constant");
					}
				}
			}
			foreach (TokenDeclSDType sdType in tokenScript.sdSrcTypesValues) {
				if (!(sdType is TokenDeclSDTypeClass)) continue;
				currentSDTClass = (TokenDeclSDTypeClass)sdType;
				foreach (TokenDeclVar tdv in currentSDTClass.members) {
					if (tdv.constant) {
						if (tdv.init is TokenRValConst) {
							TokenRValConst rvc = (TokenRValConst)tdv.init;
							tdv.type = rvc.tokType;
							tdv.location = rvc.GetCompValu ();
						} else {
							ErrorMsg (tdv, "value is not constant");
						}
					}
				}
			}
			currentSDTClass = null;

			/*
			 * For all classes that define all the methods needed for the class, ie, they aren't abstract,
			 * define a static class.$new() method with same args as the $ctor(s).  This will allow the
			 * class to be instantiated via the new operator.
			 */
			foreach (TokenDeclSDType sdType in tokenScript.sdSrcTypesValues) {
				if (!(sdType is TokenDeclSDTypeClass)) continue;
				TokenDeclSDTypeClass sdtClass = (TokenDeclSDTypeClass)sdType;

				/*
				 * See if the class as it stands would be able to fill every slot of its vtable.
				 */
				bool[] filled = new bool[sdtClass.numVirtFuncs];
				int numFilled = 0;
				for (TokenDeclSDTypeClass sdtc = sdtClass; sdtc != null; sdtc = sdtc.extends) {
					foreach (TokenDeclVar tdf in sdtc.members) {
						if ((tdf.retType != null) && (tdf.vTableIndex >= 0) && ((tdf.sdtFlags & ScriptReduce.SDT_ABSTRACT) == 0)) {
							if (!filled[tdf.vTableIndex]) {
								filled[tdf.vTableIndex] = true;
								numFilled ++;
							}
						}
					}
				}

				/*
				 * If so, define a static class.$new() method for every constructor defined for the class.
				 * Give it the same access (private/protected/public) as the script declared for the constructor.
				 * Note that the reducer made sure there is at least a default constructor for every class.
				 */
				if (numFilled >= sdtClass.numVirtFuncs) {
					List<TokenDeclVar> newobjDeclFuncs = new List<TokenDeclVar> ();
					foreach (TokenDeclVar ctorDeclFunc in sdtClass.members) {
						if ((ctorDeclFunc.funcNameSig != null) && ctorDeclFunc.funcNameSig.val.StartsWith ("$ctor(")) {
							TokenDeclVar newobjDeclFunc = DefineNewobjFunc (ctorDeclFunc);
							newobjDeclFuncs.Add (newobjDeclFunc);
						}
					}
					foreach (TokenDeclVar newobjDeclFunc in newobjDeclFuncs) {
						sdtClass.members.AddEntry (newobjDeclFunc);
					}
				}
			}

			/*
			 * Write fixed portion of object file.
			 */
			objFileWriter.Write (OBJECT_CODE_MAGIC.ToCharArray ());
			objFileWriter.Write (COMPILED_VERSION_VALUE);
			objFileWriter.Write (sourceHash);
			objFileWriter.Write (tokenScript.expiryDays);
			scriptObjCode.glblSizes.WriteToFile (objFileWriter);

			objFileWriter.Write (nStates);
			for (int i = 0; i < nStates; i ++) {
				objFileWriter.Write (scriptObjCode.stateNames[i]);
			}

			/*
			 * For debugging, we also write out global variable array slot assignments.
			 */
			foreach (TokenDeclVar declVar in tokenScript.variablesStack) {
				if (declVar.retType == null) {
					WriteOutGblAssignment ("", declVar);
				}
			}
			foreach (TokenDeclSDType sdType in tokenScript.sdSrcTypesValues) {
				if (!(sdType is TokenDeclSDTypeClass)) continue;
				TokenDeclSDTypeClass sdtClass = (TokenDeclSDTypeClass)sdType;
				foreach (TokenDeclVar declVar in sdtClass.members) {
					if ((declVar.sdtFlags & ScriptReduce.SDT_STATIC) != 0) {
						WriteOutGblAssignment (sdtClass.longName.val + ".", declVar);
					}
				}
			}
			objFileWriter.Write ("");

			/*
			 * Write out script-defined types.
			 */
			foreach (TokenDeclSDType sdType in tokenScript.sdSrcTypesValues) {
				objFileWriter.Write (sdType.longName.val);
				sdType.WriteToFile (objFileWriter);
			}
			objFileWriter.Write ("");

			/*
			 * Output function headers then bodies.
			 * Do all headers first in case bodies do forward references.
			 * Do both global functions, script-defined class static methods and 
			 * script-defined instance methods, as we handle the differences
			 * during compilation of the functions/methods themselves.
			 */
			for (int pass = 0; pass < 2; pass ++) {
				foreach (TokenDeclVar declFunc in tokenScript.variablesStack) {
					if (declFunc.retType != null) {
						if (pass == 0) GenerateMethodHeader (declFunc);
						          else GenerateMethodBody   (declFunc);
					}
				}
				foreach (TokenDeclSDType sdType in tokenScript.sdSrcTypesValues) {
					if (sdType is TokenDeclSDTypeClass) {
						TokenDeclSDTypeClass sdtClass = (TokenDeclSDTypeClass)sdType;
						foreach (TokenDeclVar declFunc in sdtClass.members) {
							if ((declFunc.retType != null) && ((declFunc.sdtFlags & ScriptReduce.SDT_ABSTRACT) == 0)) {
								if (pass == 0) GenerateMethodHeader (declFunc);
								          else GenerateMethodBody   (declFunc);
							}
						}
					}
				}
			}

			/*
			 * Output default state event handler functions.
			 * Each event handler is a private static method named __seh_default_<eventname>.
			 * Splice in a default state_entry() handler if none defined so we can init global vars.
			 */
			TokenDeclVar defaultStateEntry = null;
			for (defaultStateEntry = tokenScript.defaultState.body.eventFuncs;
			     defaultStateEntry != null;
			     defaultStateEntry = (TokenDeclVar)defaultStateEntry.nextToken) {
				if (defaultStateEntry.funcNameSig.val == "state_entry()") break;
			}
			if (defaultStateEntry == null) {
				defaultStateEntry               = new TokenDeclVar   (tokenScript.defaultState.body, null, tokenScript);
				defaultStateEntry.name          = new TokenName      (tokenScript.defaultState.body, "state_entry");
				defaultStateEntry.retType       = new TokenTypeVoid  (tokenScript.defaultState.body);
				defaultStateEntry.argDecl       = new TokenArgDecl   (tokenScript.defaultState.body);
				defaultStateEntry.body          = new TokenStmtBlock (tokenScript.defaultState.body);
				defaultStateEntry.body.function = defaultStateEntry;

				defaultStateEntry.nextToken = tokenScript.defaultState.body.eventFuncs;
				tokenScript.defaultState.body.eventFuncs = defaultStateEntry;
			}
			GenerateStateEventHandlers ("default", tokenScript.defaultState.body);

			/*
			 * Output script-defined state event handler methods.
			 * Each event handler is a private static method named __seh_<statename>_<eventname>
			 */
			foreach (KeyValuePair<string, TokenDeclState> kvp in tokenScript.states) {
				TokenDeclState declState = kvp.Value;
				GenerateStateEventHandlers (declState.name.val, declState.body);
			}

			ScriptObjWriter.TheEnd (objFileWriter);

			scriptObjCode = null;
		}

		/**
		 * @brief Write out what slot was assigned for a global or sdtclass static variable.
		 *        Constants, functions, instance fields, methods do not have slots in the global variables arrays.
		 */
		private void WriteOutGblAssignment (string pfx, TokenDeclVar declVar)
		{
			if (!declVar.constant && (declVar.retType == null)) {
				CompValuGlobalVar gblVar = (CompValuGlobalVar)declVar.location;
				objFileWriter.Write (pfx + declVar.name.val);    // string
				objFileWriter.Write (declVar.vTableArray.Name);  // string
				objFileWriter.Write (declVar.vTableIndex);       // int
				TokenDeclVar htDeclVar = declVar.heapTracker;
				if (htDeclVar != null) {
					CompValu htGblVar = (CompValuGlobalVar)htDeclVar.location;
					objFileWriter.Write (pfx + htDeclVar.name.val);
					objFileWriter.Write (htDeclVar.vTableArray.Name);
					objFileWriter.Write (htDeclVar.vTableIndex);
				}
			}
		}

		/**
		 * @brief generate event handler code
		 * Writes out a function definition for each state handler
		 * named __seh_<statename>_<eventname>
		 *
		 * However, each has just 'XMRInstance __sw' as its single argument
		 * and each of its user-visible argments is extracted from __sw.ehArgs[].
		 *
		 * So we end up generating something like this:
		 *
		 *   private static void __seh_<statecode>_<eventcode>_<statename>_<eventname>(XMRInstance __sw)
		 *   {
		 *      <typeArg0> <nameArg0> = (<typeArg0>)__sw.ehArgs[0];
		 *      <typeArg1> <nameArg1> = (<typeArg1>)__sw.ehArgs[1];
		 *
		 *      ... script code ...
		 *   }
		 *
		 * The continuations code assumes there will be no references to ehArgs[]
		 * after the first call to CheckRun() as CheckRun() makes no attempt to
		 * serialize the ehArgs[] array, as doing so would be redundant.  Any values
		 * from ehArgs[] that are being used will be in local stack variables and
		 * thus preserved that way.
		 */
		private void GenerateStateEventHandlers (string statename, TokenStateBody body)
		{
			for (Token t = body.eventFuncs; t != null; t = t.nextToken) {
				GenerateEventHandler (statename, (TokenDeclVar)t);
			}
		}

		private void GenerateEventHandler (string statename, TokenDeclVar declFunc)
		{
			string eventname = declFunc.GetSimpleName ();
			TokenArgDecl argDecl = declFunc.argDecl;

			/*
			 * Make sure event handler name is valid and that number and type of arguments is correct.
			 * Apparently some scripts exist with fewer than correct number of args in their declaration 
			 * so allow for that.  It is ok because the handlers are called with the arguments in an
			 * object[] array, and we just won't access the missing argments in the vector.  But the 
			 * specified types must match one of the prototypes in legalEventHandlers.
			 */
			TokenDeclVar protoDeclFunc = legalEventHandlers.FindExact (eventname, argDecl.types);
			if (protoDeclFunc == null) {
				ErrorMsg (declFunc, "unknown event handler " + eventname + argDecl.GetArgSig ());
				return;
			}

			/*
			 * Output function header.
			 * They just have the XMRInstance pointer as the one argument.
			 */
			int statecode = stateIndices[statename];
			int eventcode = (int)Enum.Parse (typeof (ScriptEventCode), eventname);
			string functionName = "__seh_" + statecode.ToString() + "_" + eventcode.ToString () + "_" + 
			                                 statename + "_" + eventname;
			ilGen = new ScriptObjWriter (tokenScript, 
			                             functionName,
			                             typeof (void),
			                             instanceTypeArg,
			                             objFileWriter);
			StartFunctionBody (declFunc);

			/*
			 * Output args as variable definitions and initialize each from __sw.ehArgs[].
			 * If the script writer goofed, the typecast will complain.
			 */
			int nArgs = argDecl.vars.Length;
			for (int i = 0; i < nArgs; i ++) {

				/*
				 * Say that the argument variable is going to be located in a temp var.
				 */
				TokenDeclVar argVar = argDecl.vars[i];
				TokenType argTokType = argVar.type;
				CompValu local = new CompValuTemp (argTokType, argVar.name.val, this);
				argVar.location = local;

				/*
				 * Account for any heap usage by this local variable from now on to end of function.
				 */
				NewLocalVariable (argVar);

				/*
				 * Copy from the ehArgs[i] element to the temp var.
				 * Cast as needed, there is a lot of craziness like OpenMetaverse.Quaternion.
				 */
				local.PopPre (this, argVar.name);
				PushXMRInst ();                                // instance
				ilGen.Emit (OpCodes.Ldfld, ehArgsFieldInfo);   // instance.ehArgs (array of objects)
				ilGen.PushInt (i);                             // array index = i
				ilGen.Emit (OpCodes.Ldelem, typeof (object));  // select the argument we want
				TokenType stkTokType = tokenTypeObj;           // stack has a type 'object' on it now
				Type argSysType = argTokType.ToSysType ();     // this is the type the script expects
				if (argSysType == typeof (SCRIPTFLOAT)) {      // LSL_Float/SCRIPTFLOAT -> SCRIPTFLOAT
					ilGen.Emit (OpCodes.Call, ehArgUnwrapFloat);
					stkTokType = tokenTypeFlt;             // stack has a type 'SCRIPTFLOAT' on it now
				}
				if (argSysType == typeof (int)) {              // LSL_Integer/int -> int
					ilGen.Emit (OpCodes.Call, ehArgUnwrapInteger);
					stkTokType = tokenTypeInt;             // stack has a type 'int' on it now
				}
				if (argSysType == typeof (LSL_Rotation)) {     // OpenMetaverse.Quaternion/LSL_Rotation -> LSL_Rotation
					ilGen.Emit (OpCodes.Call, ehArgUnwrapRotation);
					stkTokType = tokenTypeRot;             // stack has a type 'LSL_Rotation' on it now
				}
				if (argSysType == typeof (string)) {           // LSL_Key/LSL_String/string -> string
					ilGen.Emit (OpCodes.Call, ehArgUnwrapString);
					stkTokType = tokenTypeStr;             // stack has a type 'string' on it now
				}
				if (argSysType == typeof (LSL_Vector)) {       // OpenMetaverse.Vector3/LSL_Vector -> LSL_Vector
					ilGen.Emit (OpCodes.Call, ehArgUnwrapVector);
					stkTokType = tokenTypeVec;             // stack has a type 'LSL_Vector' on it now
				}
				local.PopPost (this, argVar.name, stkTokType); // pop stack type into argtype
			}

			/*
			 * Output code for the statements and clean up.
			 */
			GenerateFuncBody ();
		}

		/**
		 * @brief generate header for an arbitrary script-defined global function.
		 * @param declFunc = function being defined
		 */
		private void GenerateMethodHeader (TokenDeclVar declFunc)
		{
			curDeclFunc = declFunc;

			/*
			 * Make up array of all argument types as seen by the code generator.
			 * We splice in XMRInstance or XMRSDTypeClObj for the first 
			 * arg as the function itself is static, followed by script-visible
			 * arg types.
			 */
			TokenArgDecl argDecl = declFunc.argDecl;
			int nArgs = argDecl.vars.Length;
			Type[] argTypes = new Type[nArgs+1];
			if (IsSDTInstMethod ()) {
				argTypes[0] = typeof (XMRSDTypeClObj);
			} else {
				argTypes[0] = typeof (XMRInstAbstract);
			}
			for (int i = 0; i < nArgs; i ++) {
				argTypes[i+1] = argDecl.vars[i].type.ToSysType ();
			}

			/*
			 * Set up entrypoint.
			 */
			string objCodeName = declFunc.GetObjCodeName ();
			declFunc.ilGen = new ScriptObjWriter (tokenScript, 
			                                      objCodeName,
			                                      declFunc.retType.ToSysType (),
			                                      argTypes,
			                                      objFileWriter);

			/*
			 * This says how to generate a call to the function and to get a delegate.
			 */
			declFunc.location = new CompValuGlobalMeth (declFunc);

			curDeclFunc = null;
		}

		/**
		 * @brief generate code for an arbitrary script-defined function.
		 * @param name = name of the function
		 * @param argDecl = argument declarations
		 * @param body = function's code body
		 */
		private void GenerateMethodBody (TokenDeclVar declFunc)
		{
			/*
			 * Set up code generator for the function's contents.
			 */
			ilGen = declFunc.ilGen;
			StartFunctionBody (declFunc);

			/*
			 * Define location of all script-level arguments so script body can access them.
			 * The argument indices need to have +1 added to them because XMRInstance or XMRSDTypeClObj 
			 * is spliced in at arg 0.  Account for their heap usage just like they were local variables.
			 */
			TokenArgDecl argDecl = declFunc.argDecl;
			int nArgs = argDecl.vars.Length;
			for (int i = 0; i < nArgs; i ++) {
				TokenDeclVar argVar = argDecl.vars[i];
				argVar.location = new CompValuArg (argVar.type, i + 1);
				NewLocalVariable (argVar);
			}

			/*
			 * Output code for the statements and clean up.
			 */
			GenerateFuncBody ();
		}

		private void StartFunctionBody (TokenDeclVar declFunc)
		{
			/*
			 * Start current function being processed.
			 * Set 'mightGetHere' as the code at the top is always executed.
			 */
			mightGetHere = true;
			curBreakTarg = null;
			curContTarg  = null;
			curDeclFunc  = declFunc;

			/*
			 * Start generating code.
			 */
			((ScriptObjWriter)ilGen).BegMethod ();
		}

		/**
		 * @brief Define function for a script-defined type's <typename>.$new(<argsig>) method.
		 *        See GenerateStmtNewobj() for more info.
		 */
		private TokenDeclVar DefineNewobjFunc (TokenDeclVar ctorDeclFunc)
		{
			/*
			 * Set up 'static classname $new(params-same-as-ctor) { }'.
			 */
			TokenDeclVar newobjDeclFunc = new TokenDeclVar (ctorDeclFunc, null, tokenScript);
			newobjDeclFunc.name         = new TokenName (newobjDeclFunc, "$new");
			newobjDeclFunc.retType      = ctorDeclFunc.sdtClass.MakeRefToken (newobjDeclFunc);
			newobjDeclFunc.argDecl      = ctorDeclFunc.argDecl;
			newobjDeclFunc.sdtClass     = ctorDeclFunc.sdtClass;
			newobjDeclFunc.sdtFlags     = ScriptReduce.SDT_STATIC | ctorDeclFunc.sdtFlags;

			/*
			 * Declare local variable named '$objptr' in a frame just under 
			 * what the '$new(...)' function's arguments are declared in.
			 */
			TokenDeclVar objptrVar = new TokenDeclVar (newobjDeclFunc, newobjDeclFunc, tokenScript);
			objptrVar.type         = newobjDeclFunc.retType;
			objptrVar.name         = new TokenName (newobjDeclFunc, "$objptr");
			VarDict newFrame       = new VarDict ();
			newFrame.outerVarDict  = ctorDeclFunc.argDecl.varDict;
			newFrame.AddEntry (objptrVar);

			/*
			 * Set up '$objptr.$ctor'
			 */
			TokenLValName objptrLValName  = new TokenLValName (objptrVar.name);    // ref a var by giving its name
			objptrLValName.stack          = newFrame;                              // what stack to look for it in
			TokenLValIField objptrDotCtor = new TokenLValIField (newobjDeclFunc);  // an instance member reference
			objptrDotCtor.baseRVal        = objptrLValName;                        // '$objptr'
			objptrDotCtor.fieldName       = ctorDeclFunc.name;                     // '.' '$ctor'

			/*
			 * Set up '$objptr.$ctor(arglist)' call for use in the '$new(...)' body.
			 * Copy the arglist from the constructor declaration so triviality 
			 * processing will pick the correct overloaded constructor.
			 */
			TokenRValCall callCtorRVal = new TokenRValCall (newobjDeclFunc);   // doing a call of some sort
			callCtorRVal.meth          = objptrDotCtor;                        // calling $objptr.$ctor()
			TokenDeclVar[] argList     = newobjDeclFunc.argDecl.vars;          // get args $new() was declared with
			callCtorRVal.nArgs         = argList.Length;                       // ...that is nArgs we are passing to $objptr.$ctor()
			for (int i = argList.Length; -- i >= 0;) {
				TokenDeclVar arg          = argList[i];                    // find out about one of the args
				TokenLValName argLValName = new TokenLValName (arg.name);  // pass arg of that name to $objptr.$ctor()
				argLValName.stack         = ctorDeclFunc.argDecl.varDict;  // this is the VarDict the arg names are defined in
				argLValName.nextToken     = callCtorRVal.args;             // link to list of args passed to $objptr.$ctor()
				callCtorRVal.args         = argLValName;
			}

			/*
			 * Set up a funky call to the constructor for the code body.
			 * This will let code generator know there is some craziness.
			 * See GenerateStmtNewobj().
			 *
			 * This is in essence:
			 *    {
			 *        classname $objptr = newobj (classname);
			 *        $objptr.$ctor (...);
			 *        return $objptr;
			 *    }
			 */
			TokenStmtNewobj newobjStmtBody = new TokenStmtNewobj (ctorDeclFunc);
			newobjStmtBody.objptrVar       = objptrVar;
			newobjStmtBody.rValCall        = callCtorRVal;
			TokenStmtBlock newobjBody      = new TokenStmtBlock (ctorDeclFunc);
			newobjBody.statements          = newobjStmtBody;

			/*
			 * Link that code as the body of the function.
			 */
			newobjDeclFunc.body = newobjBody;

			/*
			 * Say the function calls '$objptr.$ctor(arglist)' so we will inherit ctor's triviality.
			 */
			newobjDeclFunc.unknownTrivialityCalls.AddLast (callCtorRVal);
			return newobjDeclFunc;
		}

		private class TokenStmtNewobj : TokenStmt {
			public TokenDeclVar objptrVar;
			public TokenRValCall rValCall;
			public TokenStmtNewobj (Token original) : base (original) { }
		}

		/**
		 * @brief Output function body (either event handler or script-defined method).
		 */
		private void GenerateFuncBody ()
		{
			/*
			 * We want to know if the function's code is trivial, ie,
			 * if it doesn't have anything that might be an infinite 
			 * loop and that is doesn't call anything that might have 
			 * an infinite loop.  If it is, we don't need any CheckRun()
			 * stuff or any of the frame save/restore stuff.
			 */
			bool isTrivial = curDeclFunc.IsFuncTrivial (this);

			/*
			 * Clear list of all call labels.
			 * A call label is inserted just before every call that can possibly
			 * call CheckRun(), including any direct calls to CheckRun().
			 * Then, when restoring stack, we can just switch to this label to
			 * resume at the correct spot.
			 */
			allCallLabels.Clear ();

			/*
			 * Any return statements inside function body jump to this label
			 * after putting return value in __retval.
			 */
			retLabel = ilGen.DefineLabel ("__retlbl");
			retValue = null;
			if (!(curDeclFunc.retType is TokenTypeVoid)) {
				retValue = ilGen.DeclareLocal (curDeclFunc.retType.ToSysType (), "__retval");
			}

			/*
			 * Output:
			 *    int callNo;
			 *    if (instance.callMode != CALLMODE_NORMAL) goto __cmRestore;
			 */
			callNo = null;
			ScriptMyLabel cmRestore = null;
			if (!isTrivial) {
				callNo = ilGen.DeclareLocal (typeof (int), "__callNo");
				cmRestore = ilGen.DefineLabel ("__cmRestore");
				PushXMRInst ();
				if (XMRInstAbstract.CALLMODE_NORMAL != 0) throw new Exception ();
				ilGen.Emit (OpCodes.Ldfld, ScriptCodeGen.callModeFieldInfo);
				ilGen.Emit (OpCodes.Brtrue, cmRestore);
			}

			/*
			 * Catch exceptions thrown by script body and any initialization code.
			 */
			ilGen.BeginExceptionBlock ();

			/*
			 * Splice in the code optimizer for the body of the function.
			 */
			ScriptCollector collector = new ScriptCollector ((ScriptObjWriter)ilGen);
			ilGen = collector;

			/*
			 * If this is the default state_entry() handler, output code to set all global
			 * variables to their initial values.  Note that every script must have a
			 * default state_entry() handler, we provide one if the script doesn't explicitly
			 * define one.
			 */
			string methname = ilGen.methName;
			if (methname.StartsWith ("__seh_") && methname.EndsWith ("_default_state_entry")) {

				// if (!doGblInit) goto skipGblInit;
				ScriptMyLabel skipGblInitLabel = ilGen.DefineLabel ("__skipGblInit");
				PushXMRInst ();                                  // instance
				ilGen.Emit (OpCodes.Ldfld, doGblInitFieldInfo);  // instance.doGblInit
				ilGen.Emit (OpCodes.Brfalse, skipGblInitLabel);

				// heapLeft = heapLimit;
				PushXMRInst ();                                  // instance
				ilGen.Emit (OpCodes.Dup);
				ilGen.Emit (OpCodes.Ldfld, heapLimitFieldInfo);  // instance.heapLimit
				ilGen.Emit (OpCodes.Stfld, heapLeftFieldInfo);   // instance.heapLeft

				// $globalvarinit();
				if (tokenScript.globalVarInit.body.statements != null) {
					if (!tokenScript.globalVarInit.IsFuncTrivial (this)) {
						new CallLabel (this);
					}
					PushXMRInst ();
					ilGen.Emit (OpCodes.Call, tokenScript.globalVarInit.ilGen);
				}

				// doGblInit = 0;
				PushXMRInst ();                                  // instance
				ilGen.PushInt (0);
				ilGen.Emit (OpCodes.Stfld, doGblInitFieldInfo);  // instance.doGblInit

				//skipGblInit:
				ilGen.MarkLabel (skipGblInitLabel);
			}

			/*
			 * If this is a script-defined type constructor, call the base constructor and call
			 * this class's $instfieldinit() method to initialize instance fields.
			 */
			if ((curDeclFunc.sdtClass != null) && curDeclFunc.funcNameSig.val.StartsWith ("$ctor(")) {
				if (curDeclFunc.baseCtorCall != null) {
					GenerateFromRValCall (curDeclFunc.baseCtorCall);
				}
				TokenDeclVar ifiFunc = ((TokenDeclSDTypeClass)curDeclFunc.sdtClass).instFieldInit;
				if (ifiFunc.body.statements != null) {
					if (!ifiFunc.IsFuncTrivial (this)) {
						new CallLabel (this);
					}
					ilGen.Emit (OpCodes.Ldarg_0);
					ilGen.Emit (OpCodes.Call, ifiFunc.ilGen);
				}
			}

			/*
			 * Alloc stack space for local vars.
			 * Also allocates corresponding heap-tracker vars.
			 */
			AllocLocalVarStackSpace ();

			/*
			 * See if time to suspend in case they are doing a loop with recursion.
			 */
			if (!isTrivial) EmitCallCheckRun (curDeclFunc.line);

			/*
			 * Output code body.
			 */
			GenerateStmtBlock (curDeclFunc.body);

			/*
			 * If code falls through to this point, means they are missing 
			 * a return statement.  And that is legal only if the function 
			 * returns 'void'.
			 */
			if (mightGetHere) {
				if (!(curDeclFunc.retType is TokenTypeVoid)) {
					ErrorMsg (curDeclFunc.body, "missing final return statement");
				}
				ilGen.Emit (OpCodes.Leave, retLabel);
			}

			/*
			 * End of the code to be optimized.
			 * Do optimizations then write it all out to object file.
			 * After this, all code gets written directly to object file.
			 */
			collector.Optimize ();
			ilGen = collector.WriteOutAll ();
			collector = null;

			/*
			 * Output epilog that subtracts heap usage by local vars.
			 *
			 *   finally {
			 *      if (instance.callMode ! 0) goto __cmSave;
			 *      CreditAllLocalsHeapLeft();
			 *      goto __endFin;
			 *   __cmSave:
			 *      GenerateFrameCaptureCode();
			 *   __endFin:
			 *   }
			 */
			ilGen.BeginFinallyBlock ();
			ScriptMyLabel cmSave = null;
			ScriptMyLabel endFin = null;
			if (!isTrivial) {
				cmSave = ilGen.DefineLabel ("__cmSave");
				endFin = ilGen.DefineLabel ("__endFin");
				PushXMRInst ();
				ilGen.Emit (OpCodes.Ldfld, callModeFieldInfo);
				if (XMRInstAbstract.CALLMODE_NORMAL != 0) throw new Exception ();
				ilGen.Emit (OpCodes.Brtrue, cmSave);
			}
			CreditAllLocalsHeapLeft ();
			if (!isTrivial) {
				ilGen.Emit (OpCodes.Br, endFin);
				ilGen.MarkLabel (cmSave);
				GenerateFrameCaptureCode ();
				ilGen.MarkLabel (endFin);
			}
			ilGen.Emit (OpCodes.Endfinally);
			ilGen.EndExceptionBlock ();

			/*
			 * Output the 'real' return opcode.
			 */
			ilGen.MarkLabel (retLabel);
			if (!(curDeclFunc.retType is TokenTypeVoid)) {
				ilGen.Emit (OpCodes.Ldloc, retValue);
			}
			ilGen.Emit (OpCodes.Ret);
			retLabel = null;
			retValue = null;

			/*
			 * Output code to restore stack frame from stream.
			 */
			if (!isTrivial) {
				ilGen.MarkLabel (cmRestore);
				GenerateFrameRestoreCode ();
			}

			/*
			 * No more instructions for this method.
			 */
			((ScriptObjWriter)ilGen).EndMethod ();
			ilGen = null;

			/*
			 * Not generating function code any more.
			 */
			curBreakTarg = null;
			curContTarg  = null;
			curDeclFunc  = null;
		}

		/**
		 * @brief Allocate stack space and heap tracker for all local variables, regardless of
		 *        which { } statement block they are actually defined in.  This will allow the
		 *        heap trackers to keep track of any heap use within deeply nested blocks.
		 */
		private void AllocLocalVarStackSpace ()
		{
			foreach (TokenDeclVar localVar in curDeclFunc.localVars) {

				/*
				 * Skip all 'constant' vars as they were handled by the reducer.
				 */
				if (localVar.constant) continue;

				/*
				 * Get a stack location for it and fill in with default value.
				 */
				CompValu localLoc = new CompValuTemp (localVar.type, localVar.name.val, this);
				localVar.location = localLoc;
				localLoc.PopPre (this, localVar.name);
				PushVarDefaultValue (localVar);
				localLoc.PopPost (this, localVar.name);

				/*
				 * Set up heap-tracker variable and fill in with corresponding value for 
				 * the variable's default value.
				 */
				NewLocalVariable (localVar);
			}
		}

		/**
		 * @brief Generate code to write all arguments and locals to the capture stack frame.
		 *        This includes heap-tracker and temp variables.
		 *        We only need to save what is active at the point of callLabels through because 
		 *        those are the only points we will jump to on restore.  This saves us from saving 
		 *        all the little temp vars we create.
		 */
		private void GenerateFrameCaptureCode ()
		{
			/*
			 * Build list of locals and temps active at all the call labels.
			 */
			activeTemps.Clear ();
			foreach (CallLabel cl in allCallLabels) {
				foreach (ScriptMyLocal lcl in cl.callLabel.whereAmI.localsReadBeforeWritten) {
					if (!activeTemps.Contains (lcl)) {
						activeTemps.Add (lcl);
					}
				}
			}

			/*
			 * Compute total number of slots we need to save stuff.
			 * Assume we need to save all call arguments.
			 */
			int nSaves = curDeclFunc.argDecl.vars.Length + activeTemps.Count;

			/*
			 * Output code to allocate a stack frame object with an object array.
			 * This also pushes the stack frame object on the instance.stackFrames list.
			 * It returns a pointer to the object array it allocated.
			 */
			PushXMRInst ();
			ilGen.Emit (OpCodes.Ldstr, ilGen.methName);
			ilGen.Emit (OpCodes.Ldloc, callNo);
			ilGen.PushInt (nSaves);
			ilGen.Emit (OpCodes.Call, captureStackFrameMethodInfo);

			/*
			 * Copy arg values to object array, boxing as needed.
			 */
			int i = 0;
			foreach (TokenDeclVar argVar in curDeclFunc.argDecl.varDict) {
				ilGen.Emit (OpCodes.Dup);
				ilGen.PushInt (i);
				argVar.location.PushVal (this, argVar.name, tokenTypeObj);
				ilGen.Emit (OpCodes.Stelem_Ref);
				i ++;
			}

			/*
			 * Copy local and temp values to object array, boxing as needed.
			 */
			foreach (ScriptMyLocal lcl in activeTemps) {
				ilGen.Emit (OpCodes.Dup);
				ilGen.PushInt (i ++);
				ilGen.Emit (OpCodes.Ldloc, lcl);
				if (lcl.type.IsValueType) ilGen.Emit (OpCodes.Box, lcl.type);
				ilGen.Emit (OpCodes.Stelem_Ref);
			}

			ilGen.Emit (OpCodes.Pop);
		}

		/**
		 * @brief Generate code to restore all arguments and locals from the restore stack frame.
		 *        This includes heap-tracker and temp variables.
		 */
		private void GenerateFrameRestoreCode ()
		{
			ScriptMyLocal objArray = ilGen.DeclareLocal (typeof (object[]), "__restObjArray");

			/*
			 * Output code to pop stack frame from instance.stackFrames.
			 * It returns a pointer to the object array that contains values to be restored.
			 */
			PushXMRInst ();
			ilGen.Emit (OpCodes.Ldstr, ilGen.methName);
			ilGen.Emit (OpCodes.Ldloca, callNo);
			ilGen.Emit (OpCodes.Call, restoreStackFrameMethodInfo);
			ilGen.Emit (OpCodes.Stloc, objArray);

			/*
			 * Restore argument values from object array, unboxing as needed.
			 * Although the caller has restored them to what it called us with, it's possible that this 
			 * function has modified them since, so we need to do our own restore.
			 */
			int i = 0;
			foreach (TokenDeclVar argVar in curDeclFunc.argDecl.varDict) {
				CompValu argLoc = argVar.location;
				argLoc.PopPre (this, argVar.name);
				ilGen.Emit (OpCodes.Ldloc, objArray);
				ilGen.PushInt (i);
				ilGen.Emit (OpCodes.Ldelem_Ref);
				TypeCast.CastTopOfStack (this, argVar.name, tokenTypeObj, argLoc.type, true);
				argLoc.PopPost (this, argVar.name);
				i ++;
			}

			/*
			 * Restore local and temp values from object array, unboxing as needed.
			 */
			foreach (ScriptMyLocal lcl in activeTemps) {
				ilGen.Emit (OpCodes.Ldloc, objArray);
				ilGen.PushInt (i ++);
				ilGen.Emit (OpCodes.Ldelem_Ref);
				if (lcl.type.IsValueType) ilGen.Emit (OpCodes.Unbox_Any, lcl.type);
				ilGen.Emit (OpCodes.Stloc, lcl);
			}
			activeTemps.Clear ();

			/*
			 * Output a switch statement with a case for each possible value of callNo.
			 *
			 *   switch (callNo) {
			 *      case 0: goto __call_0;
			 *      case 1: goto __call_1;
			 *      ...
			 *   }
			 *   throw new ScriptBadCallNoException (callNo);
			 */
			ScriptMyLabel[] callLabels = new ScriptMyLabel[allCallLabels.Count];
			foreach (CallLabel cl in allCallLabels) {
				callLabels[cl.index] = cl.callLabel;
			}
			ilGen.Emit (OpCodes.Ldloc, callNo);
			ilGen.Emit (OpCodes.Switch, callLabels);

			ilGen.Emit (OpCodes.Ldloc, callNo);
			ilGen.Emit (OpCodes.Newobj, scriptBadCallNoExceptionConstructorInfo);
			ilGen.Emit (OpCodes.Throw);
		}

		/**
		 * @brief There is one of these per call that can possibly call CheckRun(),
		 *        including direct calls to CheckRun().
		 */
		private class CallLabel {
			public int           index;       // sequential integer, starting at 0
			public ScriptMyLabel callLabel;   // the actual label token

			public CallLabel (ScriptCodeGen scg)
			{
				if (!scg.curDeclFunc.IsFuncTrivial (scg)) {
					this.index = scg.allCallLabels.Count;
					scg.allCallLabels.AddLast (this);
					this.callLabel = scg.ilGen.DefineLabel ("__call_" + index);
					scg.ilGen.PushInt(this.index);
					scg.ilGen.Emit (OpCodes.Stloc, scg.callNo);
					scg.ilGen.MarkLabel (this.callLabel);
				}
			}
		};

		/**
		 * @brief generate code for an arbitrary statement.
		 */
		private void GenerateStmt (TokenStmt stmt)
		{
			errorMessageToken = stmt;
			if (stmt is TokenStmtBlock)     { GenerateStmtBlock     ((TokenStmtBlock)stmt);     return; }
			if (stmt is TokenStmtBreak)     { GenerateStmtBreak     ((TokenStmtBreak)stmt);     return; }
			if (stmt is TokenStmtCont)      { GenerateStmtCont      ((TokenStmtCont)stmt);      return; }
			if (stmt is TokenStmtDo)        { GenerateStmtDo        ((TokenStmtDo)stmt);        return; }
			if (stmt is TokenStmtFor)       { GenerateStmtFor       ((TokenStmtFor)stmt);       return; }
			if (stmt is TokenStmtForEach)   { GenerateStmtForEach   ((TokenStmtForEach)stmt);   return; }
			if (stmt is TokenStmtIf)        { GenerateStmtIf        ((TokenStmtIf)stmt);        return; }
			if (stmt is TokenStmtJump)      { GenerateStmtJump      ((TokenStmtJump)stmt);      return; }
			if (stmt is TokenStmtLabel)     { GenerateStmtLabel     ((TokenStmtLabel)stmt);     return; }
			if (stmt is TokenStmtNewobj)    { GenerateStmtNewobj    ((TokenStmtNewobj)stmt);    return; }
			if (stmt is TokenStmtNull)      {                                                   return; }
			if (stmt is TokenStmtRet)       { GenerateStmtRet       ((TokenStmtRet)stmt);       return; }
			if (stmt is TokenStmtRVal)      { GenerateStmtRVal      ((TokenStmtRVal)stmt);      return; }
			if (stmt is TokenStmtState)     { GenerateStmtState     ((TokenStmtState)stmt);     return; }
			if (stmt is TokenStmtSwitch)    { GenerateStmtSwitch    ((TokenStmtSwitch)stmt);    return; }
			if (stmt is TokenStmtThrow)     { GenerateStmtThrow     ((TokenStmtThrow)stmt);     return; }
			if (stmt is TokenStmtTry)       { GenerateStmtTry       ((TokenStmtTry)stmt);       return; }
			if (stmt is TokenStmtVarIniDef) { GenerateStmtVarIniDef ((TokenStmtVarIniDef)stmt); return; }
			if (stmt is TokenStmtWhile)     { GenerateStmtWhile     ((TokenStmtWhile)stmt);     return; }
			throw new Exception ("unknown TokenStmt type " + stmt.GetType ().ToString ());
		}

		/**
		 * @brief generate statement block (ie, with braces)
		 */
		private void GenerateStmtBlock (TokenStmtBlock stmtBlock)
		{
			if (!mightGetHere) return;

			/*
			 * Push new current statement block pointer for anyone who cares.
			 */
			TokenStmtBlock oldStmtBlock = curStmtBlock;
			curStmtBlock = stmtBlock;

			/*
			 * Output the statements that make up the block.
			 */
			for (Token t = stmtBlock.statements; t != null; t = t.nextToken) {
				if (t is TokenStmt) {
					GenerateStmt ((TokenStmt)t);
				} else {
					GenerateDeclVar ((TokenDeclVar)t);
				}
			}

			/*
			 * Pop the current statement block.
			 */
			curStmtBlock = oldStmtBlock;
		}

		/**
		 * @brief output code for a 'break' statement
		 */
		private void GenerateStmtBreak (TokenStmtBreak breakStmt)
		{
			if (!mightGetHere) return;

			/*
			 * Make sure we are in a breakable situation.
			 */
			if (curBreakTarg == null) {
				ErrorMsg (breakStmt, "not in a breakable situation");
				return;
			}

			/*
			 * Output the goto instruction.
			 */
			ilGen.Emit (OpCodes.Br, curBreakTarg.label);

			/*
			 * Tell anyone who cares that the break target was actually used.
			 */
			curBreakTarg.used = true;

			/*
			 * 'break' statements never fall through.
			 */
			mightGetHere = false;
		}

		/**
		 * @brief output code for a 'continue' statement
		 */
		private void GenerateStmtCont (TokenStmtCont contStmt)
		{
			if (!mightGetHere) return;

			/*
			 * Make sure we are in a contable situation.
			 */
			if (curContTarg == null) {
				ErrorMsg (contStmt, "not in a continueable situation");
				return;
			}

			/*
			 * Output the goto instruction.
			 */
			ilGen.Emit (OpCodes.Br, curContTarg.label);

			/*
			 * Tell anyone who cares that the continue target was actually used.
			 */
			curContTarg.used = true;

			/*
			 * 'continue' statements never fall through.
			 */
			mightGetHere = false;
		}

		/**
		 * @brief output code for a 'do' statement
		 */
		private void GenerateStmtDo (TokenStmtDo doStmt)
		{
			if (!mightGetHere) return;

			BreakContTarg oldBreakTarg = curBreakTarg;
			BreakContTarg oldContTarg  = curContTarg;
			ScriptMyLabel loopLabel    = ilGen.DefineLabel ("doloop_" + doStmt.Unique);

			curBreakTarg = new BreakContTarg (ilGen, "dobreak_" + doStmt.Unique);
			curContTarg  = new BreakContTarg (ilGen, "docont_"  + doStmt.Unique);

			ilGen.MarkLabel (loopLabel);
			GenerateStmt (doStmt.bodyStmt);
			if (curContTarg.used) {
				ilGen.MarkLabel (curContTarg.label);
				mightGetHere = true;
			}

			if (mightGetHere) {
				EmitCallCheckRun (doStmt.line);
				CompValu testRVal = GenerateFromRVal (doStmt.testRVal);
				if (IsConstBoolExprTrue (testRVal)) {

					/*
					 * Unconditional looping, unconditional branch and
					 * say we never fall through to next statement.
					 */
					ilGen.Emit (OpCodes.Br, loopLabel);
					mightGetHere = false;
				} else {

					/*
					 * Conditional looping, test and brach back to top of loop.
					 */
					testRVal.PushVal (this, doStmt.testRVal, tokenTypeBool);
					ilGen.Emit (OpCodes.Brtrue, loopLabel);
				}
			}

			/*
			 * If 'break' statement was used, output target label.
			 * And assume that since a 'break' statement was used, it's possible for the code to get here.
			 */
			if (curBreakTarg.used) {
				ilGen.MarkLabel (curBreakTarg.label);
				mightGetHere = true;
			}

			curBreakTarg = oldBreakTarg;
			curContTarg  = oldContTarg;
		}

		/**
		 * @brief output code for a 'for' statement
		 */
		private void GenerateStmtFor (TokenStmtFor forStmt)
		{
			if (!mightGetHere) return;

			BreakContTarg oldBreakTarg = curBreakTarg;
			BreakContTarg oldContTarg  = curContTarg;
			ScriptMyLabel loopLabel    = ilGen.DefineLabel ("forloop_" + forStmt.Unique);

			curBreakTarg = new BreakContTarg (ilGen, "forbreak_" + forStmt.Unique);
			curContTarg  = new BreakContTarg (ilGen, "forcont_"  + forStmt.Unique);

			if (forStmt.initStmt != null) {
				GenerateStmt (forStmt.initStmt);
			}
			ilGen.MarkLabel (loopLabel);

			/*
			 * See if we have a test expression that is other than a constant TRUE.
			 * If so, test it and conditionally branch to end if false.
			 */
			if (forStmt.testRVal != null) {
				CompValu testRVal = GenerateFromRVal (forStmt.testRVal);
				if (!IsConstBoolExprTrue (testRVal)) {
					testRVal.PushVal (this, forStmt.testRVal, tokenTypeBool);
					ilGen.Emit (OpCodes.Brfalse, curBreakTarg.label);
					curBreakTarg.used = true;
				}
			}

			/*
			 * Output loop body.
			 */
			GenerateStmt (forStmt.bodyStmt);

			/*
			 * Here's where a 'continue' statement jumps to.
			 */
			if (curContTarg.used) {
				ilGen.MarkLabel (curContTarg.label);
				mightGetHere = true;
			}

			if (mightGetHere) {

				/*
				 * After checking for excessive CPU time, output increment statement, if any.
				 */
				EmitCallCheckRun (forStmt.line);
				if (forStmt.incrRVal != null) {
					GenerateFromRVal (forStmt.incrRVal);
				}

				/*
				 * Unconditional branch back to beginning of loop.
				 */
				ilGen.Emit (OpCodes.Br, loopLabel);
			}

			/*
			 * If test needs label, output label for it to jump to.
			 * Otherwise, clear mightGetHere as we know loop never
			 * falls out the bottom.
			 */
			mightGetHere = curBreakTarg.used;
			if (mightGetHere) {
				ilGen.MarkLabel (curBreakTarg.label);
			}

			curBreakTarg = oldBreakTarg;
			curContTarg  = oldContTarg;
		}

		private void GenerateStmtForEach (TokenStmtForEach forEachStmt)
		{
			if (!mightGetHere) return;

			BreakContTarg oldBreakTarg = curBreakTarg;
			BreakContTarg oldContTarg  = curContTarg;
			CompValu      keyLVal      = null;
			CompValu      valLVal      = null;
			CompValu      arrayRVal    = GenerateFromRVal (forEachStmt.arrayRVal);

			if (forEachStmt.keyLVal != null) {
				keyLVal = GenerateFromLVal (forEachStmt.keyLVal);
				if (!(keyLVal.type is TokenTypeObject)) {
					ErrorMsg (forEachStmt.arrayRVal, "must be object");
				}
			}
			if (forEachStmt.valLVal != null) {
				valLVal = GenerateFromLVal (forEachStmt.valLVal);
				if (!(valLVal.type is TokenTypeObject)) {
					ErrorMsg (forEachStmt.arrayRVal, "must be object");
				}
			}
			if (!(arrayRVal.type is TokenTypeArray)) {
				ErrorMsg (forEachStmt.arrayRVal, "must be an array");
			}

			curBreakTarg = new BreakContTarg (ilGen, "foreachbreak_" + forEachStmt.Unique);
			curContTarg  = new BreakContTarg (ilGen, "foreachcont_"  + forEachStmt.Unique);

			CompValu indexVar = new CompValuTemp (new TokenTypeInt (forEachStmt), "foreachloop_index_" + forEachStmt.Unique, this);
			ScriptMyLabel loopLabel = ilGen.DefineLabel ("foreachloop_" + forEachStmt.Unique);
			ScriptMyLocal objectVar = ((keyLVal == null) || (valLVal == null)) ? ilGen.DeclareLocal (typeof (object), "foreachobj_" + forEachStmt.Unique) : null;

			// indexVar = 0
			indexVar.PopPre (this, forEachStmt);
			ilGen.PushInt (0);
			indexVar.PopPost (this, forEachStmt);

			ilGen.MarkLabel (loopLabel);

			// ForEach arg 0: arrayRVal
			arrayRVal.PushVal (this, forEachStmt.arrayRVal);

			// ForEach arg 1: indexVar ++
			indexVar.PushVal (this, forEachStmt);
			indexVar.PopPre (this, forEachStmt);
			indexVar.PushVal (this, forEachStmt);
			ilGen.PushInt (1);
			ilGen.Emit (OpCodes.Add);
			indexVar.PopPost (this, forEachStmt);

			// ForEach arg 2: ref keyLVal
			if (keyLVal == null) {
				ilGen.Emit (OpCodes.Ldloca, objectVar);
			} else {
				keyLVal.PushRef (this, forEachStmt.keyLVal);
			}

			// ForEach arg 3: ref valLVal
			if (valLVal == null) {
				ilGen.Emit (OpCodes.Ldloca, objectVar);
			} else {
				valLVal.PushRef (this, forEachStmt.valLVal);
			}

			// Call XMR_Array.ForEach (arrayRVal, index, ref keyLVal, ref valLVal)
			ilGen.Emit (OpCodes.Callvirt, forEachMethodInfo);
			ilGen.Emit (OpCodes.Brfalse, curBreakTarg.label);
			curBreakTarg.used = true;

			GenerateStmt (forEachStmt.bodyStmt);
			if (curContTarg.used) {
				ilGen.MarkLabel (curContTarg.label);
				mightGetHere = true;
			}
			if (mightGetHere) {
				EmitCallCheckRun (forEachStmt.line);
				ilGen.Emit (OpCodes.Br, loopLabel);
			}
			ilGen.MarkLabel (curBreakTarg.label);
			mightGetHere = true;

			curBreakTarg = oldBreakTarg;
			curContTarg  = oldContTarg;
		}

		/**
		 * @brief output code for an 'if' statement
		 * Braces are necessary because what may be one statement for trueStmt or elseStmt in
		 * the script may translate to more than one statement in the resultant C# code.
		 */
		private void GenerateStmtIf (TokenStmtIf ifStmt)
		{
			if (!mightGetHere) return;

			bool constVal;

			/*
			 * Test condition and see if constant test expression.
			 */
			CompValu testRVal = GenerateFromRVal (ifStmt.testRVal);
			if (IsConstBoolExpr (testRVal, out constVal)) {

				/*
				 * Constant, output just either the true or else part.
				 */
				if (constVal) {
					GenerateStmt (ifStmt.trueStmt);
				} else if (ifStmt.elseStmt != null) {
					GenerateStmt (ifStmt.elseStmt);
				}
			} else if (ifStmt.elseStmt == null) {

				/*
				 * This is an 'if' statement without an 'else' clause.
				 */
				testRVal.PushVal (this, ifStmt.testRVal, tokenTypeBool);
				ScriptMyLabel doneLabel = ilGen.DefineLabel ("ifdone_" + ifStmt.Unique);
				ilGen.Emit (OpCodes.Brfalse, doneLabel);     // brfalse doneLabel
				GenerateStmt (ifStmt.trueStmt);              // generate true body code
				ilGen.MarkLabel (doneLabel);
				mightGetHere = true;                         // there's always a possibility of getting here
			} else {

				/*
				 * This is an 'if' statement with an 'else' clause.
				 */
				testRVal.PushVal (this, ifStmt.testRVal, tokenTypeBool);
				ScriptMyLabel elseLabel = ilGen.DefineLabel ("ifelse_" + ifStmt.Unique);
				ilGen.Emit (OpCodes.Brfalse, elseLabel);     // brfalse elseLabel
				GenerateStmt (ifStmt.trueStmt);              // generate true body code
				bool trueMightGetHere = mightGetHere;        // save whether or not true falls through
				ScriptMyLabel doneLabel = ilGen.DefineLabel ("ifdone_" + ifStmt.Unique);
				ilGen.Emit (OpCodes.Br, doneLabel);          // branch to done
				ilGen.MarkLabel (elseLabel);                 // beginning of else code
				mightGetHere = true;                         // the top of the else might be executed
				GenerateStmt (ifStmt.elseStmt);              // output else code
				ilGen.MarkLabel (doneLabel);                 // where end of true clause code branches to
				mightGetHere |= trueMightGetHere;            // gets this far if either true or else falls through
			}
		}

		/**
		 * @brief output code for a 'jump' statement
		 */
		private void GenerateStmtJump (TokenStmtJump jumpStmt)
		{
			if (!mightGetHere) return;

			/*
			 * Make sure the target label is defined somewhere in the function.
			 */
			TokenStmtLabel stmtLabel;
			if (!curDeclFunc.labels.TryGetValue (jumpStmt.label.val, out stmtLabel)) {
				ErrorMsg (jumpStmt, "undefined label " + jumpStmt.label.val);
				return;
			}
			if (!stmtLabel.labelTagged) {
				stmtLabel.labelStruct = ilGen.DefineLabel ("jump_" + stmtLabel.name.val);
				stmtLabel.labelTagged = true;
			}

			/*
			 * Find which block the target label is in.  Must be in this or an outer block,
			 * no laterals allowed.  And if we exit a try/catch block, use Leave instead of Br.
			 */
			TokenStmtBlock stmtBlock;
			OpCode brop = OpCodes.Br;
			for (stmtBlock = curStmtBlock; stmtBlock != null; stmtBlock = stmtBlock.outerStmtBlock) {
				if (stmtBlock == stmtLabel.block) break;
				if (stmtBlock.isTry || stmtBlock.isCatch) brop = OpCodes.Leave;
				if (stmtBlock.isFinally) {
					ErrorMsg (jumpStmt, "cannot jump out of finally");
					return;
				}
			}
			if (stmtBlock == null) {
				ErrorMsg (jumpStmt, "no lateral jumps allowed");
				return;
			}

			/*
			 * Finally output the branch/leave opcode.
			 */
			ilGen.Emit (brop, stmtLabel.labelStruct);

			/*
			 * 'goto' statements never fall through.
			 */
			mightGetHere = false;
		}

		/**
		 * @brief output code for a jump target label statement.
		 * If there are any backward jumps to the label, do a CheckRun() also.
		 */
		private void GenerateStmtLabel (TokenStmtLabel labelStmt)
		{
			if (!labelStmt.labelTagged) {
				labelStmt.labelStruct = ilGen.DefineLabel ("jump_" + labelStmt.name.val);
				labelStmt.labelTagged = true;
			}
			ilGen.MarkLabel (labelStmt.labelStruct);
			if (labelStmt.hasBkwdRefs) {
				EmitCallCheckRun (labelStmt.line);
			}

			/*
			 * We are going to say that the label falls through.
			 * It would be nice if we could analyze all referencing
			 * goto's to see if all of them are not used but we are
			 * going to assume that if the script writer put a goto
			 * somewhere, it is probably going to be used.
			 */
			mightGetHere = true;
		}

		/**
		 * @brief Generate code for a script-defined type's <typename>.$new(<argsig>) method.
		 *        It is used to malloc the object and initialize it.
		 *        It is defined as a script-defined type static method, so the object level
		 *        method gets the XMRInstance pointer passed as arg 0, and the method is 
		 *        supposed to return the allocated and constructed XMRSDTypeClObj
		 *        object pointer.
		 */
		private void GenerateStmtNewobj (TokenStmtNewobj newobjStmt)
		{
			/*
			 * First off, malloc a new empty XMRSDTypeClObj object
			 * then call the XMRSDTypeClObj()-level constructor.
			 * Store the result in local var $objptr.
			 */
			newobjStmt.objptrVar.location.PopPre (this, newobjStmt);
			ilGen.Emit (OpCodes.Ldarg_0);
			ilGen.PushInt (curDeclFunc.sdtClass.sdTypeIndex);
			ilGen.Emit (OpCodes.Newobj, sdtClassConstructorInfo);
			newobjStmt.objptrVar.location.PopPost (this, newobjStmt);

			/*
			 * Now call the script-level constructor.
			 * Pass the object pointer in $objptr as it's 'this' argument.
			 * The rest of the args are the script-visible args and are just copied from $new() call.
			 */
			GenerateFromRValCall (newobjStmt.rValCall);

			/*
			 * Put object pointer in retval so it gets returned to caller.
			 */
			newobjStmt.objptrVar.location.PushVal (this, newobjStmt);
			ilGen.Emit (OpCodes.Stloc, retValue);

			/*
			 * Exit the function like a return statement.
			 * And thus we don't fall through.
			 */
			ilGen.Emit (OpCodes.Leave, retLabel);
			mightGetHere = false;
		}

		/**
		 * @brief output code for a return statement.
		 * @param retStmt = return statement token, including return value if any
		 */
		private void GenerateStmtRet (TokenStmtRet retStmt)
		{
			if (!mightGetHere) return;

			for (TokenStmtBlock stmtBlock = curStmtBlock; stmtBlock != null; stmtBlock = stmtBlock.outerStmtBlock) {
				if (stmtBlock.isFinally) {
					ErrorMsg (retStmt, "cannot return out of finally");
					return;
				}
			}

			if (curDeclFunc.retType is TokenTypeVoid) {
				if (retStmt.rVal != null) {
					ErrorMsg (retStmt, "function returns void, no value allowed");
					return;
				}
			} else {
				if (retStmt.rVal == null) {
					ErrorMsg (retStmt, "function requires return value type " + curDeclFunc.retType.ToString ());
					return;
				}
				CompValu rVal = GenerateFromRVal (retStmt.rVal);
				rVal.PushVal (this, retStmt.rVal, curDeclFunc.retType);
				ilGen.Emit (OpCodes.Stloc, retValue);
			}
			ilGen.Emit (OpCodes.Leave, retLabel);

			/*
			 * 'return' statements never fall through.
			 */
			mightGetHere = false;
		}

		/**
		 * @brief the statement is just an expression, most likely an assignment or a ++ or -- thing.
		 */
		private void GenerateStmtRVal (TokenStmtRVal rValStmt)
		{
			if (!mightGetHere) return;

			GenerateFromRVal (rValStmt.rVal);
		}

		/**
		 * @brief generate code for a 'state' statement that transitions state.
		 * It sets the new state by throwing a ScriptChangeStateException.
		 */
		private void GenerateStmtState (TokenStmtState stateStmt)
		{
			if (!mightGetHere) return;

			int index = 0;  // 'default' state

			/*
			 * Set new state value by throwing an exception.
			 * These exceptions aren't catchable by script-level try { } catch { }.
			 */
			if ((stateStmt.state != null) && !stateIndices.TryGetValue (stateStmt.state.val, out index)) {
				// The moron XEngine compiles scripts that reference undefined states.
				// So rather than produce a compile-time error, we'll throw an exception at runtime.
				// ErrorMsg (stateStmt, "undefined state " + stateStmt.state.val);

				// throw new UndefinedStateException (stateStmt.state.val);
				ilGen.Emit (OpCodes.Ldstr, stateStmt.state.val);
				ilGen.Emit (OpCodes.Newobj, scriptUndefinedStateExceptionConstructorInfo);
			} else {
				ilGen.PushInt (index);				// new state's index
				ilGen.Emit (OpCodes.Newobj, scriptChangeStateExceptionConstructorInfo);
			}
			ilGen.Emit (OpCodes.Throw);

			/*
			 * 'state' statements never fall through.
			 */
			mightGetHere = false;
		}

		/**
		 * @brief output code for a 'switch' statement
		 */
		private void GenerateStmtSwitch (TokenStmtSwitch switchStmt)
		{
			if (!mightGetHere) return;

			BreakContTarg   oldBreakTarg = curBreakTarg;
			ScriptMyLabel   defaultLabel = null;
			TokenSwitchCase sortedCases  = null;
			TokenSwitchCase defaultCase  = null;

			curBreakTarg = new BreakContTarg (ilGen, "switchbreak_" + switchStmt.Unique);

			/*
			 * Build list of cases sorted by ascending values.
			 * There should not be any overlapping of values.
			 */
			for (TokenSwitchCase thisCase = switchStmt.cases; thisCase != null; thisCase = thisCase.nextCase) {
				thisCase.label = ilGen.DefineLabel ("case_" + thisCase.Unique);

				/*
				 * The default case if any, goes in its own separate slot.
				 */
				if (thisCase.rVal1 == null) {
					if (defaultCase != null) {
						ErrorMsg (thisCase, "only one default case allowed");
						ErrorMsg (defaultCase, "...prior default case");
						return;
					}
					defaultCase  = thisCase;
					defaultLabel = thisCase.label;
					continue;
				}

				/*
				 * Evaluate case operands, they must be compile-time integer constants.
				 */
				CompValu rVal = GenerateFromRVal (thisCase.rVal1);
				if (!IsConstIntExpr (rVal, out thisCase.val1)) {
					ErrorMsg (thisCase.rVal1, "must be compile-time char or integer constant");
					return;
				}
				thisCase.val2 = thisCase.val1;
				if (thisCase.rVal2 != null) {
					rVal = GenerateFromRVal (thisCase.rVal2);
					if (!IsConstIntExpr (rVal, out thisCase.val2)) {
						ErrorMsg (thisCase.rVal2, "must be compile-time char or integer constant");
						return;
					}
				}
				if (thisCase.val2 < thisCase.val1) {
					ErrorMsg (thisCase.rVal2, "must be .ge. first value for the case");
					return;
				}

				/*
				 * Insert into list, sorted by value.
				 * Note that both limits are inclusive.
				 */
				TokenSwitchCase lastCase = null;
				TokenSwitchCase nextCase;
				for (nextCase = sortedCases; nextCase != null; nextCase = nextCase.nextSortedCase) {
					if (nextCase.val1 >  thisCase.val2) break;
					if (nextCase.val2 >= thisCase.val1) {
						ErrorMsg (thisCase, "value used by previous case");
						ErrorMsg (nextCase, "...previous case");
						return;
					}
					lastCase = nextCase;
				}
				thisCase.nextSortedCase = nextCase;
				if (lastCase == null) {
					sortedCases = thisCase;
				} else {
					lastCase.nextSortedCase = thisCase;
				}
			}

			if (defaultLabel == null) {
				defaultLabel = ilGen.DefineLabel ("default_" + switchStmt.Unique);
			}

			/*
			 * Output code to calculate index, push result on stack as an integer.
			 */
			CompValu testRVal = GenerateFromRVal (switchStmt.testRVal);
			testRVal.PushVal (this, switchStmt.testRVal, tokenTypeInt);

			/*
			 * Output code to jump to the case statement's labels based on integer index on stack.
			 * Note that each case still has the integer index on stack when jumped to.
			 */
			int offset = 0;
			for (TokenSwitchCase thisCase = sortedCases; thisCase != null;) {

				/*
				 * Scan through list of cases to find the maximum number of cases who's numvalues-to-case ratio
				 * is from 0.5 to 2.0.  If such a group is found, use a CIL switch for them.  If not, just use a
				 * compare-and-branch for the current case.
				 */
				int numCases  = 0;
				int numFound  = 0;
				int lowValue  = thisCase.val1;
				int numValues = 0;
				for (TokenSwitchCase scanCase = thisCase; scanCase != null; scanCase = scanCase.nextSortedCase) {
					int nVals = scanCase.val2 - thisCase.val1 + 1;
					double ratio = (double)nVals / (double)(++ numCases);
					if ((ratio >= 0.5) && (ratio <= 2.0)) {
						numFound  = numCases;
						numValues = nVals;
					}
				}
				if (numFound > 1) {

					/*
					 * There is a group of case's, starting with thisCase, that fall within our criteria, ie, 
					 * that have a nice density of meaningful jumps.
					 *
					 * So first generate an array of jumps to the default label (explicit or implicit).
					 */
					ScriptMyLabel[] labels = new ScriptMyLabel[numValues];
					for (int i = 0; i < numValues; i ++) {
						labels[i] = defaultLabel;
					}

					/*
					 * Next, for each case in that group, fill in the corresponding array entries to jump to
					 * that case's label.
					 */
					do {
						for (int i = thisCase.val1; i <= thisCase.val2; i ++) {
							labels[i-lowValue] = thisCase.label;
						}
						thisCase = thisCase.nextSortedCase;
					} while (-- numFound > 0);

					/*
					 * Subtract the low value and do the computed jump.
					 * The OpCodes.Switch falls through if out of range (unsigned compare).
					 */
					if (offset != lowValue) {
						ilGen.PushInt (lowValue - offset);
						ilGen.Emit (OpCodes.Sub);
						offset = lowValue;
					}
					ilGen.Emit (OpCodes.Dup);
					ilGen.Emit (OpCodes.Switch, labels);
				} else {

					/*
					 * It's not economical to do with a computed jump, so output a subtract/compare/branch
					 * for thisCase.
					 */
					if (lowValue == thisCase.val2) {
						ilGen.Emit (OpCodes.Dup);
						ilGen.PushInt (lowValue - offset);
						ilGen.Emit (OpCodes.Beq, thisCase.label);
					} else {
						if (offset != lowValue) {
							ilGen.PushInt (lowValue - offset);
							ilGen.Emit (OpCodes.Sub);
							offset = lowValue;
						}
						ilGen.Emit (OpCodes.Dup);
						ilGen.PushInt (thisCase.val2 - offset);
						ilGen.Emit (OpCodes.Ble_Un, thisCase.label);
					}
					thisCase = thisCase.nextSortedCase;
				}
			}
			ilGen.Emit (OpCodes.Br, defaultLabel);

			/*
			 * Output code for the cases themselves, in the order given by the programmer, 
			 * so they fall through as programmer wants.  This includes the default case, if any.
			 *
			 * Each label is jumped to with the index still on the stack.  So pop it off in case
			 * the case body does a goto outside the switch or a return.  If the case body might
			 * fall through to the next case or the bottom of the switch, push a zero so the stack
			 * matches in all cases.
			 */
			for (TokenSwitchCase thisCase = switchStmt.cases; thisCase != null; thisCase = thisCase.nextCase) {
				ilGen.MarkLabel (thisCase.label);	// the branch comes here
				ilGen.Emit (OpCodes.Pop);		// pop the integer index off stack
				mightGetHere = true;			// it's possible to get here
				for (TokenStmt stmt = thisCase.stmts; stmt != null; stmt = (TokenStmt)(stmt.nextToken)) {
					GenerateStmt (stmt);		// output the case/explicit default body
				}
				if (mightGetHere) {
					ilGen.PushInt (0);		// in case we fall through, push a dummy integer index
				}
			}

			/*
			 * If no explicit default case, output the default label here.
			 */
			if (defaultCase == null) {
				ilGen.MarkLabel (defaultLabel);
				mightGetHere = true;
			}

			/*
			 * If the last case of the switch falls through out the bottom,
			 * we have to pop the index still on the stack.
			 */
			if (mightGetHere) {
				ilGen.Emit (OpCodes.Pop);
			}

			/*
			 * Output the 'break' statement target label.
			 * Note that the integer index is not on the stack at this point.
			 */
			if (curBreakTarg.used) {
				ilGen.MarkLabel (curBreakTarg.label);
				mightGetHere = true;
			}

			curBreakTarg = oldBreakTarg;
		}

		/**
		 * @brief output code for a throw statement.
		 * @param throwStmt = throw statement token, including value to be thrown
		 */
		private void GenerateStmtThrow (TokenStmtThrow throwStmt)
		{
			if (!mightGetHere) return;

			if (throwStmt.rVal == null) {
				if (!curStmtBlock.isCatch) {
					ErrorMsg (throwStmt, "rethrow allowed only in catch clause");
				}
				ilGen.Emit (OpCodes.Rethrow);
			} else {
				CompValu rVal = GenerateFromRVal (throwStmt.rVal);
				rVal.PushVal (this, throwStmt.rVal, tokenTypeStr);
				ilGen.Emit (OpCodes.Call, throwStrToExcMethodInfo);
				ilGen.Emit (OpCodes.Throw);
			}

			/*
			 * 'throw' statements never fall through.
			 */
			mightGetHere = false;
		}

		/**
		 * @brief output code for an 'try' statement
		 */
		private void GenerateStmtTry (TokenStmtTry tryStmt)
		{
			if (!mightGetHere) return;

			BreakContTarg oldBreakTarg = curBreakTarg;		// cannot continue out of try/catch/finally
			BreakContTarg oldContTarg  = curContTarg;		// (break jumps to end of try/catch/finally)
			curBreakTarg = null;
			curContTarg  = null;

			ScriptMyLabel tryEndLabel = ilGen.DefineLabel ("tryend_" + tryStmt.Unique);

			tryStmt.tryStmt.isTry = true;				// jumps out of try require Leave opcode
										// rethrow not allowed
										// return statements not allowed
			curBreakTarg = new BreakContTarg (ilGen, "trybreak_" + tryStmt.Unique);
			ilGen.BeginExceptionBlock ();
			GenerateStmtBlock (tryStmt.tryStmt);			// output the try block statement block
			if (curBreakTarg.used) {
				ilGen.MarkLabel (curBreakTarg.label);
				mightGetHere = true;
			}
			bool mightGetOut = mightGetHere;
			if (mightGetHere) {
				ilGen.Emit (OpCodes.Leave, tryEndLabel);
			}
			if (tryStmt.catchStmt != null) {
				tryStmt.catchStmt.isCatch = true;		// jumps out of catch require Leave opcode
										// rethrow allowed
										// return statements not allowed
				CompValu catchVarLoc = new CompValuTemp (tokenTypeStr, tryStmt.catchVar.name.val, this);
				tryStmt.catchVar.location = catchVarLoc;
				ScriptMyLabel catchLabel = ilGen.DefineLabel ("catchlbl_" + tryStmt.Unique);
				ScriptMyLocal excLocal = ilGen.DeclareLocal (typeof (Exception), "catchexc_" + tryStmt.Unique);

				curBreakTarg = new BreakContTarg (ilGen, "catchbreak_" + tryStmt.Unique);
				ilGen.BeginCatchBlock (typeof (Exception));	// start of the catch block
				ilGen.Emit (OpCodes.Stloc, excLocal);		// save pointer to exception object
				catchVarLoc.PopPre (this, tryStmt.catchVar.name);
				ilGen.Emit (OpCodes.Ldloc, excLocal);		// convert exception object to string
				ilGen.Emit (OpCodes.Call, catchExcToStrMethodInfo);
				catchVarLoc.PopPost (this, tryStmt.catchVar.name);  // ... and store in catch clause var
				catchVarLoc.PushVal (this, tryStmt.catchVar.name);  // see if null
				ilGen.Emit (OpCodes.Brtrue_S, catchLabel);
				ilGen.Emit (OpCodes.Rethrow);			// if so, rethrow exception
				ilGen.MarkLabel (catchLabel);			// if not, process script code

				mightGetHere = true;				// if we can get to the 'try' assume we can get to the 'catch'
				GenerateStmtBlock (tryStmt.catchStmt);		// output catch clause statement block
				if (curBreakTarg.used) {
					ilGen.MarkLabel (curBreakTarg.label);
					mightGetHere = true;
				}
				mightGetOut |= mightGetHere;			// remember whether or not we can get to end of try or catch at all
				if (mightGetHere) {
					ilGen.Emit (OpCodes.Leave, tryEndLabel);
				}
			}
			if (tryStmt.finallyStmt != null) {
				curBreakTarg = new BreakContTarg (ilGen, "finbreak_" + tryStmt.Unique);
				tryStmt.finallyStmt.isFinally = true;		// cannot exit finally with jump or return statement
				ilGen.BeginFinallyBlock ();			// start of the finally block
				mightGetHere = true;
				GenerateStmtBlock (tryStmt.finallyStmt);
				if (curBreakTarg.used) {
					ilGen.MarkLabel (curBreakTarg.label);
				}
				ilGen.Emit (OpCodes.Endfinally);
			}
			ilGen.EndExceptionBlock ();
			ilGen.MarkLabel (tryEndLabel);
			mightGetHere = mightGetOut;

			curBreakTarg = oldBreakTarg;
			curContTarg  = oldContTarg;
		}

		/**
		 * @brief Generate code to initialize a variable to its default value.
		 */
		private void GenerateStmtVarIniDef (TokenStmtVarIniDef varIniDefStmt)
		{
			if (!mightGetHere) return;

			CompValu left = GenerateFromLVal (varIniDefStmt.var);
			left.PopPre (this, varIniDefStmt);
			PushDefaultValue (left.type);
			left.PopPost (this, varIniDefStmt);
		}

		/**
		 * @brief generate code for a 'while' statement including the loop body.
		 */
		private void GenerateStmtWhile (TokenStmtWhile whileStmt)
		{
			if (!mightGetHere) return;

			BreakContTarg oldBreakTarg = curBreakTarg;
			BreakContTarg oldContTarg  = curContTarg;
			ScriptMyLabel loopLabel    = ilGen.DefineLabel ("whileloop_" + whileStmt.Unique);

			curBreakTarg = new BreakContTarg (ilGen, "whilebreak_" + whileStmt.Unique);
			curContTarg  = new BreakContTarg (ilGen, "whilecont_"  + whileStmt.Unique);

			ilGen.MarkLabel (loopLabel);                                        // loop:
			CompValu testRVal = GenerateFromRVal (whileStmt.testRVal);          //   testRVal = while test expression
			if (!IsConstBoolExprTrue (testRVal)) {
				testRVal.PushVal (this, whileStmt.testRVal, tokenTypeBool); //   if (!testRVal)
				ilGen.Emit (OpCodes.Brfalse, curBreakTarg.label);           //      goto break
				curBreakTarg.used = true;
			}
			GenerateStmt (whileStmt.bodyStmt);                                  //   while body statement
			if (curContTarg.used) {
				ilGen.MarkLabel (curContTarg.label);                        // cont:
				mightGetHere = true;
			}
			if (mightGetHere) {
				EmitCallCheckRun (whileStmt.line);                          //   __sw.CheckRun()
				ilGen.Emit (OpCodes.Br, loopLabel);                         //   goto loop
			}
			mightGetHere = curBreakTarg.used;
			if (mightGetHere) {
				ilGen.MarkLabel (curBreakTarg.label);                       // done:
			}

			curBreakTarg = oldBreakTarg;
			curContTarg  = oldContTarg;
		}

		/**
		 * @brief process a local variable declaration statement, possibly with initialization expression.
		 *        Note that the function header processing allocated stack space (CompValuTemp) for the
		 *        variable and now all we do is write its initialization value.
		 */
		private void GenerateDeclVar (TokenDeclVar declVar)
		{
			/*
			 * Script gave us an initialization value, so just store init value in var like an assignment statement.
			 * Also debit any heap used by the initialization value, just like an assignment statement.
			 * If no init given, the var was set to its default value when stack space was allocated at the beginning
			 * of the function.
			 */
			if (declVar.init != null) {
				CompValu local = declVar.location;
				local.PopPre (this, declVar);
				CompValu rVal = GenerateFromRVal (declVar.init, local.GetArgTypes ());
				rVal.PushVal (this, declVar.init, declVar.type);
				local.PopPost (this, declVar);
				DebitHeapLeft (declVar, true, declVar.init);
			}
		}

		/**
		 * @brief Get the type and location of an L-value (eg, variable)
		 */
		private CompValu GenerateFromLVal (TokenLVal lVal)
		{
			return GenerateFromLVal (lVal, null);
		}
		private CompValu GenerateFromLVal (TokenLVal lVal, TokenType[] argsig)
		{
			if (lVal is TokenLValArEle)     return GenerateFromLValArEle     ((TokenLValArEle)lVal);
			if (lVal is TokenLValBaseField) return GenerateFromLValBaseField ((TokenLValBaseField)lVal, argsig);
			if (lVal is TokenLValIField)    return GenerateFromLValIField    ((TokenLValIField)lVal, argsig);
			if (lVal is TokenLValName)      return GenerateFromLValName      ((TokenLValName)lVal, argsig);
			if (lVal is TokenLValSField)    return GenerateFromLValSField    ((TokenLValSField)lVal, argsig);
			throw new Exception ("bad lval class");
		}

		/**
		 * @brief we have an L-value token that is an element within an array.
		 * @returns a CompValu giving the type and location of the element of the array.
		 */
		private CompValu GenerateFromLValArEle (TokenLValArEle lVal)
		{
			CompValu subCompValu;

			/*
			 * Compute location of array itself.
			 */
			CompValu baseCompValu = GenerateFromRVal (lVal.baseRVal);

			/*
			 * Maybe it is a fixed array access.
			 */
			string basetypestring = baseCompValu.type.ToString ();
			if (basetypestring.EndsWith ("]")) {
				TokenRVal subRVal = lVal.subRVal;
				int nSubs = 1;
				if (subRVal is TokenRValList) {
					nSubs   = ((TokenRValList)subRVal).nItems;
					subRVal = ((TokenRValList)subRVal).rVal;
				}

				int rank = basetypestring.IndexOf (']') - basetypestring.IndexOf ('[');
				if (nSubs != rank) {
					ErrorMsg (lVal.baseRVal, "expect " + rank + " subscript" + ((rank == 1) ? "" : "s") + " but have " + nSubs);
				}
				CompValu[] subCompValus = new CompValu[rank];
				int i;
				for (i = 0; (subRVal != null) && (i < rank); i ++) {
					subCompValus[i] = GenerateFromRVal (subRVal);
					subRVal = (TokenRVal)subRVal.nextToken;
				}
				while (i < rank) subCompValus[i++] = new CompValuInteger (new TokenTypeInt (lVal.subRVal), 0);
				return new CompValuFixArEl (this, baseCompValu, subCompValus);
			}

			/*
			 * Maybe it is extracting a character from a string.
			 */
			if (baseCompValu.type is TokenTypeStr) {
				subCompValu = GenerateFromRVal (lVal.subRVal);
				return new CompValuStrChr (new TokenTypeChar (lVal), baseCompValu, subCompValu);
			}

			/*
			 * Access should be to XMR_Array otherwise.
			 */
			if (!(baseCompValu.type is TokenTypeArray)) {
				ErrorMsg (lVal, "taking subscript of non-array");
				return baseCompValu;
			}
			subCompValu = GenerateFromRVal (lVal.subRVal);
			return new CompValuArEle (new TokenTypeObject (lVal), baseCompValu, subCompValu);
		}

		/**
		 * @brief using 'base' within a script-defined instance method to refer to an instance field/method 
		 *        of the class being extended.
		 */
		private CompValu GenerateFromLValBaseField (TokenLValBaseField baseField, TokenType[] argsig)
		{
			string fieldName = baseField.fieldName.val;

			TokenDeclSDType sdtDecl = curDeclFunc.sdtClass;
			if ((sdtDecl == null) || ((curDeclFunc.sdtFlags & ScriptReduce.SDT_STATIC) != 0)) {
				ErrorMsg (baseField, "cannot use 'base' outside instance method body");
				return new CompValuVoid (baseField);
			}

			TokenDeclVar declVar = FindThisMember (sdtDecl.extends, baseField.fieldName, argsig);
			if (declVar != null) {
				if ((declVar.sdtFlags & ScriptReduce.SDT_STATIC) != 0) {
					ErrorMsg (baseField, "non-static reference to static member " + fieldName + ArgSigString (argsig));
					return new CompValuVoid (baseField);
				}
				if (!IsSDTInstMethod ()) {
					ErrorMsg (baseField, "cannot access instance member of class from static method");
					return new CompValuVoid (baseField);
				}
				TokenType baseType = declVar.sdtClass.MakeRefToken (baseField);
				CompValu  basePtr  = new CompValuArg (baseType, 0);
				return (declVar.retType == null) ? (CompValu)new CompValuInstField (declVar, basePtr, true) : 
				                                   (CompValu)new CompValuInstMeth (declVar, basePtr, true);
			}

			ErrorMsg (baseField, "no member " + fieldName + ArgSigString (argsig) + " rootward of " + sdtDecl.longName.val);
			return new CompValuVoid (baseField);
		}

		/**
		 * @brief we have an L-value token that is an instance field/method within a struct.
		 * @returns a CompValu giving the type and location of the field/method in the struct.
		 */
		private CompValu GenerateFromLValIField (TokenLValIField lVal, TokenType[] argsig)
		{
			CompValu baseRVal = GenerateFromRVal (lVal.baseRVal);
			string fieldName = lVal.fieldName.val + ArgSigString (argsig);

			/*
			 * Maybe they are accessing an instance field or method of a script-defined class.
			 */
			if (baseRVal.type is TokenTypeSDTypeClass) {
				TokenTypeSDTypeClass sdtType = (TokenTypeSDTypeClass)baseRVal.type;
				TokenDeclSDTypeClass sdtDecl = sdtType.decl;
				TokenDeclVar declVar = FindThisMember (sdtDecl, lVal.fieldName, argsig);
				if (declVar != null) {
					if ((declVar.sdtFlags & ScriptReduce.SDT_STATIC) != 0) {
						ErrorMsg (lVal.fieldName, "non-static reference to static member " + fieldName);
						return new CompValuVoid (lVal.fieldName);
					}
					return (declVar.retType == null) ? (CompValu)new CompValuInstField (declVar, baseRVal, false) 
					                                 : (CompValu)new CompValuInstMeth (declVar, baseRVal, false);
				}
				ErrorMsg (lVal.fieldName, "no member " + fieldName + " in class " + sdtDecl.longName.val);
				return new CompValuVoid (lVal.fieldName);
			}

			/*
			 * Maybe they are accessing a method of a script-defined interface.
			 */
			if (baseRVal.type is TokenTypeSDTypeInterface) {
				TokenTypeSDTypeInterface sdtType = (TokenTypeSDTypeInterface)baseRVal.type;
				TokenDeclSDTypeInterface sdtDecl = sdtType.decl;
				TokenDeclVar declVar = FindSingleMember (sdtDecl.methProtos, lVal.fieldName, argsig);
				if (declVar != null) {
					return new CompValuIntfMeth (declVar, baseRVal);
				}
				ErrorMsg (lVal.fieldName, "no member " + fieldName + " in interface " + sdtDecl.longName.val);
				return new CompValuVoid (lVal.fieldName);
			}

			/*
			 * Since we only have a few built-in types with fields, just pound them out.
			 */
			if (baseRVal.type is TokenTypeArray) {

				// no arguments, no parentheses, just the field name, returning integer
				// but internally, it is a call to a method()
				if (fieldName == "count") {
					return new CompValuIntInstROProp (tokenTypeInt, baseRVal, arrayCountMethodInfo);
				}

				// no arguments but with the parentheses, returning void
				if (fieldName == "clear()") {
					return new CompValuIntInstMeth (XMR_Array.clearDelegate, baseRVal, arrayClearMethodInfo);
				}

				// single integer argument, returning an object
				if (fieldName == "index(integer)") {
					return new CompValuIntInstMeth (XMR_Array.indexDelegate, baseRVal, arrayIndexMethodInfo);
				}
				if (fieldName == "value(integer)") {
					return new CompValuIntInstMeth (XMR_Array.valueDelegate, baseRVal, arrayValueMethodInfo);
				}
			}
			if (baseRVal.type is TokenTypeRot) {
				FieldInfo fi = null;
				if (fieldName == "x") fi = rotationXFieldInfo;
				if (fieldName == "y") fi = rotationYFieldInfo;
				if (fieldName == "z") fi = rotationZFieldInfo;
				if (fieldName == "s") fi = rotationSFieldInfo;
				if (fi != null) {
					return new CompValuField (new TokenTypeFloat (lVal), baseRVal, fi);
				}
			}
			if (baseRVal.type is TokenTypeVec) {
				FieldInfo fi = null;
				if (fieldName == "x") fi = vectorXFieldInfo;
				if (fieldName == "y") fi = vectorYFieldInfo;
				if (fieldName == "z") fi = vectorZFieldInfo;
				if (fi != null) {
					return new CompValuField (new TokenTypeFloat (lVal), baseRVal, fi);
				}
			}

			ErrorMsg (lVal, "type " + baseRVal.type.ToString () + " does not define member " + fieldName);
			return baseRVal;
		}

		/**
		 * @brief We have an L-value token that is a function, method or variable name.
		 * @param lVal = name we are looking for
		 * @param argsig = null: just look for name as a variable
		 *                 else: look for name as a function/method being called with the given argument types
		 *                       eg, "(string,integer,list)"
		 * @returns a CompValu giving the type and location of the function, method or variable.
		 */
		private CompValu GenerateFromLValName (TokenLValName lVal, TokenType[] argsig)
		{
			/*
			 * Look in variable stack then look for built-in constants and functions.
			 */
			TokenDeclVar var = FindNamedVar (lVal, argsig);
			if (var == null) {
				ErrorMsg (lVal, "undefined constant/function/variable " + lVal.name.val + ArgSigString (argsig));
				return new CompValuVoid (lVal);
			}

			/*
			 * Maybe it has an implied 'this.' on the front.
			 */
			if ((var.sdtClass != null) && ((var.sdtFlags & ScriptReduce.SDT_STATIC) == 0)) {

				if (!IsSDTInstMethod ()) {
					// our arg0 points to an instance of XMRInstAbstract, not var.sdtClass
					ErrorMsg (lVal, "cannot access instance member of class from static method");
					return new CompValuVoid (lVal);
				}

				/*
				 * Don't allow something such as:
				 *
				 *    class A {
				 *        integer I;
				 *        class B {
				 *            Print()
				 *            {
				 *                llOwnerSay ("I=" + (string)I); <- access to I not allowed inside class B.
				 *                                                  explicit reference required as we don't
				 *                                                  have a valid reference to class A.
				 *            }
				 *        }
				 *    }
				 */
				if (var.sdtClass != curDeclFunc.sdtClass) {
					// our arg0 points to an instance of curDeclFunc.sdtClass, not var.sdtClass
					ErrorMsg (lVal, "cannot access instance member of outer class with implied 'this'");
				}

				CompValu thisCompValu = new CompValuArg (var.sdtClass.MakeRefToken (lVal), 0);

				return (var.retType == null) ? (CompValu)new CompValuInstField (var, thisCompValu, false) 
				                             : (CompValu)new CompValuInstMeth (var, thisCompValu, false);
			}

			/*
			 * It's a local variable, static field, global, constant, etc.
			 */
			return var.location;
		}

		/**
		 * @brief we have an L-value token that is a static member within a struct.
		 * @returns a CompValu giving the type and location of the member in the struct.
		 */
		private CompValu GenerateFromLValSField (TokenLValSField lVal, TokenType[] argsig)
		{
			TokenType stType = lVal.baseType;
			string fieldName = lVal.fieldName.val + ArgSigString (argsig);

			/*
			 * Maybe they are accessing a static member of a script-defined class.
			 */
			if (stType is TokenTypeSDTypeClass) {
				TokenTypeSDTypeClass sdtType = (TokenTypeSDTypeClass)stType;
				TokenDeclVar declVar = FindThisMember (sdtType.decl, lVal.fieldName, argsig);
				if (declVar != null) {
					if ((declVar.sdtFlags & ScriptReduce.SDT_STATIC) == 0) {
						ErrorMsg (lVal.fieldName, "static reference to non-static member " + fieldName);
						return new CompValuVoid (lVal.fieldName);
					}
					return declVar.location;
				}
			}

			ErrorMsg (lVal.fieldName, "no member " + fieldName + " in " + stType.ToString ());
			return new CompValuVoid (lVal.fieldName);
		}

		/**
		 * @brief generate code from an RVal expression and return its type and where the result is stored.
		 * For anything that has side-effects, statements are generated that perform the computation then
		 * the result it put in a temp var and the temp var name is returned.
		 * For anything without side-effects, they are returned as an equivalent sequence of Emits.
		 * @param rVal = rVal token to be evaluated
		 * @param argsig = null: not being used in an function/method context
		 *                 else: string giving argument types, eg, "(string,integer,list,vector)"
		 *                       that can be used to select among overloaded methods
		 * @returns resultant type and location
		 */
		private CompValu GenerateFromRVal (TokenRVal rVal)
		{
			return GenerateFromRVal (rVal, null);
		}
		private CompValu GenerateFromRVal (TokenRVal rVal, TokenType[] argsig)
		{
			errorMessageToken = rVal;

			/*
			 * Maybe the expression can be converted to a constant.
			 */
			bool didOne;
			do {
				didOne = false;
				rVal = rVal.TryComputeConstant (LookupBodyConstants, ref didOne);
			} while (didOne);

			/*
			 * Generate code for the computation and return resulting type and location.
			 */
			if (rVal is TokenRValAsnPost)   return GenerateFromRValAsnPost   ((TokenRValAsnPost)rVal);
			if (rVal is TokenRValAsnPre)    return GenerateFromRValAsnPre    ((TokenRValAsnPre)rVal);
			if (rVal is TokenRValCall)      return GenerateFromRValCall      ((TokenRValCall)rVal);
			if (rVal is TokenRValCast)      return GenerateFromRValCast      ((TokenRValCast)rVal);
			if (rVal is TokenRValConst)     return GenerateFromRValConst     ((TokenRValConst)rVal);
			if (rVal is TokenRValIsType)    return GenerateFromRValIsType    ((TokenRValIsType)rVal);
			if (rVal is TokenRValList)      return GenerateFromRValList      ((TokenRValList)rVal);
			if (rVal is TokenRValNewArIni)  return GenerateFromRValNewArIni  ((TokenRValNewArIni)rVal);
			if (rVal is TokenRValOpBin)     return GenerateFromRValOpBin     ((TokenRValOpBin)rVal);
			if (rVal is TokenRValOpUn)      return GenerateFromRValOpUn      ((TokenRValOpUn)rVal);
			if (rVal is TokenRValParen)     return GenerateFromRValParen     ((TokenRValParen)rVal);
			if (rVal is TokenRValRot)       return GenerateFromRValRot       ((TokenRValRot)rVal);
			if (rVal is TokenRValThis)      return GenerateFromRValThis      ((TokenRValThis)rVal);
			if (rVal is TokenRValUndef)     return GenerateFromRValUndef     ((TokenRValUndef)rVal);
			if (rVal is TokenRValVec)       return GenerateFromRValVec       ((TokenRValVec)rVal);
			if (rVal is TokenLVal)          return GenerateFromLVal          ((TokenLVal)rVal, argsig);

			throw new Exception ("bad rval class " + rVal.GetType ().ToString ());
		}

		/**
		 * @brief compute the result of a binary operator (eg, add, subtract, multiply, lessthan)
		 * @param token = binary operator token, includes the left and right operands
		 * @returns where the resultant R-value is as something that doesn't have side effects
		 */
		private CompValu GenerateFromRValOpBin (TokenRValOpBin token)
		{
			CompValu leftLVal = null;
			CompValu left = null;
			CompValu right;

			/*
			 * If left operand is an L-value, create an leftLVal location marker for it.
			 * In either case, create a R-value location marker for it.
			 */
			if (token.rValLeft is TokenLVal) {
				left = leftLVal = GenerateFromLVal ((TokenLVal)token.rValLeft);
			}

			/*
			 * Simple overwriting assignments are their own special case,
			 * as we want to cast the R-value to the type of the L-value.
			 * And in the case of delegates, we want to use the arg signature
			 * of the delegate to select which overloaded method to use.
			 * And we might also be able to optimize out a temp by having
			 * the result put directly in the L-value variable.
			 */
			string opcodeIndex = token.opcode.ToString ();
			if (opcodeIndex == "=") {
				if (left == null) {
					ErrorMsg (token, "invalid L-value for =");
					left = GenerateFromRVal (token.rValLeft);
				} else {
					right = GenerateFromRVal (token.rValRight, left.GetArgTypes ());
					leftLVal.PopPre (this, token.rValLeft);
					right.PushVal (this, token.rValRight, leftLVal.type);  // push (leftLVal.type)right
					leftLVal.PopPost (this, token.rValLeft);               // pop to leftLVal
					////????DebitHeapLeft (left, true, token.rValLeft);
				}
				return left;
			}

			/*
			 * Comma operators are also special, as they say to compute the left-hand value
			 * and discard it, then compute the right-hand argument and that is the result.
			 */
			if (opcodeIndex == ",") {

				/*
				 * Compute left-hand operand but throw away result (because we say to store in a 'void').
				 */
				if (left == null) {
					GenerateFromRVal (token.rValLeft);
				}

				/*
				 * Compute right-hand operand and that is the value of the expression.
				 */
				return GenerateFromRVal (token.rValRight);
			}

			/*
			 * Computation of some sort, compute right-hand operand value then left-hand value
			 * because LSL is supposed to be right-to-left evaluation.
			 *
			 * If left-hand operand has side effects, force right-hand operand into a temp so
			 * it will get computed first, and not just stacked for later evaluation.
			 */
			right = GenerateFromRVal (token.rValRight);
			if (token.rValLeft.sideEffects && !right.isFinal) {
				CompValu rightTemp = new CompValuTemp (right.type, null, this);
				rightTemp.PopPre (this, token.rValRight);
				right.PushVal (this, token.rValRight, right.type);
				rightTemp.PopPost (this, token.rValRight);
				right = rightTemp;
			}
			left = GenerateFromRVal (token.rValLeft);

			/*
			 * If left is a script-defined class and there is a method with the operator's name,
			 * convert this to a call to that method with the right value as its single parameter.
			 * Except don't if the right value is 'undef' so they can always compare to undef.
			 */
			if ((left.type is TokenTypeSDTypeClass) && !(right.type is TokenTypeUndef)) {
				TokenTypeSDTypeClass sdtType = (TokenTypeSDTypeClass)left.type;
				TokenDeclSDTypeClass sdtDecl = sdtType.decl;
				TokenType[] argsig = new TokenType[] { right.type };
				TokenName funcName = new TokenName (token.opcode, "$op" + opcodeIndex);
				TokenDeclVar declFunc = FindThisMember (sdtDecl, funcName, argsig);
				if (declFunc != null) {
					CompValu method = new CompValuInstMeth (declFunc, left, false);
					CompValu[] argRVals = new CompValu[] { right };
					return GenerateACall (method, argRVals, token);
				}
			}

			/*
			 * Formulate key string for binOpStrings = (lefttype)(operator)(righttype)
			 */
			string leftIndex = left.type.ToString ();
			string rightIndex = right.type.ToString ();
			string key = leftIndex + opcodeIndex + rightIndex;

			/*
			 * If that key exists in table, then the operation is defined between those types
			 * ... and it produces an R-value of type as given in the table.
			 */
			BinOpStr binOpStr;
			if (BinOpStr.defined.TryGetValue (key, out binOpStr)) {

				/*
				 * If table contained an explicit assignment type like +=, output the statement without
				 * casting the L-value, then return the L-value as the resultant value.
				 *
				 * Make sure we don't include comparisons (such as ==, >=, etc).
				 * Nothing like +=, -=, %=, etc, generate a boolean, only the comparisons.
				 */
				if ((binOpStr.outtype != typeof (bool)) && opcodeIndex.EndsWith ("=")) {
					binOpStr.emitBO (this, token, left, right, left);
					////????DebitHeapLeft (left, true, token.rValLeft);
					return left;
				}

				/*
				 * It's of the form left binop right.
				 * If either the original left or right had side effects, they should have been evaluated
				 * and put in temps already, so what we have for left and right don't have side effects.
				 * So we can simply return (outtype)(left binop right) as the location of the result.
				 *
				 * ??? optimise by creating a CompValu that can have left.PushVal(),right.PushVal(),EmitBinOpCode() as its PushVal() ???
				 */
				CompValu retRVal = new CompValuTemp (TokenType.FromSysType (token.opcode, binOpStr.outtype), null, this);
				retRVal.isFinal = left.isFinal && right.isFinal;
				binOpStr.emitBO (this, token, left, right, retRVal);
				return retRVal;
			}

			/*
			 * Nothing in the table, check for comparing object pointers because of the myriad of types possible.
			 * This will compare list pointers, null pointers, script-defined type pointers, array pointers, etc.
			 * It will show equal iff the memory addresses are equal and that is good enough.
			 */
			if (!left.type.ToSysType().IsValueType && !right.type.ToSysType().IsValueType && ((opcodeIndex == "==") || (opcodeIndex == "!="))) {
				CompValu retRVal = new CompValuTemp (new TokenTypeInt (token), null, this);
				retRVal.isFinal = left.isFinal && right.isFinal;
				retRVal.PopPre (this, token);
				left.PushVal (this, token.rValLeft);
				right.PushVal (this, token.rValRight);
				ilGen.Emit (OpCodes.Ceq);
				if (opcodeIndex == "!=") {
					ilGen.PushInt (1);
					ilGen.Emit (OpCodes.Xor);
				}
				retRVal.PopPost (this, token);
				return retRVal;
			}

			/*
			 * If the opcode ends with "=", it may be something like "+=".
			 * So look up the key as if we didn't have the "=" to tell us if the operation is legal.
			 * Also, the binary operation's output type must be the same as the L-value type.
			 * Likewise, integer += float not allowed because result is float, but float += integer is ok.
			 */
			if (opcodeIndex.EndsWith ("=")) {
				key = leftIndex + opcodeIndex.Substring (0, opcodeIndex.Length - 1) + rightIndex;
				if (BinOpStr.defined.TryGetValue (key, out binOpStr)) {

					/*
					 * Now we know for something like %= that left%right is legal for the types given.
					 * We can only actually process it if the resultant type is of the left type.
					 * So for example, we can't do float += list, as float + list gives a list.
					 */
					if (binOpStr.outtype == left.type.ToSysType ()) {

						/*
						 * Types are ok, see if the '=' (read/modify/write) form is allowed...
						 */
						if (binOpStr.rmwOK) {
							if (leftLVal == null) {
								ErrorMsg (token, "invalid L-value for <op>=");
							} else {
								binOpStr.emitBO (this, token, leftLVal, right, leftLVal);
								////????DebitHeapLeft (left, true, token.rValLeft);
							}
							return left;
						}
					}
				}
			}

			/*
			 * Can't find it, oh well.
			 */
			ErrorMsg (token, "op not defined: " + leftIndex + " " + opcodeIndex + " " + rightIndex);
			return new CompValuVoid (token);
		}

		/**
		 * @brief compute the result of an unary operator
		 * @param token = unary operator token, includes the operand
		 * @returns where the resultant R-value is
		 */
		private CompValu GenerateFromRValOpUn (TokenRValOpUn token)
		{
			CompValu inRVal = GenerateFromRVal (token.rVal);

			/*
			 * Script-defined types can define their own methods to handle unary operators.
			 */
			if (inRVal.type is TokenTypeSDTypeClass) {
				TokenTypeSDTypeClass sdtType = (TokenTypeSDTypeClass)inRVal.type;
				TokenDeclSDTypeClass sdtDecl = sdtType.decl;
				TokenName funcName = new TokenName (token.opcode, "$op" + token.opcode.ToString ());
				TokenDeclVar declFunc = FindThisMember (sdtDecl, funcName, zeroArgs);
				if (declFunc != null) {
					CompValu method = new CompValuInstMeth (declFunc, inRVal, false);
					return GenerateACall (method, zeroCompValus, token);
				}
			}

			/*
			 * Otherwise use the default.
			 */
			return UnOpGenerate (inRVal, token.opcode);
		}

		/**
		 * @brief postfix operator -- this returns the type and location of the resultant value
		 */
		private CompValu GenerateFromRValAsnPost (TokenRValAsnPost asnPost)
		{
			CompValu lVal = GenerateFromLVal (asnPost.lVal);

			/*
			 * Make up a temp to save original value in.
			 */
			CompValu result = new CompValuTemp (lVal.type, null, this);

			/*
			 * Prepare to pop incremented value back into variable being incremented.
			 */
			lVal.PopPre (this, asnPost.lVal);

			/*
			 * Copy original value to temp and leave value on stack.
			 */
			lVal.PushVal (this, asnPost.lVal);
			result.PopPre (this, asnPost.lVal);  // this should push nothing on stack because it is a CIL local var
			ilGen.Emit (OpCodes.Dup);
			result.PopPost (this, asnPost.lVal);

			/*
			 * Perform the ++/--.
			 */
			if ((lVal.type is TokenTypeChar) || (lVal.type is TokenTypeInt)) {
				ilGen.PushInt (1);
			} else if (lVal.type is TokenTypeFloat) {
				ilGen.Emit (OpCodes.Ldc_R4, 1.0f);
			} else {
				lVal.PopPost (this, asnPost.lVal);
				ErrorMsg (asnPost, "invalid type for " + asnPost.postfix.ToString ());
				return lVal;
			}
			switch (asnPost.postfix.ToString ()) {
				case "++": {
					ilGen.Emit (OpCodes.Add);
					break;
				}
				case "--": {
					ilGen.Emit (OpCodes.Sub);
					break;
				}
				default: throw new Exception ("unknown asnPost op");
			}

			/*
			 * Store new value in original variable.
			 */
			lVal.PopPost (this, asnPost.lVal);

			return result;
		}

		/**
		 * @brief prefix operator -- this returns the type and location of the resultant value
		 */
		private CompValu GenerateFromRValAsnPre (TokenRValAsnPre asnPre)
		{
			CompValu lVal = GenerateFromLVal (asnPre.lVal);

			/*
			 * Make up a temp to put result in.
			 */
			CompValu result = new CompValuTemp (lVal.type, null, this);

			/*
			 * Prepare to pop incremented value back into variable being incremented.
			 */
			lVal.PopPre (this, asnPre.lVal);

			/*
			 * Push original value.
			 */
			lVal.PushVal (this, asnPre.lVal);

			/*
			 * Perform the ++/--.
			 */
			if ((lVal.type is TokenTypeChar) || (lVal.type is TokenTypeInt)) {
				ilGen.PushInt (1);
			} else if (lVal.type is TokenTypeFloat) {
				ilGen.Emit (OpCodes.Ldc_R4, 1.0f);
			} else {
				lVal.PopPost (this, asnPre.lVal);
				ErrorMsg (asnPre, "invalid type for " + asnPre.prefix.ToString ());
				return lVal;
			}
			switch (asnPre.prefix.ToString ()) {
				case "++": {
					ilGen.Emit (OpCodes.Add);
					break;
				}
				case "--": {
					ilGen.Emit (OpCodes.Sub);
					break;
				}
				default: throw new Exception ("unknown asnPre op");
			}

			/*
			 * Store new value in temp variable, keeping new value on stack.
			 */
			result.PopPre (this, asnPre.lVal);  // this should push nothing on stack because it is a CIL local var
			ilGen.Emit (OpCodes.Dup);
			result.PopPost (this, asnPre.lVal);

			/*
			 * Store new value in original variable.
			 */
			lVal.PopPost (this, asnPre.lVal);

			return result;
		}

		/**
		 * @brief Generate code that calls a function or object's method.
		 * @returns where the call's return value is stored (a TokenTypeVoid if void)
		 */
		private CompValu GenerateFromRValCall (TokenRValCall call)
		{
			CompValu method;
			CompValu[] argRVals;
			int i, nargs;
			TokenRVal arg;
			TokenType[] argTypes;

			/*
			 * Compute the values of all the function's call arguments.
			 * Save where the computation results are in the argRVals[] array.
			 * Might as well build the argument signature from the argument types, too.
			 */
			nargs = call.nArgs;
			argRVals = new CompValu[nargs];
			argTypes = new TokenType[nargs];
			if (nargs > 0) {
				i = 0;
				for (arg = call.args; arg != null; arg = (TokenRVal)arg.nextToken) {
					argRVals[i] = GenerateFromRVal (arg);
					argTypes[i] = argRVals[i].type;
					i ++;
				}
			}

			/*
			 * Get function/method's entrypoint that matches the call argument types.
			 */
			method = GenerateFromRVal (call.meth, argTypes);
			if (method == null) return null;

			return GenerateACall (method, argRVals, call);
		}

		/**
		 * @brief Generate call to a function/method.
		 * @param method = function/method being called
		 * @param argVRVals = its call parameters (zero length if none)
		 * @param call = where in source code call is being made from (for error messages)
		 * @returns type and location of return value (CompValuVoid if none)
		 */
		private CompValu GenerateACall (CompValu method, CompValu[] argRVals, Token call)
		{
			CompValu result;
			int i, nargs;
			TokenType retType;
			TokenType[] argTypes;

			/*
			 * Inline functions know how to generate their own call.
			 */
			if (method is CompValuInline) {
				CompValuInline inline = (CompValuInline)method;
				result = SetupReturnLocation (inline.declInline.retType, call);
				inline.declInline.codeGen (this, call, result, argRVals);
				return result;
			}

			/*
			 * Otherwise must be some other kind of callable.
			 */
			retType = method.GetRetType ();  // TokenTypeVoid if void; null means a variable
			if (retType == null) {
				ErrorMsg (call, "must be a function or method");
				return new CompValuVoid (call);
			}

			/*
			 * Stick in a label here that stack frame restore code can jump to
			 * in case the function being called calls CheckRun().
			 */
			if (!method.IsFuncTrivial (this)) new CallLabel (this);

			/*
			 * Make sure we have a place to put return value and prepare to pop return value into it.
			 * The PopPre() call must be done before pushing anything else so PopPost() will work.
			 */
			result = SetupReturnLocation (retType, call);

			/*
			 * Push whatever the function/method needs as a this argument, if anything.
			 */
			method.CallPre (this, call);

			/*
			 * Push the script-visible args, left-to-right.
			 */
			argTypes = method.GetArgTypes ();
			nargs    = argRVals.Length;
			for (i = 0; i < nargs; i ++) {
				if (argTypes == null) {
					argRVals[i].PushVal (this, call);
				} else {
					argRVals[i].PushVal (this, call, argTypes[i]);
				}
			}

			/*
			 * Now output call instruction.
			 */
			method.CallPost (this, call);

			/*
			 * Deal with the return value (if any), by putting it in 'result'.
			 */
			result.PopPost (this, call, retType);
			return result;
		}

		private CompValu SetupReturnLocation (TokenType retType, Token call)
		{
			CompValu result;
			if (retType is TokenTypeVoid) {
				result = new CompValuVoid (retType);
			} else {
				result = new CompValuTemp (retType, null, this);
			}
			result.PopPre (this, call);
			return result;
		}

		/**
		 * @brief Generate code that casts a value to a particular type.
		 * @returns where the result of the conversion is stored.
		 */
		private CompValu GenerateFromRValCast (TokenRValCast cast)
		{
			/*
			 * If casting to a delegate type, use the argment signature 
			 * of the delegate to help select the function/method, eg, 
			 *    '(delegate string(integer))ToString'
			 * will select 'string ToString(integer x)'
			 * instaead of 'string ToString(float x)' or anything else
			 */
			TokenType[] argsig = null;
			TokenType outType = cast.castTo;
			if (outType is TokenTypeSDTypeDelegate) {
				argsig = ((TokenTypeSDTypeDelegate)outType).decl.GetArgTypes ();
			}

			/*
			 * Generate the value that is being cast.
			 * If the value is already the requested type, just use it as is.
			 */
			CompValu inRVal = GenerateFromRVal (cast.rVal, argsig);
			if (inRVal.type == outType) return inRVal;

			/*
			 * Different type, generate casting code, putting the result in a temp of the output type.
			 */
			//??? optimize by having CompValu.PushVal() emit code for the conversion instead of needing a temp ???//
			CompValu outRVal = new CompValuTemp (outType, null, this);
			outRVal.isFinal = inRVal.isFinal;
			outRVal.PopPre (this, cast);
			inRVal.PushVal (this, cast, outType, true);
			outRVal.PopPost (this, cast);
			return outRVal;
		}

		/**
		 * @brief Constant in the script somewhere
		 * @returns where the constants value is stored
		 */
		private CompValu GenerateFromRValConst (TokenRValConst rValConst)
		{
			if (rValConst.val is char) {
				return new CompValuChar (new TokenTypeChar (rValConst), (char)(rValConst.val));
			}
			if (rValConst.val is SCRIPTFLOAT) {
				return new CompValuFloat (new TokenTypeFloat (rValConst), (SCRIPTFLOAT)(rValConst.val));
			}
			if (rValConst.val is int) {
				return new CompValuInteger (new TokenTypeInt (rValConst), (int)(rValConst.val));
			}
			if (rValConst.val is string) {
				return new CompValuString (new TokenTypeStr (rValConst), (string)(rValConst.val));
			}
			throw new Exception ("unknown constant type " + rValConst.val.GetType ());
		}

		/**
		 * @brief generate a new list object
		 * @param rValList = an rVal to create it from
		 */
		private CompValu GenerateFromRValList (TokenRValList rValList)
		{
			CompValu newList = new CompValuTemp (new TokenTypeList (rValList.rVal), null, this);
			newList.PopPre (this, rValList);

			/*
			 * Create a temp array to hold all the initial values.
			 */
			ilGen.PushInt (rValList.nItems);
			ilGen.Emit (OpCodes.Newarr, typeof (object));

			/*
			 * Populate the array.
			 */
			int i = 0;
			for (TokenRVal val = rValList.rVal; val != null; val = (TokenRVal)val.nextToken) {

				/*
				 * Get pointer to temp array object.
				 */
				ilGen.Emit (OpCodes.Dup);

				/*
				 * Get index in that array.
				 */
				ilGen.PushInt (i);

				/*
				 * Emit code to compute initial value for the element.
				 */
				CompValu eRVal = GenerateFromRVal (val);

				/*
				 * Store initialization value in array location.
				 * However, floats and ints need to be converted to LSL_Float and LSL_Integer,
				 * or things like llSetPayPrice() will puque when they try to cast the elements
				 * to LSL_Float or LSL_Integer.  Likewise with string/LSL_String.
				 *
				 * Maybe it's already LSL-boxed so we don't do anything with it except make sure
				 * it is an object, not a struct.
				 */
				eRVal.PushVal (this, val);
				if (eRVal.type.ToLSLWrapType () == null) {
					if (eRVal.type is TokenTypeFloat) {
						ilGen.Emit (OpCodes.Newobj, lslFloatConstructorInfo);
						ilGen.Emit (OpCodes.Box, typeof (LSL_Float));
					} else if (eRVal.type is TokenTypeInt) {
						ilGen.Emit (OpCodes.Newobj, lslIntegerConstructorInfo);
						ilGen.Emit (OpCodes.Box, typeof (LSL_Integer));
					} else if (eRVal.type is TokenTypeStr) {
						ilGen.Emit (OpCodes.Newobj, lslStringConstructorInfo);
						ilGen.Emit (OpCodes.Box, typeof (LSL_String));
					} else if (eRVal.type.ToSysType ().IsValueType) {
						ilGen.Emit (OpCodes.Box, eRVal.type.ToSysType ());
					}
				} else if (eRVal.type.ToLSLWrapType ().IsValueType) {

					// Convert the LSL value structs to an object of the LSL-boxed type
					ilGen.Emit (OpCodes.Box, eRVal.type.ToLSLWrapType ());
				}
				ilGen.Emit (OpCodes.Stelem, typeof (object));
				i ++;
			}

			/*
			 * Create new list object from temp initial value array (whose ref is still on the stack).
			 */
			ilGen.Emit (OpCodes.Newobj, lslListConstructorInfo);
			newList.PopPost (this, rValList);
			return newList;
		}

		/**
		 * @brief New array allocation with initializer expressions.
		 */
		private CompValu GenerateFromRValNewArIni (TokenRValNewArIni rValNewArIni)
		{
			return MallocAndInitArray (rValNewArIni.arrayType, rValNewArIni.valueList);
		}

		/**
		 * @brief Mallocate and initialize an array from its initialization list.
		 * @param arrayType = type of the array to be allocated and initialized
		 * @param values    = initialization value list used to size and initialize the array.
		 * @returns memory location of the resultant initialized array.
		 */
		private CompValu MallocAndInitArray (TokenType arrayType, TokenList values)
		{
			TokenDeclSDTypeClass arrayDecl = ((TokenTypeSDTypeClass)arrayType).decl;
			TokenType eleType = arrayDecl.arrayOfType;
			int rank = arrayDecl.arrayOfRank;

			// Get size of each of the dimensions by scanning the initialization value list
			int[] dimSizes = new int[rank];
			FillInDimSizes (dimSizes, 0, rank, values);

			// Figure out where the array's $new() method is
			TokenType[] newargsig = new TokenType[rank];
			for (int k = 0; k < rank; k ++) {
				newargsig[k] = tokenTypeInt;
			}
			TokenDeclVar newMeth = FindThisMember (arrayDecl, new TokenName (null, "$new"), newargsig);

			// Output a call to malloc the array with all default values
			//    array = ArrayType.$new (dimSizes[0], dimSizes[1], ...)
			CompValu array = new CompValuTemp (arrayType, "$newarini", this);
			array.PopPre (this, arrayType);
			PushXMRInst ();
			for (int k = 0; k < rank; k ++) {
				ilGen.PushInt (dimSizes[k]);
			}
			ilGen.Emit (OpCodes.Call, newMeth.ilGen);
			array.PopPost (this, arrayType);

			// Figure out where the array's Set() method is
			TokenType[] setargsig = new TokenType[rank+1];
			for (int k = 0; k < rank; k ++) {
				setargsig[k] = tokenTypeInt;
			}
			setargsig[rank] = eleType;
			TokenDeclVar setMeth = FindThisMember (arrayDecl, new TokenName (null, "Set"), setargsig);

			// Fill in the array with the initializer values
			FillInInitVals (array, setMeth, dimSizes, 0, rank, values, eleType);

			// The array is our resultant value
			return array;
		}

		/**
		 * @brief Compute an array's dimensions given its initialization value list
		 * @param dimSizes = filled in with array's dimensions
		 * @param dimNo    = what dimension the 'values' list applies to
		 * @param rank     = total number of dimensions of the array
		 * @param values   = list of values to initialize the array's 'dimNo' dimension with
		 * @returns with dimSizes[dimNo..rank-1] filled in
		 */
		private static void FillInDimSizes (int[] dimSizes, int dimNo, int rank, TokenList values)
		{
			// the size of a dimension is the largest number of initializer elements at this level
			// for dimNo 0, this is the number of elements in the top-level list
			if (dimSizes[dimNo] < values.tl.Count) dimSizes[dimNo] = values.tl.Count;

			// see if there is another dimension to calculate
			if (++ dimNo < rank) {

				// its size is the size of the largest initializer list at the next inner level
				foreach (Token val in values.tl) {
					if (val is TokenList) {
						TokenList subvals = (TokenList)val;
						FillInDimSizes (dimSizes, dimNo, rank, subvals);
					}
				}
			}
		}

		/**
		 * @brief Output code to fill in array's initialization values
		 * @param array      = array to be filled in
		 * @param setMeth    = the array's Set() method
		 * @param subscripts = holds subscripts being built
		 * @param dimNo      = which dimension the 'values' are for
		 * @param values     = list of initialization values for dimension 'dimNo'
		 * @param rank       = number of dimensions of 'array'
		 * @param values     = list of values to initialize the array's 'dimNo' dimension with
		 * @param eleType    = the element's type
		 * @returns with code emitted to initialize array's [subscripts[0], ..., subscripts[dimNo-1], *, *, ...]
		 *                                                          dimNo and up completely filled ---^
		 */
		private void FillInInitVals (CompValu array, TokenDeclVar setMeth, int[] subscripts, int dimNo, int rank, TokenList values, TokenType eleType)
		{
			subscripts[dimNo] = 0;
			foreach (Token val in values.tl) {
				CompValu initValue = null;

				/*
				 * If it is a sublist, process it.
				 *    If we don't have enough subscripts yet, hopefully that sublist will have enough.
				 *    If we already have enough subscripts, then that sublist can be for an element of this supposedly jagged array.
				 */
				if (val is TokenList) {
					TokenList sublist = (TokenList)val;
					if (dimNo + 1 < rank) {

						/*
						 * We don't have enough subscripts yet, hopefully the sublist has the rest.
						 */
						FillInInitVals (array, setMeth, subscripts, dimNo + 1, rank, sublist, eleType);
					} else if ((eleType is TokenTypeSDTypeClass) && (((TokenTypeSDTypeClass)eleType).decl.arrayOfType == null)) {

						/*
						 * If we aren't a jagged array either, we can't do anything with the sublist.
						 */
						ErrorMsg (val, "too many brace levels");
					} else {

						/*
						 * We are a jagged array, so malloc a subarray and initialize it with the sublist.
						 * Then we can use that subarray to fill this array's element.
						 */
						initValue = MallocAndInitArray (eleType, sublist);
					}
				}

				/*
				 * If it is a value expression, then output code to compute the value.
				 */
				if (val is TokenRVal) {
					if (dimNo + 1 < rank) {
						ErrorMsg ((Token)val, "not enough brace levels");
					} else {
						initValue = GenerateFromRVal ((TokenRVal)val);
					}
				}

				/*
				 * If there is an initValue, output "array.Set (subscript[0], subscript[1], ..., initValue)"
				 */
				if (initValue != null) {
					array.PushVal (this, val);
					for (int i = 0; i <= dimNo; i ++) {
						ilGen.PushInt (subscripts[i]);
					}
					initValue.PushVal (this, val, eleType);
					ilGen.Emit (OpCodes.Call, setMeth.ilGen);
				}

				/*
				 * That subscript is processed one way or another, on to the next.
				 */
				subscripts[dimNo] ++;
			}
		}

		/**
		 * @brief parenthesized expression
		 * @returns type and location of the result of the computation.
		 */
		private CompValu GenerateFromRValParen (TokenRValParen rValParen)
		{
			return GenerateFromRVal (rValParen.rVal);
		}

		/**
		 * @brief create a rotation object from the x,y,z,w value expressions.
		 */
		private CompValu GenerateFromRValRot (TokenRValRot rValRot)
		{
			CompValu xRVal, yRVal, zRVal, wRVal;

			xRVal = GenerateFromRVal (rValRot.xRVal);
			yRVal = GenerateFromRVal (rValRot.yRVal);
			zRVal = GenerateFromRVal (rValRot.zRVal);
			wRVal = GenerateFromRVal (rValRot.wRVal);
			return new CompValuRot (new TokenTypeRot (rValRot), xRVal, yRVal, zRVal, wRVal);
		}

		/**
		 * @brief Using 'this' as a pointer to the current script-defined instance object.
		 *        The value is located in arg #0 of the current instance method.
		 */
		private CompValu GenerateFromRValThis (TokenRValThis zhis)
		{
			if (!IsSDTInstMethod ()) {
				ErrorMsg (zhis, "cannot access instance member of class from static method");
				return new CompValuVoid (zhis);
			}
			return new CompValuArg (curDeclFunc.sdtClass.MakeRefToken (zhis), 0);
		}

		/**
		 * @brief 'undefined' constant.
		 *        If this constant gets written to an array element, it will delete that element from the array.
		 *        If the script retrieves an element by key that is not defined, it will get this value.
		 *        This value can be stored in and retrieved from variables of type 'object' or script-defined classes.
		 *        It is a runtime error to cast this value to any other type, eg, 
		 *        we don't allow list or string variables to be null pointers.
		 */
		private CompValu GenerateFromRValUndef (TokenRValUndef rValUndef)
		{
			return new CompValuNull (new TokenTypeUndef (rValUndef));
		}

		/**
		 * @brief create a vector object from the x,y,z value expressions.
		 */
		private CompValu GenerateFromRValVec (TokenRValVec rValVec)
		{
			CompValu xRVal, yRVal, zRVal;

			xRVal = GenerateFromRVal (rValVec.xRVal);
			yRVal = GenerateFromRVal (rValVec.yRVal);
			zRVal = GenerateFromRVal (rValVec.zRVal);
			return new CompValuVec (new TokenTypeVec (rValVec), xRVal, yRVal, zRVal);
		}

		/**
		 * @brief Generate code to process an <rVal> is <type> expression, and produce a boolean value.
		 */
		private CompValu GenerateFromRValIsType (TokenRValIsType rValIsType)
		{
			/*
			 * Expression we want to know the type of.
			 */
			CompValu val = GenerateFromRVal (rValIsType.rValExp);

			/*
			 * Pass it in to top-level type expression decoder.
			 */
			return GenerateFromTypeExp (val, rValIsType.typeExp);
		}

		/**
		 * @brief See if the type of the given value matches the type expression.
		 * @param val = where the value to be evaluated is stored
		 * @param typeExp = script tokens representing type expression
		 * @returns location where the boolean result is stored
		 */
		private CompValu GenerateFromTypeExp (CompValu val, TokenTypeExp typeExp)
		{
			if (typeExp is TokenTypeExpBinOp) {
				CompValu left   = GenerateFromTypeExp (val, ((TokenTypeExpBinOp)typeExp).leftOp);
				CompValu right  = GenerateFromTypeExp (val, ((TokenTypeExpBinOp)typeExp).rightOp);
				CompValu result = new CompValuTemp (tokenTypeBool, null, this);
				Token op = ((TokenTypeExpBinOp)typeExp).binOp;
				result.PopPre (this, typeExp);
				left.PushVal (this, ((TokenTypeExpBinOp)typeExp).leftOp);
				right.PushVal (this, ((TokenTypeExpBinOp)typeExp).rightOp);
				if (op is TokenKwAnd) {
					ilGen.Emit (OpCodes.And);
				} else if (op is TokenKwOr) {
					ilGen.Emit (OpCodes.Or);
				} else {
					throw new Exception ("unknown TokenTypeExpBinOp " + op.GetType ());
				}
				result.PopPost (this, typeExp);
				return result;
			}
			if (typeExp is TokenTypeExpNot) {
				CompValu interm = GenerateFromTypeExp (val, ((TokenTypeExpNot)typeExp).typeExp);
				CompValu result = new CompValuTemp (tokenTypeBool, null, this);
				result.PopPre (this, typeExp);
				interm.PushVal (this, ((TokenTypeExpNot)typeExp).typeExp, tokenTypeBool);
				ilGen.PushInt (1);
				ilGen.Emit (OpCodes.Xor);
				result.PopPost (this, typeExp);
				return result;
			}
			if (typeExp is TokenTypeExpPar) {
				return GenerateFromTypeExp (val, ((TokenTypeExpPar)typeExp).typeExp);
			}
			if (typeExp is TokenTypeExpType) {
				CompValu result = new CompValuTemp (tokenTypeBool, null, this);
				result.PopPre (this, typeExp);
				val.PushVal (this, typeExp);
				ilGen.Emit (OpCodes.Isinst, ((TokenTypeExpType)typeExp).typeToken.ToSysType ());
				ilGen.Emit (OpCodes.Ldnull);
				ilGen.Emit (OpCodes.Ceq);
				ilGen.PushInt (1);
				ilGen.Emit (OpCodes.Xor);
				result.PopPost (this, typeExp);
				return result;
			}
			if (typeExp is TokenTypeExpUndef) {
				CompValu result = new CompValuTemp (tokenTypeBool, null, this);
				result.PopPre (this, typeExp);
				val.PushVal (this, typeExp);
				ilGen.Emit (OpCodes.Ldnull);
				ilGen.Emit (OpCodes.Ceq);
				result.PopPost (this, typeExp);
				return result;
			}
			throw new Exception ("unknown TokenTypeExp type " + typeExp.GetType ());
		}

		/**
		 * @brief Push the default (null) value for a particular variable
		 * @param var = variable to get the default value for
		 * @returns with value pushed on stack
		 */
		public void PushVarDefaultValue (TokenDeclVar var)
		{
			PushDefaultValue (var.type);
		}
		public void PushDefaultValue (TokenType type)
		{
			if (type is TokenTypeArray) {
				PushXMRInst ();                // instance
				ilGen.PushInt (type.line);     // source line in file
				ilGen.PushInt (type.posn);     // source posn in line
				ilGen.Emit (OpCodes.Newobj, xmrArrayConstructorInfo);
				return;
			}
			if (type is TokenTypeChar) {
				ilGen.PushInt (0);
				return;
			}
			if (type is TokenTypeList) {
				ilGen.PushInt (0);
				ilGen.Emit (OpCodes.Newarr, typeof (object));
				ilGen.Emit (OpCodes.Newobj, lslListConstructorInfo);
				return;
			}
			if (type is TokenTypeRot) {
				// Mono is tOO stOOpid to allow: ilGen.Emit (OpCodes.Ldsfld, zeroRotationFieldInfo);
				ilGen.Emit (OpCodes.Ldc_R8, SCRIPTBASECLASS.ZERO_ROTATION.x);
				ilGen.Emit (OpCodes.Ldc_R8, SCRIPTBASECLASS.ZERO_ROTATION.y);
				ilGen.Emit (OpCodes.Ldc_R8, SCRIPTBASECLASS.ZERO_ROTATION.z);
				ilGen.Emit (OpCodes.Ldc_R8, SCRIPTBASECLASS.ZERO_ROTATION.s);
				ilGen.Emit (OpCodes.Newobj, lslRotationConstructorInfo);
				return;
			}
			if (type is TokenTypeStr) {
				ilGen.Emit (OpCodes.Ldstr, "");
				return;
			}
			if (type is TokenTypeVec) {
				// Mono is tOO stOOpid to allow: ilGen.Emit (OpCodes.Ldsfld, zeroVectorFieldInfo);
				ilGen.Emit (OpCodes.Ldc_R8, SCRIPTBASECLASS.ZERO_VECTOR.x);
				ilGen.Emit (OpCodes.Ldc_R8, SCRIPTBASECLASS.ZERO_VECTOR.y);
				ilGen.Emit (OpCodes.Ldc_R8, SCRIPTBASECLASS.ZERO_VECTOR.z);
				ilGen.Emit (OpCodes.Newobj, lslVectorConstructorInfo);
				return;
			}
			if (type is TokenTypeInt) {
				ilGen.PushInt (0);
				return;
			}
			if (type is TokenTypeFloat) {
				ilGen.Emit (OpCodes.Ldc_R4, 0.0f);
				return;
			}

			/*
			 * Default for 'object' type is 'undef'.
			 * Likewise for script-defined classes and interfaces.
			 */
			if ((type is TokenTypeObject) || (type is TokenTypeSDTypeClass) || (type is TokenTypeSDTypeInterface)) {
				ilGen.Emit (OpCodes.Ldnull);
				return;
			}

			/*
			 * Void is pushed as the default return value of a void function.
			 * So just push nothing as expected of void functions.
			 */
			if (type is TokenTypeVoid) {
				return;
			}

			/*
			 * Default for 'delegate' type is 'undef'.
			 */
			if (type is TokenTypeSDTypeDelegate) {
				ilGen.Emit (OpCodes.Ldnull);
				return;
			}

			throw new Exception ("unknown type " + type.ToString ());
		}

		/**
		 * @brief Determine if the expression has a constant boolean value
		 *        and if so, if the value is true or false.
		 * @param expr = expression to evaluate
		 * @returns true: expression is contant and has boolean value true
		 *         false: otherwise
		 */
		private bool IsConstBoolExprTrue (CompValu expr)
		{
			bool constVal;
			return IsConstBoolExpr (expr, out constVal) && constVal;
		}

		private bool IsConstBoolExpr (CompValu expr, out bool constVal)
		{
			if (expr is CompValuFloat) {
				constVal = ((CompValuFloat)expr).x != (SCRIPTFLOAT)0;
				return true;
			}
			if (expr is CompValuInteger) {
				constVal = ((CompValuInteger)expr).x != 0;
				return true;
			}

			constVal = false;
			return false;
		}

		/**
		 * @brief Determine if the expression has a constant integer value
		 *        and if so, return the integer value.
		 * @param expr = expression to evaluate
		 * @returns true: expression is contant and has integer value
		 *         false: otherwise
		 */
		private bool IsConstIntExpr (CompValu expr, out int constVal)
		{
			if (expr is CompValuChar) {
				constVal = (int)((CompValuChar)expr).x;
				return true;
			}
			if (expr is CompValuInteger) {
				constVal = ((CompValuInteger)expr).x;
				return true;
			}

			constVal = 0;
			return false;
		}

		/**
		 * @brief create table of legal event handler prototypes.
		 *        This is used to make sure script's event handler declrations are valid.
		 */
		private static VarDict CreateLegalEventHandlers ()
		{
			/*
			 * Get handler prototypes with full argument lists.
			 */
			VarDict leh = new InternalFuncDict (typeof (IEventHandlers), false);

			/*
			 * We want the scripts to be able to declare their handlers with
			 * fewer arguments than the full argument lists.  So define additional 
			 * prototypes with fewer arguments.
			 */
			TokenDeclVar[] fullArgProtos = new TokenDeclVar[leh.Count];
			int i = 0;
			foreach (TokenDeclVar fap in leh) fullArgProtos[i++] = fap;

			foreach (TokenDeclVar fap in fullArgProtos) {
				TokenArgDecl fal = fap.argDecl;
				int fullArgCount = fal.vars.Length;
				for (i = 0; i < fullArgCount; i ++) {
					TokenArgDecl shortArgList = new TokenArgDecl (null);
					for (int j = 0; j < i; j ++) {
						TokenDeclVar var = fal.vars[j];
						shortArgList.AddArg (var.type, var.name);
					}
					TokenDeclVar shortArgProto = new TokenDeclVar (null, null, null);
					shortArgProto.name         = new TokenName (null, fap.GetSimpleName ());
					shortArgProto.retType      = fap.retType;
					shortArgProto.argDecl      = shortArgList;
					leh.AddEntry (shortArgProto);
				}
			}

			return leh;
		}

		/**
		 * @brief Emit a call to CheckRun(), (voluntary multitasking switch)
		 */
		public void EmitCallCheckRun (int line)
		{
			if (curDeclFunc.IsFuncTrivial (this)) throw new Exception (curDeclFunc.fullName + " is supposed to be trivial");
			new CallLabel (this);                           // jump here when stack restored
			PushXMRInst ();                                 // instance
			ilGen.PushInt (line);                           // source line number
			ilGen.Emit (OpCodes.Call, checkRunMethodInfo);  // instance.CheckRun()
		}

		/**
		 * @brief Maintain list of current function's local variables so we can keep track
		 *        of heap usage.  We don't have to keep track of stack usage as that is done
		 *        entirely within CheckRun().  Do not include arrays as they do their own heap tracking.
		 */
		private void NewLocalVariable (TokenDeclVar var)
		{
			if ((var.type is TokenTypeList) ||
			    (var.type is TokenTypeStr)) {
				TokenDeclVar htVar = new TokenDeclVar (var, null, tokenScript);
				htVar.type         = new TokenTypeInt (var);
				htVar.name         = new TokenName (var, "__htl_" + var.name.val);
				htVar.location     = new CompValuTemp (htVar.type, htVar.name.val, this);
				var.heapTracker    = htVar;
				DebitHeapLeft (var, false, var);
			}
		}

		/**
		 * @brief A variable was just assigned a value.  If the variable references heap,
		 *        debit the instance.heapLeft to make sure the script doesn't hog memory.
		 * @param var = instance, local or global variable
		 * @param stValid = false: heapTracker contains garbage, so don't bother adding it back first
		 *                   true: heapTracker contains previous debit quantity, so add it back first
		 * @param where = token giving location in source code of assignment for tracing/debug
		 */
		private void DebitHeapLeft (TokenDeclVar var, bool stValid, Token where)
		{
			/*
			 * See if the variable is heap tracked
			 * and if so, output call to check heap usage.
			 */
			TokenDeclVar htVar = var.heapTracker;
			if (htVar != null) {
				CompValu heapTracker = htVar.location;
				heapTracker.PopPre (this, where);
				
				PushXMRInst ();                                       // instance

				var.location.PushVal (this, where);                   // object we care about

				if (stValid) {
					heapTracker.PushVal (this, where);            // previously debited amount or ...
				} else {
					ilGen.PushInt (0);                            // 0 because nothing debited before
				}

				ilGen.PushInt (where.line);
				ilGen.PushInt (where.posn);

				ilGen.Emit (OpCodes.Call, updateHeapLeftMethodInfo);  // update instance.heapLeft
				                                                      // throws exception if not enuf left

				heapTracker.PopPost (this, where);                    // new debited amount
			}
		}

		/**
		 * @brief A function is about to return, so credit any debits on heapLeft by its local variables.
		 */
		private void CreditAllLocalsHeapLeft ()
		{
			bool first = true;

			foreach (TokenDeclVar localVar in curDeclFunc.localVars) {
				TokenDeclVar htLocalVar = localVar.heapTracker;
				if (htLocalVar == null) continue;

				CompValu heapTracker = htLocalVar.location;
				if (!((CompValuTemp)heapTracker).isReferenced) continue;
				if (first) {
					PushXMRInst ();                                  // instance
					ilGen.Emit (OpCodes.Ldflda, heapLeftFieldInfo);  // &instance.heapLeft
					heapTracker.PushVal (this, localVar);            // numberOfBytes subtracted from heapLeft
					first = false;
				} else {
					heapTracker.PushVal (this, localVar);            // numberOfBytes subtracted from heapLeft
					ilGen.Emit (OpCodes.Add);                        // add them back to heapLeft
				}
			}
			if (!first) {
				ilGen.Emit (OpCodes.Call, interlockedAddMethodInfo);     // ...atomically
				ilGen.Emit (OpCodes.Pop);                                // we don't need return value
			}
		}

		/**
		 * @brief handle a unary operator, such as -x.
		 */
		private CompValu UnOpGenerate (CompValu inRVal, Token opcode)
		{
			/*
			 * - Negate
			 */
			if (opcode is TokenKwSub) {
				if (inRVal.type is TokenTypeFloat) {
					CompValu outRVal = new CompValuTemp (new TokenTypeFloat (opcode), null, this);
					outRVal.PopPre (this, opcode);        // set up for a pop
					inRVal.PushVal (this, opcode, outRVal.type);  // push value to negate, make sure not LSL-boxed
					ilGen.Emit (OpCodes.Neg);             // compute the negative
					outRVal.PopPost (this, opcode);       // pop into result
					return outRVal;                       // tell caller where we put it
				}
				if (inRVal.type is TokenTypeInt) {
					CompValu outRVal = new CompValuTemp (new TokenTypeInt (opcode), null, this);
					outRVal.PopPre (this, opcode);        // set up for a pop
					inRVal.PushVal (this, opcode, outRVal.type);  // push value to negate, make sure not LSL-boxed
					ilGen.Emit (OpCodes.Neg);             // compute the negative
					outRVal.PopPost (this, opcode);       // pop into result
					return outRVal;                       // tell caller where we put it
				}
				if (inRVal.type is TokenTypeVec) {
					CompValu outRVal = new CompValuTemp (inRVal.type, null, this);
					outRVal.PopPre (this, opcode);        // set up for a pop
					inRVal.PushVal (this, opcode);        // push vector, then call negate routine
					ilGen.Emit (OpCodes.Call, lslVectorNegateMethodInfo);
					outRVal.PopPost (this, opcode);       // pop into result
					return outRVal;                       // tell caller where we put it
				}
				ErrorMsg (opcode, "can't negate a " + inRVal.type.ToString ());
				return inRVal;
			}

			/*
			 * ~ Complement (bitwise integer)
			 */
			if (opcode is TokenKwTilde) {
				if (inRVal.type is TokenTypeInt) {
					CompValu outRVal = new CompValuTemp (new TokenTypeInt (opcode), null, this);
					outRVal.PopPre (this, opcode);        // set up for a pop
					inRVal.PushVal (this, opcode, outRVal.type);  // push value to negate, make sure not LSL-boxed
					ilGen.Emit (OpCodes.Not);             // compute the complement
					outRVal.PopPost (this, opcode);       // pop into result
					return outRVal;                       // tell caller where we put it
				}
				ErrorMsg (opcode, "can't complement a " + inRVal.type.ToString ());
				return inRVal;
			}

			/*
			 * ! Not (boolean)
			 *
			 * We stuff the 0/1 result in an int because I've seen x+!y in scripts
			 * and we don't want to have to create tables to handle int+bool and
			 * everything like that.
			 */
			if (opcode is TokenKwExclam) {
				CompValu outRVal = new CompValuTemp (new TokenTypeInt (opcode), null, this);
				outRVal.PopPre (this, opcode);         // set up for a pop
				inRVal.PushVal (this, opcode, tokenTypeBool);  // anything converts to boolean
				ilGen.PushInt (1);                     // then XOR with 1 to flip it
				ilGen.Emit (OpCodes.Xor);
				outRVal.PopPost (this, opcode);        // pop into result
				return outRVal;                        // tell caller where we put it
			}

			throw new Exception ("unhandled opcode " + opcode.ToString ());
		}

		/**
		 * @brief This is called while trying to compute the value of constant initializers.
		 *        It is passed a name and that name is looked up in the constant tables.
		 */
		private TokenRVal LookupInitConstants (TokenRVal rVal, ref bool didOne)
		{
			/*
			 * If it is a static field of a script-defined type, look it up and hopefully we find a constant there.
			 */
			TokenDeclVar gblVar;
			if (rVal is TokenLValSField) {
				TokenLValSField lvsf = (TokenLValSField)rVal;
				if (lvsf.baseType is TokenTypeSDTypeClass) {
					TokenDeclSDTypeClass sdtClass = ((TokenTypeSDTypeClass)lvsf.baseType).decl;
					gblVar = sdtClass.members.FindExact (lvsf.fieldName.val, null);
					if (gblVar != null) {
						if (gblVar.constant && (gblVar.init is TokenRValConst)) {
							didOne = true;
							return gblVar.init;
						}
					}
				}
				return rVal;
			}

			/*
			 * Only other thing we handle is stand-alone names.
			 */
			if (!(rVal is TokenLValName)) return rVal;
			string name = ((TokenLValName)rVal).name.val;

			/*
			 * If we are doing the initializations for a script-defined type,
			 * look for the constant among the fields for that type.
			 */
			if (currentSDTClass != null) {
				gblVar = currentSDTClass.members.FindExact (name, null);
				if (gblVar != null) {
					if (gblVar.constant && (gblVar.init is TokenRValConst)) {
						didOne = true;
						return gblVar.init;
					}
					return rVal;
				}
			}

			/*
			 * Look it up as a script-defined global variable.
			 * Then if the variable is defined as a constant and has a constant value,
			 * we are successful.  If it is defined as something else, return failure.
			 */
			gblVar = tokenScript.variablesStack.FindExact (name, null);
			if (gblVar != null) {
				if (gblVar.constant && (gblVar.init is TokenRValConst)) {
					didOne = true;
					return gblVar.init;
				}
				return rVal;
			}

			/*
			 * Maybe it is a built-in symbolic constant.
			 */
			ScriptConst scriptConst = ScriptConst.Lookup (name);
			if (scriptConst != null) {
				rVal = CompValuConst2RValConst (scriptConst.rVal, rVal);
				if (rVal is TokenRValConst) {
					didOne = true;
					return rVal;
				}
			}

			/*
			 * Don't know what it is, return failure.
			 */
			return rVal;
		}

		/**
		 * @brief This is called while trying to compute the value of constant expressions.
		 *        It is passed a name and that name is looked up in the constant tables.
		 */
		private TokenRVal LookupBodyConstants (TokenRVal rVal, ref bool didOne)
		{
			/*
			 * If it is a static field of a script-defined type, look it up and hopefully we find a constant there.
			 */
			TokenDeclVar gblVar;
			if (rVal is TokenLValSField) {
				TokenLValSField lvsf = (TokenLValSField)rVal;
				if (lvsf.baseType is TokenTypeSDTypeClass) {
					TokenDeclSDTypeClass sdtClass = ((TokenTypeSDTypeClass)lvsf.baseType).decl;
					gblVar = sdtClass.members.FindExact (lvsf.fieldName.val, null);
					if ((gblVar != null) && gblVar.constant && (gblVar.init is TokenRValConst)) {
						didOne = true;
						return gblVar.init;
					}
				}
				return rVal;
			}

			/*
			 * Only other thing we handle is stand-alone names.
			 */
			if (!(rVal is TokenLValName)) return rVal;
			string name = ((TokenLValName)rVal).name.val;

			/*
			 * Scan through the variable stack and hopefully we find a constant there.
			 * But we stop as soon as we get a match because that's what the script is referring to.
			 */
			CompValu val;
			for (VarDict vars = ((TokenLValName)rVal).stack; vars != null; vars = vars.outerVarDict) {
				TokenDeclVar var = vars.FindExact (name, null);
				if (var != null) {
					val = var.location;
					goto foundit;
				}
			}

			/*
			 * Maybe it is a built-in symbolic constant.
			 */
			ScriptConst scriptConst = ScriptConst.Lookup (name);
			if (scriptConst != null) {
				val = scriptConst.rVal;
				goto foundit;
			}

			/*
			 * Don't know what it is, return failure.
			 */
			return rVal;

			/*
			 * Found a CompValu.  If it's a simple constant, then use it.
			 * Otherwise tell caller we failed to simplify.
			 */
		foundit:
			rVal = CompValuConst2RValConst (val, rVal);
			if (rVal is TokenRValConst) {
				didOne = true;
			}
			return rVal;
		}

		private static TokenRVal CompValuConst2RValConst (CompValu val, TokenRVal rVal)
		{
			if (val is CompValuChar)    rVal = new TokenRValConst (rVal, ((CompValuChar)val).x);
			if (val is CompValuFloat)   rVal = new TokenRValConst (rVal, ((CompValuFloat)val).x);
			if (val is CompValuInteger) rVal = new TokenRValConst (rVal, ((CompValuInteger)val).x);
			if (val is CompValuString)  rVal = new TokenRValConst (rVal, ((CompValuString)val).x);
			return rVal;
		}

		/**
		 * @brief Generate code to push XMR_Instance pointer on stack.
		 */
		public void PushXMRInst ()
		{
			// for everything except script-defined class instance methods,
			// arg 0 holds the XMR_Instance pointer
			ilGen.Emit (OpCodes.Ldarg_0);

			if (IsSDTInstMethod ()) {

				// for script-defined class instance methods,
				// arg 0 holds the XMRSDTypeClObj pointer
				// and so we read the XMR_Instance pointer from
				// its XMRSDTypeClObj.xmrInst field
				ilGen.Emit (OpCodes.Ldfld, sdtXMRInstFieldInfo);
			}
		}

		/**
		 * @returns true: Ldarg_0 gives XMRSDTypeClObj pointer
		 *                - this is the case for instance methods
		 *         false: Ldarg_0 gives XMR_Instance pointer
		 *                - this is the case for both global functions and static methods
		 */
		public bool IsSDTInstMethod ()
		{
			return (curDeclFunc.sdtClass != null) && 
			       ((curDeclFunc.sdtFlags & ScriptReduce.SDT_STATIC) == 0);
		}

		/**
		 * @brief Look for a simply named function or variable (not a field or method)
		 */
		public TokenDeclVar FindNamedVar (TokenLValName lValName, TokenType[] argsig)
		{
			/*
			 * Look in variable stack for the given name.
			 */
			for (VarDict vars = lValName.stack; vars != null; vars = vars.outerVarDict) {

				// first look for it possibly with an argument signature
				// so we pick the correct overloaded method
				TokenDeclVar var = FindSingleMember (vars, lValName.name, argsig);
				if (var != null) return var;

				// if that fails, try it without the argument signature.
				// delegates get entered like any other variable, ie, 
				// no signature on their name.
				if (argsig != null) {
					var = FindSingleMember (vars, lValName.name, null);
					if (var != null) return var;
				}
			}

			/*
			 * If not found, try one of the built-in constants or functions.
			 */
			if (argsig == null) {
				ScriptConst scriptConst = ScriptConst.Lookup (lValName.name.val);
				if (scriptConst != null) {
					TokenDeclVar var = new TokenDeclVar (lValName.name, null, tokenScript);
					var.name     = lValName.name;
					var.type     = scriptConst.rVal.type;
					var.location = scriptConst.rVal;
					return var;
				}
			} else {
				TokenDeclVar inline = FindSingleMember (inlineFunctions, lValName.name, argsig);
				if (inline != null) return inline;
			}

			return null;
		}

		/**
		 * @brief Find a member of a script-defined type class.
		 * @param sdtType = reference to class declaration
		 * @param name = name of member to find
		 * @param argsig = argument signature used to select among overloaded members
		 * @returns null: no such member found
		 *          else: the member found
		 */
		public TokenDeclVar FindThisMember (TokenTypeSDTypeClass sdtType, TokenName name, TokenType[] argsig)
		{
			return FindThisMember (sdtType.decl, name, argsig);
		}
		public TokenDeclVar FindThisMember (TokenDeclSDTypeClass sdtDecl, TokenName name, TokenType[] argsig)
		{
			for (TokenDeclSDTypeClass sdtd = sdtDecl; sdtd != null; sdtd = sdtd.extends) {
				TokenDeclVar declVar = FindSingleMember (sdtd.members, name, argsig);
				if (declVar != null) return declVar;
			}
			return null;
		}

		/**
		 * @brief Look for a single member that matches the given name and argument signature
		 * @param where = which dictionary to look in
		 * @param name = basic name of the field or method, eg, "Printable"
		 * @param argsig = argument types the method is being called with, eg, "(string)"
		 *                 or null to find a field
		 * @returns null: no member found
		 *          else: the member found
		 */
		private TokenDeclVar FindSingleMember (VarDict where, TokenName name, TokenType[] argsig)
		{
			TokenDeclVar[] members = where.FindCallables (name.val, argsig);
			if (members == null) return null;
			if (members.Length > 1) {
				ErrorMsg (name, "more than one matching member");
				for (int i = 0; i < members.Length; i ++) {
					ErrorMsg (members[i], "  " + members[i].argDecl.GetArgSig ());
				}
			}
			CheckAccess (members[0], name);
			return members[0];
		}

		/**
		 * @brief Find an exact function name and argument signature match.
		 *        Also verify that the return value type is an exact match.
		 * @param where = which method dictionary to look in
		 * @param name = basic name of the method, eg, "Printable"
		 * @param ret = expected return value type
		 * @param argsig = argument types the method is being called with, eg, "(string)"
		 * @returns null: no exact match found
		 *          else: the matching function
		 */
		private TokenDeclVar FindExactWithRet (VarDict where, TokenName name, TokenType ret, TokenType[] argsig)
		{
			TokenDeclVar func = where.FindExact (name.val, argsig);
			if ((func != null) && (func.retType.ToString () != ret.ToString ())) {
				ErrorMsg (name, "return type mismatch, have " + func.retType.ToString () + ", expect " + ret.ToString ());
			}
			if (func != null) CheckAccess (func, name);
			return func;
		}

		/**
		 * @brief Check the private/protected/public access flags of a member.
		 */
		private void CheckAccess (TokenDeclVar var, Token errorAt)
		{
			TokenDeclSDType nested;
			TokenDeclSDType definedBy  = var.sdtClass;
			TokenDeclSDType accessedBy = curDeclFunc.sdtClass;

			/*******************************\
			 *  Check member-level access  *
			\*******************************/

			/*
			 * Note that if accessedBy is null, ie, accessing from global function (or event handlers),
			 * anything tagged as SDT_PRIVATE or SDT_PROTECTED will fail.
			 */

			/*
			 * Private means accessed by the class that defined the member or accessed by a nested class
			 * of the class that defined the member.
			 */
			if ((var.sdtFlags & ScriptReduce.SDT_PRIVATE) != 0) {
				for (nested = accessedBy; nested != null; nested = nested.outerSDType) {
					if (nested == definedBy) goto acc1ok;
				}
				ErrorMsg (errorAt, "private member " + var.fullName + " cannot be accessed by " + curDeclFunc.fullName);
				return;
			}

			/*
			 * Protected means:
			 *   If being accessed by an inner class, the inner class has access to it if the inner class derives 
			 *   from the declaring class.  It also has access to it if an outer class derives from the declaring 
			 *   class.
			 */
			if ((var.sdtFlags & ScriptReduce.SDT_PROTECTED) != 0) {
				for (nested = accessedBy; nested != null; nested = nested.outerSDType) {
					for (TokenDeclSDType rootward = nested; rootward != null; rootward = rootward.extends) {
						if (rootward == definedBy) goto acc1ok;
					}
				}
				ErrorMsg (errorAt, "protected member " + var.fullName + " cannot be accessed by " + curDeclFunc.fullName);
				return;
			}
		acc1ok:

			/******************************\
			 *  Check class-level access  *
			\******************************/

			/*
			 * If being accessed by same or inner class than where defined, it is ok.
			 *
			 *      class DefiningClass {
			 *          varBeingAccessed;
			 *                         .
			 *                         .
			 *                         .
			 *                  class AccessingClass {
			 *                      functionDoingAccess() { }
			 *                  }
			 *                         .
			 *                         .
			 *                         .
			 *      }
			 */
			nested = accessedBy;
			while (true) {
				if (nested == definedBy) return;
				if (nested == null) break;
				nested = (TokenDeclSDTypeClass)nested.outerSDType;
			}

			/*
			 * It is being accessed by an outer class than where defined, 
			 * check for a 'private' or 'protected' class tag that blocks.
			 */
			do {

				/*
				 * If the field's class is defined directly inside the accessing class,
				 * access is allowed regardless of class-level private or protected tags.
				 *
				 *      class AccessingClass {
				 *          functionDoingAccess() { }
				 *          class DefiningClass {
				 *              varBeingAccessed;
				 *          }
				 *      }
				 */
				if (definedBy.outerSDType == accessedBy) return;

				/*
				 * If the field's class is defined two or more levels inside the accessing class, 
				 * access is denied if the defining class is tagged private.
				 *
				 *      class AccessingClass {
				 *          functionDoingAccess() { }
				 *                         .
				 *                         .
				 *                         .
				 *                  class IntermediateClass {
				 *                      private class DefiningClass {
				 *                          varBeingAccessed;
				 *                      }
				 *                  }
				 *                         .
				 *                         .
				 *                         .
				 *      }
				 */
				if ((definedBy.accessLevel & ScriptReduce.SDT_PRIVATE) != 0) {
					ErrorMsg (errorAt, "member " + var.fullName + " cannot be accessed by " + curDeclFunc.fullName + 
					                   " because of private class " + definedBy.longName.val);
					return;
				}

				/*
				 * Likewise, if DefiningClass is tagged protected, the AccessingClass must derive from the
				 * IntermediateClass or access is denied.
				 */
				if ((definedBy.accessLevel & ScriptReduce.SDT_PROTECTED) != 0) {
					for (TokenDeclSDType extends = accessedBy; extends != definedBy.outerSDType; extends = extends.extends) {
						if (extends == null) {
							ErrorMsg (errorAt, "member " + var.fullName + " cannot be accessed by " + curDeclFunc.fullName + 
							                   " because of protected class " + definedBy.longName.val);
							return;
						}
					}
				}

				/*
				 * Check next outer level.
				 */
				definedBy = definedBy.outerSDType;
			} while (definedBy != null);
		}

		/**
		 * @brief Convert a list of argument types to printable string, eg, "(list,string,float,integer)"
		 *        If given a null, return "" indicating it is a field not a method
		 */
		public static string ArgSigString (TokenType[] argsig)
		{
			if (argsig == null) return "";
			StringBuilder sb = new StringBuilder ("(");
			for (int i = 0; i < argsig.Length; i ++) {
				if (i > 0) sb.Append (",");
				sb.Append (argsig[i].ToString ());
			}
			sb.Append (")");
			return sb.ToString ();
		}

		/**
		 * @brief output error message and remember that we did
		 */
		public void ErrorMsg (Token token, string message)
		{
			if ((token == null) || (token.emsg == null)) token = errorMessageToken;
			if (!youveAnError || (token.file != lastErrorFile) || (token.line > lastErrorLine)) {
				token.ErrorMsg (message);
				youveAnError  = true;
				lastErrorFile = token.file;
				lastErrorLine = token.line;
			}
		}

		/**
		 * @brief Find a private static method.
		 * @param owner = class the method is part of
		 * @param name = name of method to find
		 * @param args = array of argument types
		 * @returns pointer to method
		 */
		public static MethodInfo GetStaticMethod (Type owner, string name, Type[] args)
		{
			MethodInfo mi = owner.GetMethod (name, BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic, null, args, null);
			if (mi == null) {
				throw new Exception ("undefined method " + owner.ToString () + "." + name);
			}
			return mi;
		}

		public static LSL_Vector LSLVectorNegate (LSL_Vector v) { return -v; }

		/**
		 * @brief Called at runtime to convert the string given by the script in a throw statement to an exception.
		 */
		public static Exception ThrowStrToExc (string msg)
		{
			return new ScriptThrownException (msg);
		}

		/**
		 * @brief Called at runtime to convert a caught exception to the string given to the catch clause.
		 *        If we return null, the script's catch clause will do a rethrow before letting the script see it.
		 */
		public static string CatchExcToStr (Exception exc)
		{
			if (exc is IXMRUncatchable) return null;
			return exc.ToString ();
		}

		/**
		 * @brief An heap referencing variable was just set to a new object so we need to
		 *        update instance.heapLeft to reflect the new amount of heap available
		 *        to the script.
		 * @param instance = script instance who's heap usage is being updated
		 * @param value = object pointer value that was just written
		 * @param oldHeapUse = what was previously debited by the variable that was just written
		 * @returns amount being debited by the new assignment
		 *          instance.heapLeft = adjusted to reflect new heap avaialbe to script
		 * Throws exception if the new value exceeds available amount.
		 */
		public static int UpdateHeapLeft (XMRInstAbstract instance, object value, int oldHeapUse, int srcLine, int srcPosn)
		{
			int newHeapUse = 0;

			     if (value is XMR_Array)  newHeapUse = ((XMR_Array)value).Size;
			else if (value is LSL_List)   newHeapUse = ((LSL_List)value).Size;
			else if (value is LSL_String) newHeapUse = ((LSL_String)value).Length * 2 + 24;
			else if (value is string)     newHeapUse = ((string)value).Length * 2 + 24;

			int heapNeeded  = newHeapUse - oldHeapUse;
			int newHeapLeft = Interlocked.Add (ref instance.heapLeft, -heapNeeded);
			int oldHeapLeft = newHeapLeft + heapNeeded;
			if (newHeapLeft < 0) {
				GC.Collect ();
				GC.WaitForPendingFinalizers ();  // in case XMR_Array can give anything back
				if (instance.heapLeft < 0) {
					///???throw new OutOfHeapException (heapNeeded, oldHeapLeft, srcLine, srcPosn);
				}
			}

			if (instance.traceHeapUse != null) {
				Console.WriteLine("traceHeapUse: {0} {1}.{2}: old={3} new={4} left={5}", 
					instance.traceHeapUse, srcLine, srcPosn, oldHeapUse, newHeapUse, instance.heapLeft);
			}

			return newHeapUse;
		}

		/**
		 * @brief Defines an internal label that is used as a target for 'break' and 'continue' statements.
		 */
		private class BreakContTarg {
			public ScriptMyLabel label;
			public bool used;
			public BreakContTarg (ScriptMyILGen ilGen, string name) {
				label = ilGen.DefineLabel (name);  // label to be used
				used  = false;                     // assume it isn't referenced at all
			}
		}

		/**
		 * @brief Convert 'objFileReader' format to 'scriptObjCode' format.
		 *   'objFileReader' is a serialized form of the CIL code we generated
		 *   'asmFileWriter' is where we write the disassembly to (or null if not wanted)
		 *   'scriptObjCode' is an in-memory object with methods filled in from the CIL code
		 * Throws an exception if there is any error (theoretically).
		 */
		public static ScriptObjCode PerformGeneration (string descName,
		                                               BinaryReader objFileReader, 
		                                               TextWriter asmFileWriter)
		{
			/*
			 * Check version number to make sure we know how to process file contents.
			 */
			char[] ocm = objFileReader.ReadChars (OBJECT_CODE_MAGIC.Length);
			if (new String (ocm) != OBJECT_CODE_MAGIC) {
				throw new Exception ("not an XMR object file (bad magic)");
			}
			int cvv = objFileReader.ReadInt32 ();
			if (cvv != COMPILED_VERSION_VALUE) {
				throw new Exception ("object version is " + cvv.ToString () + 
				                     " but accept only " + COMPILED_VERSION_VALUE.ToString ());
			}

			/*
			 * Fill in simple parts of scriptObjCode object.
			 */
			ScriptObjCode scriptObjCode = new ScriptObjCode ();
			scriptObjCode.sourceHash    = objFileReader.ReadString ();
			scriptObjCode.expiryDays    = objFileReader.ReadInt32 ();
			scriptObjCode.glblSizes.ReadFromFile (objFileReader);

			int nStates = objFileReader.ReadInt32 ();

			scriptObjCode.stateNames = new string[nStates];
			for (int i = 0; i < nStates; i ++) {
				scriptObjCode.stateNames[i] = objFileReader.ReadString ();
				if (asmFileWriter != null) {
					asmFileWriter.WriteLine ("  state[{0}] = {1}", i, scriptObjCode.stateNames[i]);
				}
			}

			if (asmFileWriter != null) {
				scriptObjCode.glblSizes.WriteAsmFile (asmFileWriter, "numGbl");
			}

			string gblName;
			while ((gblName = objFileReader.ReadString ()) != "") {
				string gblType = objFileReader.ReadString ();
				int gblIndex = objFileReader.ReadInt32 ();
				if (asmFileWriter != null) {
					asmFileWriter.WriteLine ("  {0} = {1}[{2}]", gblName, gblType, gblIndex);
				}
			}

			/*
			 * Read in script-defined types.
			 */
			scriptObjCode.sdObjTypesName = new Dictionary<string, TokenDeclSDType> ();
			scriptObjCode.sdDelTypes = new Dictionary<Type, string> ();
			int maxIndex = -1;
			while ((gblName = objFileReader.ReadString ()) != "") {
				TokenDeclSDType sdt = TokenDeclSDType.ReadFromFile (scriptObjCode.sdObjTypesName, 
				                                      gblName, objFileReader, asmFileWriter);
				scriptObjCode.sdObjTypesName.Add (gblName, sdt);
				if (maxIndex < sdt.sdTypeIndex) maxIndex = sdt.sdTypeIndex;
				if (sdt is TokenDeclSDTypeDelegate) {
					scriptObjCode.sdDelTypes.Add (sdt.GetSysType (), gblName);
				}
			}
			scriptObjCode.sdObjTypesIndx = new TokenDeclSDType[maxIndex+1];
			foreach (TokenDeclSDType sdt in scriptObjCode.sdObjTypesName.Values) {
				scriptObjCode.sdObjTypesIndx[sdt.sdTypeIndex] = sdt;
			}

			/*
			 * Now fill in the methods (the hard part).
			 */
			EndMethodWrapper endMethodWrapper     = new EndMethodWrapper ();
			endMethodWrapper.scriptObjCode        = scriptObjCode;
			endMethodWrapper.descName             = descName;
			scriptObjCode.scriptEventHandlerTable = new ScriptEventHandler[nStates,(int)ScriptEventCode.Size];
			scriptObjCode.dynamicMethods          = new Dictionary<string, DynamicMethod> ();
			ScriptObjWriter.CreateObjCode (scriptObjCode.sdObjTypesName, objFileReader, endMethodWrapper.EndMethod, asmFileWriter);

			/*
			 * We enter all script event handler methods in the ScriptEventHandler table.
			 * They are named:  __seh_<statenumber>_<eventnumber>_<bunchofstuffwedontcareabout>
			 */
			foreach (KeyValuePair<string, DynamicMethod> kvp in scriptObjCode.dynamicMethods) {
				string methName = kvp.Key;
				if (methName.StartsWith ("__seh_")) {
					int j = methName.IndexOf ('_', 6);      // terminates <statenumber>
					int k = methName.IndexOf ('_', j + 1);  // terminates <eventnumber>
					int stateCode = Int32.Parse (methName.Substring (6, j - 6));
					int eventCode = Int32.Parse (methName.Substring (j + 1, k - j - 1));
					scriptObjCode.scriptEventHandlerTable[stateCode,eventCode] = 
							(ScriptEventHandler)kvp.Value.CreateDelegate (typeof (ScriptEventHandler));
				}
			}

			/*
			 * Fill in all script-defined class vtables.
			 */
			foreach (TokenDeclSDType sdt in scriptObjCode.sdObjTypesIndx) {
				if ((sdt != null) && (sdt is TokenDeclSDTypeClass)) {
					TokenDeclSDTypeClass sdtc = (TokenDeclSDTypeClass)sdt;
					sdtc.FillVTables (scriptObjCode);
				}
			}

			return scriptObjCode;
		}

		/**
		 * @brief Called once for every method found in objFileReader file.
		 *        It enters the method in the ScriptObjCode object table so it can be called.
		 */
		private class EndMethodWrapper {
			public ScriptObjCode scriptObjCode;
			public string descName;

			public void EndMethod (DynamicMethod method)
			{
				scriptObjCode.dynamicMethods.Add (method.Name, method);
			}
		}
	}

	/**
	 * @brief Marker interface indicates an exception that can't be caught by a script-level try/catch.
	 */
	public interface IXMRUncatchable { }

	/**
	 * @brief Thrown by a script when it attempts to change to an undefined state.
	 * These can be detected at compile time but the moron XEngine compiles
	 * such things, so we compile them as runtime errors.
	 */
	public class ScriptUndefinedStateException : Exception {
		public string stateName;
		public ScriptUndefinedStateException (string stateName) : base ("undefined state " + stateName) {
			this.stateName = stateName;
		}
	}

	/**
	 * @brief Thrown by a script when it attempts to change to a defined state.
	 */
	public class ScriptChangeStateException : Exception, IXMRUncatchable {
		public int newState;
		public ScriptChangeStateException (int newState) {
			this.newState = newState;
		}
	}

	/**
	 * @brief Thrown by a script from a 'throw' statement.
	 */
	public class ScriptThrownException : Exception {
		public ScriptThrownException (string msg) : base (msg) { }
	}

	public class OutOfHeapException : Exception {
		public OutOfHeapException(int heapNeeded, int heapLeft, int srcLine, int srcPosn)
			: base ("need " + heapNeeded + ", have only " + heapLeft + 
				" heap bytes left at " + srcLine + ":" + srcPosn)
		{ }
	}
	public class OutOfStackException : Exception { }

	public class ScriptBadCallNoException : Exception {
		public ScriptBadCallNoException (int callNo) : base ("bad callNo " + callNo) { }
	}
}
