/********************************************************\
 *  COPYRIGHT 2009,2010, Mike Rieker, Beverly, MA, USA  *
 *  All rights reserved.                                *
\********************************************************/

using OpenSim.Region.ScriptEngine.Shared.ScriptBase;
using OpenSim.Region.ScriptEngine.XMREngine;
using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Reflection.Emit;
using System.Text;
using System.Threading;

#include "lsltypes.h"

/**
 * @brief translate a reduced script token into corresponding CIL code.
 * The single script token contains a tokenized and textured version of the whole script file.
 */

namespace OpenSim.Region.ScriptEngine.XMREngine
{

	public class ScriptCodeGen
	{
		public static readonly string OBJECT_CODE_MAGIC = "XMRObjectCode";
		public static int COMPILED_VERSION_VALUE = 15;  // incremented when compiler changes for compatibility testing

		public static readonly int CALL_FRAME_MEMUSE = 64;
		public static readonly int STRING_LEN_TO_MEMUSE = 2;

		public static Exception outOfStackException = new OutOfStackException ();

		/*
		 * Static tables that there only needs to be one copy of for all.
		 */
		private static Dictionary<string, BinOpStr> binOpStrings = BinOpStr.DefineBinOps ();
		private static Dictionary<string, CompValu> inlineFunctions = CompValuInline.CreateDictionary ();
		private static Dictionary<string, TokenDeclFunc> legalEventHandlers = CreateLegalEventHandlers ();
		private static TokenTypeBool   tokenTypeBool = new TokenTypeBool   (null);
		private static TokenTypeFloat  tokenTypeFlt  = new TokenTypeFloat  (null);
		private static TokenTypeInt    tokenTypeInt  = new TokenTypeInt    (null);
		private static TokenTypeObject tokenTypeObj  = new TokenTypeObject (null);
		private static TokenTypeRot    tokenTypeRot  = new TokenTypeRot    (null);
		private static TokenTypeStr    tokenTypeStr  = new TokenTypeStr    (null);
		private static TokenTypeVec    tokenTypeVec  = new TokenTypeVec    (null);
		private static Type[] instanceTypeArg = new Type[] { typeof (XMRInstAbstract) };

		private static ConstructorInfo lslFloatConstructorInfo = typeof (LSL_Float).GetConstructor (new Type[] { typeof (SCRIPTFLOAT) });
		private static ConstructorInfo lslIntegerConstructorInfo = typeof (LSL_Integer).GetConstructor (new Type[] { typeof (int) });
		private static ConstructorInfo lslListConstructorInfo = typeof (LSL_List).GetConstructor (new Type[] { typeof (object[]) });
		public  static ConstructorInfo lslRotationConstructorInfo = typeof (LSL_Rotation).GetConstructor (new Type[] { typeof (double), typeof (double), typeof (double), typeof (double) });
		private static ConstructorInfo lslStringConstructorInfo = typeof (LSL_String).GetConstructor (new Type[] { typeof (string) });
		public  static ConstructorInfo lslVectorConstructorInfo = typeof (LSL_Vector).GetConstructor (new Type[] { typeof (double), typeof (double), typeof (double) });
		private static ConstructorInfo scriptBadCallNoExceptionConstructorInfo = typeof (ScriptBadCallNoException).GetConstructor (new Type[] { typeof (int) });
		private static ConstructorInfo scriptChangeStateExceptionConstructorInfo = typeof (ScriptChangeStateException).GetConstructor (new Type[] { typeof (int) });
		private static ConstructorInfo scriptUndefinedStateExceptionConstructorInfo = typeof (ScriptUndefinedStateException).GetConstructor (new Type[] { typeof (string) });
		private static ConstructorInfo xmrArrayConstructorInfo = typeof (XMR_Array).GetConstructor (new Type[] { typeof (XMRInstAbstract), typeof (int), typeof (int) });
		private static FieldInfo callModeFieldInfo     = typeof (XMRInstAbstract).GetField ("callMode");
		private static FieldInfo doGblInitFieldInfo    = typeof (XMRInstAbstract).GetField ("doGblInit");
		private static FieldInfo ehArgsFieldInfo       = typeof (XMRInstAbstract).GetField ("ehArgs");
		public  static FieldInfo heapLeftFieldInfo     = typeof (XMRInstAbstract).GetField ("heapLeft");
		private static FieldInfo heapLimitFieldInfo    = typeof (XMRInstAbstract).GetField ("heapLimit");
		private static FieldInfo rotationXFieldInfo    = typeof (LSL_Rotation).GetField ("x");
		private static FieldInfo rotationYFieldInfo    = typeof (LSL_Rotation).GetField ("y");
		private static FieldInfo rotationZFieldInfo    = typeof (LSL_Rotation).GetField ("z");
		private static FieldInfo rotationSFieldInfo    = typeof (LSL_Rotation).GetField ("s");
		private static FieldInfo vectorXFieldInfo      = typeof (LSL_Vector).GetField ("x");
		private static FieldInfo vectorYFieldInfo      = typeof (LSL_Vector).GetField ("y");
		private static FieldInfo vectorZFieldInfo      = typeof (LSL_Vector).GetField ("z");

		private static MethodInfo arrayClearMethodInfo = typeof (XMR_Array).GetMethod ("__pub_clear", new Type[] { });
		private static MethodInfo arrayCountMethodInfo = typeof (XMR_Array).GetMethod ("__pub_count", new Type[] { });
		private static MethodInfo arrayIndexMethodInfo = typeof (XMR_Array).GetMethod ("__pub_index", new Type[] { typeof (int) });
		private static MethodInfo arrayValueMethodInfo = typeof (XMR_Array).GetMethod ("__pub_value", new Type[] { typeof (int) });
		private static MethodInfo checkRunMethodInfo   = typeof (XMRInstAbstract).GetMethod ("CheckRun", new Type[] { typeof (int) });
		private static MethodInfo ehArgUnwrapFloat     = GetStaticMethod (typeof (TypeCast), "EHArgUnwrapFloat",    new Type[] { typeof (object) });
		private static MethodInfo ehArgUnwrapInteger   = GetStaticMethod (typeof (TypeCast), "EHArgUnwrapInteger",  new Type[] { typeof (object) });
		private static MethodInfo ehArgUnwrapRotation  = GetStaticMethod (typeof (TypeCast), "EHArgUnwrapRotation", new Type[] { typeof (object) });
		private static MethodInfo ehArgUnwrapString    = GetStaticMethod (typeof (TypeCast), "EHArgUnwrapString",   new Type[] { typeof (object) });
		private static MethodInfo ehArgUnwrapVector    = GetStaticMethod (typeof (TypeCast), "EHArgUnwrapVector",   new Type[] { typeof (object) });
		private static MethodInfo forEachMethodInfo    = typeof (XMR_Array).GetMethod ("ForEach", 
		                                                                               new Type[] { typeof (int),
		                                                                                            typeof (object).MakeByRefType (),
		                                                                                            typeof (object).MakeByRefType () });
		private static MethodInfo captureStackFrameMethodInfo = typeof (XMRInstAbstract).GetMethod ("CaptureStackFrame", new Type[] { typeof (string), typeof (int), typeof (int) });
		private static MethodInfo restoreStackFrameMethodInfo = typeof (XMRInstAbstract).GetMethod ("RestoreStackFrame", new Type[] { typeof (string), typeof (int).MakeByRefType () });
		private static MethodInfo interlockedAddMethodInfo    = GetStaticMethod (typeof (Interlocked), "Add", new Type[] { typeof (int).MakeByRefType (), typeof (int) });
		private static MethodInfo updateHeapLeftMethodInfo = GetStaticMethod (typeof (ScriptCodeGen), 
		                                                                      "UpdateHeapLeft", 
		                                                                      new Type[] { typeof (XMRInstAbstract),
		                                                                                   typeof (object),
		                                                                                   typeof (int),
		                                                                                   typeof (int),
		                                                                                   typeof (int) });
		private static MethodInfo lslVectorNegateMethodInfo = GetStaticMethod (typeof (ScriptCodeGen), 
		                                                                       "LSLVectorNegate", 
		                                                                       new Type[] { typeof (LSL_Vector) });
		private static MethodInfo throwStrToExcMethodInfo = GetStaticMethod (typeof (ScriptCodeGen),
		                                                                     "ThrowStrToExc",
		                                                                     new Type[] { typeof (string) });
		private static MethodInfo catchExcToStrMethodInfo = GetStaticMethod (typeof (ScriptCodeGen),
		                                                                     "CatchExcToStr",
		                                                                     new Type[] { typeof (Exception) });

		public static bool CodeGen (TokenScript tokenScript, BinaryWriter objFileWriter)
		{
			TypeCast.CreateLegalTypeCasts ();

			/*
			 * Run compiler such that it has a 'this' context for convenience.
			 */
			ScriptCodeGen scg = new ScriptCodeGen (tokenScript, objFileWriter);

			/*
			 * Return pointer to resultant script object code.
			 */
			return !scg.youveAnError;
		}

		/*
		 * There is one set of these variables for each script being compiled.
		 */
		private bool mightGetHere = false;
		private bool youveAnError = false;
		private BreakContTarg curBreakTarg = null;
		private BreakContTarg curContTarg  = null;
		private int nStates = 0;
		private Token errorMessageToken = null;
		private TokenDeclFunc curDeclFunc = null;
		private TokenStmtBlock curStmtBlock = null;
		private BinaryWriter objFileWriter = null;
		private TokenScript tokenScript = null;
		public  int tempCompValuNum = 0;

		private Dictionary<string, TokenDeclFunc> scriptFunctions = null;
		private Dictionary<string, int> stateIndices = null;
		private Stack<Dictionary<string, CompValu>> scriptVariablesStack = null;
		private Dictionary<string, CompValu> scriptInstanceVariables = null;

		// code generation output
		public ScriptObjCode scriptObjCode = null;

		// These get cleared at beginning of every function definition
		public  ScriptMyILGen ilGen    = null;  // the output instruction stream
		private ScriptMyLabel retLabel = null;  // where to jump to exit function
		private ScriptMyLocal retValue = null;
		private ScriptMyLocal callNo   = null;
		private LinkedList<CallLabel> allCallLabels = new LinkedList<CallLabel> ();
		public  LinkedList<CompValuTemp> activeTemps = new LinkedList<CompValuTemp> ();

		private ScriptCodeGen (TokenScript tokenScript, BinaryWriter objFileWriter)
		{
			this.tokenScript   = tokenScript;
			this.objFileWriter = objFileWriter;

			try {
				PerformCompilation ();
			} finally {
				objFileWriter = null;
				scriptObjCode = null;
			}
		}

		/**
		 * @brief Convert 'tokenScript' to 'objFileWriter' format.
		 *   'tokenScript' is a parsed/reduced abstract syntax tree of the script source file
		 *   'objFileWriter' is a serialized form of the CIL code that we generate
		 * Note:  The scriptObjCode herein is only temporary and is discarded on return.
		 *        Use PerformGeneration() to create the 'real' one.
		 */
		private void PerformCompilation ()
		{

			/*
			 * errorMessageToken is used only when the given token doesn't have a
			 * output delegate associated with it such as for backend API functions
			 * that only have one copy for the whole system.  It is kept up-to-date
			 * approximately but is rarely needed so going to assume it doesn't have 
			 * to be exact.
			 */
			errorMessageToken = tokenScript;

			/*
			 * Set up dictionary to translate function names to their declaration.
			 * We only do top-level functions so this doesn't need to be a stack.
			 */
			scriptFunctions = new Dictionary<string, TokenDeclFunc> ();

			/*
			 * Set up dictionary to translate state names to their index number.
			 */
			stateIndices = new Dictionary<string, int> ();

			/*
			 * Assign each state its own unique index.
			 * The default state gets 0.
			 */
			nStates = 0;
			tokenScript.defaultState.body.index = nStates ++;
			stateIndices.Add ("default", 0);
			foreach (KeyValuePair<string, TokenDeclState> kvp in tokenScript.states) {
				TokenDeclState declState = kvp.Value;
				declState.body.index = nStates ++;
				stateIndices.Add (declState.name.val, declState.body.index);
			}

			/*
			 * Make up an array that translates state indices to state name strings.
			 */
			scriptObjCode = new ScriptObjCode ();
			scriptObjCode.stateNames = new string[nStates];
			scriptObjCode.stateNames[0] = "default";
			foreach (KeyValuePair<string, TokenDeclState> kvp in tokenScript.states) {
				TokenDeclState declState = kvp.Value;
				scriptObjCode.stateNames[declState.body.index] = declState.name.val;
			}

			/*
			 * Put script defined functions in 'scriptFunctions' dictionary so any calls
			 * made by functions or event handlers will be seen, in case of forward
			 * references.
			 *
			 * Prefix the names with __fun_ to keep them separate from any XMRInstance functions.
			 */
			foreach (KeyValuePair<string, TokenDeclFunc> kvp in tokenScript.funcs) {
				TokenDeclFunc declFunc = kvp.Value;
				scriptFunctions.Add (declFunc.funcName.val, declFunc);
			}

			/*
			 * Set up stack of dictionaries to translate variable names to their declaration.
			 * Then push the first element on the stack that will get the built-in functions.
			 * Then push the second element on the stack that will get any script-defined global variables.
			 */
			scriptVariablesStack = new Stack<Dictionary<string, CompValu>> ();
			scriptVariablesStack.Push (inlineFunctions);
			scriptInstanceVariables = PushVarDefnBlock ();

			/*
			 * Assign all global variables a slot in its corresponding XMRInstance.gbl<Type>s[] array.
			 * Global variables are simply elements of those arrays at runtime, thus we don't need to create
			 * an unique class for each script, we can just use XMRInstance as is for all.
			 */
			foreach (KeyValuePair<string, TokenDeclVar> kvp in tokenScript.vars) {
				TokenDeclVar declVar = kvp.Value;

				/*
				 * Omit 'constant' variables as they were handled by the reducer.
				 */
				if (declVar.constant) continue;

				/*
				 * Create entry in the value array for the variable.
				 */
				CompValu globalVar = new CompValuGlobalVar (declVar, scriptObjCode);

				/*
				 * Add its name to top-level variable definition stack so code can see it.
				 */
				AddVarDefinition (declVar.name, globalVar);

				/*
				 * If it references heap, add it to list of global vars that reference heap.  We use 
				 * this list to maintain instance.heapLeft to keep track of how much heap script is 
				 * allowed to use.  Do not include arrays as they do their own heap tracking.
				 */
				if ((declVar.type is TokenTypeList) ||
				    (declVar.type is TokenTypeStr)) {
					TokenDeclVar stDeclVar = new TokenDeclVar (declVar, null);
					stDeclVar.type = new TokenTypeInt (declVar);
					stDeclVar.name = new TokenName (declVar, "__htg_" + declVar.name.val);
					globalVar.heapTracker = new CompValuGlobalVar (stDeclVar, scriptObjCode);
				}
			}

			/*
			 * Write fixed portion of object file.
			 */
			objFileWriter.Write (OBJECT_CODE_MAGIC.ToCharArray ());
			objFileWriter.Write (COMPILED_VERSION_VALUE);

			objFileWriter.Write (scriptObjCode.numGblArrays);
			objFileWriter.Write (scriptObjCode.numGblFloats);
			objFileWriter.Write (scriptObjCode.numGblIntegers);
			objFileWriter.Write (scriptObjCode.numGblLists);
			objFileWriter.Write (scriptObjCode.numGblObjects);
			objFileWriter.Write (scriptObjCode.numGblRotations);
			objFileWriter.Write (scriptObjCode.numGblStrings);
			objFileWriter.Write (scriptObjCode.numGblVectors);

			objFileWriter.Write (nStates);
			for (int i = 0; i < nStates; i ++) {
				objFileWriter.Write (scriptObjCode.stateNames[i]);
			}

			/*
			 * For debugging, we also write out global variable assignments.
			 */
			foreach (KeyValuePair<string, CompValu> kvp in scriptInstanceVariables) {
				CompValuGlobalVar gblVar = (CompValuGlobalVar)kvp.Value;
				objFileWriter.Write (kvp.Key);            // string
				objFileWriter.Write (gblVar.field.Name);  // string
				objFileWriter.Write (gblVar.index);       // int
				CompValu heapTracker = kvp.Value.heapTracker;
				if (heapTracker != null) {
					gblVar = (CompValuGlobalVar)heapTracker;
					objFileWriter.Write ("__htg_" + kvp.Key);
					objFileWriter.Write (gblVar.field.Name);
					objFileWriter.Write (gblVar.index);
				}
			}
			objFileWriter.Write ("");

			/*
			 * Output each global function as a private method.
			 *
			 * Prefix the names with __fun_ to keep them separate from any XMRInstance functions.
			 */

			/*
			 * Output function headers then bodies.
			 * Do all headers first in case bodies do forward references.
			 */
			foreach (KeyValuePair<string, TokenDeclFunc> kvp in tokenScript.funcs) {
				TokenDeclFunc declFunc = kvp.Value;
				GenerateMethodHeader (declFunc);
			}
			foreach (KeyValuePair<string, TokenDeclFunc> kvp in tokenScript.funcs) {
				TokenDeclFunc declFunc = kvp.Value;
				GenerateMethodBody (declFunc);
			}

			/*
			 * Output default state event handler methods.
			 * Each event handler is a private static method named __seh_default_<eventname>.
			 * Splice in a default state_entry() handler if none defined so we init global vars.
			 */
			TokenDeclFunc defaultStateEntry = null;
			for (defaultStateEntry = tokenScript.defaultState.body.eventFuncs;
			     defaultStateEntry != null;
			     defaultStateEntry = (TokenDeclFunc)defaultStateEntry.nextToken) {
				if (defaultStateEntry.funcName.val == "state_entry") break;
			}
			if (defaultStateEntry == null) {
				defaultStateEntry               = new TokenDeclFunc (tokenScript.defaultState.body);
				defaultStateEntry.retType       = new TokenTypeVoid  (tokenScript.defaultState.body);
				defaultStateEntry.funcName      = new TokenName      (tokenScript.defaultState.body, "state_entry");
				defaultStateEntry.argDecl       = new TokenArgDecl   (tokenScript.defaultState.body);
				defaultStateEntry.argDecl.types = new TokenType[0];
				defaultStateEntry.argDecl.names = new TokenName[0];
				defaultStateEntry.argDecl.locns = new CompValu[0];
				defaultStateEntry.body          = new TokenStmtBlock (tokenScript.defaultState.body);
				defaultStateEntry.body.function = defaultStateEntry;

				defaultStateEntry.nextToken = tokenScript.defaultState.body.eventFuncs;
				tokenScript.defaultState.body.eventFuncs = defaultStateEntry;
			}
			GenerateStateEventHandlers ("default", tokenScript.defaultState.body);

			/*
			 * Output script-defined state event handler methods.
			 * Each event handler is a private static method named __seh_<statename>_<eventname>
			 */
			foreach (KeyValuePair<string, TokenDeclState> kvp in tokenScript.states) {
				TokenDeclState declState = kvp.Value;
				GenerateStateEventHandlers (declState.name.val, declState.body);
			}

			ScriptMyILGen.TheEnd (objFileWriter);

			scriptObjCode = null;
		}

		/**
		 * @brief generate event handler code
		 * Writes out a function definition for each state handler
		 * named __seh_<statename>_<eventname>
		 *
		 * However, each has just 'XMRInstance __sw' as its single argument
		 * and each of its user-visible argments is extracted from __sw.ehArgs[].
		 *
		 * So we end up generating something like this:
		 *
		 *   private static void __seh_<statecode>_<eventcode>_<statename>_<eventname>(XMRInstance __sw)
		 *   {
		 *      <typeArg0> <nameArg0> = (<typeArg0>)__sw.ehArgs[0];
		 *      <typeArg1> <nameArg1> = (<typeArg1>)__sw.ehArgs[1];
		 *
		 *      ... script code ...
		 *   }
		 *
		 * The continuations code assumes there will be no references to ehArgs[]
		 * after the first call to CheckRun() as CheckRun() makes no attempt to
		 * serialize the ehArgs[] array, as doing so would be redundant.  Any values
		 * from ehArgs[] that are being used will be in local stack variables and
		 * thus preserved that way.
		 */
		private void GenerateStateEventHandlers (string statename, TokenStateBody body)
		{
			for (Token t = body.eventFuncs; t != null; t = t.nextToken) {
				GenerateEventHandler (statename, (TokenDeclFunc)t);
			}
		}

		private void GenerateEventHandler (string statename, TokenDeclFunc declFunc)
		{
			string eventname = declFunc.funcName.val;
			TokenArgDecl argDecl = declFunc.argDecl;
			int nargs = argDecl.types.Length;

			/*
			 * Make sure event handler name is valid and that number and type of arguments is correct.
			 * Apparently some scripts exist with fewer than correct number of args in their declaration 
			 * so allow for that.  It is ok because the handlers are called with the arguments in an
			 * object[] array, and we just won't access the missing argments in the vector.
			 */
			if (!legalEventHandlers.ContainsKey (eventname)) {
				ErrorMsg (declFunc, "unknown event handler " + eventname);
				return;
			}
			TokenDeclFunc protoDeclFunc = legalEventHandlers[eventname];
			if (nargs > protoDeclFunc.argDecl.types.Length) {
				ErrorMsg (declFunc, eventname + "(...) supposed to have " + protoDeclFunc.argDecl.types.Length + 
				                    " arg(s), not " + nargs);
				nargs = protoDeclFunc.argDecl.types.Length;
			}

			/*
			 * In any case, for arguments that were specified, they must be of correct type.
			 */
			for (int i = 0; i < nargs; i ++) {
				if (protoDeclFunc.argDecl.types[i].ToSysType () != argDecl.types[i].ToSysType ()) {
					ErrorMsg (declFunc, eventname + "(... " + argDecl.types[i].ToString () + " " + 
					                    argDecl.names[i] + " ...) should be " + 
					                    protoDeclFunc.argDecl.types[i].ToString ());
				}
			}

			/*
			 * Output function header.
			 * They just have the XMRInstance pointer as the one argument.
			 */
			int statecode = stateIndices[statename];
			int eventcode = (int)Enum.Parse (typeof (ScriptEventCode), eventname);
			string functionName = "__seh_" + statecode.ToString() + "_" + eventcode.ToString () + "_" + 
			                                 statename + "_" + eventname;
			ilGen = new ScriptMyILGen (functionName,
			                           typeof (void),
			                           instanceTypeArg,
			                           objFileWriter);
			StartFunctionBody (declFunc);

			/*
			 * Output args as variable definitions and initialize each from __sw.ehArgs[].
			 * If the script writer goofed, the typecast will complain.
			 */
			if (nargs > 0) {
				ScriptMyLocal swehArgs = ilGen.DeclareLocal (typeof (object[]), "ehArgs");

				ilGen.Emit (OpCodes.Ldarg_0);                 // instance
				ilGen.Emit (OpCodes.Ldfld, ehArgsFieldInfo);  // instance.ehArgs
				ilGen.Emit (OpCodes.Stloc, swehArgs);

				for (int i = 0; i < nargs; i ++) {

					// <argtype> __lcl_<argname> = (<argtype>)__sw.ehArgs[i];
					TokenType argTokType = argDecl.types[i];
					Type argSysType = argTokType.ToSysType ();
					CompValu local = new CompValuTemp (argTokType, argDecl.names[i].val, this);
					argDecl.locns[i] = local;
					local.PopPre (this);
					ilGen.Emit (OpCodes.Ldloc, swehArgs);          // __sw.ehArgs
					PushConstantI4 (i);                            // array index = i
					ilGen.Emit (OpCodes.Ldelem, typeof (object));  // it is an array of objects
					TokenType stkTokType = tokenTypeObj;           // stack has a type 'object' on it now
					if (argSysType == typeof (SCRIPTFLOAT)) {      // LSL_Float/SCRIPTFLOAT -> SCRIPTFLOAT
						ilGen.Emit (OpCodes.Call, ehArgUnwrapFloat);
						stkTokType = tokenTypeFlt;             // stack has a type 'SCRIPTFLOAT' on it now
					}
					if (argSysType == typeof (int)) {              // LSL_Integer/int -> int
						ilGen.Emit (OpCodes.Call, ehArgUnwrapInteger);
						stkTokType = tokenTypeInt;             // stack has a type 'int' on it now
					}
					if (argSysType == typeof (LSL_Rotation)) {     // OpenMetaverse.Quaternion/LSL_Rotation -> LSL_Rotation
						ilGen.Emit (OpCodes.Call, ehArgUnwrapRotation);
						stkTokType = tokenTypeRot;             // stack has a type 'LSL_Rotation' on it now
					}
					if (argSysType == typeof (string)) {           // LSL_Key/LSL_String/string -> string
						ilGen.Emit (OpCodes.Call, ehArgUnwrapString);
						stkTokType = tokenTypeStr;             // stack has a type 'string' on it now
					}
					if (argSysType == typeof (LSL_Vector)) {       // OpenMetaverse.Vector3/LSL_Vector -> LSL_Vector
						ilGen.Emit (OpCodes.Call, ehArgUnwrapVector);
						stkTokType = tokenTypeVec;             // stack has a type 'LSL_Vector' on it now
					}
					local.PopPost (this, stkTokType);              // pop stack type into argtype

					/*
					 * Account for any heap usage by this local variable from now on to end of function.
					 */
					NewLocalVariable (local, argDecl.names[i]);

					/*
					 * The argument is now defined as a local variable accessible to the function body.
					 */
					AddVarDefinition (argDecl.names[i], local);
				}
			}

			/*
			 * Output code for the statements and clean up.
			 */
			GenerateFuncBody ();
		}

		/**
		 * @brief generate header for an arbitrary script-defined global function.
		 * @param name = name of the function
		 * @param argDecl = argument declarations
		 * @param body = function's code body
		 */
		private void GenerateMethodHeader (TokenDeclFunc declFunc)
		{
			string name = declFunc.funcName.val;
			TokenArgDecl argDecl = declFunc.argDecl;

			/*
			 * Make up array of all argument types.
			 * We splice in XMRInstance for the first arg as the function is static.
			 * Might as well build argument signature string while we're at it.
			 */
			StringBuilder argsigsb = new StringBuilder ("(");
			Type[] argTypes = new Type[argDecl.types.Length+1];
			argTypes[0] = typeof (XMRInstAbstract);
			for (int i = 0; i < argDecl.types.Length; i ++) {
				if (i > 0) argsigsb.Append (",");
				argsigsb.Append (argDecl.types[i].ToString ());
				argTypes[i+1] = argDecl.types[i].ToSysType ();
			}
			argsigsb.Append (")");
			string argsigst = argsigsb.ToString ();

			/*
			 * Set up entrypoint.
			 */
			string methodName = "__fun_" + name + argsigst;
			declFunc.ilGen = new ScriptMyILGen (methodName,
			                                    declFunc.retType.ToSysType (),
			                                    argTypes,
			                                    objFileWriter);

			/*
			 * Set up an entry as if it were a global variable so GenerateFromLValName () will see it.
			 * We have to cram the arg signature on the end of the name in case of overloading.
			 */
			TokenTypeDelegate delType = new TokenTypeDelegate (declFunc, declFunc.retType, argDecl.types);
			CompValu globalMeth = new CompValuGlobalMeth (declFunc, delType);
			AddVarDefinition (declFunc.funcName, delType.argSig, globalMeth);
		}

		/**
		 * @brief generate code for an arbitrary script-defined function.
		 * @param name = name of the function
		 * @param argDecl = argument declarations
		 * @param body = function's code body
		 */
		private void GenerateMethodBody (TokenDeclFunc declFunc)
		{
			/*
			 * Set up code generator for the function's contents.
			 */
			ilGen = declFunc.ilGen;
			StartFunctionBody (declFunc);

			/*
			 * Define all arguments as named variables so script body can reference them.
			 * The argument indices need to have +1 added to them because XMRInstance is spliced in at arg 0.
			 * Account for their heap usage just like they were local variables.
			 */
			TokenArgDecl argDecl = declFunc.argDecl;
			int nargs = argDecl.types.Length;
			for (int i = 0; i < nargs; i ++) {
				CompValu arg = new CompValuArg (argDecl.types[i], i + 1);
				argDecl.locns[i] = arg;
				NewLocalVariable (arg, argDecl.names[i]);
				AddVarDefinition (argDecl.names[i], arg);
			}

			/*
			 * Output code for the statements and clean up.
			 */
			GenerateFuncBody ();
		}

		private void StartFunctionBody (TokenDeclFunc declFunc)
		{
			/*
			 * Start current function being processed.
			 * Set 'mightGetHere' as the code at the top is always executed.
			 */
			mightGetHere = true;
			curBreakTarg = null;
			curContTarg  = null;
			curDeclFunc  = declFunc;

			/*
			 * Any vars defined by function, including its args, go in their own var block.
			 */
			PushVarDefnBlock ();

			/*
			 * Start generating code.
			 */
			ilGen.BegMethod ();
		}

		/**
		 * @brief Output function body (either event handler or script-defined method).
		 */
		private void GenerateFuncBody ()
		{
			/*
			 * Clear list of all call labels.
			 * A call label is inserted just before every call that can possibly
			 * call CheckRun(), including any direct calls to CheckRun().
			 * Then, when restoring stack, we can just switch to this label to
			 * resume at the correct spot.
			 */
			allCallLabels.Clear ();

			/*
			 * Clear list of active CompValuTemps.
			 */
			activeTemps.Clear ();

			/*
			 * Any return statements inside function body jump to this label
			 * after putting return value in __retval.
			 */
			retLabel = ilGen.DefineLabel ("__retlbl");
			retValue = null;
			if (!(curDeclFunc.retType is TokenTypeVoid)) {
				retValue = ilGen.DeclareLocal (curDeclFunc.retType.ToSysType (), "__retval");
			}

			/*
			 * Output:
			 *    int callNo;
			 *    if (instance.callMode != CALLMODE_NORMAL) goto __cmRestore;
			 */
			callNo = ilGen.DeclareLocal (typeof (int), "__callNo");
			ScriptMyLabel cmRestore = ilGen.DefineLabel ("__cmRestore");
			ilGen.Emit (OpCodes.Ldarg_0);
			if (XMRInstAbstract.CALLMODE_NORMAL != 0) throw new Exception ();
			ilGen.Emit (OpCodes.Ldfld, ScriptCodeGen.callModeFieldInfo);
			ilGen.Emit (OpCodes.Brtrue, cmRestore);

			/*
			 * Catch exceptions thrown by script body and any initialization code.
			 */
			ilGen.BeginExceptionBlock ();

			/*
			 * If this is the default state_entry() handler, output code to set all global
			 * variables to their initial values.  Note that every script must have a
			 * default state_entry() handler, we provide one if the script doesn't explicitly
			 * define one.
			 */
			string methname = ilGen.methName;
			if (methname.StartsWith ("__seh_") && methname.EndsWith ("_default_state_entry")) {
				ScriptMyLabel skipGblInitLabel = ilGen.DefineLabel ("__skipGblInit");
				ilGen.Emit (OpCodes.Ldarg_0);                    // instance
				ilGen.Emit (OpCodes.Ldfld, doGblInitFieldInfo);  // instance.doGblInit
				ilGen.Emit (OpCodes.Brfalse, skipGblInitLabel);
				ilGen.Emit (OpCodes.Ldarg_0);                    // instance
				ilGen.Emit (OpCodes.Dup);
				ilGen.Emit (OpCodes.Ldfld, heapLimitFieldInfo);  // instance.heapLimit
				ilGen.Emit (OpCodes.Stfld, heapLeftFieldInfo);   // instance.heapLeft
				foreach (KeyValuePair<string, TokenDeclVar> kvp in tokenScript.vars) {
					TokenDeclVar gblDeclVar = kvp.Value;

					if (gblDeclVar.constant) continue;
					CompValu var = scriptInstanceVariables[gblDeclVar.name.val];
					var.PopPre (this);
					if (gblDeclVar.init != null) {
						CompValu rVal = GenerateFromRVal (gblDeclVar.init);
						rVal.PushVal (this, gblDeclVar.type);
					} else {
						PushVarDefaultValue (gblDeclVar);
					}
					var.PopPost (this);

					DebitHeapLeft (var, false, gblDeclVar);
				}
				ilGen.Emit (OpCodes.Ldarg_0);                    // instance
				PushConstantI4 (0);
				ilGen.Emit (OpCodes.Stfld, doGblInitFieldInfo);  // instance.doGblInit
				ilGen.MarkLabel (skipGblInitLabel);
			}

			/*
			 * Alloc stack space for local vars.
			 * Also allocates corresponding heap-tracker vars.
			 */
			AllocLocalVarStackSpace ();

			/*
			 * See if time to suspend in case they are doing a loop with recursion.
			 */
			EmitCallCheckRun (curDeclFunc.line);

			/*
			 * Output code body.
			 */
			GenerateStmtBlock (curDeclFunc.body);

			/*
			 * If code falls through to this point, means they are missing 
			 * a return statement.  And that is legal only if the function 
			 * returns 'void'.
			 */
			if (mightGetHere) {
				if (!(curDeclFunc.retType is TokenTypeVoid)) {
					ErrorMsg (curDeclFunc.body, "missing final return statement");
				}
				ilGen.Emit (OpCodes.Leave, retLabel);
			}

			/*
			 * Output epilog that subtracts heap usage by local vars.
			 *
			 *   finally {
			 *      if (instance.callMode ! 0) goto __cmSave;
			 *      CreditAllLocalsHeapLeft();
			 *      goto __endFin;
			 *   __cmSave:
			 *      GenerateFrameCaptureCode();
			 *   __endFin:
			 *   }
			 */
			ilGen.BeginFinallyBlock ();
			ScriptMyLabel cmSave = ilGen.DefineLabel ("__cmSave");
			ScriptMyLabel endFin = ilGen.DefineLabel ("__endFin");
			ilGen.Emit (OpCodes.Ldarg_0);
			ilGen.Emit (OpCodes.Ldfld, callModeFieldInfo);
			if (XMRInstAbstract.CALLMODE_NORMAL != 0) throw new Exception ();
			ilGen.Emit (OpCodes.Brtrue, cmSave);
			CreditAllLocalsHeapLeft ();
			ilGen.Emit (OpCodes.Br, endFin);
			ilGen.MarkLabel (cmSave);
			GenerateFrameCaptureCode ();
			ilGen.MarkLabel (endFin);
			ilGen.Emit (OpCodes.Endfinally);
			ilGen.EndExceptionBlock ();

			/*
			 * Output the 'real' return opcode.
			 */
			ilGen.MarkLabel (retLabel);
			if (!(curDeclFunc.retType is TokenTypeVoid)) {
				ilGen.Emit (OpCodes.Ldloc, retValue);
			}
			ilGen.Emit (OpCodes.Ret);
			retLabel = null;
			retValue = null;

			/*
			 * Output code to restore stack frame from stream.
			 */
			ilGen.MarkLabel (cmRestore);
			GenerateFrameRestoreCode ();

			/*
			 * No more instructions for this method.
			 */
			ilGen.EndMethod ();
			ilGen = null;

			/*
			 * Pop off the top-level local definition block.
			 */
			PopVarDefnBlock ();

			/*
			 * Not generating function code any more.
			 */
			curBreakTarg = null;
			curContTarg  = null;
			curDeclFunc  = null;
		}


		/**
		 * @brief Allocate stack space and heap tracker for all local variables, regardless of
		 *        which { } statement block they are actually defined in.  This will allow the
		 *        heap trackers to keep track of any heap use within deeply nested blocks.
		 *
		 * We don't add it to the var definition stack as we don't want it to be visible
		 * until the script says the variable is declared.
		 */
		private void AllocLocalVarStackSpace ()
		{
			foreach (TokenDeclVar localVar in curDeclFunc.localVars) {

				/*
				 * Skip all 'constant' vars as they were handled by the reducer.
				 */
				if (localVar.constant) continue;

				/*
				 * Get a stack location for it and fill in with default value.
				 */
				CompValu localLoc = new CompValuTemp (localVar.type, localVar.name.val, this);
				localVar.location = localLoc;
				localLoc.PopPre (this);
				PushVarDefaultValue (localVar);
				localLoc.PopPost (this);

				/*
				 * Set up heap-tracker variable and fill in with corresponding value for 
				 * the variable's default value.
				 */
				NewLocalVariable (localLoc, localVar.name);
			}
		}

		/**
		 * @brief Generate code to write all arguments and locals to the capture stack frame.
		 *        This includes heap-tracker and temp variables.
		 */
		private void GenerateFrameCaptureCode ()
		{
			int nSaves = curDeclFunc.argDecl.locns.Length + curDeclFunc.localVars.Count + activeTemps.Count;

			/*
			 * Output code to allocate a stack frame object with an object array.
			 * This also pushes the stack frame object on the instance.stackFrames list.
			 * It returns a pointer to the object array it allocated.
			 */
			ilGen.Emit (OpCodes.Ldarg_0);
			ilGen.Emit (OpCodes.Ldstr, ilGen.methName);
			ilGen.Emit (OpCodes.Ldloc, callNo);
			PushConstantI4 (nSaves);
			ilGen.Emit (OpCodes.Call, captureStackFrameMethodInfo);

			/*
			 * Copy arg values to object array, boxing as needed.
			 */
			int i = 0;
			foreach (CompValu argLoc in curDeclFunc.argDecl.locns) {
				ilGen.Emit (OpCodes.Dup);
				PushConstantI4 (i ++);
				argLoc.PushVal (this, tokenTypeObj);
				ilGen.Emit (OpCodes.Stelem_Ref);
			}

			/*
			 * Copy local values to object array, boxing as needed.
			 */
			foreach (TokenDeclVar localVar in curDeclFunc.localVars) {
				ilGen.Emit (OpCodes.Dup);
				PushConstantI4 (i ++);
				CompValu localLoc = localVar.location;
				localLoc.PushVal (this, tokenTypeObj);
				ilGen.Emit (OpCodes.Stelem_Ref);
			}

			/*
			 * Copy temp values to object array, boxing as needed.
			 */
			foreach (CompValu temp in activeTemps) {
				ilGen.Emit (OpCodes.Dup);
				PushConstantI4 (i ++);
				temp.PushVal (this, tokenTypeObj);
				ilGen.Emit (OpCodes.Stelem_Ref);
			}

			ilGen.Emit (OpCodes.Pop);
		}

		/**
		 * @brief Generate code to restore all arguments and locals from the restore stack frame.
		 *        This includes heap-tracker and temp variables.
		 */
		private void GenerateFrameRestoreCode ()
		{
			ScriptMyLocal objArray = ilGen.DeclareLocal (typeof (object[]), "__restObjArray");

			/*
			 * Output code to pop stack frame from instance.stackFrames.
			 * It returns a pointer to the object array that contains values to be restored.
			 */
			ilGen.Emit (OpCodes.Ldarg_0);
			ilGen.Emit (OpCodes.Ldstr, ilGen.methName);
			ilGen.Emit (OpCodes.Ldloca, callNo);
			ilGen.Emit (OpCodes.Call, restoreStackFrameMethodInfo);
			ilGen.Emit (OpCodes.Stloc, objArray);

			/*
			 * Restore argument values from object array, unboxing as needed.
			 * Although the caller has restored them to what it called us with, it's possible that this 
			 * function has modified them since, so we need to do our own restore.
			 */
			int i = 0;
			foreach (CompValu argLoc in curDeclFunc.argDecl.locns) {
				argLoc.PopPre (this);
				ilGen.Emit (OpCodes.Ldloc, objArray);
				PushConstantI4 (i ++);
				ilGen.Emit (OpCodes.Ldelem_Ref);
				argLoc.PopPost (this, tokenTypeObj);
			}

			/*
			 * Restore local values from object array, unboxing as needed.
			 */
			foreach (TokenDeclVar localVar in curDeclFunc.localVars) {
				CompValu localLoc = localVar.location;
				localLoc.PopPre (this);
				ilGen.Emit (OpCodes.Ldloc, objArray);
				PushConstantI4 (i ++);
				ilGen.Emit (OpCodes.Ldelem_Ref);
				localLoc.PopPost (this, tokenTypeObj);
			}

			/*
			 * Restore temp values from object array, unboxing as needed.
			 */
			foreach (CompValu temp in activeTemps) {
				temp.PopPre (this);
				ilGen.Emit (OpCodes.Ldloc, objArray);
				PushConstantI4 (i ++);
				ilGen.Emit (OpCodes.Ldelem_Ref);
				temp.PopPost (this, tokenTypeObj);
			}

			/*
			 * Output a switch statement with a case for each possible value of callNo.
			 *
			 *   switch (callNo) {
			 *      case 0: goto __call_0;
			 *      case 1: goto __call_1;
			 *      ...
			 *   }
			 *   throw new ScriptBadCallNoException (callNo);
			 */
			ScriptMyLabel[] callLabels = new ScriptMyLabel[allCallLabels.Count];
			foreach (CallLabel cl in allCallLabels) {
				callLabels[cl.index] = cl.callLabel;
			}
			ilGen.Emit (OpCodes.Ldloc, callNo);
			ilGen.Emit (OpCodes.Switch, callLabels);

			ilGen.Emit (OpCodes.Ldloc, callNo);
			ilGen.Emit (OpCodes.Newobj, scriptBadCallNoExceptionConstructorInfo);
			ilGen.Emit (OpCodes.Throw);
		}

		/**
		 * @brief There is one of these per call that can possibly call CheckRun(),
		 *        including direct calls to CheckRun().
		 */
		private class CallLabel {
			public int           index;       // sequential integer, starting at 0
			public ScriptMyLabel callLabel;   // the actual label token

			public CallLabel (ScriptCodeGen scg)
			{
				this.index = scg.allCallLabels.Count;
				scg.allCallLabels.AddLast (this);
				this.callLabel = scg.ilGen.DefineLabel ("__call_" + index);
				scg.PushConstantI4(this.index);
				scg.ilGen.Emit (OpCodes.Stloc, scg.callNo);
				scg.ilGen.MarkLabel (this.callLabel);
			}
		};

		/**
		 * @brief generate code for an arbitrary statement.
		 */
		private void GenerateStmt (TokenStmt stmt)
		{
			errorMessageToken = stmt;
			if (stmt is TokenStmtBlock)   { GenerateStmtBlock   ((TokenStmtBlock)stmt);   return; }
			if (stmt is TokenStmtBreak)   { GenerateStmtBreak   ((TokenStmtBreak)stmt);   return; }
			if (stmt is TokenStmtCont)    { GenerateStmtCont    ((TokenStmtCont)stmt);    return; }
			if (stmt is TokenStmtDo)      { GenerateStmtDo      ((TokenStmtDo)stmt);      return; }
			if (stmt is TokenStmtFor)     { GenerateStmtFor     ((TokenStmtFor)stmt);     return; }
			if (stmt is TokenStmtForEach) { GenerateStmtForEach ((TokenStmtForEach)stmt); return; }
			if (stmt is TokenStmtIf)      { GenerateStmtIf      ((TokenStmtIf)stmt);      return; }
			if (stmt is TokenStmtJump)    { GenerateStmtJump    ((TokenStmtJump)stmt);    return; }
			if (stmt is TokenStmtLabel)   { GenerateStmtLabel   ((TokenStmtLabel)stmt);   return; }
			if (stmt is TokenStmtNull)    {                                               return; }
			if (stmt is TokenStmtRet)     { GenerateStmtRet     ((TokenStmtRet)stmt);     return; }
			if (stmt is TokenStmtRVal)    { GenerateStmtRVal    ((TokenStmtRVal)stmt);    return; }
			if (stmt is TokenStmtState)   { GenerateStmtState   ((TokenStmtState)stmt);   return; }
			if (stmt is TokenStmtSwitch)  { GenerateStmtSwitch  ((TokenStmtSwitch)stmt);  return; }
			if (stmt is TokenStmtThrow)   { GenerateStmtThrow   ((TokenStmtThrow)stmt);   return; }
			if (stmt is TokenStmtTry)     { GenerateStmtTry     ((TokenStmtTry)stmt);     return; }
			if (stmt is TokenStmtWhile)   { GenerateStmtWhile   ((TokenStmtWhile)stmt);   return; }
			throw new Exception ("unknown TokenStmt type " + stmt.GetType ().ToString ());
		}

		/**
		 * @brief generate statement block (ie, with braces)
		 */
		private void GenerateStmtBlock (TokenStmtBlock stmtBlock)
		{
			if (!mightGetHere) return;

			/*
			 * Start a new variable defintion block.
			 */
			PushVarDefnBlock ();

			/*
			 * Push new current statement block pointer for anyone who cares.
			 */
			TokenStmtBlock oldStmtBlock = curStmtBlock;
			curStmtBlock = stmtBlock;

			/*
			 * Output the statements that make up the block.
			 */
			for (Token t = stmtBlock.statements; t != null; t = t.nextToken) {
				if (t is TokenStmt) {
					GenerateStmt ((TokenStmt)t);
				} else {
					GenerateDeclVar ((TokenDeclVar)t);
				}
			}

			/*
			 * Pop the current statement block.
			 */
			curStmtBlock = oldStmtBlock;

			/*
			 * Pop the local var definition stack.
			 */
			PopVarDefnBlock ();
		}

		/**
		 * @brief output code for a 'break' statement
		 */
		private void GenerateStmtBreak (TokenStmtBreak breakStmt)
		{
			if (!mightGetHere) return;

			/*
			 * Make sure we are in a breakable situation.
			 */
			if (curBreakTarg == null) {
				ErrorMsg (breakStmt, "not in a breakable situation");
				return;
			}

			/*
			 * Output the goto instruction.
			 */
			ilGen.Emit (OpCodes.Br, curBreakTarg.label);

			/*
			 * Tell anyone who cares that the break target was actually used.
			 */
			curBreakTarg.used = true;

			/*
			 * 'break' statements never fall through.
			 */
			mightGetHere = false;
		}

		/**
		 * @brief output code for a 'continue' statement
		 */
		private void GenerateStmtCont (TokenStmtCont contStmt)
		{
			if (!mightGetHere) return;

			/*
			 * Make sure we are in a contable situation.
			 */
			if (curContTarg == null) {
				ErrorMsg (contStmt, "not in a continueable situation");
				return;
			}

			/*
			 * Output the goto instruction.
			 */
			ilGen.Emit (OpCodes.Br, curContTarg.label);

			/*
			 * Tell anyone who cares that the continue target was actually used.
			 */
			curContTarg.used = true;

			/*
			 * 'continue' statements never fall through.
			 */
			mightGetHere = false;
		}

		/**
		 * @brief output code for a 'do' statement
		 */
		private void GenerateStmtDo (TokenStmtDo doStmt)
		{
			if (!mightGetHere) return;

			BreakContTarg oldBreakTarg = curBreakTarg;
			BreakContTarg oldContTarg  = curContTarg;
			ScriptMyLabel loopLabel    = ilGen.DefineLabel ("doloop_" + doStmt.Unique);

			curBreakTarg = new BreakContTarg (ilGen, "dobreak_" + doStmt.Unique);
			curContTarg  = new BreakContTarg (ilGen, "docont_"  + doStmt.Unique);

			ilGen.MarkLabel (loopLabel);
			GenerateStmt (doStmt.bodyStmt);
			if (curContTarg.used) {
				ilGen.MarkLabel (curContTarg.label);
				mightGetHere = true;
			}

			if (mightGetHere) {
				EmitCallCheckRun (doStmt.line);
				if (IsConstBoolExprTrue (doStmt.testRVal)) {

					/*
					 * Unconditional looping, don't bother with the test
					 * and say we never fall through to next statement.
					 */
					ilGen.Emit (OpCodes.Br, loopLabel);
					mightGetHere = false;
				} else {

					/*
					 * Conditional looping, output test and brach back to top of loop.
					 */
					CompValu testRVal = GenerateFromRVal (doStmt.testRVal);
					testRVal.PushVal (this, tokenTypeBool);
					ilGen.Emit (OpCodes.Brtrue, loopLabel);
				}
			}

			/*
			 * If 'break' statement was used, output target label.
			 * And assume that since a 'break' statement was used, it's possible for the code to get here.
			 */
			if (curBreakTarg.used) {
				ilGen.MarkLabel (curBreakTarg.label);
				mightGetHere = true;
			}

			curBreakTarg = oldBreakTarg;
			curContTarg  = oldContTarg;
		}

		/**
		 * @brief output code for a 'for' statement
		 * Must use labels and if/goto's instead of braces as the test expression may generate temp 
		 * assignment statements and then we can't cram all the temp assignment statments in a real
		 * for statement.
		 */
		private void GenerateStmtFor (TokenStmtFor forStmt)
		{
			if (!mightGetHere) return;

			BreakContTarg oldBreakTarg = curBreakTarg;
			BreakContTarg oldContTarg  = curContTarg;
			ScriptMyLabel loopLabel    = ilGen.DefineLabel ("forloop_" + forStmt.Unique);

			curBreakTarg = new BreakContTarg (ilGen, "forbreak_" + forStmt.Unique);
			curContTarg  = new BreakContTarg (ilGen, "forcont_"  + forStmt.Unique);

			if (forStmt.initStmt != null) {
				GenerateStmt (forStmt.initStmt);
			}
			ilGen.MarkLabel (loopLabel);

			/*
			 * See if we have a test expression that is other than a constant TRUE.
			 */
			if ((forStmt.testRVal != null) && !IsConstBoolExprTrue (forStmt.testRVal)) {
				CompValu testRVal = GenerateFromRVal (forStmt.testRVal);
				testRVal.PushVal (this, tokenTypeBool);
				ilGen.Emit (OpCodes.Brfalse, curBreakTarg.label);
				curBreakTarg.used = true;
			}

			/*
			 * Output loop body.
			 */
			GenerateStmt (forStmt.bodyStmt);

			/*
			 * Here's where a 'continue' statement jumps to.
			 */
			if (curContTarg.used) {
				ilGen.MarkLabel (curContTarg.label);
				mightGetHere = true;
			}

			if (mightGetHere) {

				/*
				 * After checking for excessive CPU time, output increment statement, if any.
				 */
				EmitCallCheckRun (forStmt.line);
				if (forStmt.incrRVal != null) {
					GenerateFromRVal (forStmt.incrRVal);
				}

				/*
				 * Unconditional branch back to beginning of loop.
				 */
				ilGen.Emit (OpCodes.Br, loopLabel);
			}

			/*
			 * If test needs label, output label for it to jump to.
			 * Otherwise, clear mightGetHere as we know loop never
			 * falls out the bottom.
			 */
			mightGetHere = curBreakTarg.used;
			if (mightGetHere) {
				ilGen.MarkLabel (curBreakTarg.label);
			}

			curBreakTarg = oldBreakTarg;
			curContTarg  = oldContTarg;
		}

		private void GenerateStmtForEach (TokenStmtForEach forEachStmt)
		{
			if (!mightGetHere) return;

			BreakContTarg oldBreakTarg = curBreakTarg;
			BreakContTarg oldContTarg  = curContTarg;
			CompValu      keyLVal      = null;
			CompValu      valLVal      = null;
			CompValu      arrayRVal    = GenerateFromRVal (forEachStmt.arrayRVal);

			if (forEachStmt.keyLVal != null) {
				keyLVal = GenerateFromLVal (forEachStmt.keyLVal);
				if (!(keyLVal.type is TokenTypeObject)) {
					ErrorMsg (forEachStmt.arrayRVal, "must be object");
				}
			}
			if (forEachStmt.valLVal != null) {
				valLVal = GenerateFromLVal (forEachStmt.valLVal);
				if (!(valLVal.type is TokenTypeObject)) {
					ErrorMsg (forEachStmt.arrayRVal, "must be object");
				}
			}
			if (!(arrayRVal.type is TokenTypeArray)) {
				ErrorMsg (forEachStmt.arrayRVal, "must be an array");
			}

			curBreakTarg = new BreakContTarg (ilGen, "foreachbreak_" + forEachStmt.Unique);
			curContTarg  = new BreakContTarg (ilGen, "foreachcont_"  + forEachStmt.Unique);

			ScriptMyLabel loopLabel = ilGen.DefineLabel ("foreachloop_" + forEachStmt.Unique);
			ScriptMyLocal indexVar  = ilGen.DeclareLocal (typeof (int), "foreachidx_" + forEachStmt.Unique);
			ScriptMyLocal objectVar = ((keyLVal == null) || (valLVal == null)) ? ilGen.DeclareLocal (typeof (object), "foreachobj_" + forEachStmt.Unique) : null;

			ilGen.MarkLabel (loopLabel);

			// ForEach arg 0: arrayRVal
			arrayRVal.PushVal (this);

			// ForEach arg 1: indexVar ++
			ilGen.Emit (OpCodes.Ldloc, indexVar);
			ilGen.Emit (OpCodes.Dup);
			PushConstantI4 (1);
			ilGen.Emit (OpCodes.Add);
			ilGen.Emit (OpCodes.Stloc, indexVar);

			// ForEach arg 2: ref keyLVal
			if (keyLVal == null) {
				ilGen.Emit (OpCodes.Ldloca, objectVar);
			} else {
				keyLVal.PushByRef (this);
			}

			// ForEach arg 3: ref valLVal
			if (valLVal == null) {
				ilGen.Emit (OpCodes.Ldloca, objectVar);
			} else {
				valLVal.PushByRef (this);
			}

			// Call XMR_Array.ForEach (arrayRVal, index, ref keyLVal, ref valLVal)
			ilGen.Emit (OpCodes.Callvirt, forEachMethodInfo);
			ilGen.Emit (OpCodes.Brfalse, curBreakTarg.label);
			curBreakTarg.used = true;

			GenerateStmt (forEachStmt.bodyStmt);
			if (curContTarg.used) {
				ilGen.MarkLabel (curContTarg.label);
				mightGetHere = true;
			}
			if (mightGetHere) {
				EmitCallCheckRun (forEachStmt.line);
				ilGen.Emit (OpCodes.Br, loopLabel);
			}
			ilGen.MarkLabel (curBreakTarg.label);
			mightGetHere = true;

			curBreakTarg = oldBreakTarg;
			curContTarg  = oldContTarg;
		}

		/**
		 * @brief output code for an 'if' statement
		 * Braces are necessary because what may be one statement for trueStmt or elseStmt in
		 * the script may translate to more than one statement in the resultant C# code.
		 */
		private void GenerateStmtIf (TokenStmtIf ifStmt)
		{
			if (!mightGetHere) return;

			bool constVal;

			/*
			 * See if constant test expression.
			 */
			if (IsConstBoolExpr (ifStmt.testRVal, out constVal)) {

				/*
				 * Constant, output just either the true or else part.
				 */
				if (constVal) {
					GenerateStmt (ifStmt.trueStmt);
				} else if (ifStmt.elseStmt != null) {
					GenerateStmt (ifStmt.elseStmt);
				}
			} else if (ifStmt.elseStmt == null) {

				/*
				 * This is an 'if' statement without an 'else' clause.
				 */
				CompValu testRVal = GenerateFromRVal (ifStmt.testRVal);
				testRVal.PushVal (this, tokenTypeBool);      // generate test code
				ScriptMyLabel doneLabel = ilGen.DefineLabel ("ifdone_" + ifStmt.Unique);
				ilGen.Emit (OpCodes.Brfalse, doneLabel);     // brfalse doneLabel
				GenerateStmt (ifStmt.trueStmt);              // generate true body code
				ilGen.MarkLabel (doneLabel);
				mightGetHere = true;                         // there's always a possibility of getting here
			} else {

				/*
				 * This is an 'if' statement with an 'else' clause.
				 */
				CompValu testRVal = GenerateFromRVal (ifStmt.testRVal);
				testRVal.PushVal (this, tokenTypeBool);      // generate test code
				ScriptMyLabel elseLabel = ilGen.DefineLabel ("ifelse_" + ifStmt.Unique);
				ilGen.Emit (OpCodes.Brfalse, elseLabel);     // brfalse elseLabel
				GenerateStmt (ifStmt.trueStmt);              // generate true body code
				bool trueMightGetHere = mightGetHere;        // save whether or not true falls through
				ScriptMyLabel doneLabel = ilGen.DefineLabel ("ifdone_" + ifStmt.Unique);
				ilGen.Emit (OpCodes.Br, doneLabel);          // branch to done
				ilGen.MarkLabel (elseLabel);                 // beginning of else code
				mightGetHere = true;                         // the top of the else might be executed
				GenerateStmt (ifStmt.elseStmt);              // output else code
				ilGen.MarkLabel (doneLabel);                 // where end of true clause code branches to
				mightGetHere |= trueMightGetHere;            // gets this far if either true or else falls through
			}
		}

		/**
		 * @brief output code for a 'jump' statement
		 */
		private void GenerateStmtJump (TokenStmtJump jumpStmt)
		{
			if (!mightGetHere) return;

			/*
			 * Make sure the target label is defined somewhere in the function.
			 */
			TokenStmtLabel stmtLabel;
			if (!curDeclFunc.labels.TryGetValue (jumpStmt.label.val, out stmtLabel)) {
				ErrorMsg (jumpStmt, "undefined label " + jumpStmt.label.val);
				return;
			}
			if (!stmtLabel.labelTagged) {
				stmtLabel.labelStruct = ilGen.DefineLabel ("jump_" + stmtLabel.name.val);
				stmtLabel.labelTagged = true;
			}

			/*
			 * Find which block the target label is in.  Must be in this or an outer block,
			 * no laterals allowed.  And if we exit a try/catch block, use Leave instead of Br.
			 */
			TokenStmtBlock stmtBlock;
			OpCode brop = OpCodes.Br;
			for (stmtBlock = curStmtBlock; stmtBlock != null; stmtBlock = stmtBlock.outerStmtBlock) {
				if (stmtBlock == stmtLabel.block) break;
				if (stmtBlock.isTry || stmtBlock.isCatch) brop = OpCodes.Leave;
				if (stmtBlock.isFinally) {
					ErrorMsg (jumpStmt, "cannot jump out of finally");
					return;
				}
			}
			if (stmtBlock == null) {
				ErrorMsg (jumpStmt, "no lateral jumps allowed");
				return;
			}

			/*
			 * Finally output the branch/leave opcode.
			 */
			ilGen.Emit (brop, stmtLabel.labelStruct);

			/*
			 * 'goto' statements never fall through.
			 */
			mightGetHere = false;
		}

		/**
		 * @brief output code for a jump target label statement.
		 * If there are any backward jumps to the label, do a CheckRun() also.
		 */
		private void GenerateStmtLabel (TokenStmtLabel labelStmt)
		{
			if (!labelStmt.labelTagged) {
				labelStmt.labelStruct = ilGen.DefineLabel ("jump_" + labelStmt.name.val);
				labelStmt.labelTagged = true;
			}
			ilGen.MarkLabel (labelStmt.labelStruct);
			if (labelStmt.hasBkwdRefs) {
				EmitCallCheckRun (labelStmt.line);
			}

			/*
			 * We are going to say that the label falls through.
			 * It would be nice if we could analyze all referencing
			 * goto's to see if all of them are not used but we are
			 * going to assume that if the script writer put a goto
			 * somewhere, it is probably going to be used.
			 */
			mightGetHere = true;
		}

		/**
		 * @brief output code for a return statement.
		 * @param retStmt = return statement token, including return value if any
		 */
		private void GenerateStmtRet (TokenStmtRet retStmt)
		{
			if (!mightGetHere) return;

			for (TokenStmtBlock stmtBlock = curStmtBlock; stmtBlock != null; stmtBlock = stmtBlock.outerStmtBlock) {
				if (stmtBlock.isFinally) {
					ErrorMsg (retStmt, "cannot return out of finally");
					return;
				}
			}

			if (curDeclFunc.retType is TokenTypeVoid) {
				if (retStmt.rVal != null) {
					ErrorMsg (retStmt, "function returns void, no value allowed");
					return;
				}
			} else {
				if (retStmt.rVal == null) {
					ErrorMsg (retStmt, "function requires return value type " + curDeclFunc.retType.ToString ());
					return;
				}
				CompValu rVal = GenerateFromRVal (retStmt.rVal);
				rVal.PushVal (this, curDeclFunc.retType);
				ilGen.Emit (OpCodes.Stloc, retValue);
			}
			ilGen.Emit (OpCodes.Leave, retLabel);

			/*
			 * 'return' statements never fall through.
			 */
			mightGetHere = false;
		}

		/**
		 * @brief the statement is just an expression, most likely an assignment or a ++ or -- thing.
		 */
		private void GenerateStmtRVal (TokenStmtRVal rValStmt)
		{
			if (!mightGetHere) return;

			GenerateFromRVal (rValStmt.rVal);
		}

		/**
		 * @brief generate code for a 'state' statement that transitions state.
		 * It sets the new state by throwing a ScriptChangeStateException.
		 */
		private void GenerateStmtState (TokenStmtState stateStmt)
		{
			if (!mightGetHere) return;

			int index = 0;  // 'default' state

			/*
			 * Set new state value by throwing an exception.
			 * These exceptions aren't catchable by script-level try { } catch { }.
			 */
			if ((stateStmt.state != null) && !stateIndices.TryGetValue (stateStmt.state.val, out index)) {
				// The moron XEngine compiles scripts that reference undefined states.
				// So rather than produce a compile-time error, we'll throw an exception at runtime.
				// ErrorMsg (stateStmt, "undefined state " + stateStmt.state.val);

				// throw new UndefinedStateException (stateStmt.state.val);
				ilGen.Emit (OpCodes.Ldstr, stateStmt.state.val);
				ilGen.Emit (OpCodes.Newobj, scriptUndefinedStateExceptionConstructorInfo);
			} else {
				PushConstantI4 (index);				// new state's index
				ilGen.Emit (OpCodes.Newobj, scriptChangeStateExceptionConstructorInfo);
			}
			ilGen.Emit (OpCodes.Throw);

			/*
			 * 'state' statements never fall through.
			 */
			mightGetHere = false;
		}

		/**
		 * @brief output code for a 'switch' statement
		 */
		private void GenerateStmtSwitch (TokenStmtSwitch switchStmt)
		{
			if (!mightGetHere) return;

			BreakContTarg   oldBreakTarg = curBreakTarg;
			ScriptMyLabel   defaultLabel = null;
			TokenSwitchCase sortedCases  = null;
			TokenSwitchCase defaultCase  = null;

			curBreakTarg = new BreakContTarg (ilGen, "switchbreak_" + switchStmt.Unique);

			/*
			 * Build list of cases sorted by ascending values.
			 * There should not be any overlapping of values.
			 */
			for (TokenSwitchCase thisCase = switchStmt.cases; thisCase != null; thisCase = thisCase.nextCase) {
				thisCase.label = ilGen.DefineLabel ("case_" + thisCase.Unique);

				/*
				 * The default case if any, goes in its own separate slot.
				 */
				if (thisCase.rVal1 == null) {
					if (defaultCase != null) {
						ErrorMsg (thisCase, "only one default case allowed");
						ErrorMsg (defaultCase, "...prior default case");
						return;
					}
					defaultCase  = thisCase;
					defaultLabel = thisCase.label;
					continue;
				}

				/*
				 * Evaluate case operands, they must be compile-time integer constants.
				 */
				if (!IsConstIntExpr (thisCase.rVal1, out thisCase.val1)) {
					ErrorMsg (thisCase.rVal1, "must be compile-time constant");
					return;
				}
				thisCase.val2 = thisCase.val1;
				if ((thisCase.rVal2 != null) && !IsConstIntExpr (thisCase.rVal2, out thisCase.val2)) {
					ErrorMsg (thisCase.rVal2, "must be compile-time constant");
					return;
				}
				if (thisCase.val2 < thisCase.val1) {
					ErrorMsg (thisCase.rVal2, "must be .ge. first value for the case");
					return;
				}

				/*
				 * Insert into list, sorted by value.
				 * Note that both limits are inclusive.
				 */
				TokenSwitchCase lastCase = null;
				TokenSwitchCase nextCase;
				for (nextCase = sortedCases; nextCase != null; nextCase = nextCase.nextSortedCase) {
					if (nextCase.val1 >  thisCase.val2) break;
					if (nextCase.val2 >= thisCase.val1) {
						ErrorMsg (thisCase, "value used by previous case");
						ErrorMsg (nextCase, "...previous case");
						return;
					}
					lastCase = nextCase;
				}
				thisCase.nextSortedCase = nextCase;
				if (lastCase == null) {
					sortedCases = thisCase;
				} else {
					lastCase.nextSortedCase = thisCase;
				}
			}

			if (defaultLabel == null) {
				defaultLabel = ilGen.DefineLabel ("default_" + switchStmt.Unique);
			}

			/*
			 * Output code to calculate index, push result on stack as an integer.
			 */
			CompValu testRVal = GenerateFromRVal (switchStmt.testRVal);
			testRVal.PushVal (this, tokenTypeInt);

			/*
			 * Output code to jump to the case statement's labels based on integer index on stack.
			 * Note that each case still has the integer index on stack when jumped to.
			 */
			int offset = 0;
			for (TokenSwitchCase thisCase = sortedCases; thisCase != null;) {

				/*
				 * Scan through list of cases to find the maximum number of cases who's numvalues-to-case ratio
				 * is from 0.5 to 2.0.  If such a group is found, use a CIL switch for them.  If not, just use a
				 * compare-and-branch for the current case.
				 */
				int numCases  = 0;
				int numFound  = 0;
				int lowValue  = thisCase.val1;
				int numValues = 0;
				for (TokenSwitchCase scanCase = thisCase; scanCase != null; scanCase = scanCase.nextSortedCase) {
					int nVals = scanCase.val2 - thisCase.val1 + 1;
					double ratio = (double)nVals / (double)(++ numCases);
					if ((ratio >= 0.5) && (ratio <= 2.0)) {
						numFound  = numCases;
						numValues = nVals;
					}
				}
				if (numFound > 1) {

					/*
					 * There is a group of case's, starting with thisCase, that fall within our criteria, ie, 
					 * that have a nice density of meaningful jumps.
					 *
					 * So first generate an array of jumps to the default label (explicit or implicit).
					 */
					ScriptMyLabel[] labels = new ScriptMyLabel[numValues];
					for (int i = 0; i < numValues; i ++) {
						labels[i] = defaultLabel;
					}

					/*
					 * Next, for each case in that group, fill in the corresponding array entries to jump to
					 * that case's label.
					 */
					do {
						for (int i = thisCase.val1; i <= thisCase.val2; i ++) {
							labels[i-lowValue] = thisCase.label;
						}
						thisCase = thisCase.nextSortedCase;
					} while (-- numFound > 0);

					/*
					 * Subtract the low value and do the computed jump.
					 * The OpCodes.Switch falls through if out of range (unsigned compare).
					 */
					if (offset != lowValue) {
						PushConstantI4 (lowValue - offset);
						ilGen.Emit (OpCodes.Sub);
						offset = lowValue;
					}
					ilGen.Emit (OpCodes.Dup);
					ilGen.Emit (OpCodes.Switch, labels);
				} else {

					/*
					 * It's not economical to do with a computed jump, so output a subtract/compare/branch
					 * for thisCase.
					 */
					if (lowValue == thisCase.val2) {
						ilGen.Emit (OpCodes.Dup);
						PushConstantI4 (lowValue - offset);
						ilGen.Emit (OpCodes.Beq, thisCase.label);
					} else {
						if (offset != lowValue) {
							PushConstantI4 (lowValue - offset);
							ilGen.Emit (OpCodes.Sub);
							offset = lowValue;
						}
						ilGen.Emit (OpCodes.Dup);
						PushConstantI4 (thisCase.val2 - offset);
						ilGen.Emit (OpCodes.Ble_Un, thisCase.label);
					}
					thisCase = thisCase.nextSortedCase;
				}
			}
			ilGen.Emit (OpCodes.Br, defaultLabel);

			/*
			 * Output code for the cases themselves, in the order given by the programmer, 
			 * so they fall through as programmer wants.  This includes the default case, if any.
			 *
			 * Each label is jumped to with the index still on the stack.  So pop it off in case
			 * the case body does a goto outside the switch or a return.  If the case body might
			 * fall through to the next case or the bottom of the switch, push a zero so the stack
			 * matches in all cases.
			 */
			for (TokenSwitchCase thisCase = switchStmt.cases; thisCase != null; thisCase = thisCase.nextCase) {
				ilGen.MarkLabel (thisCase.label);	// the branch comes here
				ilGen.Emit (OpCodes.Pop);		// pop the integer index off stack
				mightGetHere = true;			// it's possible to get here
				for (TokenStmt stmt = thisCase.stmts; stmt != null; stmt = (TokenStmt)(stmt.nextToken)) {
					GenerateStmt (stmt);		// output the case/explicit default body
				}
				if (mightGetHere) {
					PushConstantI4 (0);		// in case we fall through, push a dummy integer index
				}
			}

			/*
			 * If no explicit default case, output the default label here.
			 */
			if (defaultCase == null) {
				ilGen.MarkLabel (defaultLabel);
				mightGetHere = true;
			}

			/*
			 * If the last case of the switch falls through out the bottom,
			 * we have to pop the index still on the stack.
			 */
			if (mightGetHere) {
				ilGen.Emit (OpCodes.Pop);
			}

			/*
			 * Output the 'break' statement target label.
			 * Note that the integer index is not on the stack at this point.
			 */
			if (curBreakTarg.used) {
				ilGen.MarkLabel (curBreakTarg.label);
				mightGetHere = true;
			}

			curBreakTarg = oldBreakTarg;
		}

		/**
		 * @brief output code for a throw statement.
		 * @param throwStmt = throw statement token, including value to be thrown
		 */
		private void GenerateStmtThrow (TokenStmtThrow throwStmt)
		{
			if (!mightGetHere) return;

			if (throwStmt.rVal == null) {
				if (!curStmtBlock.isCatch) {
					ErrorMsg (throwStmt, "rethrow allowed only in catch clause");
				}
				ilGen.Emit (OpCodes.Rethrow);
			} else {
				CompValu rVal = GenerateFromRVal (throwStmt.rVal);
				rVal.PushVal (this, tokenTypeStr);
				ilGen.Emit (OpCodes.Call, throwStrToExcMethodInfo);
				ilGen.Emit (OpCodes.Throw);
			}

			/*
			 * 'throw' statements never fall through.
			 */
			mightGetHere = false;
		}

		/**
		 * @brief output code for an 'try' statement
		 */
		private void GenerateStmtTry (TokenStmtTry tryStmt)
		{
			if (!mightGetHere) return;

			BreakContTarg oldBreakTarg = curBreakTarg;		// cannot continue out of try/catch/finally
			BreakContTarg oldContTarg  = curContTarg;		// (break jumps to end of try/catch/finally)
			curBreakTarg = null;
			curContTarg  = null;

			ScriptMyLabel tryEndLabel = ilGen.DefineLabel ("tryend_" + tryStmt.Unique);


			tryStmt.tryStmt.isTry = true;				// jumps out of try require Leave opcode
										// rethrow not allowed
										// return statements not allowed
			curBreakTarg = new BreakContTarg (ilGen, "trybreak_" + tryStmt.Unique);
			ilGen.BeginExceptionBlock ();
			GenerateStmtBlock (tryStmt.tryStmt);			// output the try block statement block
			if (curBreakTarg.used) {
				ilGen.MarkLabel (curBreakTarg.label);
				mightGetHere = true;
			}
			bool mightGetOut = mightGetHere;
			ilGen.Emit (OpCodes.Leave, tryEndLabel);
			if (tryStmt.catchStmt != null) {
				tryStmt.catchStmt.isCatch = true;		// jumps out of catch require Leave opcode
										// rethrow allowed
										// return statements not allowed
				CompValuTemp catchVarLoc = new CompValuTemp (tokenTypeStr, tryStmt.catchVar.val, this);
				Dictionary<string, CompValu> frame = PushVarDefnBlock ();
				frame.Add (tryStmt.catchVar.val, catchVarLoc);
				ScriptMyLabel catchLabel = ilGen.DefineLabel ("catchlbl_" + tryStmt.Unique);
				ScriptMyLocal excLocal = ilGen.DeclareLocal (typeof (Exception), "catchexc_" + tryStmt.Unique);

				curBreakTarg = new BreakContTarg (ilGen, "catchbreak_" + tryStmt.Unique);
				ilGen.BeginCatchBlock (typeof (Exception));	// start of the catch block
				ilGen.Emit (OpCodes.Stloc, excLocal);		// save pointer to exception object
				catchVarLoc.PopPre (this);
				ilGen.Emit (OpCodes.Ldloc, excLocal);		// convert exception object to string
				ilGen.Emit (OpCodes.Call, catchExcToStrMethodInfo);
				catchVarLoc.PopPost (this);			// ... and store in catch clause var
				catchVarLoc.PushVal (this);			// see if null
				ilGen.Emit (OpCodes.Brtrue_S, catchLabel);
				ilGen.Emit (OpCodes.Rethrow);			// if so, rethrow exception
				ilGen.MarkLabel (catchLabel);			// if not, process script code

				mightGetHere = true;				// if we can get to the 'try' assume we can get to the 'catch'
				GenerateStmtBlock (tryStmt.catchStmt);		// output catch clause statement block
				if (curBreakTarg.used) {
					ilGen.MarkLabel (curBreakTarg.label);
					mightGetHere = true;
				}
				mightGetOut |= mightGetHere;			// remember whether or not we can get to end of try or catch at all
				ilGen.Emit (OpCodes.Leave, tryEndLabel);

				PopVarDefnBlock ();				// forget about catch clause var
			}
			if (tryStmt.finallyStmt != null) {
				curBreakTarg = new BreakContTarg (ilGen, "finbreak_" + tryStmt.Unique);
				tryStmt.finallyStmt.isFinally = true;		// cannot exit finally with jump or return statement
				ilGen.BeginFinallyBlock ();			// start of the finally block
				mightGetHere = true;
				GenerateStmtBlock (tryStmt.finallyStmt);
				if (curBreakTarg.used) {
					ilGen.MarkLabel (curBreakTarg.label);
				}
				ilGen.Emit (OpCodes.Endfinally);
			}
			ilGen.EndExceptionBlock ();
			ilGen.MarkLabel (tryEndLabel);
			mightGetHere = mightGetOut;

			curBreakTarg = oldBreakTarg;
			curContTarg  = oldContTarg;
		}

		/**
		 * @brief generate code for a 'while' statement including the loop body.
		 */
		private void GenerateStmtWhile (TokenStmtWhile whileStmt)
		{
			if (!mightGetHere) return;

			BreakContTarg oldBreakTarg = curBreakTarg;
			BreakContTarg oldContTarg  = curContTarg;
			ScriptMyLabel loopLabel    = ilGen.DefineLabel ("whileloop_" + whileStmt.Unique);

			curBreakTarg = new BreakContTarg (ilGen, "whilebreak_" + whileStmt.Unique);
			curContTarg  = new BreakContTarg (ilGen, "whilecont_"  + whileStmt.Unique);

			ilGen.MarkLabel (loopLabel);                                        // loop:
			if (!IsConstBoolExprTrue (whileStmt.testRVal)) {
				CompValu testRVal = GenerateFromRVal (whileStmt.testRVal);  //   testRVal = while test expression
				testRVal.PushVal (this, tokenTypeBool);                     //   if (!testRVal)
				ilGen.Emit (OpCodes.Brfalse, curBreakTarg.label);           //      goto break
				curBreakTarg.used = true;
			}
			GenerateStmt (whileStmt.bodyStmt);                                  //   while body statement
			if (curContTarg.used) {
				ilGen.MarkLabel (curContTarg.label);                        // cont:
				mightGetHere = true;
			}
			if (mightGetHere) {
				EmitCallCheckRun (whileStmt.line);                          //   __sw.CheckRun()
				ilGen.Emit (OpCodes.Br, loopLabel);                         //   goto loop
			}
			mightGetHere = curBreakTarg.used;
			if (mightGetHere) {
				ilGen.MarkLabel (curBreakTarg.label);                       // done:
			}

			curBreakTarg = oldBreakTarg;
			curContTarg  = oldContTarg;
		}

		/**
		 * @brief process a local variable declaration statement, possibly with initialization expression.
		 *        Note that the function header processing allocated stack space (CompValuTemp) for the
		 *        variable and now all we do is make it visible to the script at this point and compute
		 *        its initialization value.
		 */
		private void GenerateDeclVar (TokenDeclVar declVar)
		{
			CompValu local = declVar.location;

			/*
			 * Script gave us an initialization value, so just store init value in var like an assignment statement.
			 * Also debit any heap used by the initialization value, just like an assignment statement.
			 * If no init given, the var was set to its default value when stack space was allocated at the beginning
			 * of the function.
			 */
			if (declVar.init != null) {
				local.PopPre (this);
				string argsig = null;
				if (local.type is TokenTypeDelegate) {
					argsig = ((TokenTypeDelegate)local.type).argSig;
				}
				CompValu rVal = GenerateFromRVal (declVar.init, argsig);
				rVal.PushVal (this, declVar.type);
				local.PopPost (this);
				DebitHeapLeft (local, true, declVar);
			}

			/*
			 * Now it's ok for subsequent expressions in the block to reference the local variable.
			 */
			AddVarDefinition (declVar.name, local);
		}

		/**
		 * @brief Get the type and location of an L-value (eg, variable)
		 */
		private CompValu GenerateFromLVal (TokenLVal lVal)
		{
			return GenerateFromLVal (lVal, null);
		}
		private CompValu GenerateFromLVal (TokenLVal lVal, string argsig)
		{
			if (lVal is TokenLValArEle)  return GenerateFromLValArEle  ((TokenLValArEle)lVal);
			if (lVal is TokenLValIField) return GenerateFromLValIField ((TokenLValIField)lVal);
			if (lVal is TokenLValName)   return GenerateFromLValName   ((TokenLValName)lVal, argsig);
			throw new Exception ("bad lval class");
		}

		/**
		 * @brief we have an L-value token that is an element within an array.
		 * @returns a CompValu giving the type and location of the element of the array.
		 */
		private CompValu GenerateFromLValArEle (TokenLValArEle lVal)
		{
			/*
			 * Compute subscript before rest of lVal in case of multiple subscripts.
			 */
			CompValu subRVal = GenerateFromRVal (lVal.subRVal);

			/*
			 * Compute location of array itself.
			 */
			CompValu baseRVal = GenerateFromRVal (lVal.baseRVal);

			/*
			 * It better be an array!
			 */
			if (!(baseRVal.type is TokenTypeArray)) {
				ErrorMsg (lVal, "taking subscript of non-array");
				return baseRVal;
			}

			/*
			 * Ok, generate reference.
			 */
			return new CompValuArEle (new TokenTypeObject (lVal), baseRVal, subRVal);
		}

		/**
		 * @brief we have an L-value token that is a field within a struct.
		 * @returns a CompValu giving the type and location of the field in the struct.
		 */
		private CompValu GenerateFromLValIField (TokenLValIField lVal)
		{
			CompValu baseRVal = GenerateFromRVal (lVal.baseRVal);
			string fieldName = lVal.field.val;

			/*
			 * Since we only have a few types with fields, just pound them out.
			 */
			if (baseRVal.type is TokenTypeArray) {

				// no arguments, no parentheses, just the field name, returning integer
				// but internally, it is a call to a method()
				if (fieldName == "count") {
					TokenType retType = new TokenTypeInt (lVal);
					return new CompValuIntInstROProp (retType, baseRVal, arrayCountMethodInfo);
				}

				// no arguments but with the parentheses, returning void
				if (fieldName == "clear") {
					TokenType retType = new TokenTypeVoid (lVal);
					TokenType[] argTypes = new TokenType[0];
					TokenTypeDelegate ttd = new TokenTypeDelegate (lVal, retType, argTypes);
					return new CompValuIntInstMeth (ttd, baseRVal, arrayClearMethodInfo);
				}

				// single integer argument, returning an object
				MethodInfo mi = null;
				if (fieldName == "index") mi = arrayIndexMethodInfo;
				if (fieldName == "value") mi = arrayValueMethodInfo;
				if (mi != null) {
					TokenType retType = new TokenTypeObject (lVal);
					TokenType[] argTypes = new TokenType[] { new TokenTypeInt (lVal) };
					TokenTypeDelegate ttd = new TokenTypeDelegate (lVal, retType, argTypes);
					return new CompValuIntInstMeth (ttd, baseRVal, mi);
				}
			}
			if (baseRVal.type is TokenTypeRot) {
				FieldInfo fi = null;
				if (fieldName == "x") fi = rotationXFieldInfo;
				if (fieldName == "y") fi = rotationYFieldInfo;
				if (fieldName == "z") fi = rotationZFieldInfo;
				if (fieldName == "s") fi = rotationSFieldInfo;
				if (fi != null) {
					return new CompValuField (new TokenTypeFloat (lVal), baseRVal, fi);
				}
			}
			if (baseRVal.type is TokenTypeVec) {
				FieldInfo fi = null;
				if (fieldName == "x") fi = vectorXFieldInfo;
				if (fieldName == "y") fi = vectorYFieldInfo;
				if (fieldName == "z") fi = vectorZFieldInfo;
				if (fi != null) {
					return new CompValuField (new TokenTypeFloat (lVal), baseRVal, fi);
				}
			}

			ErrorMsg (lVal, "type " + baseRVal.type + " does not define field " + fieldName);
			return baseRVal;
		}

		/**
		 * @brief we have an L-value token that is a function, method or variable name.
		 * @param lVal = name we are looking for
		 * @param argsig = null: just look for name as a variable
		 *                 else: look for name as a function/method being called with the given argument types
		 *                       eg, "(string,integer,list)"
		 * @returns a CompValu giving the type and location of the function, method or variable.
		 */
		private CompValu GenerateFromLValName (TokenLValName lVal, string argsig)
		{
			string name = lVal.name.val;
			string namesig = name;
			if (argsig != null) namesig += argsig;

			foreach (Dictionary<string, CompValu> vars in scriptVariablesStack) {
				CompValu defn;
				if (vars.TryGetValue (namesig, out defn)) {
					return defn;
				}
				if (vars.TryGetValue (name, out defn)) {
					return defn;
				}
			}

			ErrorMsg (lVal, "undefined function/method/variable " + name);
			foreach (Dictionary<string, CompValu> vars in scriptVariablesStack) {
				foreach (KeyValuePair<string, CompValu> kvp in vars) {
					Console.WriteLine ("GenerateFromLValName*: " + kvp.Key + " = " + kvp.Value);
				}
			}
			return new CompValuVoid (lVal);
		}

		/**
		 * @brief generate code from an RVal expression and return its type and where the result is stored.
		 * For anything that has side-effects, statements are generated that perform the computation then
		 * the result it put in a temp var and the temp var name is returned.
		 * For anything without side-effects, they are returned as an equivalent sequence of Emits.
		 * @param rVal = rVal token to be evaluated
		 * @param argsig = null: not being used in an function/method context
		 *                 else: string giving argument types, eg, "(string,integer,list,vector)"
		 *                       that can be used to select among overloaded methods
		 * @returns resultant type and location
		 */
		private CompValu GenerateFromRVal (TokenRVal rVal)
		{
			return GenerateFromRVal (rVal, null);
		}
		private CompValu GenerateFromRVal (TokenRVal rVal, string argsig)
		{
			errorMessageToken = rVal;
			if (rVal is TokenRValAsnPost)  return GenerateFromRValAsnPost  ((TokenRValAsnPost)rVal);
			if (rVal is TokenRValAsnPre)   return GenerateFromRValAsnPre   ((TokenRValAsnPre)rVal);
			if (rVal is TokenRValCall)     return GenerateFromRValCall     ((TokenRValCall)rVal);
			if (rVal is TokenRValCast)     return GenerateFromRValCast     ((TokenRValCast)rVal);
			if (rVal is TokenRValConst)    return GenerateFromRValConst    ((TokenRValConst)rVal);
			if (rVal is TokenRValCVSField) return GenerateFromRValCVSField ((TokenRValCVSField)rVal);
			if (rVal is TokenRValIsType)   return GenerateFromRValIsType   ((TokenRValIsType)rVal);
			if (rVal is TokenRValList)     return GenerateFromRValList     ((TokenRValList)rVal);
			if (rVal is TokenRValOpBin)    return GenerateFromRValOpBin    ((TokenRValOpBin)rVal);
			if (rVal is TokenRValOpUn)     return GenerateFromRValOpUn     ((TokenRValOpUn)rVal);
			if (rVal is TokenRValParen)    return GenerateFromRValParen    ((TokenRValParen)rVal);
			if (rVal is TokenRValRot)      return GenerateFromRValRot      ((TokenRValRot)rVal);
			if (rVal is TokenRValUndef)    return GenerateFromRValUndef    ((TokenRValUndef)rVal);
			if (rVal is TokenRValVec)      return GenerateFromRValVec      ((TokenRValVec)rVal);
			if (rVal is TokenLVal)         return GenerateFromLVal         ((TokenLVal)rVal, argsig);
			throw new Exception ("bad rval class " + rVal.GetType ().ToString ());
		}

		/**
		 * @brief compute the result of a binary operator (eg, add, subtract, multiply, lessthan)
		 * @param token = binary operator token, includes the left and right operands
		 * @returns where the resultant R-value is as something that doesn't have side effects
		 */
		private CompValu GenerateFromRValOpBin (TokenRValOpBin token)
		{
			CompValu leftLVal = null;
			CompValu left = null;
			CompValu right;

			/*
			 * If left operand is an L-value, create an leftLVal location marker for it.
			 * In either case, create a R-value location marker for it.
			 */
			if (token.rValLeft is TokenLVal) {
				left = leftLVal = GenerateFromLVal ((TokenLVal)token.rValLeft);
			}

			/*
			 * Simple overwriting assignments are their own special case,
			 * as we want to cast the R-value to the type of the L-value.
			 * And in the case of delegates, we want to use the arg signature
			 * of the delegate to select which overloaded method to use.
			 * And we might also be able to optimize out a temp by having
			 * the result put directly in the L-value variable.
			 */
			string opcodeIndex = token.opcode.ToString ();
			if (opcodeIndex == "=") {
				if (left == null) {
					ErrorMsg (token, "invalid L-value for =");
					left = GenerateFromRVal (token.rValLeft);
				} else {
					string argsig = null;
					if (left.type is TokenTypeDelegate) {
						argsig = ((TokenTypeDelegate)left.type).argSig;
					}
					right = GenerateFromRVal (token.rValRight, argsig);
					leftLVal.PopPre (this);
					right.PushVal (this, leftLVal.type);  // push (leftLVal.type)right
					leftLVal.PopPost (this);              // pop to leftLVal
					DebitHeapLeft (left, true, token.rValLeft);
				}
				return left;
			}

			/*
			 * Comma operators are also special, as they say to compute the left-hand value
			 * and discard it, then compute the right-hand argument and that is the result.
			 */
			if (opcodeIndex == ",") {

				/*
				 * Compute left-hand operand but throw away result (because we say to store in a 'void').
				 */
				if (left == null) {
					GenerateFromRVal (token.rValLeft);
				}

				/*
				 * Compute right-hand operand and that is the value of the expression.
				 */
				return GenerateFromRVal (token.rValRight);
			}

			/*
			 * Computation of some sort, compute right-hand operand value then left-hand value
			 * because LSL is supposed to be right-to-left evaluation.
			 *
			 * If left-hand operand has side effects, force right-hand operand into a temp so
			 * it will get computed first, and not just stacked for later evaluation.
			 */
			right = GenerateFromRVal (token.rValRight);
			if (token.rValLeft.sideEffects && !right.isFinal) {
				CompValu rightTemp = new CompValuTemp (right.type, null, this);
				rightTemp.PopPre (this);
				right.PushVal (this, right.type);
				rightTemp.PopPost (this);
				right = rightTemp;
			}
			left = GenerateFromRVal (token.rValLeft);

			/*
			 * Formulate key string for binOpStrings = (lefttype)(operator)(righttype)
			 */
			string leftIndex = left.type.ToString ();
			string rightIndex = right.type.ToString ();
			string key = leftIndex + opcodeIndex + rightIndex;

			/*
			 * If that key exists in table, then the operation is defined between those types
			 * ... and it produces an R-value of type as given in the table.
			 */
			BinOpStr binOpStr;
			if (binOpStrings.TryGetValue (key, out binOpStr)) {

				/*
				 * If table contained an explicit assignment type like +=, output the statement without
				 * casting the L-value, then return the L-value as the resultant value.
				 *
				 * Make sure we don't include comparisons (such as ==, >=, etc).
				 * Nothing like +=, -=, %=, etc, generate a boolean, only the comparisons.
				 */
				if ((binOpStr.outtype != typeof (bool)) && opcodeIndex.EndsWith ("=")) {
					binOpStr.emitBO (this, left, right, left);
					DebitHeapLeft (left, true, token.rValLeft);
					return left;
				}

				/*
				 * It's of the form left binop right.
				 * If either the original left or right had side effects, they should have been evaluated
				 * and put in temps already, so what we have for left and right don't have side effects.
				 * So we can simply return (outtype)(left binop right) as the location of the result.
				 *
				 * ??? optimise by creating a CompValu that can have left.PushVal(),right.PushVal(),EmitBinOpCode() as its PushVal() ???
				 */
				CompValu retRVal = new CompValuTemp (TokenType.FromSysType (token.opcode, binOpStr.outtype), null, this);
				retRVal.isFinal = left.isFinal && right.isFinal;
				binOpStr.emitBO (this, left, right, retRVal);
				return retRVal;
			}

			/*
			 * If the opcode ends with "=", it may be something like "+=".
			 * So look up the key as if we didn't have the "=" to tell us if the operation is legal.
			 * Also, the binary operation's output type must be the same as the L-value type.
			 * Likewise, integer += float not allowed because result is float, but float += integer is ok.
			 */
			if (opcodeIndex.EndsWith ("=")) {
				key = leftIndex + opcodeIndex.Substring (0, opcodeIndex.Length - 1) + rightIndex;
				if (binOpStrings.TryGetValue (key, out binOpStr)) {

					/*
					 * Now we know for something like %= that left%right is legal for the types given.
					 * We can only actually process it if the resultant type is of the left type.
					 * So for example, we can't do float += list, as float + list gives a list.
					 */
					if (binOpStr.outtype == left.type.ToSysType ()) {

						/*
						 * Types are ok, see if the '=' (read/modify/write) form is allowed...
						 */
						if (binOpStr.rmwOK) {
							if (leftLVal == null) {
								ErrorMsg (token, "invalid L-value for <op>=");
							} else {
								binOpStr.emitBO (this, leftLVal, right, leftLVal);
								DebitHeapLeft (left, true, token.rValLeft);
							}
							return left;
						}
					}
				}
			}

			/*
			 * Can't find it, oh well.
			 */
			ErrorMsg (token, "op not defined: " + leftIndex + " " + opcodeIndex + " " + rightIndex);
			return new CompValuVoid (token);
		}

		/**
		 * @brief compute the result of an unary operator
		 * @param token = unary operator token, includes the operand
		 * @returns where the resultant R-value is
		 */
		private CompValu GenerateFromRValOpUn (TokenRValOpUn token)
		{
			CompValu inRVal = GenerateFromRVal (token.rVal);
			return UnOpGenerate (inRVal, token.opcode);
		}

		/**
		 * @brief postfix operator -- this returns the type and location of the resultant value
		 */
		private CompValu GenerateFromRValAsnPost (TokenRValAsnPost asnPost)
		{
			CompValu lVal = GenerateFromLVal (asnPost.lVal);

			/*
			 * Make up a temp to save original value in.
			 */
			CompValu result = new CompValuTemp (lVal.type, null, this);

			/*
			 * Prepare to pop incremented value back into variable being incremented.
			 */
			lVal.PopPre (this);

			/*
			 * Copy original value to temp and leave value on stack.
			 */
			lVal.PushVal (this);
			result.PopPre (this);  // this should push nothing on stack because it is a CIL local var
			ilGen.Emit (OpCodes.Dup);
			result.PopPost (this);

			/*
			 * Perform the ++/--.
			 */
			if (lVal.type is TokenTypeInt) {
				PushConstantI4 (1);
			} else if (lVal.type is TokenTypeFloat) {
				ilGen.Emit (OpCodes.Ldc_R4, 1.0f);
			} else {
				lVal.PopPost (this);
				ErrorMsg (asnPost, "invalid type for " + asnPost.postfix.ToString ());
				return lVal;
			}
			switch (asnPost.postfix.ToString ()) {
				case "++": {
					ilGen.Emit (OpCodes.Add);
					break;
				}
				case "--": {
					ilGen.Emit (OpCodes.Sub);
					break;
				}
				default: throw new Exception ("unknown asnPost op");
			}

			/*
			 * Store new value in original variable.
			 */
			lVal.PopPost (this);

			return result;
		}

		/**
		 * @brief prefix operator -- this returns the type and location of the resultant value
		 */
		private CompValu GenerateFromRValAsnPre (TokenRValAsnPre asnPre)
		{
			CompValu lVal = GenerateFromLVal (asnPre.lVal);

			/*
			 * Make up a temp to put result in.
			 */
			CompValu result = new CompValuTemp (lVal.type, null, this);

			/*
			 * Prepare to pop incremented value back into variable being incremented.
			 */
			lVal.PopPre (this);

			/*
			 * Push original value.
			 */
			lVal.PushVal (this);

			/*
			 * Perform the ++/--.
			 */
			if (lVal.type is TokenTypeInt) {
				PushConstantI4 (1);
			} else if (lVal.type is TokenTypeFloat) {
				ilGen.Emit (OpCodes.Ldc_R4, 1.0f);
			} else {
				lVal.PopPost (this);
				ErrorMsg (asnPre, "invalid type for " + asnPre.prefix.ToString ());
				return lVal;
			}
			switch (asnPre.prefix.ToString ()) {
				case "++": {
					ilGen.Emit (OpCodes.Add);
					break;
				}
				case "--": {
					ilGen.Emit (OpCodes.Sub);
					break;
				}
				default: throw new Exception ("unknown asnPre op");
			}

			/*
			 * Store new value in temp variable, keeping new value on stack.
			 */
			result.PopPre (this);  // this should push nothing on stack because it is a CIL local var
			ilGen.Emit (OpCodes.Dup);
			result.PopPost (this);

			/*
			 * Store new value in original variable.
			 */
			lVal.PopPost (this);

			return result;
		}

		/**
		 * @brief Generate code that calls a function or object's method.
		 * @returns where the call's return value is stored (a TokenTypeVoid if void)
		 */
		private CompValu GenerateFromRValCall (TokenRValCall call)
		{
			CompValu method, result;
			CompValu[] argRVals;
			CompValuInline inline;
			int i, nargs;
			string argsigst;
			StringBuilder argsigsb;
			TokenType retType;
			TokenType[] argTypes;

			/*
			 * Compute the values of all the function's call arguments.
			 * Save where the computation results are in the argRVals[] array.
			 * Might as well build the argument signature from the argument types, too.
			 */
			nargs = call.nArgs;
			argsigsb = new StringBuilder ("(");
			argRVals = new CompValu[nargs];
			if (nargs > 0) {
				i = 0;
				for (TokenRVal arg = call.args; arg != null; arg = (TokenRVal)arg.nextToken) {
					argRVals[i] = GenerateFromRVal (arg);
					if (i > 0) argsigsb.Append (",");
					argsigsb.Append (argRVals[i].type.ToString ());
					i ++;
				}
			}
			argsigsb.Append (")");
			argsigst = argsigsb.ToString ();

			/*
			 * Get function/method's entrypoint that matches the argument signature.
			 */
			method = GenerateFromRVal (call.meth, argsigst);
			if (method == null) return null;

			/*
			 * Inline functions are their own thing.
			 */
			if (method is CompValuInline) {
				inline = (CompValuInline)method;
				result = SetupReturnLocation (inline.retType);
				inline.codeGen (this, call, result, argRVals);
				return result;
			}

			/*
			 * Otherwise must some other kind of callable.
			 */
			retType = method.GetRetType ();  // TokenTypeVoid if void; null means a variable
			if (retType == null) {
				ErrorMsg (call.meth, "must be a function or method");
				return new CompValuVoid (call.meth);
			}

			/*
			 * Stick in a label here that stack frame restore code can jump to.
			 */
			new CallLabel (this);

			/*
			 * Make sure we have a place to put return value and prepare to pop return value into it.
			 * The PopPre() call must be done before pushing anything else so PopPost() will work.
			 */
			result = SetupReturnLocation (retType);

			/*
			 * Push whatever the function/method needs as a this argument, if anything.
			 */
			method.CallPre (this);

			/*
			 * Push the script-visible args, left-to-right.
			 */
			argTypes = method.GetArgTypes ();
			for (i = 0; i < nargs; i ++) {
				if (argTypes == null) {
					argRVals[i].PushVal (this);
				} else {
					argRVals[i].PushVal (this, argTypes[i]);
				}
			}

			/*
			 * Now output call instruction.
			 */
			method.CallPost (this);

			/*
			 * Deal with the return value (if any), by putting it in 'result'.
			 */
			result.PopPost (this, retType);
			return result;
		}

		private CompValu SetupReturnLocation (TokenType retType)
		{
			CompValu result;
			if (retType is TokenTypeVoid) {
				result = new CompValuVoid (retType);
			} else {
				result = new CompValuTemp (retType, null, this);
			}
			result.PopPre (this);
			return result;
		}

		/**
		 * @brief Generate code that casts a value to a particular type.
		 * @returns where the result of the conversion is stored.
		 */
		private CompValu GenerateFromRValCast (TokenRValCast cast)
		{
			/*
			 * If casting to a delegate type, use the argment signature 
			 * of the delegate to help select the function/method.
			 */
			string argsig = null;
			TokenType outType = cast.castTo;
			if (outType is TokenTypeDelegate) {
				argsig = ((TokenTypeDelegate)outType).argSig;
			}

			/*
			 * Generate the value that is being cast.
			 * If the value is already the requested type, just use it as is.
			 */
			CompValu inRVal = GenerateFromRVal (cast.rVal, argsig);
			if (inRVal.type == outType) return inRVal;

			/*
			 * Different type, generate casting code, putting the result in a temp of the output type.
			 */
			//??? optimize by having CompValu.PushVal() emit code for the conversion instead of needing a temp ???//
			CompValu outRVal = new CompValuTemp (outType, null, this);
			outRVal.isFinal = inRVal.isFinal;
			outRVal.PopPre (this);
			inRVal.PushVal (this, outType, true);
			outRVal.PopPost (this);
			return outRVal;
		}

		/**
		 * @brief Constant in the script somewhere
		 * @returns where the constants value is stored
		 */
		private CompValu GenerateFromRValConst (TokenRValConst rValConst)
		{
			if (rValConst.val is SCRIPTFLOAT) {
				return new CompValuFloat (new TokenTypeFloat (rValConst), (SCRIPTFLOAT)(rValConst.val));
			}
			if (rValConst.val is int) {
				return new CompValuInteger (new TokenTypeInt (rValConst), (int)(rValConst.val));
			}
			if (rValConst.val is string) {
				return new CompValuString (new TokenTypeStr (rValConst), (string)(rValConst.val));
			}
			throw new Exception ("unknown constant type " + rValConst.val.GetType ());
		}

		/**
		 * @brief One of the non-scalar predefined constants
		 * @returns where the constants value is stored
		 */
		private CompValu GenerateFromRValCVSField (TokenRValCVSField rValCVSF)
		{
			return rValCVSF.cvsf;
		}

		/**
		 * @brief generate a new list object
		 * @param rValList = an rVal to create it from
		 */
		private CompValu GenerateFromRValList (TokenRValList rValList)
		{
			CompValu newList = new CompValuTemp (new TokenTypeList (rValList.rVal), null, this);
			newList.PopPre (this);

			/*
			 * Create a temp array to hold all the initial values.
			 */
			PushConstantI4 (rValList.nItems);
			ilGen.Emit (OpCodes.Newarr, typeof (object));

			/*
			 * Populate the array.
			 */
			int i = 0;
			for (TokenRVal val = rValList.rVal; val != null; val = (TokenRVal)val.nextToken) {

				/*
				 * Get pointer to temp array object.
				 */
				ilGen.Emit (OpCodes.Dup);

				/*
				 * Get index in that array.
				 */
				PushConstantI4 (i);

				/*
				 * Emit code to compute initial value for the element.
				 */
				CompValu eRVal = GenerateFromRVal (val);

				/*
				 * Store initialization value in array location.
				 * However, floats and ints need to be converted to LSL_Float and LSL_Integer,
				 * or things like llSetPayPrice() will puque when they try to cast the elements
				 * to LSL_Float or LSL_Integer.  Likewise with string/LSL_String.
				 *
				 * Maybe it's already LSL-boxed so we don't do anything with it except make sure
				 * it is an object, not a struct.
				 */
				eRVal.PushVal (this);
				if (eRVal.type.ToLSLWrapType () == null) {
					if (eRVal.type is TokenTypeFloat) {
						ilGen.Emit (OpCodes.Newobj, lslFloatConstructorInfo);
						ilGen.Emit (OpCodes.Box, typeof (LSL_Float));
					} else if (eRVal.type is TokenTypeInt) {
						ilGen.Emit (OpCodes.Newobj, lslIntegerConstructorInfo);
						ilGen.Emit (OpCodes.Box, typeof (LSL_Integer));
					} else if (eRVal.type is TokenTypeStr) {
						ilGen.Emit (OpCodes.Newobj, lslStringConstructorInfo);
						ilGen.Emit (OpCodes.Box, typeof (LSL_String));
					} else if (eRVal.type.ToSysType ().IsValueType) {
						ilGen.Emit (OpCodes.Box, eRVal.type.ToSysType ());
					}
				} else if (eRVal.type.ToLSLWrapType ().IsValueType) {

					// Convert the LSL value structs to an object of the LSL-boxed type
					ilGen.Emit (OpCodes.Box, eRVal.type.ToLSLWrapType ());
				}
				ilGen.Emit (OpCodes.Stelem, typeof (object));
				i ++;
			}

			/*
			 * Create new list object from temp initial value array (whose ref is still on the stack).
			 */
			ilGen.Emit (OpCodes.Newobj, lslListConstructorInfo);
			newList.PopPost (this);
			return newList;
		}

		/**
		 * @brief parenthesized expression
		 * @returns type and location of the result of the computation.
		 */
		private CompValu GenerateFromRValParen (TokenRValParen rValParen)
		{
			return GenerateFromRVal (rValParen.rVal);
		}

		/**
		 * @brief create a rotation object from the x,y,z,w value expressions.
		 */
		private CompValu GenerateFromRValRot (TokenRValRot rValRot)
		{
			CompValu xRVal, yRVal, zRVal, wRVal;

			xRVal = GenerateFromRVal (rValRot.xRVal);
			yRVal = GenerateFromRVal (rValRot.yRVal);
			zRVal = GenerateFromRVal (rValRot.zRVal);
			wRVal = GenerateFromRVal (rValRot.wRVal);
			return new CompValuRot (new TokenTypeRot (rValRot), xRVal, yRVal, zRVal, wRVal);
		}

		/**
		 * @brief 'undefined' constant.
		 *        If this constant gets written to an array element, it will delete that element from the array.
		 *        If the script retrieves an element by key that is not defined, it will get this value.
		 *        This value can be stored in and retrieved from variables of type 'object'.
		 *        It is a runtime error to cast this value to any type, eg, we don't allow string variables to be null pointers.
		 */
		private CompValu GenerateFromRValUndef (TokenRValUndef rValUndef)
		{
			return new CompValuNull (new TokenTypeObject (rValUndef));
		}

		/**
		 * @brief create a vector object from the x,y,z value expressions.
		 */
		private CompValu GenerateFromRValVec (TokenRValVec rValVec)
		{
			CompValu xRVal, yRVal, zRVal;

			xRVal = GenerateFromRVal (rValVec.xRVal);
			yRVal = GenerateFromRVal (rValVec.yRVal);
			zRVal = GenerateFromRVal (rValVec.zRVal);
			return new CompValuVec (new TokenTypeVec (rValVec), xRVal, yRVal, zRVal);
		}

		/**
		 * @brief Generate code to process an <rVal> is <type> expression, and produce a boolean value.
		 */
		private CompValu GenerateFromRValIsType (TokenRValIsType rValIsType)
		{
			/*
			 * Expression we want to know the type of.
			 */
			CompValu val = GenerateFromRVal (rValIsType.rValExp);

			/*
			 * Pass it in to top-level type expression decoder.
			 */
			return GenerateFromTypeExp (val, rValIsType.typeExp);
		}

		/**
		 * @brief See if the type of the given value matches the type expression.
		 * @param val = where the value to be evaluated is stored
		 * @param typeExp = script tokens representing type expression
		 * @returns location where the boolean result is stored
		 */
		private CompValu GenerateFromTypeExp (CompValu val, TokenTypeExp typeExp)
		{
			if (typeExp is TokenTypeExpBinOp) {
				CompValu left   = GenerateFromTypeExp (val, ((TokenTypeExpBinOp)typeExp).leftOp);
				CompValu right  = GenerateFromTypeExp (val, ((TokenTypeExpBinOp)typeExp).rightOp);
				CompValu result = new CompValuTemp (tokenTypeBool, null, this);
				Token op = ((TokenTypeExpBinOp)typeExp).binOp;
				result.PopPre (this);
				left.PushVal (this);
				right.PushVal (this);
				if (op is TokenKwAnd) {
					ilGen.Emit (OpCodes.And);
				} else if (op is TokenKwOr) {
					ilGen.Emit (OpCodes.Or);
				} else {
					throw new Exception ("unknown TokenTypeExpBinOp " + op.GetType ());
				}
				result.PopPost (this);
				return result;
			}
			if (typeExp is TokenTypeExpNot) {
				CompValu interm = GenerateFromTypeExp (val, ((TokenTypeExpNot)typeExp).typeExp);
				CompValu result = new CompValuTemp (tokenTypeBool, null, this);
				result.PopPre (this);
				interm.PushVal (this, tokenTypeBool);
				PushConstantI4 (1);
				ilGen.Emit (OpCodes.Xor);
				result.PopPost (this);
				return result;
			}
			if (typeExp is TokenTypeExpPar) {
				return GenerateFromTypeExp (val, ((TokenTypeExpPar)typeExp).typeExp);
			}
			if (typeExp is TokenTypeExpType) {
				CompValu result = new CompValuTemp (tokenTypeBool, null, this);
				result.PopPre (this);
				val.PushVal (this);
				ilGen.Emit (OpCodes.Isinst, ((TokenTypeExpType)typeExp).typeToken.ToSysType ());
				ilGen.Emit (OpCodes.Ldnull);
				ilGen.Emit (OpCodes.Ceq);
				PushConstantI4 (1);
				ilGen.Emit (OpCodes.Xor);
				result.PopPost (this);
				return result;
			}
			if (typeExp is TokenTypeExpUndef) {
				CompValu result = new CompValuTemp (tokenTypeBool, null, this);
				result.PopPre (this);
				val.PushVal (this);
				ilGen.Emit (OpCodes.Ldnull);
				ilGen.Emit (OpCodes.Ceq);
				result.PopPost (this);
				return result;
			}
			throw new Exception ("unknown TokenTypeExp type " + typeExp.GetType ());
		}

		/**
		 * @brief Push the default (null) value for a particular variable
		 * @param var = variable to get the default value for
		 * @returns with value pushed on stack
		 */
		private void PushVarDefaultValue (TokenDeclVar var)
		{
			TokenType type = var.type;
			if (type is TokenTypeArray) {
				ilGen.Emit (OpCodes.Ldarg_0);  // instance
				PushConstantI4 (var.line);     // source line in file
				PushConstantI4 (var.posn);     // source posn in line
				ilGen.Emit (OpCodes.Newobj, xmrArrayConstructorInfo);
				return;
			}
			if (type is TokenTypeList) {
				PushConstantI4 (0);
				ilGen.Emit (OpCodes.Newarr, typeof (object));
				ilGen.Emit (OpCodes.Newobj, lslListConstructorInfo);
				return;
			}
			if (type is TokenTypeRot) {
				// Mono is tOO stOOpid to allow: ilGen.Emit (OpCodes.Ldsfld, zeroRotationFieldInfo);
				ilGen.Emit (OpCodes.Ldc_R8, ScriptBaseClass.ZERO_ROTATION.x);
				ilGen.Emit (OpCodes.Ldc_R8, ScriptBaseClass.ZERO_ROTATION.y);
				ilGen.Emit (OpCodes.Ldc_R8, ScriptBaseClass.ZERO_ROTATION.z);
				ilGen.Emit (OpCodes.Ldc_R8, ScriptBaseClass.ZERO_ROTATION.s);
				ilGen.Emit (OpCodes.Newobj, lslRotationConstructorInfo);
				return;
			}
			if (type is TokenTypeStr) {
				ilGen.Emit (OpCodes.Ldstr, "");
				return;
			}
			if (type is TokenTypeVec) {
				// Mono is tOO stOOpid to allow: ilGen.Emit (OpCodes.Ldsfld, zeroVectorFieldInfo);
				ilGen.Emit (OpCodes.Ldc_R8, ScriptBaseClass.ZERO_VECTOR.x);
				ilGen.Emit (OpCodes.Ldc_R8, ScriptBaseClass.ZERO_VECTOR.y);
				ilGen.Emit (OpCodes.Ldc_R8, ScriptBaseClass.ZERO_VECTOR.z);
				ilGen.Emit (OpCodes.Newobj, lslVectorConstructorInfo);
				return;
			}
			if (type is TokenTypeInt) {
				PushConstantI4 (0);
				return;
			}
			if (type is TokenTypeFloat) {
				ilGen.Emit (OpCodes.Ldc_R4, 0.0f);
				return;
			}

			/*
			 * Default for 'object' type is 'undef'.
			 */
			if (type is TokenTypeObject) {
				ilGen.Emit (OpCodes.Ldnull);
				return;
			}

			/*
			 * Void is pushed as the default return value of a void function.
			 * So just push nothing as expected of void functions.
			 */
			if (type is TokenTypeVoid) {
				return;
			}

			/*
			 * Default for 'delegate' type is 'undef'.
			 */
			if (type is TokenTypeDelegate) {
				ilGen.Emit (OpCodes.Ldnull);
				return;
			}

			throw new Exception ("unknown type " + type.ToString ());
		}

		/**
		 * @brief Determine if the expression has a constant boolean value
		 *        and if so, if the value is true or false.
		 * @param expr = expression to evaluate
		 * @returns true: expression is contant and has boolean value true
		 *         false: otherwise
		 */
		private bool IsConstBoolExprTrue (TokenRVal expr)
		{
			bool constVal;
			return IsConstBoolExpr (expr, out constVal) && constVal;
		}

		private bool IsConstBoolExpr (TokenRVal expr, out bool constVal)
		{
			if (expr is TokenRValConst) {
				object val = ((TokenRValConst)expr).val;
				if (val is SCRIPTFLOAT) {
					constVal = (SCRIPTFLOAT)val != 0.0;
					return true;
				}
				if (val is int) {
					constVal = (int)val != 0.0;
					return true;
				}
			}

			constVal = false;
			return false;
		}

		/**
		 * @brief Determine if the expression has a constant integer value
		 *        and if so, return the integer value.
		 * @param expr = expression to evaluate
		 * @returns true: expression is contant and has integer value
		 *         false: otherwise
		 */
		private bool IsConstIntExpr (TokenRVal expr, out int constVal)
		{
			if (expr is TokenRValConst) {
				object val = ((TokenRValConst)expr).val;
				if (val is SCRIPTFLOAT) {
					constVal = (int)(SCRIPTFLOAT)val;
					return true;
				}
				if (val is int) {
					constVal = (int)val;
					return true;
				}
			}

			constVal = 0;
			return false;
		}

		/**
		 * @brief create table of legal event handler prototypes.
		 *        This is used to make sure script's event handler declrations are valid.
		 */
		private static Dictionary<string, TokenDeclFunc> CreateLegalEventHandlers ()
		{
			Dictionary<string, TokenDeclFunc> leh = new InternalFuncDict (typeof (IEventHandlers), false);
			return leh;
		}

		/**
		 * @brief Push an integer constant
		 */
		public void PushConstantI4 (int c)
		{
			switch (c) {
				case -1: {
					ilGen.Emit (OpCodes.Ldc_I4_M1);
					return;
				}
				case 0: {
					ilGen.Emit (OpCodes.Ldc_I4_0);
					return;
				}
				case 1: {
					ilGen.Emit (OpCodes.Ldc_I4_1);
					return;
				}
				case 2: {
					ilGen.Emit (OpCodes.Ldc_I4_2);
					return;
				}
				case 3: {
					ilGen.Emit (OpCodes.Ldc_I4_3);
					return;
				}
				case 4: {
					ilGen.Emit (OpCodes.Ldc_I4_4);
					return;
				}
				case 5: {
					ilGen.Emit (OpCodes.Ldc_I4_5);
					return;
				}
				case 6: {
					ilGen.Emit (OpCodes.Ldc_I4_6);
					return;
				}
				case 7: {
					ilGen.Emit (OpCodes.Ldc_I4_7);
					return;
				}
				case 8: {
					ilGen.Emit (OpCodes.Ldc_I4_8);
					return;
				}
				default: break;
			}
			if ((c >= 0) && (c <= 127)) {  // negatives dont seem to work
				ilGen.Emit (OpCodes.Ldc_I4_S, c);
				return;
			}
			ilGen.Emit (OpCodes.Ldc_I4, c);
		}

		/**
		 * @brief Emit a call to CheckRun(), (voluntary multitasking switch)
		 */
		public void EmitCallCheckRun (int line)
		{
			new CallLabel (this);                           // jump here when stack restored
			ilGen.Emit (OpCodes.Ldarg_0);                   // instance
			PushConstantI4 (line);                          // source line number
			ilGen.Emit (OpCodes.Call, checkRunMethodInfo);  // instance.CheckRun()
		}

		/**
		 * @brief Maintain list of current function's local variables so we can keep track
		 *        of heap usage.  We don't have to keep track of stack usage as that is done
		 *        entirely within CheckRun().  Do not include arrays as they do their own heap tracking.
		 */
		private void NewLocalVariable (CompValu local, TokenName name)
		{
			if ((local.type is TokenTypeList) ||
			    (local.type is TokenTypeStr)) {
				local.heapTracker = new CompValuTemp (new TokenTypeInt (name), "__htl_" + name.val, this);
				DebitHeapLeft (local, false, name);
			}
		}

		/**
		 * @brief A variable was just assigned a value.  If the variable references heap,
		 *        debit the instance.heapLeft to make sure the script doesn't hog memory.
		 * @param value = local or global variable
		 * @param stValid = false: heapTracker contains garbage, so don't bother adding it back first
		 *                   true: heapTracker contains previous debit quantity, so add it back first
		 * @param name = token giving location in source code of assignment for tracing/debug
		 */
		private void DebitHeapLeft (CompValu value, bool stValid, Token name)
		{
			/*
			 * If just did something like 'arr[idx] = val' the 
			 * array as an object keeps track of heap use so we 
			 * want to reference the array object itself.
			 */
			if (value is CompValuArEle) {
				value = ((CompValuArEle)value).arr;
			}

			/*
			 * Now see if the variable is heap tracked
			 * and if so, output call to check heap usage.
			 */
			CompValu heapTracker = value.heapTracker;
			if (heapTracker != null) {
				heapTracker.PopPre (this);
				
				ilGen.Emit (OpCodes.Ldarg_0);                         // instance

				value.PushVal (this);                                 // object we care about

				if (stValid) {
					heapTracker.PushVal (this);                   // previously debited amount or ...
				} else {
					PushConstantI4 (0);                           // 0 because nothing debited before
				}

				PushConstantI4 (name.line);
				PushConstantI4 (name.posn);

				ilGen.Emit (OpCodes.Call, updateHeapLeftMethodInfo);  // update instance.heapLeft
				                                                      // throws exception if not enuf left

				heapTracker.PopPost (this);                           // new debited amount
			}
		}

		/**
		 * @brief A function is about to return, so credit any debits on heapLeft by its local variables.
		 */
		private void CreditAllLocalsHeapLeft ()
		{
			bool first = true;

			foreach (TokenDeclVar localVar in curDeclFunc.localVars) {
				CompValu heapTracker = localVar.location.heapTracker;
				if (heapTracker == null) continue;

				if (first) {
					ilGen.Emit (OpCodes.Ldarg_0);                    // instance
					ilGen.Emit (OpCodes.Ldflda, heapLeftFieldInfo);  // &instance.heapLeft
					heapTracker.PushVal (this);                      // numberOfBytes subtracted from heapLeft
					first = false;
				} else {
					heapTracker.PushVal (this);                      // numberOfBytes subtracted from heapLeft
					ilGen.Emit (OpCodes.Add);                        // add them back to heapLeft
				}
			}
			if (!first) {
				ilGen.Emit (OpCodes.Call, interlockedAddMethodInfo);     // ...atomically
				ilGen.Emit (OpCodes.Pop);                                // we don't need return value
			}
		}

		/**
		 * @brief maintain variable definition stack.
		 * It translates a variable name string to its declaration.
		 */
		private Dictionary<string, CompValu> PushVarDefnBlock ()
		{
			Dictionary<string, CompValu> frame = new Dictionary<string, CompValu> ();
			scriptVariablesStack.Push (frame);
			return frame;
		}
		private void PopVarDefnBlock ()
		{
			scriptVariablesStack.Pop ();
		}
		private void AddVarDefinition (TokenName name, CompValu var)
		{
			AddVarDefinition (name, null, var);
		}
		private void AddVarDefinition (TokenName name, string argSig, CompValu var)
		{
			Dictionary<string, CompValu> vars = scriptVariablesStack.Peek ();
			string namesig = name.val;

			/*
			 * If entrypoint refers to a possibly overloaded method, add the 
			 * argument signature to the name, so we end up cataloging stuff 
			 * like "Verify(array,list,string)" for such things.
			 */
			if (argSig != null) namesig += argSig;

			/*
			 * Only allow one of each namesig.
			 */
			if (vars.ContainsKey (namesig)) {
				ErrorMsg (name, "duplicate var definition " + namesig);
			} else {
				vars.Add (namesig, var);
			}
		}

		/**
		 * @brief handle a unary operator, such as -x.
		 */
		private CompValu UnOpGenerate (CompValu inRVal, Token opcode)
		{
			/*
			 * - Negate
			 */
			if (opcode is TokenKwSub) {
				if (inRVal.type is TokenTypeFloat) {
					CompValu outRVal = new CompValuTemp (new TokenTypeFloat (opcode), null, this);
					outRVal.PopPre (this);                // set up for a pop
					inRVal.PushVal (this, outRVal.type);  // push value to negate, make sure not LSL-boxed
					ilGen.Emit (OpCodes.Neg);             // compute the negative
					outRVal.PopPost (this);               // pop into result
					return outRVal;                       // tell caller where we put it
				}
				if (inRVal.type is TokenTypeInt) {
					CompValu outRVal = new CompValuTemp (new TokenTypeInt (opcode), null, this);
					outRVal.PopPre (this);                // set up for a pop
					inRVal.PushVal (this, outRVal.type);  // push value to negate, make sure not LSL-boxed
					ilGen.Emit (OpCodes.Neg);             // compute the negative
					outRVal.PopPost (this);               // pop into result
					return outRVal;                       // tell caller where we put it
				}
				if (inRVal.type is TokenTypeVec) {
					CompValu outRVal = new CompValuTemp (inRVal.type, null, this);
					outRVal.PopPre (this);                // set up for a pop
					inRVal.PushVal (this);                // push vector, then call negate routine
					ilGen.Emit (OpCodes.Call, lslVectorNegateMethodInfo);
					outRVal.PopPost (this);               // pop into result
					return outRVal;                       // tell caller where we put it
				}
				ErrorMsg (opcode, "can't negate a " + inRVal.type.ToString ());
				return inRVal;
			}

			/*
			 * ~ Complement (bitwise integer)
			 */
			if (opcode is TokenKwTilde) {
				if (inRVal.type is TokenTypeInt) {
					CompValu outRVal = new CompValuTemp (new TokenTypeInt (opcode), null, this);
					outRVal.PopPre (this);                // set up for a pop
					inRVal.PushVal (this, outRVal.type);  // push value to negate, make sure not LSL-boxed
					ilGen.Emit (OpCodes.Not);             // compute the complement
					outRVal.PopPost (this);               // pop into result
					return outRVal;                       // tell caller where we put it
				}
				ErrorMsg (opcode, "can't complement a " + inRVal.type.ToString ());
				return inRVal;
			}

			/*
			 * ! Not (boolean)
			 *
			 * We stuff the 0/1 result in an int because I've seen x+!y in scripts
			 * and we don't want to have to create tables to handle int+bool and
			 * everything like that.
			 */
			if (opcode is TokenKwExclam) {
				CompValu outRVal = new CompValuTemp (new TokenTypeInt (opcode), null, this);
				outRVal.PopPre (this);                 // set up for a pop
				inRVal.PushVal (this, tokenTypeBool);  // anything converts to boolean
				PushConstantI4 (1);                    // then XOR with 1 to flip it
				ilGen.Emit (OpCodes.Xor);
				outRVal.PopPost (this);                // pop into result
				return outRVal;                        // tell caller where we put it
			}

			throw new Exception ("unhandled opcode " + opcode.ToString ());
		}

		/**
		 * @brief output error message and remember that we did
		 */
		public void ErrorMsg (Token token, string message)
		{
			if ((token == null) || (token.emsg == null)) token = errorMessageToken;
			token.ErrorMsg (message);
			youveAnError = true;
		}

		/**
		 * @brief Find a private static method.
		 * @param owner = class the method is part of
		 * @param name = name of method to find
		 * @param args = array of argument types
		 * @returns pointer to method
		 */
		public static MethodInfo GetStaticMethod (Type owner, string name, Type[] args)
		{
			MethodInfo mi = owner.GetMethod (name, BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic, null, args, null);
			if (mi == null) {
				throw new Exception ("undefined method " + owner.ToString () + "." + name);
			}
			return mi;
		}

		public static LSL_Vector LSLVectorNegate (LSL_Vector v) { return -v; }

		/**
		 * @brief Called at runtime to convert the string given by the script in a throw statement to an exception.
		 */
		public static Exception ThrowStrToExc (string msg)
		{
			return new ScriptThrownException (msg);
		}

		/**
		 * @brief Called at runtime to convert a caught exception to the string given to the catch clause.
		 *        If we return null, the script's catch clause will do a rethrow before letting the script see it.
		 */
		public static string CatchExcToStr (Exception exc)
		{
			if (exc is IXMRUncatchable) return null;
			return exc.ToString ();
		}

		/**
		 * @brief An heap referencing variable was just set to a new object so we need to
		 *        update instance.heapLeft to reflect the new amount of heap available
		 *        to the script.
		 * @param instance = script instance who's heap usage is being updated
		 * @param value = object pointer value that was just written
		 * @param oldHeapUse = what was previously debited by the variable that was just written
		 * @returns amount being debited by the new assignment
		 *          instance.heapLeft = adjusted to reflect new heap avaialbe to script
		 * Throws exception if the new value exceeds available amount.
		 */
		public static int UpdateHeapLeft (XMRInstAbstract instance, object value, int oldHeapUse, int srcLine, int srcPosn)
		{
			int newHeapUse = 0;

			     if (value is XMR_Array)  newHeapUse = ((XMR_Array)value).Size;
			else if (value is LSL_List)   newHeapUse = ((LSL_List)value).Size;
			else if (value is LSL_String) newHeapUse = ((LSL_String)value).Length * 2 + 24;
			else if (value is string)     newHeapUse = ((string)value).Length * 2 + 24;

			int heapNeeded  = newHeapUse - oldHeapUse;
			int newHeapLeft = Interlocked.Add (ref instance.heapLeft, -heapNeeded);
			int oldHeapLeft = newHeapLeft + heapNeeded;
			if (newHeapLeft < 0) {
				GC.Collect ();
				GC.WaitForPendingFinalizers ();  // in case XMR_Array can give anything back
				if (instance.heapLeft < 0) {
					throw new OutOfHeapException (heapNeeded, oldHeapLeft, srcLine, srcPosn);
				}
			}

			if (instance.traceHeapUse != null) {
				Console.WriteLine("traceHeapUse: {0} {1}.{2}: old={3} new={4} left={5}", 
					instance.traceHeapUse, srcLine, srcPosn, oldHeapUse, newHeapUse, instance.heapLeft);
			}

			return newHeapUse;
		}

		/**
		 * @brief Defines an internal label that is used as a target for 'break' and 'continue' statements.
		 */
		private class BreakContTarg {
			public ScriptMyLabel label;
			public bool used;
			public BreakContTarg (ScriptMyILGen ilGen, string name) {
				label = ilGen.DefineLabel (name);  // label to be used
				used  = false;                     // assume it isn't referenced at all
			}
		}

		/**
		 * @brief Convert 'objFileReader' format to 'scriptObjCode' format.
		 *   'objFileReader' is a serialized form of the CIL code we generated
		 *   'asmFileWriter' is where we write the disassembly to (or null if not wanted)
		 *   'scriptObjCode' is an in-memory object with methods filled in from the CIL code
		 * Throws an exception if there is any error (theoretically).
		 */
		public static ScriptObjCode PerformGeneration (string descName,
		                                               BinaryReader objFileReader, 
		                                               TextWriter asmFileWriter)
		{
			/*
			 * Check version number to make sure we know how to process file contents.
			 */
			char[] ocm = objFileReader.ReadChars (OBJECT_CODE_MAGIC.Length);
			if (new String (ocm) != OBJECT_CODE_MAGIC) {
				throw new Exception ("not an XMR object file (bad magic)");
			}
			int cvv = objFileReader.ReadInt32 ();
			if (cvv != COMPILED_VERSION_VALUE) {
				throw new Exception ("object version is " + cvv.ToString () + 
				                     " but accept only " + COMPILED_VERSION_VALUE.ToString ());
			}

			/*
			 * Fill in simple parts of scriptObjCode object.
			 */
			ScriptObjCode scriptObjCode   = new ScriptObjCode ();
			scriptObjCode.numGblArrays    = objFileReader.ReadInt32 ();
			scriptObjCode.numGblFloats    = objFileReader.ReadInt32 ();
			scriptObjCode.numGblIntegers  = objFileReader.ReadInt32 ();
			scriptObjCode.numGblLists     = objFileReader.ReadInt32 ();
			scriptObjCode.numGblObjects   = objFileReader.ReadInt32 ();
			scriptObjCode.numGblRotations = objFileReader.ReadInt32 ();
			scriptObjCode.numGblStrings   = objFileReader.ReadInt32 ();
			scriptObjCode.numGblVectors   = objFileReader.ReadInt32 ();

			int nStates = objFileReader.ReadInt32 ();

			scriptObjCode.stateNames = new string[nStates];
			for (int i = 0; i < nStates; i ++) {
				scriptObjCode.stateNames[i] = objFileReader.ReadString ();
				if (asmFileWriter != null) {
					asmFileWriter.WriteLine ("  state[{0}] = {1}", i, scriptObjCode.stateNames[i]);
				}
			}

			if (asmFileWriter != null) {
				asmFileWriter.WriteLine ("  numGblArrays    {0}", scriptObjCode.numGblArrays);
				asmFileWriter.WriteLine ("  numGblFloats    {0}", scriptObjCode.numGblFloats);
				asmFileWriter.WriteLine ("  numGblIntegers  {0}", scriptObjCode.numGblIntegers);
				asmFileWriter.WriteLine ("  numGblLists     {0}", scriptObjCode.numGblLists);
				asmFileWriter.WriteLine ("  numGblObjects   {0}", scriptObjCode.numGblObjects);
				asmFileWriter.WriteLine ("  numGblRotations {0}", scriptObjCode.numGblRotations);
				asmFileWriter.WriteLine ("  numGblStrings   {0}", scriptObjCode.numGblStrings);
				asmFileWriter.WriteLine ("  numGblVectors   {0}", scriptObjCode.numGblVectors);
			}

			string gblName;
			while ((gblName = objFileReader.ReadString ()) != "") {
				string gblType = objFileReader.ReadString ();
				int gblIndex = objFileReader.ReadInt32 ();
				if (asmFileWriter != null) {
					asmFileWriter.WriteLine ("  {0} = {1}[{2}]", gblName, gblType, gblIndex);
				}
			}

			/*
			 * Now fill in the methods (the hard part).
			 */
			EndMethodWrapper endMethodWrapper = new EndMethodWrapper ();
			endMethodWrapper.scriptObjCode = scriptObjCode;
			endMethodWrapper.descName      = descName;
			scriptObjCode.scriptEventHandlerTable = new ScriptEventHandler[nStates,(int)ScriptEventCode.Size];
			scriptObjCode.dynamicMethods = new Dictionary<string, DynamicMethod> ();
			ScriptMyILGen.CreateObjCode (objFileReader, endMethodWrapper.EndMethod, asmFileWriter);

			return scriptObjCode;
		}

		/**
		 * @brief Called once for every method found in objFileReader file.
		 *        It enters the method in the ScriptObjCode object so it can be called.
		 */
		private class EndMethodWrapper {
			public ScriptObjCode scriptObjCode;
			public string descName;

			public void EndMethod (DynamicMethod method)
			{
				string methName = method.Name;

				/*
				 * We catalog all methods (event handlers and user-defined functions) 
				 * so we can restore them from stack dump.
				 */
				scriptObjCode.dynamicMethods.Add (methName, method);

				/*
				 * We enter all script event handler methods in the ScriptEventHandler table.
				 * They are named:  __seh_<statenumber>_<eventnumber>_<bunchofstuffwedontcareabout>
				 */
				if (methName.StartsWith ("__seh_")) {
					int j = methName.IndexOf ('_', 6);      // terminates <statenumber>
					int k = methName.IndexOf ('_', j + 1);  // terminates <eventnumber>
					int stateCode = Int32.Parse (methName.Substring (6, j - 6));
					int eventCode = Int32.Parse (methName.Substring (j + 1, k - j - 1));
					scriptObjCode.scriptEventHandlerTable[stateCode,eventCode] = 
							(ScriptEventHandler)method.CreateDelegate (typeof (ScriptEventHandler));
				}
			}
		}
	}

	/**
	 * @brief Marker interface indicates an exception that can't be caught by a script-level try/catch.
	 */
	public interface IXMRUncatchable { }

	/**
	 * @brief Thrown by a script when it attempts to change to an undefined state.
	 * These can be detected at compile time but the moron XEngine compiles
	 * such things, so we compile them as runtime errors.
	 */
	public class ScriptUndefinedStateException : Exception {
		public string stateName;
		public ScriptUndefinedStateException (string stateName) : base ("undefined state " + stateName) {
			this.stateName = stateName;
		}
	}

	/**
	 * @brief Thrown by a script when it attempts to change to a defined state.
	 */
	public class ScriptChangeStateException : Exception, IXMRUncatchable {
		public int newState;
		public ScriptChangeStateException (int newState) {
			this.newState = newState;
		}
	}

	/**
	 * @brief Thrown by a script from a 'throw' statement.
	 */
	public class ScriptThrownException : Exception {
		public ScriptThrownException (string msg) : base (msg) { }
	}

	public class OutOfHeapException : Exception {
		public OutOfHeapException(int heapNeeded, int heapLeft, int srcLine, int srcPosn)
			: base ("need " + heapNeeded + ", have only " + heapLeft + 
				" heap bytes left at " + srcLine + ":" + srcPosn)
		{ }
	}
	public class OutOfStackException : Exception { }

	public class ScriptBadCallNoException : Exception {
		public ScriptBadCallNoException (int callNo) : base ("bad callNo " + callNo) { }
	}
}
