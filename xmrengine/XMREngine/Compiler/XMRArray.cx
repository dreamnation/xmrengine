/***************************************************\
 *  COPYRIGHT 2010, Mike Rieker, Beverly, MA, USA  *
 *  All rights reserved.                           *
\***************************************************/

using System;
using System.Collections.Generic;
using System.IO;
using System.Text;

#include "lsltypes.h"

// This class exists in the main app domain
//
namespace OpenSim.Region.ScriptEngine.XMREngine
{

    /**
     * @brief Array objects.
     */
    public class XMR_Array : IDisposable {
        private const int EMPTYHEAP = 64;

        private bool enumrValid;                              // true: enumr set to return array[arrayValid]
                                                              // false: array[0..arrayValid-1] is all there is
        private Dictionary<object, object> dnary = new Dictionary<object, object> ();
        private Dictionary<object, object>.Enumerator enumr;  // enumerator used to fill 'array' past arrayValid to end of dictionary
        private int arrayValid;                               // number of elements in 'array' that have been filled in
        private int heapUse = EMPTYHEAP;                      // approx number of bytes of heap used by all dnary elements
        private KeyValuePair<object, object>[] array;         // list of kvp's that have been returned by ForEach() since last modification
        private XMRInstAbstract inst;                         // script instance debited with heap use

        public static TokenTypeSDTypeDelegate countDelegate = new TokenTypeSDTypeDelegate (new TokenTypeInt    (null), new TokenType[0]);
        public static TokenTypeSDTypeDelegate clearDelegate = new TokenTypeSDTypeDelegate (new TokenTypeVoid   (null), new TokenType[0]);
        public static TokenTypeSDTypeDelegate indexDelegate = new TokenTypeSDTypeDelegate (new TokenTypeObject (null), new TokenType[] { new TokenTypeInt (null) });
        public static TokenTypeSDTypeDelegate valueDelegate = new TokenTypeSDTypeDelegate (new TokenTypeObject (null), new TokenType[] { new TokenTypeInt (null) });

        public XMR_Array (XMRInstAbstract inst, int line, int posn)
        {
            this.inst = inst;
            ScriptCodeGen.UpdateHeapLeft (inst, this, 0, line, posn);
        }

        ~XMR_Array ()
        {
            Dispose ();
        }

        public void Dispose ()
        {
            if (inst != null) {
                int oldHeapUse = heapUse;
                heapUse = 0;
                dnary   = null;
                array   = null;
                ScriptCodeGen.UpdateHeapLeft (inst, this, oldHeapUse, 0, 0);
                inst    = null;
            }
        }

        public static TokenType GetRValType (TokenName name)
        {
            if (name.val == "count") return new TokenTypeInt (name);
            if (name.val == "clear") return clearDelegate;
            if (name.val == "index") return indexDelegate;
            if (name.val == "value") return valueDelegate;
            return new TokenTypeVoid (name);
        }

        /**
         * @brief Handle 'array[index]' syntax to get or set an element of the dictionary.
         * Get returns null if element not defined, script sees type 'undef'.
         * Setting an element to null removes it.
         */
        public object GetByKey(object key)
        {
            object val;
            key = FixKey (key);
            if (!dnary.TryGetValue (key, out val)) val = null;
            return val;
        }

        public void SetByKey(object key, object value)
        {
            SetByKey (key, value, 0, 0);
        }

        public void SetByKey(object key, object value, int line, int posn)
        {
            key = FixKey (key);

            /*
             * Update heap use based on old vs new value.
             * Might throw an OutOfHeapException.
             */
            if (inst != null) {
                int oldHeapUse = heapUse;
                object oldValue;
                if (dnary.TryGetValue (key, out oldValue)) {
                    heapUse -= HeapUseOfObj (key);
                    heapUse -= HeapUseOfObj (oldValue);
                }
                if (value != null) {
                    heapUse += HeapUseOfObj (key);
                    heapUse += HeapUseOfObj (value);
                }
                ScriptCodeGen.UpdateHeapLeft (inst, this, oldHeapUse, line, posn);
            }

            /*
             * Save new value in array, replacing one of same key if there.
             * null means remove the value, ie, script did array[key] = undef.
             */
            if (value != null) {
                dnary[key] = value;
            } else {
                dnary.Remove (key);

                /*
                 * Shrink the enumeration array, but always leave at least one element.
                 */
                if ((array != null) && (dnary.Count < array.Length / 2)) {
                    Array.Resize<KeyValuePair<object, object>> (ref array, array.Length / 2);
                }
            }

            /*
             * The enumeration array is invalid because the dictionary has been modified.
             * Next time a ForEach() call happens, it will repopulate 'array' as elements are retrieved.
             */
            arrayValid = 0;
        }

        /**
         * @brief Converts an 'object' type to array, key, list, string, but disallows null,
         *        as our language doesn't allow types other than 'object' to be null.
         *        Value types (float, rotation, etc) don't need explicit check for null as
         *        the C# runtime can't convert a null to a value type, and throws an exception.
         *        But for any reference type (array, key, etc) we must manually check for null.
         */
        public static XMR_Array Obj2Array (object obj)
        {
            if (obj == null) throw new NullReferenceException ();
            return (XMR_Array)obj;
        }
        public static LSL_Key Obj2Key (object obj)
        {
            if (obj == null) throw new NullReferenceException ();
            return (LSL_Key)obj;
        }
        public static LSL_List Obj2List (object obj)
        {
            if (obj == null) throw new NullReferenceException ();
            return (LSL_List)obj;
        }
        public static LSL_String Obj2String (object obj)
        {
            if (obj == null) throw new NullReferenceException ();
            return obj.ToString ();
        }

        /**
         * @brief remove all elements from the array.
         *        sets everything to its 'just constructed' state.
         */
        public void __pub_clear ()
        {
            int oldHeapUse = heapUse;
            dnary.Clear ();
            heapUse    = EMPTYHEAP;
            enumrValid = false;
            arrayValid = 0;
            array = null;
            ScriptCodeGen.UpdateHeapLeft (inst, this, oldHeapUse, 0, 0);
        }

        /**
         * @brief return number of elements in the array.
         */
        public int __pub_count () {
            return dnary.Count;
        }

        /**
         * @brief Retrieve index (key) of an arbitrary element.
         * @param number = number of the element (0 based)
         * @returns null: array doesn't have that many elements
         *          else: index (key) for that element
         */
        public object __pub_index (int number)
        {
            object key = null;
            object val = null;
            ForEach (number, ref key, ref val);
            return key;
        }


        /**
         * @brief Retrieve value of an arbitrary element.
         * @param number = number of the element (0 based)
         * @returns null: array doesn't have that many elements
         *          else: value for that element
         */
        public object __pub_value (int number)
        {
            object key = null;
            object val = null;
            ForEach (number, ref key, ref val);
            return val;
        }

        /**
         * @brief Called in each iteration of a 'foreach' statement.
         * @param number = index of element to retrieve (0 = first one)
         * @returns false: element does not exist
         *           true: element exists:
         *                 key = key of retrieved element
         *                 val = value of retrieved element
         */
        public bool ForEach (int number, ref object key, ref object val)
        {
            /*
             * If we don't have any array, we can't have ever done
             * any calls here before, so allocate an array big enough
             * and set everything else to the beginning.
             */
            if (array == null) {
                array = new KeyValuePair<object, object>[dnary.Count];
                arrayValid = 0;
            }

            /*
             * If dictionary modified since last enumeration, get a new enumerator.
             */
            if (arrayValid == 0) {
                enumr = dnary.GetEnumerator ();
                enumrValid = true;
            }

            /*
             * Make sure we have filled the array up enough for requested element.
             */
            while ((arrayValid <= number) && enumrValid && enumr.MoveNext ()) {
                if (arrayValid >= array.Length) {
                    Array.Resize<KeyValuePair<object, object>> (ref array, dnary.Count);
                }
                array[arrayValid++] = enumr.Current;
            }

            /*
             * If we don't have that many elements, return end-of-array status.
             */
            if (arrayValid <= number) return false;

            /*
             * Return the element values.
             */
            key = UnfixKey (array[number].Key);
            val = array[number].Value;
            return true;
        }

        /**
         * @brief Transmit array out in such a way that it can be reconstructed,
         *        including any in-progress ForEach() enumerations.
         */
        public delegate void SendArrayObjDelegate (object graph);
        public void SendArrayObj (SendArrayObjDelegate sendObj)
        {
            int index = arrayValid;
            object key = null;
            object val = null;

            /*
             * Completely fill the array from where it is already filled to the end.
             * Any elements before arrayValid remain as the current enumerator has
             * seen them, and any after arrayValid will be filled by that same
             * enumerator.  The array will then be used on the receiving end to iterate
             * in the same exact order, because a new enumerator on the receiving end
             * probably wouldn't see them in the same order.
             */
            while (ForEach (index ++, ref key, ref val)) { }

            /*
             * Set the count then the elements themselves.
             */
            sendObj ((object)arrayValid);
            for (index = 0; index < arrayValid; index ++) {
                sendObj (UnfixKey (array[index].Key));
                sendObj (array[index].Value);
            }
        }

        /**
         * @brief Receive array in.  Any previous contents are erased.
         *        Set up such that any enumeration in progress will resume
         *        at the exact spot and in the exact same order as they
         *        were in on the sending side.
         */
        public delegate object RecvArrayObjDelegate ();
        public void RecvArrayObj (RecvArrayObjDelegate recvObj)
        {
            int index;
            int oldHeapUse = heapUse;

            /*
             * Empty the dictionary.
             */
            dnary.Clear ();
            heapUse = EMPTYHEAP;

            /*
             * Any enumerator in progress is now invalid, and all elements
             * for enumeration must come from the array, so they will be in
             * the same order they were in on the sending side.
             */
            enumrValid = false;

            /*
             * Get number of elements we will receive and set up an
             * array to receive them into.  The array will be used
             * for any enumerations in progress, and will have elements
             * in order as given by previous calls to those enumerations.
             */
            arrayValid = (int)recvObj ();
            array = new KeyValuePair<object, object>[arrayValid];

            /*
             * Fill the array and dictionary.
             * Any enumerations will use the array so they will be in the
             * same order as on the sending side (until the dictionary is
             * modified).
             */
            for (index = 0; index < arrayValid; index ++) {
                object key = FixKey (recvObj ());
                object val = recvObj ();
                array[index] = new KeyValuePair<object, object> (key, val);
                dnary.Add (key, val);
                heapUse += HeapUseOfObj (key);
                heapUse += HeapUseOfObj (val);
            }
            ScriptCodeGen.UpdateHeapLeft (inst, this, oldHeapUse, 0, 0);
        }

        /**
         * Retrieve total approximate heap use by the array.
         */
        public int Size {
            get {
                return heapUse;
            }
        }
        private static int HeapUseOfObj (object o)
        {
            if (o == null) return 0;
            if (o is int)          return 4;
            if (o is LSL_Integer)  return 4;
            if (o is LSL_Float)    return 8;
            if (o is LSL_Key)      return 16 + 2 * ((string)(LSL_Key)o).Length;
            if (o is LSL_String)   return 16 + 2 * ((string)(LSL_String)o).Length;
            if (o is LSL_List)     return ((LSL_List)o).Size;
            if (o is LSL_Vector)   return 24;
            if (o is LSL_Rotation) return 32;
            if (o is object[]) {
                object[] a = (object[])o;
                int s = a.Length * 4;
                foreach (object oo in a) {
                    s += HeapUseOfObj (oo);
                }
                return s;
            }
            if (o is SCRIPTFLOAT)  return 8;
            return 0;
        }

        /**
         * We want our index values to be of consistent type, otherwise we get things like (LSL_Integer)1 != (int)1.
         * So strip off any LSL-ness from the types.
         * We also deep-strip any given lists used as keys (multi-dimensional arrays).
         */
        private static object FixKey (object key)
        {
            if (key is LSL_Integer) return (int)(LSL_Integer)key;
            if (key is LSL_Float)   return (SCRIPTFLOAT)(LSL_Float)key;
            if (key is LSL_Key)     return (string)(LSL_Key)key;
            if (key is LSL_String)  return (string)(LSL_String)key;
            if (key is LSL_List)    return new XMRArrayListKey ((LSL_List)key);
            return key;  // int, SCRIPTFLOAT, string, LSL_Vector, LSL_Rotation, etc are ok as is
        }

        /**
         * @brief When returning a key, such as for array.index(), we want to return the original
         *        LSL_List, not the sanitized one, as the script compiler expects an LSL_List.
         *        Any other sanitized types can remain as is (int, string, etc).
         */
        private static object UnfixKey (object key)
        {
            if (key is XMRArrayListKey) key = ((XMRArrayListKey)key).GetOriginal ();
            return key;
        }

        /**
         * @brief Lists used as keys must be sanitized first.
         *        List gets converted to an object[] and each element is converted from LSL_ types to system types where possible.
         *        And we also need an equality operator that compares the values of all elements of the list, not just the lengths.
         *        Note that just like LSL_Lists, we consider these objects to be immutable, so they can be directly used as keys in
         *        the dictionary as they don't ever change.
         */
        private class XMRArrayListKey {
            private LSL_List original;
            private object[] cleaned;
            private int length;
            private int hashCode;

            /**
             * @brief Construct a sanitized object[] from a list.
             *        Also save the original list in case we need it later.
             */
            public XMRArrayListKey (LSL_List key)
            {
                original = key;
                object[] given = key.Data;
                int len  = given.Length;
                length   = len;
                cleaned  = new object[len];
                int hc   = len;
                for (int i = 0; i < len; i ++) {
                    object v   = FixKey (given[i]);
                    hc        += hc + ((hc < 0) ? 1 : 0);
                    hc        ^= v.GetHashCode ();
                    cleaned[i] = v;
                }
                hashCode = hc;
            }

            /**
             * @brief See if the given object is an XMRArrayListKey and every value is equal to our own.
             */
            public override bool Equals (object o)
            {
                if (!(o is XMRArrayListKey)) return false;
                XMRArrayListKey a = (XMRArrayListKey)o;
                int len = a.length;
                if (len != length) return false;
                if (a.hashCode != hashCode) return false;
                for (int i = 0; i < len; i ++) {
                    if (!cleaned[i].Equals (a.cleaned[i])) return false;
                }
                return true;
            }

            /**
             * @brief Get an hash code.
             */
            public override int GetHashCode ()
            {
                return hashCode;
            }

            /**
             * @brief Get the original LSL_List we were built from.
             */
            public LSL_List GetOriginal ()
            {
                return original;
            }
        }
    }
}
