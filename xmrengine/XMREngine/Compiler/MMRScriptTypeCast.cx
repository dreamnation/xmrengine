/***************************************************\
 *  COPYRIGHT 2010, Mike Rieker, Beverly, MA, USA  *
 *  All rights reserved.                           *
\***************************************************/

#include "lsltypes.h"

using OpenSim.Region.ScriptEngine.Shared.ScriptBase;
using OpenSim.Region.ScriptEngine.XMREngine;
using System;
using System.Collections.Generic;
using System.Reflection;
using System.Reflection.Emit;


/**
 * @brief Generate script object code to perform type casting
 */

namespace OpenSim.Region.ScriptEngine.XMREngine
{

	public class TypeCast {
		private delegate void CastDelegate (ScriptMyILGen ilGen);

		private static ConstructorInfo floatConstructorStringInfo   = typeof (LSL_Float).GetConstructor (new Type[] { typeof (string) });
		private static ConstructorInfo integerConstructorStringInfo = typeof (LSL_Integer).GetConstructor (new Type[] { typeof (string) });
		private static ConstructorInfo lslFloatConstructorInfo      = typeof (LSL_Float).GetConstructor (new Type[] { typeof (SCRIPTFLOAT) });
		private static ConstructorInfo lslIntegerConstructorInfo    = typeof (LSL_Integer).GetConstructor (new Type[] { typeof (int) });
		private static ConstructorInfo lslStringConstructorInfo     = typeof (LSL_String).GetConstructor (new Type[] { typeof (string) });
		private static ConstructorInfo rotationConstrucorStringInfo = typeof (LSL_Rotation).GetConstructor (new Type[] { typeof (string) });
		private static ConstructorInfo vectorConstrucorStringInfo   = typeof (LSL_Vector).GetConstructor (new Type[] { typeof (string) });
		private static FieldInfo  lslFloatValueFieldInfo     = typeof (LSL_Float).GetField ("value");
		private static FieldInfo  lslIntegerValueFieldInfo   = typeof (LSL_Integer).GetField ("value");
		private static FieldInfo  lslStringValueFieldInfo    = typeof (LSL_String).GetField ("m_string");
		private static FieldInfo  sdtcITableFieldInfo        = typeof (XMRSDTypeClassInstance).GetField ("sdtcITable");
		private static MethodInfo floatToStringMethodInfo    = typeof (TypeCast).GetMethod ("FloatToString",      new Type[] { typeof (SCRIPTFLOAT) });
		private static MethodInfo intToStringMethodInfo      = typeof (TypeCast).GetMethod ("IntegerToString",    new Type[] { typeof (int) });
		private static MethodInfo listToStringMethodInfo     = typeof (TypeCast).GetMethod ("ListToString",       new Type[] { typeof (LSL_List) });
		private static MethodInfo objectToStringMethodInfo   = typeof (TypeCast).GetMethod ("ObjectToString",     new Type[] { typeof (object) });
		private static MethodInfo rotationToBoolMethodInfo   = typeof (TypeCast).GetMethod ("RotationToBool",     new Type[] { typeof (LSL_Rotation) });
		private static MethodInfo rotationToStringMethodInfo = typeof (TypeCast).GetMethod ("RotationToString",   new Type[] { typeof (LSL_Rotation) });
		private static MethodInfo vectorToBoolMethodInfo     = typeof (TypeCast).GetMethod ("VectorToBool",       new Type[] { typeof (LSL_Vector) });
		private static MethodInfo vectorToStringMethodInfo   = typeof (TypeCast).GetMethod ("VectorToString",     new Type[] { typeof (LSL_Vector) });
		private static MethodInfo listOfOneObjMethodInfo     = typeof (TypeCast).GetMethod ("ListOfOneObj",       new Type[] { typeof (object) });
		private static MethodInfo sdTypeClassCastClass2ClassMethodInfo = typeof (XMRSDTypeClassInstance).GetMethod ("CastClass2Class", new Type[] { typeof (object),     typeof (string) });
		private static MethodInfo sdTypeClassCastIFace2ClassMethodInfo = typeof (XMRSDTypeClassInstance).GetMethod ("CastIFace2Class", new Type[] { typeof (Delegate[]), typeof (string) });
		private static MethodInfo sdTypeClassCastObj2IFaceMethodInfo   = typeof (XMRSDTypeClassInstance).GetMethod ("CastObj2IFace",   new Type[] { typeof (object),     typeof (string) });

		/*
		 * List of all allowed type casts and how to perform the casting.
		 */
		private static Dictionary<string, CastDelegate> legalTypeCasts = null;

		/**
		 * @brief create a dictionary of legal type casts.
		 * Defines what EXPLICIT type casts are allowed in addition to the IMPLICIT ones.
		 * Key is of the form <oldtype> <newtype> for IMPLICIT casting.
		 * Key is of the form <oldtype>*<newtype> for EXPLICIT casting.
		 * Value is a delegate that generates code to perform the type cast.
		 */
		public static void CreateLegalTypeCasts ()
		{
			if (legalTypeCasts == null) {
				Dictionary<string, CastDelegate> ltc = new Dictionary<string, CastDelegate> ();

				// IMPLICIT type casts (a space is in middle of the key)
				// EXPLICIT type casts (an * is in middle of the key)
				ltc.Add ("array object",    TypeCastArray2Object);
				ltc.Add ("bool float",      TypeCastBool2Float);
				ltc.Add ("bool integer",    TypeCastBool2Integer);
				ltc.Add ("bool object",     TypeCastBool2Object);
				ltc.Add ("bool string",     TypeCastBool2String);
				ltc.Add ("float bool",      TypeCastFloat2Bool);
				ltc.Add ("float integer",   TypeCastFloat2Integer);
				ltc.Add ("float*list",      TypeCastFloat2List);
				ltc.Add ("float object",    TypeCastFloat2Object);
				ltc.Add ("float string",    TypeCastFloat2String);
				ltc.Add ("integer bool",    TypeCastInteger2Bool);
				ltc.Add ("integer float",   TypeCastInteger2Float);
				ltc.Add ("integer*list",    TypeCastInteger2List);
				ltc.Add ("integer object",  TypeCastInteger2Object);
				ltc.Add ("integer string",  TypeCastInteger2String);
				ltc.Add ("list object",     TypeCastList2Object);
				ltc.Add ("list*string",     TypeCastList2String);
				ltc.Add ("object array",    TypeCastObject2Array);
				ltc.Add ("object bool",     TypeCastObject2Bool);
				ltc.Add ("object float",    TypeCastObject2Float);
				ltc.Add ("object integer",  TypeCastObject2Integer);
				ltc.Add ("object list",     TypeCastObject2List);
				ltc.Add ("object rotation", TypeCastObject2Rotation);
				ltc.Add ("object string",   TypeCastObject2String);
				ltc.Add ("object vector",   TypeCastObject2Vector);
				ltc.Add ("rotation bool",   TypeCastRotation2Bool);
				ltc.Add ("rotation list",   TypeCastRotation2List);
				ltc.Add ("rotation object", TypeCastRotation2Object);
				ltc.Add ("rotation string", TypeCastRotation2String);
				ltc.Add ("string bool",     TypeCastString2Bool);
				ltc.Add ("string float",    TypeCastString2Float);
				ltc.Add ("string integer",  TypeCastString2Integer);
				ltc.Add ("string list",     TypeCastString2List);
				ltc.Add ("string object",   TypeCastString2Object);
				ltc.Add ("string rotation", TypeCastString2Rotation);
				ltc.Add ("string vector",   TypeCastString2Vector);
				ltc.Add ("vector bool",     TypeCastVector2Bool);
				ltc.Add ("vector list",     TypeCastVector2List);
				ltc.Add ("vector object",   TypeCastVector2Object);
				ltc.Add ("vector string",   TypeCastVector2String);

				//MB()
				legalTypeCasts = ltc;
			}
			//MB()
		}

		/**
		 * @brief Emit code that converts the top stack item from 'oldType' to 'newType'
		 * @param scg = what script we are compiling
		 * @param oldType = type of item currently on the stack
		 * @param newType = type to convert it to
		 * @param explicitAllowed = false: only consider implicit casts
		 *                           true: consider both implicit and explicit casts
		 * @returns with code emitted for conversion (or error message output if not allowed, and stack left unchanged)
		 */
		public static void CastTopOfStack (ScriptCodeGen scg, TokenType oldType, TokenType newType, bool explicitAllowed)
		{
			CastDelegate castDelegate;

			/*
			 * Script-defined classes can be cast up and down the tree.
			 */
			if ((oldType is TokenTypeSDTypeClass) && (newType is TokenTypeSDTypeClass)) {
				TokenDeclSDTypeClass oldSDTC = ((TokenTypeSDTypeClass)oldType).decl;
				TokenDeclSDTypeClass newSDTC = ((TokenTypeSDTypeClass)newType).decl;

				// implicit cast allowed from leaf toward root
				for (TokenDeclSDTypeClass sdtc = oldSDTC; sdtc != null; sdtc = sdtc.extends) {
					if (sdtc == newSDTC) return;
				}

				// explicit cast allowed from root toward leaf
				for (TokenDeclSDTypeClass sdtc = newSDTC; sdtc != null; sdtc = sdtc.extends) {
					if (sdtc == oldSDTC) {
						if (!explicitAllowed) {
							scg.ErrorMsg (newType, "must explicitly cast from " + oldType.ToString () + 
							                                             " to " + newType.ToString ());
						}
						scg.ilGen.Emit (OpCodes.Ldstr, newType.ToString ());
						scg.ilGen.Emit (OpCodes.Call, sdTypeClassCastClass2ClassMethodInfo);
						return;
					}
				}

				// not on same branch
				scg.ErrorMsg (newType, "illegal to cast from " + oldType.ToString () + 
				                                        " to " + newType.ToString ());
				return;
			}

			/*
			 * One script-defined interface type cannot be cast to another script-defined interface type.
			 */
			if ((oldType is TokenTypeSDTypeInterface) && (newType is TokenTypeSDTypeInterface)) {
				scg.ErrorMsg (newType, "illegal to cast from " + oldType.ToString () + 
				                                        " to " + newType.ToString ());
				return;
			}

			/*
			 * A script-defined class type can be implicitly cast to a script-defined interface type that it 
			 * implements.  The result is an array of delegates that give the class's implementation of the 
			 * various methods defined by the interface.
			 */
			if ((oldType is TokenTypeSDTypeClass) && (newType is TokenTypeSDTypeInterface)) {
				TokenDeclSDTypeClass oldSDTC = ((TokenTypeSDTypeClass)oldType).decl;
				int intfIndex;
				if (!oldSDTC.intfIndices.TryGetValue (newType.ToString (), out intfIndex)) {
					scg.ErrorMsg (newType, oldType.ToString () + " does not implement " + newType.ToString ());
					intfIndex = -1;
				}
				scg.ilGen.Emit (OpCodes.Ldfld, sdtcITableFieldInfo);
				scg.PushConstantI4 (intfIndex);
				scg.ilGen.Emit (OpCodes.Ldelem, typeof (Delegate[]));
				return;
			}

			/*
			 * A script-defined interface type can be explicitly cast to a script-defined class type by 
			 * extracting the Target property from element 0 of the delegate array that is the interface
			 * object and making sure it casts to the correct script-defined class type.
			 */
			if ((oldType is TokenTypeSDTypeInterface) && (newType is TokenTypeSDTypeClass)) {
				if (!explicitAllowed) {
					scg.ErrorMsg (newType, "must explicitly cast from " + oldType.ToString () + 
					                                             " to " + newType.ToString ());
				}
				scg.ilGen.Emit (OpCodes.Ldstr, newType.ToString ());
				scg.ilGen.Emit (OpCodes.Call, sdTypeClassCastIFace2ClassMethodInfo);
				return;
			}

			/*
			 * A script-defined interface type can be implicitly cast to object.
			 */
			if ((oldType is TokenTypeSDTypeInterface) && (newType is TokenTypeObject)) {
				return;
			}

			/*
			 * An object can be explicitly cast to a script-defined interface.
			 */
			if ((oldType is TokenTypeObject) && (newType is TokenTypeSDTypeInterface)) {
				if (!explicitAllowed) {
					scg.ErrorMsg (newType, "must explicitly cast from " + oldType.ToString () + 
					                                             " to " + newType.ToString ());
				}
				scg.ilGen.Emit (OpCodes.Ldstr, newType.ToString ());
				scg.ilGen.Emit (OpCodes.Call, sdTypeClassCastObj2IFaceMethodInfo);
				return;
			}

			/*
			 * If the basic types are the same, there is no conceptual casting needed.
			 * However, there may be wraping/unwraping to/from the LSL wrappers.
			 */
			if (oldType.ToSysType () == newType.ToSysType ()) {
				if (oldType.ToLSLWrapType () != newType.ToLSLWrapType ()) {
					LSLUnwrap (scg.ilGen, oldType);
					LSLWrap (scg.ilGen, newType);
				}
				return;
			}

			/*
			 * Cast to void is always allowed, such as discarding value from 'i++' or function return value.
			 */
			if (newType is TokenTypeVoid) {
				scg.ilGen.Emit (OpCodes.Pop);
				return;
			}

			/*
			 * Script-defined classes can be implicitly cast to objects.
			 */
			if ((oldType is TokenTypeSDTypeClass) && (newType is TokenTypeObject)) {
				return;
			}

			/*
			 * Script-defined classes can be explicitly cast from objects and other script-defined classes.
			 * Note that we must manually check that it is the correct SDTypeClass however because as far as 
			 * mono is concerned, all SDTypeClass's are the same.
			 */
			if ((oldType is TokenTypeObject) && (newType is TokenTypeSDTypeClass)) {
				if (!explicitAllowed) {
					scg.ErrorMsg (newType, "must explicitly cast from object to " + newType.ToString ());
				}
				scg.ilGen.Emit (OpCodes.Ldstr, newType.ToString ());
				scg.ilGen.Emit (OpCodes.Call, sdTypeClassCastClass2ClassMethodInfo);
				return;
			}

			/*
			 * Delegates can be implicitly cast to/from objects.
			 */
			if ((oldType is TokenTypeSDTypeDelegate) && (newType is TokenTypeObject)) {
				return;
			}
			if ((oldType is TokenTypeObject) && (newType is TokenTypeSDTypeDelegate)) {
				scg.ilGen.Emit (OpCodes.Castclass, newType.ToSysType ());
				return;
			}

			/*
			 * Some actual conversion is needed, see if it is in table of legal casts.
			 */
			string oldString = oldType.ToString ();
			string newString = newType.ToString ();
			string key = oldString + " " + newString;

			if (!legalTypeCasts.TryGetValue (key, out castDelegate)) {
				key = oldString + "*" + newString;
				if (!explicitAllowed || !legalTypeCasts.TryGetValue (key, out castDelegate)) {
					scg.ErrorMsg (newType, "illegal to cast from " + oldString + " to " + newString);
					return;
				}
			}

			/*
			 * Ok, output cast.  But make sure it is in native form without any LSL wrapping.
			 */
			LSLUnwrap (scg.ilGen, oldType);
			castDelegate (scg.ilGen);
			LSLWrap (scg.ilGen, newType);
		}

		/**
		 * @brief If value on the stack is an LSL-style wrapped value, unwrap it.
		 */
		public static void LSLUnwrap (ScriptMyILGen ilGen, TokenType type)
		{
			if (type.ToLSLWrapType () == typeof (LSL_Float)) {
				ilGen.Emit (OpCodes.Ldfld, lslFloatValueFieldInfo);
			}
			if (type.ToLSLWrapType () == typeof (LSL_Integer)) {
				ilGen.Emit (OpCodes.Ldfld, lslIntegerValueFieldInfo);
			}
			if (type.ToLSLWrapType () == typeof (LSL_String)) {
				ilGen.Emit (OpCodes.Ldfld, lslStringValueFieldInfo);
			}
		}

		/**
		 * @brief If caller wants the unwrapped value on stack wrapped LSL-style, wrap it.
		 */
		private static void LSLWrap (ScriptMyILGen ilGen, TokenType type)
		{
			if (type.ToLSLWrapType () == typeof (LSL_Float)) {
				ilGen.Emit (OpCodes.Newobj, lslFloatConstructorInfo);
			}
			if (type.ToLSLWrapType () == typeof (LSL_Integer)) {
				ilGen.Emit (OpCodes.Newobj, lslIntegerConstructorInfo);
			}
			if (type.ToLSLWrapType () == typeof (LSL_String)) {
				ilGen.Emit (OpCodes.Newobj, lslStringConstructorInfo);
			}
		}

		private static void TypeCastArray2Object (ScriptMyILGen ilGen)
		{
		}
		private static void TypeCastBool2Float (ScriptMyILGen ilGen)
		{
			if (typeof (SCRIPTFLOAT) == typeof (float)) {
				ilGen.Emit (OpCodes.Conv_R4);
			} else if (typeof (SCRIPTFLOAT) == typeof (double)) {
				ilGen.Emit (OpCodes.Conv_R8);
			} else {
				throw new Exception ("unknown type");
			}
		}
		private static void TypeCastBool2Integer (ScriptMyILGen ilGen)
		{
		}
		private static void TypeCastBool2Object (ScriptMyILGen ilGen)
		{
			ilGen.Emit (OpCodes.Box, typeof (bool));
		}
		private static void TypeCastFloat2Bool (ScriptMyILGen ilGen)
		{
			ilGen.Emit (OpCodes.Ldc_R4, 0.0f);
			ilGen.Emit (OpCodes.Ceq);
			ilGen.Emit (OpCodes.Ldc_I4_1);
			ilGen.Emit (OpCodes.Xor);
		}
		private static void TypeCastFloat2Integer (ScriptMyILGen ilGen)
		{
			ilGen.Emit (OpCodes.Conv_I4);
		}
		private static void TypeCastFloat2Object (ScriptMyILGen ilGen)
		{
			ilGen.Emit (OpCodes.Box, typeof (SCRIPTFLOAT));
		}
		private static void TypeCastInteger2Bool (ScriptMyILGen ilGen)
		{
			ilGen.Emit (OpCodes.Ldc_I4_0);
			ilGen.Emit (OpCodes.Ceq);
			ilGen.Emit (OpCodes.Ldc_I4_1);
			ilGen.Emit (OpCodes.Xor);
		}
		private static void TypeCastInteger2Float (ScriptMyILGen ilGen)
		{
			if (typeof (SCRIPTFLOAT) == typeof (float)) {
				ilGen.Emit (OpCodes.Conv_R4);
			} else if (typeof (SCRIPTFLOAT) == typeof (double)) {
				ilGen.Emit (OpCodes.Conv_R8);
			} else {
				throw new Exception ("unknown type");
			}
		}
		private static void TypeCastInteger2Object (ScriptMyILGen ilGen)
		{
			ilGen.Emit (OpCodes.Box, typeof (int));
		}
		private static void TypeCastList2Object (ScriptMyILGen ilGen)
		{
		}
		private static void TypeCastObject2Array (ScriptMyILGen ilGen)
		{
			ilGen.Emit (OpCodes.Castclass, typeof (XMR_Array));
		}
		private static void TypeCastObject2Bool (ScriptMyILGen ilGen)
		{
			ilGen.Emit (OpCodes.Unbox_Any, typeof (bool));
		}
		private static void TypeCastObject2Float (ScriptMyILGen ilGen)
		{
			ilGen.Emit (OpCodes.Unbox_Any, typeof (SCRIPTFLOAT));
		}
		private static void TypeCastObject2Integer (ScriptMyILGen ilGen)
		{
			ilGen.Emit (OpCodes.Unbox_Any, typeof (int));
		}
		private static void TypeCastObject2List (ScriptMyILGen ilGen)
		{
			ilGen.Emit (OpCodes.Castclass, typeof (LSL_List));
		}
		private static void TypeCastObject2Rotation (ScriptMyILGen ilGen)
		{
			ilGen.Emit (OpCodes.Unbox_Any, typeof (LSL_Rotation));
		}
		private static void TypeCastObject2Vector (ScriptMyILGen ilGen)
		{
			ilGen.Emit (OpCodes.Unbox_Any, typeof (LSL_Vector));
		}
		private static void TypeCastRotation2Bool (ScriptMyILGen ilGen)
		{
			ilGen.Emit (OpCodes.Call, rotationToBoolMethodInfo);
		}
		private static void TypeCastRotation2Object (ScriptMyILGen ilGen)
		{
			ilGen.Emit (OpCodes.Box, typeof (LSL_Rotation));
		}
		private static void TypeCastString2Bool (ScriptMyILGen ilGen)
		{
			ilGen.Emit (OpCodes.Ldstr, "");
			ilGen.Emit (OpCodes.Ceq);
			ilGen.Emit (OpCodes.Ldc_I4_1);
			ilGen.Emit (OpCodes.Xor);
		}
		private static void TypeCastString2Object (ScriptMyILGen ilGen)
		{
		}
		private static void TypeCastString2Rotation (ScriptMyILGen ilGen)
		{
			ilGen.Emit (OpCodes.Newobj, rotationConstrucorStringInfo);
		}
		private static void TypeCastString2Vector (ScriptMyILGen ilGen)
		{
			ilGen.Emit (OpCodes.Newobj, vectorConstrucorStringInfo);
		}
		private static void TypeCastVector2Bool (ScriptMyILGen ilGen)
		{
			ilGen.Emit (OpCodes.Call, vectorToBoolMethodInfo);
		}
		private static void TypeCastVector2List (ScriptMyILGen ilGen)
		{
			ilGen.Emit (OpCodes.Box, typeof (LSL_Vector));
			ilGen.Emit (OpCodes.Call, listOfOneObjMethodInfo);
		}
		private static void TypeCastVector2Object (ScriptMyILGen ilGen)
		{
			ilGen.Emit (OpCodes.Box, typeof (LSL_Vector));
		}
		private static void TypeCastBool2String (ScriptMyILGen ilGen)
		{
			ilGen.Emit (OpCodes.Newobj, rotationConstrucorStringInfo);
		}
		private static void TypeCastFloat2List (ScriptMyILGen ilGen)
		{
			ilGen.Emit (OpCodes.Box, typeof (SCRIPTFLOAT));
			ilGen.Emit (OpCodes.Call, listOfOneObjMethodInfo);
		}
		private static void TypeCastFloat2String (ScriptMyILGen ilGen)
		{
			ilGen.Emit (OpCodes.Call, floatToStringMethodInfo);
		}
		private static void TypeCastInteger2List (ScriptMyILGen ilGen)
		{
			ilGen.Emit (OpCodes.Box, typeof (int));
			ilGen.Emit (OpCodes.Call, listOfOneObjMethodInfo);
		}
		private static void TypeCastInteger2String (ScriptMyILGen ilGen)
		{
			ilGen.Emit (OpCodes.Call, intToStringMethodInfo);
		}
		private static void TypeCastList2String (ScriptMyILGen ilGen)
		{
			ilGen.Emit (OpCodes.Call, listToStringMethodInfo);
		}
		private static void TypeCastObject2String (ScriptMyILGen ilGen)
		{
			ilGen.Emit (OpCodes.Call, objectToStringMethodInfo);
		}
		private static void TypeCastRotation2List (ScriptMyILGen ilGen)
		{
			ilGen.Emit (OpCodes.Box, typeof (LSL_Rotation));
			ilGen.Emit (OpCodes.Call, listOfOneObjMethodInfo);
		}
		private static void TypeCastRotation2String (ScriptMyILGen ilGen)
		{
			ilGen.Emit (OpCodes.Call, rotationToStringMethodInfo);
		}
		private static void TypeCastString2Float (ScriptMyILGen ilGen)
		{
			ilGen.Emit (OpCodes.Newobj, floatConstructorStringInfo);
			ilGen.Emit (OpCodes.Ldfld, lslFloatValueFieldInfo);
		}
		private static void TypeCastString2Integer (ScriptMyILGen ilGen)
		{
			ilGen.Emit (OpCodes.Newobj, integerConstructorStringInfo);
			ilGen.Emit (OpCodes.Ldfld, lslIntegerValueFieldInfo);
		}
		private static void TypeCastString2List (ScriptMyILGen ilGen)
		{
			ilGen.Emit (OpCodes.Newobj, lslStringConstructorInfo);
			ilGen.Emit (OpCodes.Box, typeof (LSL_String));
			ilGen.Emit (OpCodes.Call, listOfOneObjMethodInfo);
		}
		private static void TypeCastVector2String (ScriptMyILGen ilGen)
		{
			ilGen.Emit (OpCodes.Call, vectorToStringMethodInfo);
		}

		/*
		 * Because the calls are funky, let the compiler handle them.
		 */
		public static bool     RotationToBool   (LSL_Rotation x) { return !x.Equals (ScriptBaseClass.ZERO_ROTATION); }
		public static bool     VectorToBool     (LSL_Vector x)   { return !x.Equals (ScriptBaseClass.ZERO_VECTOR); }
		public static string   FloatToString    (SCRIPTFLOAT x)  { return x.ToString ("0.000000"); }
		public static string   IntegerToString  (int x)          { return x.ToString (); }
		public static string   ListToString     (LSL_List x)     { return x.ToString (); }
		public static string   ObjectToString   (object x)       { return (x == null) ? null : x.ToString (); }
		public static string   RotationToString (LSL_Rotation x) { return x.ToString (); }
		public static string   VectorToString   (LSL_Vector x)   { return x.ToString (); }
		public static LSL_List ListOfOneObj     (object x)       { return new LSL_List (new object[1] { x }); }

		public static SCRIPTFLOAT EHArgUnwrapFloat (object x)
		{
			if (x is LSL_Float) return (SCRIPTFLOAT)(LSL_Float)x;
			return (SCRIPTFLOAT)x;
		}

		public static int EHArgUnwrapInteger (object x)
		{
			if (x is LSL_Integer) return (int)(LSL_Integer)x;
			return (int)x;
		}
 
		public static LSL_Rotation EHArgUnwrapRotation (object x)
		{
			if (x is OpenMetaverse.Quaternion) {
				OpenMetaverse.Quaternion q = (OpenMetaverse.Quaternion)x;
				return new LSL_Rotation(q.X, q.Y, q.Z, q.W);
			}
			return (LSL_Rotation)x;
		}

		public static string EHArgUnwrapString (object x)
		{
			if (x is LSL_Key)    return (string)(LSL_Key)x;
			if (x is LSL_String) return (string)(LSL_String)x;
			return (string)x;
		}
 
		public static LSL_Vector EHArgUnwrapVector (object x)
		{
			if (x is OpenMetaverse.Vector3) {
				OpenMetaverse.Vector3 v = (OpenMetaverse.Vector3)x;
				return new LSL_Vector(v.X, v.Y, v.Z);
			}
			return (LSL_Vector)x;
		}
	}
}
