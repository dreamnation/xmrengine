/********************************************************\
 *  COPYRIGHT 2009,2010, Mike Rieker, Beverly, MA, USA  *
 *  All rights reserved.                                *
\********************************************************/

/**
 * @brief Main program for the stand-alone script compiler.
 */

using System;
using System.Collections.Generic;
using System.IO;
using System.IO.Compression;
using System.Reflection;
using System.Security.Cryptography;
using System.Text;

namespace OpenSim.Region.ScriptEngine.XMREngine
{
    public class StandAloneCompiler
    {
        /**
         * @brief Stand-alone compiler main program.
         *
         * mono xmrengcomp.exe -out objfilename -asm asmfilename sourcefiles...
         */
        public static void Main (string[] args)
        {
            MMRWebRequest.allowFileURL = true;
 
#ifdef SECRET_STUFF
            bool decode = false;
            string asmFileName = null;
            string srcFileName = null;
#endif
            bool plaintext = false;
            string objFileName = null;
            string sourceHash = null;
            List<string> sourceFileNames = new List<string> ();

            ScriptCodeGen.xmrInstSuperType = typeof (XMRInstAbstract);

            if (!encryption) {
                Console.WriteLine("ENCRYPTION IS DISABLED");
            }
            if (!compression) {
                Console.WriteLine("COMPRESSION IS DISABLED");
            }

            /*
             * Decode command-line arguments.
             */
            for (int i = 0; i < args.Length; i ++) {
                string arg = args[i];
                if (arg[0] == '?') goto usage;
                if (arg[0] != '-') {
                    sourceFileNames.Add (arg);
                    continue;
                }
#ifdef SECRET_STUFF
                if (arg == "-asm") {
                    asmFileName = args[++i];
                    continue;
                }
                if (arg == "-decode") {
                    decode = true;
                    continue;
                }
                if (arg == "-genkey") {
                    GenKey ();
                    return;
                }
                if (arg == "-plaintext") {
                    plaintext = true;
                    continue;
                }
                if (arg == "-src") {
                    srcFileName = args[++i];
                    continue;
                }
#endif
                if (arg == "-builtins") {
                    TokenDeclInline.PrintBuiltins (false, Console.WriteLine);
                    return;
                }
                if (arg == "-out") {
                    objFileName = args[++i];
                    continue;
                }
                if (arg == "-version") {
                    goto version;
                }
                Console.WriteLine ("unknown option " + arg);
                goto usage;
            }

#ifdef SECRET_STUFF
            if (decode) {
                if (sourceFileNames.Count != 1) {
                    Console.WriteLine ("need exactly one input file for -decode");
                    goto usage;
                }

                DecodeFile (sourceFileNames[0], asmFileName, objFileName, plaintext);
                return;
            }
#endif

            /*
             * Normal compilation function, make sure an output
             * file was specified (where we will write the encrypted
             * object file).
             */
            if (objFileName == null) {
                Console.WriteLine ("missing -out option");
                goto usage;
            }

            /*
             * Read whole source into memory.
             */
            string cameFrom = null;
            StringBuilder sourceBuilder = new StringBuilder ();
            if (sourceFileNames.Count == 0) {
                sourceBuilder.Append (Console.In.ReadToEnd ());
                cameFrom = "console://";
            } else {
                foreach (string sourceFileName in sourceFileNames) {
                    if (cameFrom == null) cameFrom = "file://" + sourceFileName;
                    sourceBuilder.Append ("# 1 \"" + sourceFileName + "\"\n");
                    sourceBuilder.Append (File.ReadAllText (sourceFileName));
                }
            }
            string source = sourceBuilder.ToString ();

            /*
             * Parse source string into tokens.
             */
            TokenBegin tokenBegin = TokenBegin.Construct(cameFrom, null, StandAloneErrorMessage, source, out sourceHash);
            if (tokenBegin == null) {
                Console.WriteLine ("Parsing errors.");
                Environment.Exit (1);
            }

            /*
             * Create abstract syntax tree from raw tokens.
             */
            TokenScript tokenScript = ScriptReduce.Reduce(tokenBegin);
            if (tokenScript == null) {
                Console.WriteLine ("Reduction errors.");
                Environment.Exit (1);
            }

            /*
             * If -src option, write reconstructed source code out.
             */
#ifdef SECRET_STUFF
            if (srcFileName != null) {
                StringBuilder sb = new StringBuilder ();
                tokenScript.DebString (sb);
                File.WriteAllText (srcFileName, new FormatSource (sb.ToString ()).ToString ());
            }
#endif

            /*
             * Attempt to compile AST to object code.
             */
            Stream objFileStream = new FileStream (objFileName, FileMode.Create);
            if (!plaintext) objFileStream = Encrypt (objFileStream);
            BinaryWriter objFileWriter = new BinaryWriter (objFileStream);
            bool ok;
            try {
                ok = ScriptCodeGen.CodeGen(tokenScript, objFileWriter, sourceHash);
            } finally {
                objFileWriter.Close ();
            }
            if (!ok) {
                File.Delete (objFileName);
                Console.WriteLine ("Compilation errors.");
                Environment.Exit (1);
            }

            /*
             * If they want the assembly file, disassemble object file to get it.
             */
#ifdef SECRET_STUFF
            if (asmFileName != null) {
                objFileStream = new FileStream (objFileName, FileMode.Open);
                if (!plaintext) objFileStream = Decrypt (objFileStream);
                BinaryReader objFileReader = new BinaryReader (objFileStream);
                TextWriter asmFileWriter = (asmFileName != "-") ? File.CreateText (asmFileName) : Console.Out;
                try {
                    new ScriptObjCode (objFileReader, asmFileWriter);
                } finally {
                    objFileReader.Close ();
                    asmFileWriter.Flush ();
                    asmFileWriter.Close ();
                }
            }
#endif
            return;

usage:
            Console.WriteLine ("");
            Console.WriteLine ("xmrengcomp.exe -out <outputxmrobjfile> [-asm <outputxmrasmfile>] [<inputsourcefile> ...]");
            Console.WriteLine ("               omit inputsourcefiles to read from stdin");
            Console.WriteLine ("xmrengcomp.exe -builtins");
            Console.WriteLine ("xmrengcomp.exe -version");
#ifdef SECRET_STUFF
            Console.WriteLine ("xmrengcomp.exe -genkey");
            Console.WriteLine ("xmrengcomp.exe -decode [-asm <outputxmrasmfile>] [-plaintext] <inputbinaryfile>");
#endif
version:
            Console.WriteLine ("");
            Console.WriteLine ("XMREngine standalone compiler, version 1." + ScriptCodeGen.COMPILED_VERSION_VALUE);
            Console.WriteLine ("    commit " + ScriptCompCommit.commitInfo);
            Console.WriteLine ("    fetchbinary fingerprint " + Fingerprint);
            Console.WriteLine ("");
        }

        public static void StandAloneErrorMessage (Token token, string message)
        {
            Console.WriteLine ("{0} {1}", token.SrcLoc, message);
        }

#ifdef SECRET_STUFF
        /**
         * @brief Called for the -decode option to figure out what an object file
         *        contains (either encrypted abstract syntax tree or CIL object)
         *        and disassemble it.
         * @param decodeFileName = name of the one-and-only input file
         * @param asmFileName = null: don't bother disassembling
         *                      else: name of assembly output file
         * @param objFileName = null: don't bother writing decrypted CIL object file
         *                      else: name of decrypted CIL object file to write
         */
        private static void DecodeFile (string decodeFileName, string asmFileName, string objFileName, bool plaintext)
        {
            /*
             * Open file to decode.
             */
            Stream decodeFileStream = File.OpenRead (decodeFileName);
            if (!plaintext) decodeFileStream = Decrypt (decodeFileStream);

            /*
             * decodeFileStream = CIL object file.
             * If given an asmFileName, disassemble it.
             */
            TextWriter asmFileWriter = null;
            if (asmFileName != null) {
                Console.WriteLine("Creating disassembly file " + asmFileName);
                asmFileWriter = (asmFileName != "-") ? File.CreateText (asmFileName) : Console.Out;
            }

            /*
             * Read object file to check it for errors.
             * Maybe also write disassembly to a file for debugging.
             */
            BinaryReader objFileReader = new BinaryReader (decodeFileStream);
            try {
                new ScriptObjCode (objFileReader, asmFileWriter);
            } finally {
                objFileReader.Close ();
                if (asmFileWriter != null) {
                    asmFileWriter.Flush ();
                    asmFileWriter.Close ();
                }
            }
            Console.WriteLine("All done.");
        }

        /**
         * @brief This is run only once by Meta7 to generate our public and private
         *        key pair.  A new key can be generated if the compile version changes.
         */
        private static void GenKey ()
        {
            RSACryptoServiceProvider rsa = new RSACryptoServiceProvider (rsaBits);
            RSAParameters rsap = rsa.ExportParameters (true);

            byte[][] publicKey  = new byte[][] {
                rsap.Exponent,
                rsap.Modulus
            };

            File.WriteAllText ("MMRScriptXmrBinPublicKey.h", "        private static byte[][] publicKey = " + ByteByteArrayToString (publicKey));

            byte[][] privateKey = new byte[][] {
                rsap.D,
                rsap.DP,
                rsap.DQ,
                rsap.Exponent,
                rsap.InverseQ,
                rsap.Modulus,
                rsap.P,
                rsap.Q
            };

            File.WriteAllText ("MMRScriptXmrBinPrivateKey.h", "        private static byte[][] privateKey = " + ByteByteArrayToString (privateKey));
        }

        public static string ByteByteArrayToString (byte[][] array)
        {
            StringBuilder sb = new StringBuilder ();
            sb.Append ("new byte[][] {");
            for (int i = 0; i < array.Length; i ++) {
                byte[] row = array[i];
                if (i > 0) sb.Append (',');
                sb.Append ("\n      new byte[] {");
                for (int j = 0; j < row.Length; j ++) {
                    if (j > 0) {
                        sb.Append (',');
                        if (j % 8 == 0) {
                            sb.Append ("\n                  ");
                        }
                    }
                    sb.Append (" 0x");
                    sb.Append (row[j].ToString ("X2"));
                }
                sb.Append (" }");
            }
            sb.Append (" };");
            return sb.ToString ();
        }
#endif

#ifdef SECRET_STUFF
        private class FormatSource
        {
            private bool escaped = false;
            private char quoted  = (char)0;
            private int  begline = 0;
            private int  indent  = 0;
            private int  parens  = 0;
            private StringBuilder sb = new StringBuilder ();

            public FormatSource (string src)
            {
                foreach (char c in src)
                {
                    if (quoted != (char)0) {
                        sb.Append (c);
                        if (c == '\\') {
                            escaped = !escaped;
                        } else {
                            if ((c == quoted) && !escaped) quoted = (char)0;
                            escaped = false;
                        }
                        continue;
                    }

                    switch (c) {
                        case ';': {
                            TrimTrailingSpaces ();
                            sb.Append (';');
                            if (parens > 0) sb.Append (' ');
                                       else NewLine ();
                            break;
                        }

                        case '{': {
                            TrimTrailingSpaces ();
                            if ((sb.Length > 0) && (sb[sb.Length-1] > ' ')) {
                                sb.Append (' ');
                            }
                            sb.Append ('{');
                            indent ++;
                            NewLine ();
                            break;
                        }

                        case '}': {
                            if (indent > 0) -- indent;
                            TrimTrailingSpaces ();
                            sb.Append ('}');
                            NewLine ();
                            break;
                        }

                        case '(': {
                            parens ++;
                            sb.Append ('(');
                            break;
                        }

                        case ')': {
                            if (parens > 0) -- parens;
                            sb.Append (')');
                            break;
                        }

                        case '\'':
                        case '"': {
                            sb.Append (c);
                            quoted = c;
                            break;
                        }

                        default: {
                            if (c <= ' ') {
                                TrimTrailingSpaces ();
                                if (sb.Length > begline + indent * 4) sb.Append (' ');
                            } else {
                                sb.Append (c);
                            }
                            break;
                        }
                    }
                }
            }

            private void TrimTrailingSpaces ()
            {
                int len = sb.Length;
                while ((len > begline + indent * 4) && (sb[len-1] <= ' ')) {
                    sb.Remove (-- len, 1);
                }
            }

            private void NewLine ()
            {
                int len = sb.Length;
                while (len > 0) {
                    char c = sb[len-1];
                    if (c == '\n') break;
                    if (c >= ' ') break;
                    sb.Remove (-- len, 1);
                }
                if ((len == 0) || (sb[len-1] != '\n')) {
                    sb.Append ('\n');
                }
                begline = sb.Length;
                sb.Append ("".PadRight (indent * 4));
            }

            public override string ToString ()
            {
                return sb.ToString ();
            }
        }
#endif

#include "MMRScriptXmrBinEncrypt.h"
#ifdef SECRET_STUFF
#include "MMRScriptXmrBinDecrypt.h"
#endif
    }
}
