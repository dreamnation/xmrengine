/********************************************************\
 *  COPYRIGHT 2009,2010, Mike Rieker, Beverly, MA, USA  *
 *  All rights reserved.                                *
\********************************************************/

/**
 * @brief Main program for the stand-alone script compiler.
 */

using System;
using System.Collections.Generic;
using System.IO;
using System.IO.Compression;
using System.Reflection;
using System.Security.Cryptography;
using System.Text;

namespace OpenSim.Region.ScriptEngine.XMREngine
{
    public class StandAloneCompiler
    {
        /**
         * @brief Stand-alone compiler main program.
         *
         * mono xmrengcomp.exe -out objfilename -asm asmfilename sourcefiles...
         */
        public static void Main (string[] args)
        {
            MMRWebRequest.allowFileURL = true;
 
#ifdef SECRET_STUFF
            bool decode = false;
            string asmFileName = null;
            string srcFileName = null;
#endif
            bool plaintext = false;
            string outFileName = null;
            string sourceHash = null;
            List<string> sourceFileNames = new List<string> ();

            ScriptCodeGen.xmrInstSuperType = typeof (XMRSuperType);
            ScriptObjWriter.DefineInternalType ("xmrsuper", typeof (XMRSuperType));

            if (!encryption) {
                Console.WriteLine("ENCRYPTION IS DISABLED");
            }
            if (!compression) {
                Console.WriteLine("COMPRESSION IS DISABLED");
            }

            /*
             * Decode command-line arguments.
             */
            for (int i = 0; i < args.Length; i ++) {
                string arg = args[i];
                if (arg[0] == '?') goto usage;
                if (arg[0] != '-') {
                    sourceFileNames.Add (arg);
                    continue;
                }
#ifdef SECRET_STUFF
                if (arg == "-asm") {
                    asmFileName = args[++i];
                    continue;
                }
                if (arg == "-decode") {
                    decode = true;
                    continue;
                }
                if (arg == "-genkey") {
                    GenKey ();
                    return;
                }
                if (arg == "-plaintext") {
                    plaintext = true;
                    continue;
                }
                if (arg == "-src") {
                    srcFileName = args[++i];
                    continue;
                }
#endif
                if (arg == "-builtins") {
                    TokenDeclInline.PrintBuiltins (false, Console.WriteLine);
                    return;
                }
                if (arg == "-out") {
                    outFileName = args[++i];
                    continue;
                }
                if (arg == "-version") {
                    goto version;
                }
                Console.WriteLine ("unknown option " + arg);
                goto usage;
            }

#ifdef SECRET_STUFF
            if (decode) {
                if (sourceFileNames.Count != 1) {
                    Console.WriteLine ("need exactly one input file for -decode");
                    goto usage;
                }

                DecodeFile (sourceFileNames[0], asmFileName, srcFileName, plaintext);
                return;
            }
#endif

            /*
             * Normal compilation function, make sure an output
             * file was specified (where we will write the encrypted
             * object file).
             */
            if (outFileName == null) {
                Console.WriteLine ("missing -out option");
                goto usage;
            }

            /*
             * Read whole source into memory.
             */
            string cameFrom = null;
            StringBuilder sourceBuilder = new StringBuilder ();
            if (sourceFileNames.Count == 0) {
                sourceBuilder.Append (Console.In.ReadToEnd ());
                cameFrom = "console://";
            } else {
                foreach (string sourceFileName in sourceFileNames) {
                    if (cameFrom == null) cameFrom = "file://" + sourceFileName;
                    sourceBuilder.Append ("# 1 \"" + sourceFileName + "\"\n");
                    sourceBuilder.Append (File.ReadAllText (sourceFileName));
                }
            }
            string source = sourceBuilder.ToString ();

            /*
             * Parse source string into tokens.
             */
            TokenBegin tokenBegin = TokenBegin.Construct(cameFrom, null, StandAloneErrorMessage, source, out sourceHash);
            if (tokenBegin == null) {
                Console.WriteLine ("Parsing errors.");
                Environment.Exit (1);
            }

            /*
             * Create abstract syntax tree from raw tokens.
             */
            TokenScript tokenScript = ScriptReduce.Reduce(tokenBegin);
            if (tokenScript == null) {
                Console.WriteLine ("Reduction errors.");
                Environment.Exit (1);
            }

            /*
             * Attempt to compile AST to object code.
             */
            Stream objFileStream = new FileStream (outFileName, FileMode.Create);
            if (!plaintext) objFileStream = Encrypt (objFileStream);
            BinaryWriter objFileWriter = new BinaryWriter (objFileStream);
            bool ok;
            try {
                ok = ScriptCodeGen.CodeGen(tokenScript, objFileWriter, sourceHash);
            } finally {
                objFileWriter.Close ();
            }
            if (!ok) {
                File.Delete (outFileName);
                Console.WriteLine ("Compilation errors.");
                Environment.Exit (1);
            }

            /*
             * If they want the assembly file, disassemble object file to get it.
             */
#ifdef SECRET_STUFF
            if (asmFileName != null) {
                objFileStream = new FileStream (outFileName, FileMode.Open);
                if (!plaintext) objFileStream = Decrypt (objFileStream);
                BinaryReader objFileReader = new BinaryReader (objFileStream);
                TextWriter asmFileWriter = (asmFileName != "-") ? File.CreateText (asmFileName) : Console.Out;
                try {
                    new ScriptObjCode (objFileReader, asmFileWriter, null);
                } finally {
                    objFileReader.Close ();
                    asmFileWriter.Flush ();
                    asmFileWriter.Close ();
                }
            }

            if (srcFileName != null) {
                objFileStream = new FileStream (outFileName, FileMode.Open);
                if (!plaintext) objFileStream = Decrypt (objFileStream);
                BinaryReader objFileReader = new BinaryReader (objFileStream);
                TextWriter srcFileWriter = (srcFileName != "-") ? File.CreateText (srcFileName) : Console.Out;
                try {
                    new ScriptObjCode (objFileReader, null, srcFileWriter);
                } finally {
                    objFileReader.Close ();
                    srcFileWriter.Flush ();
                    srcFileWriter.Close ();
                }
            }
#endif
            return;

usage:
            Console.WriteLine ("");
#ifdef SECRET_STUFF
            Console.WriteLine ("xmrengcomp.exe -out <outputxmrobjfile> [-asm <outputxmrasmfile>] [-plaintext] [-src <reconstructedsource>] [<inputsourcefile> ...]");
#else
            Console.WriteLine ("xmrengcomp.exe -out <outputxmrobjfile> [<inputsourcefile> ...]");
#endif
            Console.WriteLine ("               omit inputsourcefiles to read from stdin");
            Console.WriteLine ("xmrengcomp.exe -builtins");
            Console.WriteLine ("xmrengcomp.exe -version");
#ifdef SECRET_STUFF
            Console.WriteLine ("xmrengcomp.exe -genkey");
            Console.WriteLine ("xmrengcomp.exe -decode [-asm <outputxmrasmfile>] [-plaintext] [-src <reconstructedsource>] <inputobjectfile>");
#endif
version:
            Console.WriteLine ("");
            Console.WriteLine ("XMREngine standalone compiler, version 1." + ScriptCodeGen.COMPILED_VERSION_VALUE);
            Console.WriteLine ("    commit " + ScriptCompCommit.commitInfo);
            Console.WriteLine ("    fetchbinary fingerprint " + Fingerprint);
            Console.WriteLine ("");
        }

        public static void StandAloneErrorMessage (Token token, string message)
        {
            Console.WriteLine ("{0} {1}", token.SrcLoc, message);
        }

#ifdef SECRET_STUFF
        /**
         * @brief Called for the -decode option to figure out what an object file
         *        contains (either encrypted abstract syntax tree or CIL object)
         *        and disassemble it.
         * @param decodeFileName = name of the one-and-only input file
         * @param asmFileName = null: don't bother disassembling
         *                      else: name of assembly output file
         * @param srcFileName = null: don't bother decompiling
         *                      else: name of decompiled output file
         */
        private static void DecodeFile (string decodeFileName, string asmFileName, string srcFileName, bool plaintext)
        {
            /*
             * Maybe disassemble.
             */
            if (asmFileName != null) {

                /*
                 * Open file to decode.
                 */
                Stream decodeFileStream = File.OpenRead (decodeFileName);
                if (!plaintext) decodeFileStream = Decrypt (decodeFileStream);

                /*
                 * Create file to write disassembly to.
                 */
                Console.WriteLine ("Creating disassembly file " + asmFileName);
                TextWriter asmFileWriter = (asmFileName != "-") ? File.CreateText (asmFileName) : Console.Out;

                /*
                 * Write disassembly to a file for debugging.
                 */
                BinaryReader objFileReader = new BinaryReader (decodeFileStream);
                try {
                    new ScriptObjCode (objFileReader, asmFileWriter, null);
                } finally {
                    objFileReader.Close ();
                    asmFileWriter.Flush ();
                    asmFileWriter.Close ();
                }
            }

            /*
             * Maybe decompile.
             */
            if (srcFileName != null) {
                Stream decodeFileStream = File.OpenRead (decodeFileName);
                if (!plaintext) decodeFileStream = Decrypt (decodeFileStream);
                BinaryReader objFileReader = new BinaryReader (decodeFileStream);
                Console.WriteLine ("Creating decompile file " + srcFileName);
                TextWriter srcFileWriter = (srcFileName != "-") ? File.CreateText (srcFileName) : Console.Out;
                try {
                    new ScriptObjCode (objFileReader, null, srcFileWriter);
                } finally {
                    objFileReader.Close ();
                    srcFileWriter.Flush ();
                    srcFileWriter.Close ();
                }
            }

            Console.WriteLine("All done.");
        }

        /**
         * @brief This is run only once by Meta7 to generate our public and private
         *        key pair.  A new key can be generated if the compile version changes.
         */
        private static void GenKey ()
        {
            RSACryptoServiceProvider rsa = new RSACryptoServiceProvider (rsaBits);
            RSAParameters rsap = rsa.ExportParameters (true);

            byte[][] publicKey  = new byte[][] {
                rsap.Exponent,
                rsap.Modulus
            };

            File.WriteAllText ("MMRScriptXmrBinPublicKey.h", "        private static byte[][] publicKey = " + ByteByteArrayToString (publicKey));

            byte[][] privateKey = new byte[][] {
                rsap.D,
                rsap.DP,
                rsap.DQ,
                rsap.Exponent,
                rsap.InverseQ,
                rsap.Modulus,
                rsap.P,
                rsap.Q
            };

            File.WriteAllText ("MMRScriptXmrBinPrivateKey.h", "        private static byte[][] privateKey = " + ByteByteArrayToString (privateKey));
        }

        public static string ByteByteArrayToString (byte[][] array)
        {
            StringBuilder sb = new StringBuilder ();
            sb.Append ("new byte[][] {");
            for (int i = 0; i < array.Length; i ++) {
                byte[] row = array[i];
                if (i > 0) sb.Append (',');
                sb.Append ("\n      new byte[] {");
                for (int j = 0; j < row.Length; j ++) {
                    if (j > 0) {
                        sb.Append (',');
                        if (j % 8 == 0) {
                            sb.Append ("\n                  ");
                        }
                    }
                    sb.Append (" 0x");
                    sb.Append (row[j].ToString ("X2"));
                }
                sb.Append (" }");
            }
            sb.Append (" };");
            return sb.ToString ();
        }
#endif

#include "MMRScriptXmrBinEncrypt.h"
#ifdef SECRET_STUFF
#include "MMRScriptXmrBinDecrypt.h"
#endif
    }

    public abstract class XMRSuperType : XMRInstAbstract {
    }
}
